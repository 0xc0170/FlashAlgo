/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KL28Z256VLH76RM, Rev.0, Feb 2015
**     Version:             rev. 1.8, 2015-05-12
**     Build:               b150513
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2015 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2014-12-29)
**         Initial version.
**     - rev. 1.1 (2015-03-19)
**         Make array for registers in XRDC, PCC and TRGMUX
**     - rev. 1.2 (2015-03-20)
**         Add vector table for intmux0
**         Add IRQS for SCG, RCM, DAC, TSI
**     - rev. 1.3 (2015-03-26)
**         Update FGPIO and GPIO
**         Update IRQ for LPIT
**     - rev. 1.4 (2015-04-08)
**         Group channel registers for LPIT
**     - rev. 1.5 (2015-04-15)
**         Group channel registers for INTMUX
**     - rev. 1.6 (2015-05-06)
**         Correct FOPT reset value
**         Correct vector table size
**         Remove parts with 256K flash size
**     - rev. 1.7 (2015-05-08)
**         Reduce register for XRDC
**     - rev. 1.8 (2015-05-12)
**         Add CMP
**         DMAMUX channel count to 8
**         Add PIDR for GPIO/FGPIO
**         Rename PIT to LPIT in PCC
**         SCG, USB register update
**         SIM, TRGMUX1, TRNG, TSTMR0/1 base address update
**         Add KEY related macros for WDOG
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __MKL28Z7_EXTENSION_H__
#define __MKL28Z7_EXTENSION_H__

#include "MKL28Z7.h"
#include "fsl_bitaccess.h"

/*
 * MKL28Z7 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC Status and Control Registers 1
 * - ADC_CFG1 - ADC Configuration Register 1
 * - ADC_CFG2 - ADC Configuration Register 2
 * - ADC_R - ADC Data Result Register
 * - ADC_CV1 - Compare Value Registers
 * - ADC_CV2 - Compare Value Registers
 * - ADC_SC2 - Status and Control Register 2
 * - ADC_SC3 - Status and Control Register 3
 * - ADC_OFS - ADC Offset Correction Register
 * - ADC_PG - ADC Plus-Side Gain Register
 * - ADC_MG - ADC Minus-Side Gain Register
 * - ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLMD - ADC Minus-Side General Calibration Value Register
 * - ADC_CLMS - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 */

#define ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */

/*******************************************************************************
 * ADC_SC1 - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s (module disabled). Writing any of the SC1n registers while
 * that specific SC1n register is actively controlling a conversion aborts the
 * current conversion. None of the SC1B-SC1n registers are used for software
 * trigger operation and therefore writes to the SC1B-SC1n registers do not initiate a
 * new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (BME_OR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
#define ADC_CLR_SC1(base, index, value) (BME_AND32(&ADC_SC1_REG(base, index), (uint32_t)(~(value))))
#define ADC_TOG_SC1(base, index, value) (BME_XOR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. The input channel decode depends on the
 * value of DIFF. DAD0-DAD3 are associated with the input pin pairs DADPx and
 * DADMx. Some of the input channel options in the bitfield-setting descriptions might
 * not be available for your device. For the actual ADC channel assignments for
 * your device, see the Chip Configuration details. The successive approximation
 * converter subsystem is turned off when the channel select bits are all set,
 * that is, ADCH = 11111. This feature allows explicit disabling of the ADC and
 * isolation of the input channel from all sources. Terminating continuous
 * conversions this way prevents an additional single conversion from being performed. It
 * is not necessary to set ADCH to all 1s to place the ADC in a low-power state
 * when continuous conversions are not enabled because the module automatically
 * enters a low-power state when a conversion completes.
 *
 * Values:
 * - 0b00000 - When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is
 *     selected as input.
 * - 0b00001 - When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is
 *     selected as input.
 * - 0b00010 - When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is
 *     selected as input.
 * - 0b00011 - When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is
 *     selected as input.
 * - 0b00100 - When DIFF=0, AD4 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00101 - When DIFF=0, AD5 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00110 - When DIFF=0, AD6 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00111 - When DIFF=0, AD7 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01000 - When DIFF=0, AD8 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01001 - When DIFF=0, AD9 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01010 - When DIFF=0, AD10 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01011 - When DIFF=0, AD11 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01100 - When DIFF=0, AD12 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01101 - When DIFF=0, AD13 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01110 - When DIFF=0, AD14 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01111 - When DIFF=0, AD15 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10000 - When DIFF=0, AD16 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10001 - When DIFF=0, AD17 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10010 - When DIFF=0, AD18 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10011 - When DIFF=0, AD19 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10100 - When DIFF=0, AD20 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10101 - When DIFF=0, AD21 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10110 - When DIFF=0, AD22 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10111 - When DIFF=0, AD23 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b11000 - Reserved.
 * - 0b11001 - Reserved.
 * - 0b11010 - When DIFF=0, Temp Sensor (single-ended) is selected as input;
 *     when DIFF=1, Temp Sensor (differential) is selected as input.
 * - 0b11011 - When DIFF=0, Bandgap (single-ended) is selected as input; when
 *     DIFF=1, Bandgap (differential) is selected as input.
 * - 0b11100 - Reserved.
 * - 0b11101 - When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH
 *     (differential) is selected as input. Voltage reference selected is determined
 *     by SC2[REFSEL].
 * - 0b11110 - When DIFF=0,VREFSL is selected as input; when DIFF=1, it is
 *     reserved. Voltage reference selected is determined by SC2[REFSEL].
 * - 0b11111 - Module is disabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_ADCH_SHIFT), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field DIFF[5] (RW)
 *
 * Configures the ADC to operate in differential mode. When enabled, this mode
 * automatically selects from the differential channels, and changes the
 * conversion algorithm and the number of cycles to complete a conversion.
 *
 * Values:
 * - 0b0 - Single-ended conversions and input channels are selected.
 * - 0b1 - Differential conversions and input channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_DIFF field. */
#define ADC_RD_SC1_DIFF(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_DIFF_MASK) >> ADC_SC1_DIFF_SHIFT)
#define ADC_BRD_SC1_DIFF(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))

/*! @brief Set the DIFF field to a new value. */
#define ADC_WR_SC1_DIFF(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_DIFF_MASK, ADC_SC1_DIFF(value)))
#define ADC_BWR_SC1_DIFF(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_DIFF_SHIFT), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0b0 - Conversion complete interrupt is disabled.
 * - 0b1 - Conversion complete interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_AIEN_SHIFT), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0b0 - Conversion is not completed.
 * - 0b1 - Conversion is completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT, ADC_SC1_COCO_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (BME_OR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG1(base, value) (BME_AND32(&ADC_CFG1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG1(base, value) (BME_XOR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 0b00 - Bus clock
 * - 0b01 - Bus clock divided by 2(BUSCLK/2)
 * - 0b10 - Alternate clock (ALTCLK)
 * - 0b11 - Asynchronous clock (ADACK)
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADICLK_SHIFT), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 0b00 - When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is
 *     differential 9-bit conversion with 2's complement output.
 * - 0b01 - When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it
 *     is differential 13-bit conversion with 2's complement output.
 * - 0b10 - When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it
 *     is differential 11-bit conversion with 2's complement output
 * - 0b11 - When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it
 *     is differential 16-bit conversion with 2's complement output
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_MODE_SHIFT), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0b0 - Short sample time.
 * - 0b1 - Long sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define ADC_RD_CFG1_ADLSMP(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLSMP_MASK) >> ADC_CFG1_ADLSMP_SHIFT)
#define ADC_BRD_CFG1_ADLSMP(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))

/*! @brief Set the ADLSMP field to a new value. */
#define ADC_WR_CFG1_ADLSMP(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLSMP_MASK, ADC_CFG1_ADLSMP(value)))
#define ADC_BWR_CFG1_ADLSMP(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLSMP_SHIFT), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 0b00 - The divide ratio is 1 and the clock rate is input clock.
 * - 0b01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 0b10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 0b11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADIV_SHIFT), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0b0 - Normal power configuration.
 * - 0b1 - Low-power configuration. The power is reduced at the expense of
 *     maximum clock speed.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define ADC_RD_CFG1_ADLPC(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLPC_MASK) >> ADC_CFG1_ADLPC_SHIFT)
#define ADC_BRD_CFG1_ADLPC(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))

/*! @brief Set the ADLPC field to a new value. */
#define ADC_WR_CFG1_ADLPC(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLPC_MASK, ADC_CFG1_ADLPC(value)))
#define ADC_BWR_CFG1_ADLPC(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLPC_SHIFT), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (BME_OR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG2(base, value) (BME_AND32(&ADC_CFG2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG2(base, value) (BME_XOR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 0b00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 0b01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 0b10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 0b11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define ADC_RD_CFG2_ADLSTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADLSTS_MASK) >> ADC_CFG2_ADLSTS_SHIFT)
#define ADC_BRD_CFG2_ADLSTS(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))

/*! @brief Set the ADLSTS field to a new value. */
#define ADC_WR_CFG2_ADLSTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADLSTS_MASK, ADC_CFG2_ADLSTS(value)))
#define ADC_BWR_CFG2_ADLSTS(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADLSTS_SHIFT), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0b0 - Normal conversion sequence selected.
 * - 0b1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define ADC_RD_CFG2_ADHSC(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADHSC_MASK) >> ADC_CFG2_ADHSC_SHIFT)
#define ADC_BRD_CFG2_ADHSC(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))

/*! @brief Set the ADHSC field to a new value. */
#define ADC_WR_CFG2_ADHSC(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADHSC_MASK, ADC_CFG2_ADHSC(value)))
#define ADC_BWR_CFG2_ADHSC(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADHSC_SHIFT), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0b0 - Asynchronous clock output disabled; Asynchronous clock is enabled
 *     only if selected by ADICLK and a conversion is active.
 * - 0b1 - Asynchronous clock and clock output is enabled regardless of the
 *     state of the ADC.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define ADC_RD_CFG2_ADACKEN(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADACKEN_MASK) >> ADC_CFG2_ADACKEN_SHIFT)
#define ADC_BRD_CFG2_ADACKEN(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))

/*! @brief Set the ADACKEN field to a new value. */
#define ADC_WR_CFG2_ADACKEN(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADACKEN_MASK, ADC_CFG2_ADACKEN(value)))
#define ADC_BWR_CFG2_ADACKEN(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADACKEN_SHIFT), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0b0 - ADxxa channels are selected.
 * - 0b1 - ADxxb channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define ADC_RD_CFG2_MUXSEL(base) ((ADC_CFG2_REG(base) & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT)
#define ADC_BRD_CFG2_MUXSEL(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))

/*! @brief Set the MUXSEL field to a new value. */
#define ADC_WR_CFG2_MUXSEL(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_MUXSEL_MASK, ADC_CFG2_MUXSEL(value)))
#define ADC_BWR_CFG2_MUXSEL(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_MUXSEL_SHIFT), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement modes.
 * For example, when configured for 10-bit single-ended mode, D[15:10] are
 * cleared. When configured for 11-bit differential mode, D[15:10] carry the sign bit,
 * that is, bit 10 extended through bit 15. The following table describes the
 * behavior of the data result registers in the different modes of operation. Data
 * result register description Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7
 * D6 D5 D4 D3 D2 D1 D0 Format 16-bit differential S D D D D D D D D D D D D D D D
 * Signed 2's complement 16-bit single-ended D D D D D D D D D D D D D D D D
 * Unsigned right justified 13-bit differential S S S S D D D D D D D D D D D D
 * Sign-extended 2's complement 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D
 * Unsigned right-justified 11-bit differential S S S S S S D D D D D D D D D D
 * Sign-extended 2's complement 10-bit single-ended 0 0 0 0 0 0 D D D D D D D D D D
 * Unsigned right-justified 9-bit differential S S S S S S S S D D D D D D D D
 * Sign-extended 2's complement 8-bit single-ended 0 0 0 0 0 0 0 0 D D D D D D D D
 * Unsigned right-justified S: Sign bit or sign bit extension; D: Data, which is
 * 2's complement data if indicated
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (ADC_RD_R_D(base, index))
/*@}*/

/*******************************************************************************
 * ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define ADC_RD_CV1(base)         (ADC_CV1_REG(base))
#define ADC_WR_CV1(base, value)  (ADC_CV1_REG(base) = (value))
#define ADC_RMW_CV1(base, mask, value) (ADC_WR_CV1(base, (ADC_RD_CV1(base) & ~(mask)) | (value)))
#define ADC_SET_CV1(base, value) (BME_OR32(&ADC_CV1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV1(base, value) (BME_AND32(&ADC_CV1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV1(base, value) (BME_XOR32(&ADC_CV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV1_CV field. */
#define ADC_RD_CV1_CV(base)  ((ADC_CV1_REG(base) & ADC_CV1_CV_MASK) >> ADC_CV1_CV_SHIFT)
#define ADC_BRD_CV1_CV(base) (ADC_RD_CV1_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV1_CV(base, value) (ADC_RMW_CV1(base, ADC_CV1_CV_MASK, ADC_CV1_CV(value)))
#define ADC_BWR_CV1_CV(base, value) (ADC_WR_CV1_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define ADC_RD_CV2(base)         (ADC_CV2_REG(base))
#define ADC_WR_CV2(base, value)  (ADC_CV2_REG(base) = (value))
#define ADC_RMW_CV2(base, mask, value) (ADC_WR_CV2(base, (ADC_RD_CV2(base) & ~(mask)) | (value)))
#define ADC_SET_CV2(base, value) (BME_OR32(&ADC_CV2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV2(base, value) (BME_AND32(&ADC_CV2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV2(base, value) (BME_XOR32(&ADC_CV2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV2_CV field. */
#define ADC_RD_CV2_CV(base)  ((ADC_CV2_REG(base) & ADC_CV2_CV_MASK) >> ADC_CV2_CV_SHIFT)
#define ADC_BRD_CV2_CV(base) (ADC_RD_CV2_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV2_CV(base, value) (ADC_RMW_CV2(base, ADC_CV2_CV_MASK, ADC_CV2_CV(value)))
#define ADC_BWR_CV2_CV(base, value) (ADC_WR_CV2_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (BME_OR32(&ADC_SC2_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC2(base, value) (BME_AND32(&ADC_SC2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC2(base, value) (BME_XOR32(&ADC_SC2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 0b00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 0b01 - Alternate reference pair, that is, VALTH and VALTL . This pair may
 *     be additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to
 *     this MCU
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_REFSEL_SHIFT), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_DMAEN_SHIFT), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0b0 - Range function disabled. Only CV1 is compared.
 * - 0b1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACREN_SHIFT), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0b0 - Configures less than threshold, outside range not inclusive and
 *     inside range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 0b1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFGT_SHIFT), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0b0 - Compare function disabled.
 * - 0b1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFE_SHIFT), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0b0 - Software trigger selected.
 * - 0b1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ADTRG_SHIFT), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0b0 - Conversion not in progress.
 * - 0b1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT, ADC_SC2_ADACT_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (BME_OR32(&ADC_SC3_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC3(base, value) (BME_AND32(&ADC_SC3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC3(base, value) (BME_XOR32(&ADC_SC3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 0b00 - 4 samples averaged.
 * - 0b01 - 8 samples averaged.
 * - 0b10 - 16 samples averaged.
 * - 0b11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGS_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGS_SHIFT), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0b0 - Hardware average function disabled.
 * - 0b1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGE_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGE_SHIFT), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0b0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 0b1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, (ADC_SC3_ADCO_MASK | ADC_SC3_CALF_MASK), ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_ADCO_SHIFT), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0b0 - Calibration completed normally.
 * - 0b1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))

/*! @brief Set the CALF field to a new value. */
#define ADC_WR_SC3_CALF(base, value) (ADC_RMW_SC3(base, ADC_SC3_CALF_MASK, ADC_SC3_CALF(value)))
#define ADC_BWR_SC3_CALF(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CALF_SHIFT), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, (ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK), ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CAL_SHIFT), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation. For more
 * information regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to
 * achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (BME_OR32(&ADC_OFS_REG(base), (uint32_t)(value)))
#define ADC_CLR_OFS(base, value) (BME_AND32(&ADC_OFS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_OFS(base, value) (BME_XOR32(&ADC_OFS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (ADC_RD_OFS_OFS(base))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (ADC_WR_OFS_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Plus-Side Gain Register (PG) contains the gain error correction for the
 * plus-side input in differential mode or the overall conversion in single-ended
 * mode. PG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between PG[15] and PG[14]. This register must be
 * written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met. For more information
 * regarding the calibration procedure, please refer to the Calibration functionThe
 * ADC contains a self-calibration function that is required to achieve the
 * specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define ADC_RD_PG(base)          (ADC_PG_REG(base))
#define ADC_WR_PG(base, value)   (ADC_PG_REG(base) = (value))
#define ADC_RMW_PG(base, mask, value) (ADC_WR_PG(base, (ADC_RD_PG(base) & ~(mask)) | (value)))
#define ADC_SET_PG(base, value)  (BME_OR32(&ADC_PG_REG(base), (uint32_t)(value)))
#define ADC_CLR_PG(base, value)  (BME_AND32(&ADC_PG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_PG(base, value)  (BME_XOR32(&ADC_PG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_PG_PG field. */
#define ADC_RD_PG_PG(base)   ((ADC_PG_REG(base) & ADC_PG_PG_MASK) >> ADC_PG_PG_SHIFT)
#define ADC_BRD_PG_PG(base)  (ADC_RD_PG_PG(base))

/*! @brief Set the PG field to a new value. */
#define ADC_WR_PG_PG(base, value) (ADC_RMW_PG(base, ADC_PG_PG_MASK, ADC_PG_PG(value)))
#define ADC_BWR_PG_PG(base, value) (ADC_WR_PG_PG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_MG - ADC Minus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_MG - ADC Minus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Minus-Side Gain Register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between MG[15] and MG[14]. This register must
 * be written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met. For more information
 * regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to achieve the
 * specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define ADC_RD_MG(base)          (ADC_MG_REG(base))
#define ADC_WR_MG(base, value)   (ADC_MG_REG(base) = (value))
#define ADC_RMW_MG(base, mask, value) (ADC_WR_MG(base, (ADC_RD_MG(base) & ~(mask)) | (value)))
#define ADC_SET_MG(base, value)  (BME_OR32(&ADC_MG_REG(base), (uint32_t)(value)))
#define ADC_CLR_MG(base, value)  (BME_AND32(&ADC_MG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_MG(base, value)  (BME_XOR32(&ADC_MG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_MG_MG field. */
#define ADC_RD_MG_MG(base)   ((ADC_MG_REG(base) & ADC_MG_MG_MASK) >> ADC_MG_MG_SHIFT)
#define ADC_BRD_MG_MG(base)  (ADC_RD_MG_MG(base))

/*! @brief Set the MG field to a new value. */
#define ADC_WR_MG_MG(base, value) (ADC_RMW_MG(base, ADC_MG_MG_MASK, ADC_MG_MG(value)))
#define ADC_BWR_MG_MG(base, value) (ADC_WR_MG_MG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met. For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define ADC_RD_CLPD(base)        (ADC_CLPD_REG(base))
#define ADC_WR_CLPD(base, value) (ADC_CLPD_REG(base) = (value))
#define ADC_RMW_CLPD(base, mask, value) (ADC_WR_CLPD(base, (ADC_RD_CLPD(base) & ~(mask)) | (value)))
#define ADC_SET_CLPD(base, value) (BME_OR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPD(base, value) (BME_AND32(&ADC_CLPD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPD(base, value) (BME_XOR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define ADC_RD_CLPD_CLPD(base) ((ADC_CLPD_REG(base) & ADC_CLPD_CLPD_MASK) >> ADC_CLPD_CLPD_SHIFT)
#define ADC_BRD_CLPD_CLPD(base) (BME_UBFX32(&ADC_CLPD_REG(base), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))

/*! @brief Set the CLPD field to a new value. */
#define ADC_WR_CLPD_CLPD(base, value) (ADC_RMW_CLPD(base, ADC_CLPD_CLPD_MASK, ADC_CLPD_CLPD(value)))
#define ADC_BWR_CLPD_CLPD(base, value) (BME_BFI32(&ADC_CLPD_REG(base), ((uint32_t)(value) << ADC_CLPD_CLPD_SHIFT), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (BME_OR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPS(base, value) (BME_AND32(&ADC_CLPS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPS(base, value) (BME_XOR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (BME_UBFX32(&ADC_CLPS_REG(base), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (BME_BFI32(&ADC_CLPS_REG(base), ((uint32_t)(value) << ADC_CLPS_CLPS_SHIFT), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define ADC_RD_CLP4(base)        (ADC_CLP4_REG(base))
#define ADC_WR_CLP4(base, value) (ADC_CLP4_REG(base) = (value))
#define ADC_RMW_CLP4(base, mask, value) (ADC_WR_CLP4(base, (ADC_RD_CLP4(base) & ~(mask)) | (value)))
#define ADC_SET_CLP4(base, value) (BME_OR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP4(base, value) (BME_AND32(&ADC_CLP4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP4(base, value) (BME_XOR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define ADC_RD_CLP4_CLP4(base) ((ADC_CLP4_REG(base) & ADC_CLP4_CLP4_MASK) >> ADC_CLP4_CLP4_SHIFT)
#define ADC_BRD_CLP4_CLP4(base) (ADC_RD_CLP4_CLP4(base))

/*! @brief Set the CLP4 field to a new value. */
#define ADC_WR_CLP4_CLP4(base, value) (ADC_RMW_CLP4(base, ADC_CLP4_CLP4_MASK, ADC_CLP4_CLP4(value)))
#define ADC_BWR_CLP4_CLP4(base, value) (ADC_WR_CLP4_CLP4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (BME_OR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP3(base, value) (BME_AND32(&ADC_CLP3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP3(base, value) (BME_XOR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (ADC_RD_CLP3_CLP3(base))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (ADC_WR_CLP3_CLP3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (BME_OR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP2(base, value) (BME_AND32(&ADC_CLP2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP2(base, value) (BME_XOR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (BME_UBFX32(&ADC_CLP2_REG(base), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (BME_BFI32(&ADC_CLP2_REG(base), ((uint32_t)(value) << ADC_CLP2_CLP2_SHIFT), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (BME_OR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP1(base, value) (BME_AND32(&ADC_CLP1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP1(base, value) (BME_XOR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (BME_UBFX32(&ADC_CLP1_REG(base), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (BME_BFI32(&ADC_CLP1_REG(base), ((uint32_t)(value) << ADC_CLP1_CLP1_SHIFT), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (BME_OR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP0(base, value) (BME_AND32(&ADC_CLP0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP0(base, value) (BME_XOR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (BME_UBFX32(&ADC_CLP0_REG(base), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (BME_BFI32(&ADC_CLP0_REG(base), ((uint32_t)(value) << ADC_CLP0_CLP0_SHIFT), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMD - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMD - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Minus-Side General Calibration Value (CLMx) registers contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLM0[5:0], CLM1[6:0],
 * CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0]. CLMx are automatically
 * set when the self-calibration sequence is done, that is, CAL is cleared. If
 * these registers are written by the user after calibration, the linearity error
 * specifications may not be met. For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define ADC_RD_CLMD(base)        (ADC_CLMD_REG(base))
#define ADC_WR_CLMD(base, value) (ADC_CLMD_REG(base) = (value))
#define ADC_RMW_CLMD(base, mask, value) (ADC_WR_CLMD(base, (ADC_RD_CLMD(base) & ~(mask)) | (value)))
#define ADC_SET_CLMD(base, value) (BME_OR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMD(base, value) (BME_AND32(&ADC_CLMD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMD(base, value) (BME_XOR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define ADC_RD_CLMD_CLMD(base) ((ADC_CLMD_REG(base) & ADC_CLMD_CLMD_MASK) >> ADC_CLMD_CLMD_SHIFT)
#define ADC_BRD_CLMD_CLMD(base) (BME_UBFX32(&ADC_CLMD_REG(base), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))

/*! @brief Set the CLMD field to a new value. */
#define ADC_WR_CLMD_CLMD(base, value) (ADC_RMW_CLMD(base, ADC_CLMD_CLMD_MASK, ADC_CLMD_CLMD(value)))
#define ADC_BWR_CLMD_CLMD(base, value) (BME_BFI32(&ADC_CLMD_REG(base), ((uint32_t)(value) << ADC_CLMD_CLMD_SHIFT), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMS - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMS - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define ADC_RD_CLMS(base)        (ADC_CLMS_REG(base))
#define ADC_WR_CLMS(base, value) (ADC_CLMS_REG(base) = (value))
#define ADC_RMW_CLMS(base, mask, value) (ADC_WR_CLMS(base, (ADC_RD_CLMS(base) & ~(mask)) | (value)))
#define ADC_SET_CLMS(base, value) (BME_OR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMS(base, value) (BME_AND32(&ADC_CLMS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMS(base, value) (BME_XOR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define ADC_RD_CLMS_CLMS(base) ((ADC_CLMS_REG(base) & ADC_CLMS_CLMS_MASK) >> ADC_CLMS_CLMS_SHIFT)
#define ADC_BRD_CLMS_CLMS(base) (BME_UBFX32(&ADC_CLMS_REG(base), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))

/*! @brief Set the CLMS field to a new value. */
#define ADC_WR_CLMS_CLMS(base, value) (ADC_RMW_CLMS(base, ADC_CLMS_CLMS_MASK, ADC_CLMS_CLMS(value)))
#define ADC_BWR_CLMS_CLMS(base, value) (BME_BFI32(&ADC_CLMS_REG(base), ((uint32_t)(value) << ADC_CLMS_CLMS_SHIFT), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM4 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define ADC_RD_CLM4(base)        (ADC_CLM4_REG(base))
#define ADC_WR_CLM4(base, value) (ADC_CLM4_REG(base) = (value))
#define ADC_RMW_CLM4(base, mask, value) (ADC_WR_CLM4(base, (ADC_RD_CLM4(base) & ~(mask)) | (value)))
#define ADC_SET_CLM4(base, value) (BME_OR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM4(base, value) (BME_AND32(&ADC_CLM4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM4(base, value) (BME_XOR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define ADC_RD_CLM4_CLM4(base) ((ADC_CLM4_REG(base) & ADC_CLM4_CLM4_MASK) >> ADC_CLM4_CLM4_SHIFT)
#define ADC_BRD_CLM4_CLM4(base) (ADC_RD_CLM4_CLM4(base))

/*! @brief Set the CLM4 field to a new value. */
#define ADC_WR_CLM4_CLM4(base, value) (ADC_RMW_CLM4(base, ADC_CLM4_CLM4_MASK, ADC_CLM4_CLM4(value)))
#define ADC_BWR_CLM4_CLM4(base, value) (ADC_WR_CLM4_CLM4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM3 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define ADC_RD_CLM3(base)        (ADC_CLM3_REG(base))
#define ADC_WR_CLM3(base, value) (ADC_CLM3_REG(base) = (value))
#define ADC_RMW_CLM3(base, mask, value) (ADC_WR_CLM3(base, (ADC_RD_CLM3(base) & ~(mask)) | (value)))
#define ADC_SET_CLM3(base, value) (BME_OR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM3(base, value) (BME_AND32(&ADC_CLM3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM3(base, value) (BME_XOR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define ADC_RD_CLM3_CLM3(base) ((ADC_CLM3_REG(base) & ADC_CLM3_CLM3_MASK) >> ADC_CLM3_CLM3_SHIFT)
#define ADC_BRD_CLM3_CLM3(base) (ADC_RD_CLM3_CLM3(base))

/*! @brief Set the CLM3 field to a new value. */
#define ADC_WR_CLM3_CLM3(base, value) (ADC_RMW_CLM3(base, ADC_CLM3_CLM3_MASK, ADC_CLM3_CLM3(value)))
#define ADC_BWR_CLM3_CLM3(base, value) (ADC_WR_CLM3_CLM3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM2 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define ADC_RD_CLM2(base)        (ADC_CLM2_REG(base))
#define ADC_WR_CLM2(base, value) (ADC_CLM2_REG(base) = (value))
#define ADC_RMW_CLM2(base, mask, value) (ADC_WR_CLM2(base, (ADC_RD_CLM2(base) & ~(mask)) | (value)))
#define ADC_SET_CLM2(base, value) (BME_OR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM2(base, value) (BME_AND32(&ADC_CLM2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM2(base, value) (BME_XOR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define ADC_RD_CLM2_CLM2(base) ((ADC_CLM2_REG(base) & ADC_CLM2_CLM2_MASK) >> ADC_CLM2_CLM2_SHIFT)
#define ADC_BRD_CLM2_CLM2(base) (BME_UBFX32(&ADC_CLM2_REG(base), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))

/*! @brief Set the CLM2 field to a new value. */
#define ADC_WR_CLM2_CLM2(base, value) (ADC_RMW_CLM2(base, ADC_CLM2_CLM2_MASK, ADC_CLM2_CLM2(value)))
#define ADC_BWR_CLM2_CLM2(base, value) (BME_BFI32(&ADC_CLM2_REG(base), ((uint32_t)(value) << ADC_CLM2_CLM2_SHIFT), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM1 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define ADC_RD_CLM1(base)        (ADC_CLM1_REG(base))
#define ADC_WR_CLM1(base, value) (ADC_CLM1_REG(base) = (value))
#define ADC_RMW_CLM1(base, mask, value) (ADC_WR_CLM1(base, (ADC_RD_CLM1(base) & ~(mask)) | (value)))
#define ADC_SET_CLM1(base, value) (BME_OR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM1(base, value) (BME_AND32(&ADC_CLM1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM1(base, value) (BME_XOR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define ADC_RD_CLM1_CLM1(base) ((ADC_CLM1_REG(base) & ADC_CLM1_CLM1_MASK) >> ADC_CLM1_CLM1_SHIFT)
#define ADC_BRD_CLM1_CLM1(base) (BME_UBFX32(&ADC_CLM1_REG(base), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))

/*! @brief Set the CLM1 field to a new value. */
#define ADC_WR_CLM1_CLM1(base, value) (ADC_RMW_CLM1(base, ADC_CLM1_CLM1_MASK, ADC_CLM1_CLM1(value)))
#define ADC_BWR_CLM1_CLM1(base, value) (BME_BFI32(&ADC_CLM1_REG(base), ((uint32_t)(value) << ADC_CLM1_CLM1_SHIFT), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM0 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define ADC_RD_CLM0(base)        (ADC_CLM0_REG(base))
#define ADC_WR_CLM0(base, value) (ADC_CLM0_REG(base) = (value))
#define ADC_RMW_CLM0(base, mask, value) (ADC_WR_CLM0(base, (ADC_RD_CLM0(base) & ~(mask)) | (value)))
#define ADC_SET_CLM0(base, value) (BME_OR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM0(base, value) (BME_AND32(&ADC_CLM0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM0(base, value) (BME_XOR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define ADC_RD_CLM0_CLM0(base) ((ADC_CLM0_REG(base) & ADC_CLM0_CLM0_MASK) >> ADC_CLM0_CLM0_SHIFT)
#define ADC_BRD_CLM0_CLM0(base) (BME_UBFX32(&ADC_CLM0_REG(base), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))

/*! @brief Set the CLM0 field to a new value. */
#define ADC_WR_CLM0_CLM0(base, value) (ADC_RMW_CLM0(base, ADC_CLM0_CLM0_MASK, ADC_CLM0_CLM0(value)))
#define ADC_BWR_CLM0_CLM0(base, value) (BME_BFI32(&ADC_CLM0_REG(base), ((uint32_t)(value) << ADC_CLM0_CLM0_SHIFT), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))
/*@}*/

/*
 * MKL28Z7 CAU
 *
 * Memory Mapped Cryptographic Acceleration Unit (MMCAU)
 *
 * Registers defined in this header file:
 * - CAU_DIRECT - Direct access register 0
 * - CAU_LDR_CASR - Status register - Load Register command
 * - CAU_LDR_CAA - Accumulator register - Load Register command
 * - CAU_LDR_CA - General Purpose Register 0 - Load Register command
 * - CAU_STR_CASR - Status register - Store Register command
 * - CAU_STR_CAA - Accumulator register - Store Register command
 * - CAU_STR_CA - General Purpose Register 0 - Store Register command
 * - CAU_ADR_CASR - Status register - Add Register command
 * - CAU_ADR_CAA - Accumulator register - Add to register command
 * - CAU_ADR_CA - General Purpose Register 0 - Add to register command
 * - CAU_RADR_CASR - Status register - Reverse and Add to Register command
 * - CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 * - CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command
 * - CAU_XOR_CASR - Status register - Exclusive Or command
 * - CAU_XOR_CAA - Accumulator register - Exclusive Or command
 * - CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command
 * - CAU_ROTL_CASR - Status register - Rotate Left command
 * - CAU_ROTL_CAA - Accumulator register - Rotate Left command
 * - CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command
 * - CAU_AESC_CASR - Status register - AES Column Operation command
 * - CAU_AESC_CAA - Accumulator register - AES Column Operation command
 * - CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command
 * - CAU_AESIC_CASR - Status register - AES Inverse Column Operation command
 * - CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 * - CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command
 */

#define CAU_INSTANCE_COUNT (1U) /*!< Number of instances of the CAU module. */
#define CAU0_IDX (0U) /*!< Instance number for CAU0. */

/*******************************************************************************
 * CAU_DIRECT - Direct access register 0
 ******************************************************************************/

/*!
 * @brief CAU_DIRECT - Direct access register 0 (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_DIRECT register
 */
/*@{*/
#define CAU_WR_DIRECT(base, index, value) (CAU_DIRECT_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CASR - Status register - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CASR - Status register - Load Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CASR register
 */
/*@{*/
#define CAU_WR_LDR_CASR(base, value) (CAU_LDR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CASR bitfields
 */

/*!
 * @name Register CAU_LDR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_LDR_CASR_IC(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_IC(value)))
#define CAU_BWR_LDR_CASR_IC(base, value) (CAU_WR_LDR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_LDR_CASR_DPE(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_DPE(value)))
#define CAU_BWR_LDR_CASR_DPE(base, value) (CAU_WR_LDR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_LDR_CASR_VER(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_VER(value)))
#define CAU_BWR_LDR_CASR_VER(base, value) (CAU_WR_LDR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CAA - Accumulator register - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CAA - Accumulator register - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CAA register
 */
/*@{*/
#define CAU_WR_LDR_CAA(base, value) (CAU_LDR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CA - General Purpose Register 0 - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CA - General Purpose Register 0 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CA register
 */
/*@{*/
#define CAU_WR_LDR_CA(base, index, value) (CAU_LDR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_STR_CASR - Status register - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CASR - Status register - Store Register command (RO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CASR register
 */
/*@{*/
#define CAU_RD_STR_CASR(base)    (CAU_STR_CASR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CASR bitfields
 */

/*!
 * @name Register CAU_STR_CASR, field IC[0] (RO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_IC field. */
#define CAU_RD_STR_CASR_IC(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_IC_MASK) >> CAU_STR_CASR_IC_SHIFT)
#define CAU_BRD_STR_CASR_IC(base) (CAU_RD_STR_CASR_IC(base))
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field DPE[1] (RO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_DPE field. */
#define CAU_RD_STR_CASR_DPE(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_DPE_MASK) >> CAU_STR_CASR_DPE_SHIFT)
#define CAU_BRD_STR_CASR_DPE(base) (CAU_RD_STR_CASR_DPE(base))
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field VER[31:28] (RO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_VER field. */
#define CAU_RD_STR_CASR_VER(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_VER_MASK) >> CAU_STR_CASR_VER_SHIFT)
#define CAU_BRD_STR_CASR_VER(base) (CAU_RD_STR_CASR_VER(base))
/*@}*/

/*******************************************************************************
 * CAU_STR_CAA - Accumulator register - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CAA - Accumulator register - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CAA register
 */
/*@{*/
#define CAU_RD_STR_CAA(base)     (CAU_STR_CAA_REG(base))
/*@}*/

/*******************************************************************************
 * CAU_STR_CA - General Purpose Register 0 - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CA - General Purpose Register 0 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CA register
 */
/*@{*/
#define CAU_RD_STR_CA(base, index) (CAU_STR_CA_REG(base, index))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CASR - Status register - Add Register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CASR - Status register - Add Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CASR register
 */
/*@{*/
#define CAU_WR_ADR_CASR(base, value) (CAU_ADR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CASR bitfields
 */

/*!
 * @name Register CAU_ADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_ADR_CASR_IC(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_IC(value)))
#define CAU_BWR_ADR_CASR_IC(base, value) (CAU_WR_ADR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_ADR_CASR_DPE(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_DPE(value)))
#define CAU_BWR_ADR_CASR_DPE(base, value) (CAU_WR_ADR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_ADR_CASR_VER(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_VER(value)))
#define CAU_BWR_ADR_CASR_VER(base, value) (CAU_WR_ADR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CAA - Accumulator register - Add to register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CAA - Accumulator register - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CAA register
 */
/*@{*/
#define CAU_WR_ADR_CAA(base, value) (CAU_ADR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CA - General Purpose Register 0 - Add to register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CA - General Purpose Register 0 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CA register
 */
/*@{*/
#define CAU_WR_ADR_CA(base, index, value) (CAU_ADR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CASR - Status register - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CASR - Status register - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CASR register
 */
/*@{*/
#define CAU_WR_RADR_CASR(base, value) (CAU_RADR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CASR bitfields
 */

/*!
 * @name Register CAU_RADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_RADR_CASR_IC(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_IC(value)))
#define CAU_BWR_RADR_CASR_IC(base, value) (CAU_WR_RADR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_RADR_CASR_DPE(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_DPE(value)))
#define CAU_BWR_RADR_CASR_DPE(base, value) (CAU_WR_RADR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_RADR_CASR_VER(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_VER(value)))
#define CAU_BWR_RADR_CASR_VER(base, value) (CAU_WR_RADR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CAA register
 */
/*@{*/
#define CAU_WR_RADR_CAA(base, value) (CAU_RADR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CA register
 */
/*@{*/
#define CAU_WR_RADR_CA(base, index, value) (CAU_RADR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CASR - Status register - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CASR - Status register - Exclusive Or command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CASR register
 */
/*@{*/
#define CAU_WR_XOR_CASR(base, value) (CAU_XOR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CASR bitfields
 */

/*!
 * @name Register CAU_XOR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_XOR_CASR_IC(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_IC(value)))
#define CAU_BWR_XOR_CASR_IC(base, value) (CAU_WR_XOR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_XOR_CASR_DPE(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_DPE(value)))
#define CAU_BWR_XOR_CASR_DPE(base, value) (CAU_WR_XOR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_XOR_CASR_VER(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_VER(value)))
#define CAU_BWR_XOR_CASR_VER(base, value) (CAU_WR_XOR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CAA - Accumulator register - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CAA - Accumulator register - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CAA register
 */
/*@{*/
#define CAU_WR_XOR_CAA(base, value) (CAU_XOR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CA register
 */
/*@{*/
#define CAU_WR_XOR_CA(base, index, value) (CAU_XOR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CASR - Status register - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CASR - Status register - Rotate Left command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CASR register
 */
/*@{*/
#define CAU_WR_ROTL_CASR(base, value) (CAU_ROTL_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CASR bitfields
 */

/*!
 * @name Register CAU_ROTL_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_ROTL_CASR_IC(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_IC(value)))
#define CAU_BWR_ROTL_CASR_IC(base, value) (CAU_WR_ROTL_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_ROTL_CASR_DPE(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_DPE(value)))
#define CAU_BWR_ROTL_CASR_DPE(base, value) (CAU_WR_ROTL_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_ROTL_CASR_VER(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_VER(value)))
#define CAU_BWR_ROTL_CASR_VER(base, value) (CAU_WR_ROTL_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CAA - Accumulator register - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CAA - Accumulator register - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CAA register
 */
/*@{*/
#define CAU_WR_ROTL_CAA(base, value) (CAU_ROTL_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CA register
 */
/*@{*/
#define CAU_WR_ROTL_CA(base, index, value) (CAU_ROTL_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CASR - Status register - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CASR - Status register - AES Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CASR register
 */
/*@{*/
#define CAU_WR_AESC_CASR(base, value) (CAU_AESC_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CASR bitfields
 */

/*!
 * @name Register CAU_AESC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_AESC_CASR_IC(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_IC(value)))
#define CAU_BWR_AESC_CASR_IC(base, value) (CAU_WR_AESC_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_AESC_CASR_DPE(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_DPE(value)))
#define CAU_BWR_AESC_CASR_DPE(base, value) (CAU_WR_AESC_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_AESC_CASR_VER(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_VER(value)))
#define CAU_BWR_AESC_CASR_VER(base, value) (CAU_WR_AESC_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CAA - Accumulator register - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CAA - Accumulator register - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CAA register
 */
/*@{*/
#define CAU_WR_AESC_CAA(base, value) (CAU_AESC_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CA register
 */
/*@{*/
#define CAU_WR_AESC_CA(base, index, value) (CAU_AESC_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CASR - Status register - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CASR - Status register - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CASR register
 */
/*@{*/
#define CAU_WR_AESIC_CASR(base, value) (CAU_AESIC_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CASR bitfields
 */

/*!
 * @name Register CAU_AESIC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_AESIC_CASR_IC(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_IC(value)))
#define CAU_BWR_AESIC_CASR_IC(base, value) (CAU_WR_AESIC_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_AESIC_CASR_DPE(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_DPE(value)))
#define CAU_BWR_AESIC_CASR_DPE(base, value) (CAU_WR_AESIC_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_AESIC_CASR_VER(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_VER(value)))
#define CAU_BWR_AESIC_CASR_VER(base, value) (CAU_WR_AESIC_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CAA register
 */
/*@{*/
#define CAU_WR_AESIC_CAA(base, value) (CAU_AESIC_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CA register
 */
/*@{*/
#define CAU_WR_AESIC_CA(base, index, value) (CAU_AESIC_CA_REG(base, index) = (value))
/*@}*/

/*
 * MKL28Z7 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_CR0 - CMP Control Register 0
 * - CMP_CR1 - CMP Control Register 1
 * - CMP_FPR - CMP Filter Period Register
 * - CMP_SCR - CMP Status and Control Register
 * - CMP_DACCR - DAC Control Register
 * - CMP_MUXCR - MUX Control Register
 */

#define CMP_INSTANCE_COUNT (2U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */
#define CMP1_IDX (1U) /*!< Instance number for CMP1. */

/*******************************************************************************
 * CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define CMP_RD_CR0(base)         (CMP_CR0_REG(base))
#define CMP_WR_CR0(base, value)  (CMP_CR0_REG(base) = (value))
#define CMP_RMW_CR0(base, mask, value) (CMP_WR_CR0(base, (CMP_RD_CR0(base) & ~(mask)) | (value)))
#define CMP_SET_CR0(base, value) (BME_OR8(&CMP_CR0_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR0(base, value) (BME_AND8(&CMP_CR0_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR0(base, value) (BME_XOR8(&CMP_CR0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 0b00 - Level 0
 * - 0b01 - Level 1
 * - 0b10 - Level 2
 * - 0b11 - Level 3
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define CMP_RD_CR0_HYSTCTR(base) ((CMP_CR0_REG(base) & CMP_CR0_HYSTCTR_MASK) >> CMP_CR0_HYSTCTR_SHIFT)
#define CMP_BRD_CR0_HYSTCTR(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_CR0_HYSTCTR(base, value) (CMP_RMW_CR0(base, CMP_CR0_HYSTCTR_MASK, CMP_CR0_HYSTCTR(value)))
#define CMP_BWR_CR0_HYSTCTR(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_HYSTCTR_SHIFT), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 0b000 - Filter is disabled. If SE = 1, then COUT is a logic 0. This is not
 *     a legal state, and is not recommended. If SE = 0, COUT = COUTA.
 * - 0b001 - One sample must agree. The comparator output is simply sampled.
 * - 0b010 - 2 consecutive samples must agree.
 * - 0b011 - 3 consecutive samples must agree.
 * - 0b100 - 4 consecutive samples must agree.
 * - 0b101 - 5 consecutive samples must agree.
 * - 0b110 - 6 consecutive samples must agree.
 * - 0b111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define CMP_RD_CR0_FILTER_CNT(base) ((CMP_CR0_REG(base) & CMP_CR0_FILTER_CNT_MASK) >> CMP_CR0_FILTER_CNT_SHIFT)
#define CMP_BRD_CR0_FILTER_CNT(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_CR0_FILTER_CNT(base, value) (CMP_RMW_CR0(base, CMP_CR0_FILTER_CNT_MASK, CMP_CR0_FILTER_CNT(value)))
#define CMP_BWR_CR0_FILTER_CNT(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_FILTER_CNT_SHIFT), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define CMP_RD_CR1(base)         (CMP_CR1_REG(base))
#define CMP_WR_CR1(base, value)  (CMP_CR1_REG(base) = (value))
#define CMP_RMW_CR1(base, mask, value) (CMP_WR_CR1(base, (CMP_RD_CR1(base) & ~(mask)) | (value)))
#define CMP_SET_CR1(base, value) (BME_OR8(&CMP_CR1_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR1(base, value) (BME_AND8(&CMP_CR1_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR1(base, value) (BME_XOR8(&CMP_CR1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0b0 - Analog Comparator is disabled.
 * - 0b1 - Analog Comparator is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_EN field. */
#define CMP_RD_CR1_EN(base)  ((CMP_CR1_REG(base) & CMP_CR1_EN_MASK) >> CMP_CR1_EN_SHIFT)
#define CMP_BRD_CR1_EN(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_CR1_EN(base, value) (CMP_RMW_CR1(base, CMP_CR1_EN_MASK, CMP_CR1_EN(value)))
#define CMP_BWR_CR1_EN(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_EN_SHIFT), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0b0 - CMPO is not available on the associated CMPO output pin. If the
 *     comparator does not own the pin, this field has no effect.
 * - 0b1 - CMPO is available on the associated CMPO output pin. The comparator
 *     output (CMPO) is driven out on the associated CMPO output pin if the
 *     comparator owns the pin. If the comparator does not own the field, this bit has
 *     no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_OPE field. */
#define CMP_RD_CR1_OPE(base) ((CMP_CR1_REG(base) & CMP_CR1_OPE_MASK) >> CMP_CR1_OPE_SHIFT)
#define CMP_BRD_CR1_OPE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_CR1_OPE(base, value) (CMP_RMW_CR1(base, CMP_CR1_OPE_MASK, CMP_CR1_OPE(value)))
#define CMP_BWR_CR1_OPE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_OPE_SHIFT), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0b0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 0b1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_COS field. */
#define CMP_RD_CR1_COS(base) ((CMP_CR1_REG(base) & CMP_CR1_COS_MASK) >> CMP_CR1_COS_SHIFT)
#define CMP_BRD_CR1_COS(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_CR1_COS(base, value) (CMP_RMW_CR1(base, CMP_CR1_COS_MASK, CMP_CR1_COS(value)))
#define CMP_BWR_CR1_COS(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_COS_SHIFT), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0b0 - Does not invert the comparator output.
 * - 0b1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_INV field. */
#define CMP_RD_CR1_INV(base) ((CMP_CR1_REG(base) & CMP_CR1_INV_MASK) >> CMP_CR1_INV_SHIFT)
#define CMP_BRD_CR1_INV(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))

/*! @brief Set the INV field to a new value. */
#define CMP_WR_CR1_INV(base, value) (CMP_RMW_CR1(base, CMP_CR1_INV_MASK, CMP_CR1_INV(value)))
#define CMP_BWR_CR1_INV(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_INV_SHIFT), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0b0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 0b1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has
 *     faster output propagation delay and higher current consumption.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define CMP_RD_CR1_PMODE(base) ((CMP_CR1_REG(base) & CMP_CR1_PMODE_MASK) >> CMP_CR1_PMODE_SHIFT)
#define CMP_BRD_CR1_PMODE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_CR1_PMODE(base, value) (CMP_RMW_CR1(base, CMP_CR1_PMODE_MASK, CMP_CR1_PMODE(value)))
#define CMP_BWR_CR1_PMODE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_PMODE_SHIFT), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field TRIGM[5] (RW)
 *
 * CMP and DAC are configured to CMP Trigger mode when CMP_CR1[TRIGM] is set to
 * 1. In addition, the CMP should be enabled. If the DAC is to be used as a
 * reference to the CMP, it should also be enabled. CMP Trigger mode depends on an
 * external timer resource to periodically enable the CMP and 6-bit DAC in order to
 * generate a triggered compare. Upon setting TRIGM, the CMP and DAC are placed
 * in a standby state until an external timer resource trigger is received. See
 * the chip configuration for details about the external timer resource.
 *
 * Values:
 * - 0b0 - Trigger mode is disabled.
 * - 0b1 - Trigger mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_TRIGM field. */
#define CMP_RD_CR1_TRIGM(base) ((CMP_CR1_REG(base) & CMP_CR1_TRIGM_MASK) >> CMP_CR1_TRIGM_SHIFT)
#define CMP_BRD_CR1_TRIGM(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))

/*! @brief Set the TRIGM field to a new value. */
#define CMP_WR_CR1_TRIGM(base, value) (CMP_RMW_CR1(base, CMP_CR1_TRIGM_MASK, CMP_CR1_TRIGM(value)))
#define CMP_BWR_CR1_TRIGM(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_TRIGM_SHIFT), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * 1s to both field locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0b0 - Windowing mode is not selected.
 * - 0b1 - Windowing mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_WE field. */
#define CMP_RD_CR1_WE(base)  ((CMP_CR1_REG(base) & CMP_CR1_WE_MASK) >> CMP_CR1_WE_SHIFT)
#define CMP_BRD_CR1_WE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_CR1_WE(base, value) (CMP_RMW_CR1(base, CMP_CR1_WE_MASK, CMP_CR1_WE(value)))
#define CMP_BWR_CR1_WE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_WE_SHIFT), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * 1s to both field locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0b0 - Sampling mode is not selected.
 * - 0b1 - Sampling mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_SE field. */
#define CMP_RD_CR1_SE(base)  ((CMP_CR1_REG(base) & CMP_CR1_SE_MASK) >> CMP_CR1_SE_SHIFT)
#define CMP_BRD_CR1_SE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_CR1_SE(base, value) (CMP_RMW_CR1(base, CMP_CR1_SE_MASK, CMP_CR1_SE(value)))
#define CMP_BWR_CR1_SE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_SE_SHIFT), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define CMP_RD_FPR(base)         (CMP_FPR_REG(base))
#define CMP_WR_FPR(base, value)  (CMP_FPR_REG(base) = (value))
#define CMP_RMW_FPR(base, mask, value) (CMP_WR_FPR(base, (CMP_RD_FPR(base) & ~(mask)) | (value)))
#define CMP_SET_FPR(base, value) (BME_OR8(&CMP_FPR_REG(base), (uint8_t)(value)))
#define CMP_CLR_FPR(base, value) (BME_AND8(&CMP_FPR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_FPR(base, value) (BME_XOR8(&CMP_FPR_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define CMP_RD_SCR(base)         (CMP_SCR_REG(base))
#define CMP_WR_SCR(base, value)  (CMP_SCR_REG(base) = (value))
#define CMP_RMW_SCR(base, mask, value) (CMP_WR_SCR(base, (CMP_RD_SCR(base) & ~(mask)) | (value)))
#define CMP_SET_SCR(base, value) (BME_OR8(&CMP_SCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_SCR(base, value) (BME_AND8(&CMP_SCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_SCR(base, value) (BME_XOR8(&CMP_SCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_COUT field. */
#define CMP_RD_SCR_COUT(base) ((CMP_SCR_REG(base) & CMP_SCR_COUT_MASK) >> CMP_SCR_COUT_SHIFT)
#define CMP_BRD_SCR_COUT(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_COUT_SHIFT, CMP_SCR_COUT_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is level sensitive .
 *
 * Values:
 * - 0b0 - Falling-edge on COUT has not been detected.
 * - 0b1 - Falling-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFF field. */
#define CMP_RD_SCR_CFF(base) ((CMP_SCR_REG(base) & CMP_SCR_CFF_MASK) >> CMP_SCR_CFF_SHIFT)
#define CMP_BRD_SCR_CFF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_SCR_CFF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_CFF(value)))
#define CMP_BWR_SCR_CFF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFF_SHIFT), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is level sensitive .
 *
 * Values:
 * - 0b0 - Rising-edge on COUT has not been detected.
 * - 0b1 - Rising-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFR field. */
#define CMP_RD_SCR_CFR(base) ((CMP_SCR_REG(base) & CMP_SCR_CFR_MASK) >> CMP_SCR_CFR_SHIFT)
#define CMP_BRD_SCR_CFR(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_SCR_CFR(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK), CMP_SCR_CFR(value)))
#define CMP_BWR_SCR_CFR(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFR_SHIFT), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IEF field. */
#define CMP_RD_SCR_IEF(base) ((CMP_SCR_REG(base) & CMP_SCR_IEF_MASK) >> CMP_SCR_IEF_SHIFT)
#define CMP_BRD_SCR_IEF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_SCR_IEF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IEF_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IEF(value)))
#define CMP_BWR_SCR_IEF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IEF_SHIFT), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IER field. */
#define CMP_RD_SCR_IER(base) ((CMP_SCR_REG(base) & CMP_SCR_IER_MASK) >> CMP_SCR_IER_SHIFT)
#define CMP_BRD_SCR_IER(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_SCR_IER(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IER_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IER(value)))
#define CMP_BWR_SCR_IER(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IER_SHIFT), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define CMP_RD_SCR_DMAEN(base) ((CMP_SCR_REG(base) & CMP_SCR_DMAEN_MASK) >> CMP_SCR_DMAEN_SHIFT)
#define CMP_BRD_SCR_DMAEN(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_SCR_DMAEN(base, value) (CMP_RMW_SCR(base, (CMP_SCR_DMAEN_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_DMAEN(value)))
#define CMP_BWR_SCR_DMAEN(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_DMAEN_SHIFT), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define CMP_RD_DACCR(base)       (CMP_DACCR_REG(base))
#define CMP_WR_DACCR(base, value) (CMP_DACCR_REG(base) = (value))
#define CMP_RMW_DACCR(base, mask, value) (CMP_WR_DACCR(base, (CMP_RD_DACCR(base) & ~(mask)) | (value)))
#define CMP_SET_DACCR(base, value) (BME_OR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_DACCR(base, value) (BME_AND8(&CMP_DACCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_DACCR(base, value) (BME_XOR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define CMP_RD_DACCR_VOSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VOSEL_MASK) >> CMP_DACCR_VOSEL_SHIFT)
#define CMP_BRD_DACCR_VOSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_DACCR_VOSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VOSEL_MASK, CMP_DACCR_VOSEL(value)))
#define CMP_BWR_DACCR_VOSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VOSEL_SHIFT), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0b0 - Vin1 is selected as resistor ladder network supply reference.
 * - 0b1 - Vin2 is selected as resistor ladder network supply reference.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define CMP_RD_DACCR_VRSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VRSEL_MASK) >> CMP_DACCR_VRSEL_SHIFT)
#define CMP_BRD_DACCR_VRSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_DACCR_VRSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VRSEL_MASK, CMP_DACCR_VRSEL(value)))
#define CMP_BWR_DACCR_VRSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VRSEL_SHIFT), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0b0 - DAC is disabled.
 * - 0b1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define CMP_RD_DACCR_DACEN(base) ((CMP_DACCR_REG(base) & CMP_DACCR_DACEN_MASK) >> CMP_DACCR_DACEN_SHIFT)
#define CMP_BRD_DACCR_DACEN(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_DACCR_DACEN(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_DACEN_MASK, CMP_DACCR_DACEN(value)))
#define CMP_BWR_DACCR_DACEN(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_DACEN_SHIFT), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define CMP_RD_MUXCR(base)       (CMP_MUXCR_REG(base))
#define CMP_WR_MUXCR(base, value) (CMP_MUXCR_REG(base) = (value))
#define CMP_RMW_MUXCR(base, mask, value) (CMP_WR_MUXCR(base, (CMP_RD_MUXCR(base) & ~(mask)) | (value)))
#define CMP_SET_MUXCR(base, value) (BME_OR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_MUXCR(base, value) (BME_AND8(&CMP_MUXCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_MUXCR(base, value) (BME_XOR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define CMP_RD_MUXCR_MSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_MSEL_MASK) >> CMP_MUXCR_MSEL_SHIFT)
#define CMP_BRD_MUXCR_MSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_MUXCR_MSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_MSEL_MASK, CMP_MUXCR_MSEL(value)))
#define CMP_BWR_MUXCR_MSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_MSEL_SHIFT), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define CMP_RD_MUXCR_PSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSEL_MASK) >> CMP_MUXCR_PSEL_SHIFT)
#define CMP_BRD_MUXCR_PSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_MUXCR_PSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSEL_MASK, CMP_MUXCR_PSEL(value)))
#define CMP_BWR_MUXCR_PSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_PSEL_SHIFT), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSTM[7] (RW)
 *
 * This bit is used to enable to MUX pass through mode. Pass through mode is
 * always available but for some devices this feature must be always disabled due to
 * the lack of package pins.
 *
 * Values:
 * - 0b0 - Pass Through Mode is disabled.
 * - 0b1 - Pass Through Mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSTM field. */
#define CMP_RD_MUXCR_PSTM(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSTM_MASK) >> CMP_MUXCR_PSTM_SHIFT)
#define CMP_BRD_MUXCR_PSTM(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_PSTM_SHIFT, CMP_MUXCR_PSTM_WIDTH))

/*! @brief Set the PSTM field to a new value. */
#define CMP_WR_MUXCR_PSTM(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSTM_MASK, CMP_MUXCR_PSTM(value)))
#define CMP_BWR_MUXCR_PSTM(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_PSTM_SHIFT), CMP_MUXCR_PSTM_SHIFT, CMP_MUXCR_PSTM_WIDTH))
/*@}*/

/*
 * MKL28Z7 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - CRC_DATAL - CRC_DATAL register.
 * - CRC_DATAH - CRC_DATAH register.
 * - CRC_DATALL - CRC_DATALL register.
 * - CRC_DATALU - CRC_DATALU register.
 * - CRC_DATAHL - CRC_DATAHL register.
 * - CRC_DATAHU - CRC_DATAHU register.
 * - CRC_DATA - CRC Data register
 * - CRC_GPOLY - CRC Polynomial register
 * - CRC_GPOLYL - CRC_GPOLYL register.
 * - CRC_GPOLYH - CRC_GPOLYH register.
 * - CRC_GPOLYLL - CRC_GPOLYLL register.
 * - CRC_GPOLYLU - CRC_GPOLYLU register.
 * - CRC_GPOLYHL - CRC_GPOLYHL register.
 * - CRC_GPOLYHU - CRC_GPOLYHU register.
 * - CRC_CTRL - CRC Control register
 * - CRC_CTRLHU - CRC_CTRLHU register.
 */

#define CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define CRC_IDX (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * CRC_DATALL - CRC_DATALL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALL - CRC_DATALL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALL register
 */
/*@{*/
#define CRC_RD_DATALL(base)      (CRC_DATALL_REG(base))
#define CRC_WR_DATALL(base, value) (CRC_DATALL_REG(base) = (value))
#define CRC_RMW_DATALL(base, mask, value) (CRC_WR_DATALL(base, (CRC_RD_DATALL(base) & ~(mask)) | (value)))
#define CRC_SET_DATALL(base, value) (BME_OR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALL(base, value) (BME_AND8(&CRC_DATALL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALL(base, value) (BME_XOR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAL - CRC_DATAL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAL - CRC_DATAL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAL register
 */
/*@{*/
#define CRC_RD_DATAL(base)       (CRC_DATAL_REG(base))
#define CRC_WR_DATAL(base, value) (CRC_DATAL_REG(base) = (value))
#define CRC_RMW_DATAL(base, mask, value) (CRC_WR_DATAL(base, (CRC_RD_DATAL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAL(base, value) (BME_OR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAL(base, value) (BME_AND16(&CRC_DATAL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAL(base, value) (BME_XOR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATA - CRC Data register
 ******************************************************************************/

/*!
 * @brief CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC Data register contains the value of the seed, data, and checksum.
 * When CTRL[WAS] is set, any write to the data register is regarded as the seed
 * value. When CTRL[WAS] is cleared, any write to the data register is regarded as
 * data for general CRC computation. In 16-bit CRC mode, the HU and HL fields are
 * not used for programming the seed value, and reads of these fields return an
 * indeterminate value. In 32-bit CRC mode, all fields are used for programming
 * the seed value. When programming data values, the values can be written 8 bits,
 * 16 bits, or 32 bits at a time, provided all bytes are contiguous; with MSB of
 * data value written first. After all data values are written, the CRC result
 * can be read from this data register. In 16-bit CRC mode, the CRC result is
 * available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value,
 * provided the CRC module is configured.
 */
/*!
 * @name Constants and macros for entire CRC_DATA register
 */
/*@{*/
#define CRC_RD_DATA(base)        (CRC_DATA_REG(base))
#define CRC_WR_DATA(base, value) (CRC_DATA_REG(base) = (value))
#define CRC_RMW_DATA(base, mask, value) (CRC_WR_DATA(base, (CRC_RD_DATA(base) & ~(mask)) | (value)))
#define CRC_SET_DATA(base, value) (BME_OR32(&CRC_DATA_REG(base), (uint32_t)(value)))
#define CRC_CLR_DATA(base, value) (BME_AND32(&CRC_DATA_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_DATA(base, value) (BME_XOR32(&CRC_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATA bitfields
 */

/*!
 * @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LL field. */
#define CRC_RD_DATA_LL(base) ((CRC_DATA_REG(base) & CRC_DATA_LL_MASK) >> CRC_DATA_LL_SHIFT)
#define CRC_BRD_DATA_LL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))

/*! @brief Set the LL field to a new value. */
#define CRC_WR_DATA_LL(base, value) (CRC_RMW_DATA(base, CRC_DATA_LL_MASK, CRC_DATA_LL(value)))
#define CRC_BWR_DATA_LL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LL_SHIFT), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LU field. */
#define CRC_RD_DATA_LU(base) ((CRC_DATA_REG(base) & CRC_DATA_LU_MASK) >> CRC_DATA_LU_SHIFT)
#define CRC_BRD_DATA_LU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))

/*! @brief Set the LU field to a new value. */
#define CRC_WR_DATA_LU(base, value) (CRC_RMW_DATA(base, CRC_DATA_LU_MASK, CRC_DATA_LU(value)))
#define CRC_BWR_DATA_LU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LU_SHIFT), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HL field. */
#define CRC_RD_DATA_HL(base) ((CRC_DATA_REG(base) & CRC_DATA_HL_MASK) >> CRC_DATA_HL_SHIFT)
#define CRC_BRD_DATA_HL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))

/*! @brief Set the HL field to a new value. */
#define CRC_WR_DATA_HL(base, value) (CRC_RMW_DATA(base, CRC_DATA_HL_MASK, CRC_DATA_HL(value)))
#define CRC_BWR_DATA_HL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HL_SHIFT), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HU field. */
#define CRC_RD_DATA_HU(base) ((CRC_DATA_REG(base) & CRC_DATA_HU_MASK) >> CRC_DATA_HU_SHIFT)
#define CRC_BRD_DATA_HU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))

/*! @brief Set the HU field to a new value. */
#define CRC_WR_DATA_HU(base, value) (CRC_RMW_DATA(base, CRC_DATA_HU_MASK, CRC_DATA_HU(value)))
#define CRC_BWR_DATA_HU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HU_SHIFT), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_DATALU - CRC_DATALU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALU - CRC_DATALU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALU register
 */
/*@{*/
#define CRC_RD_DATALU(base)      (CRC_DATALU_REG(base))
#define CRC_WR_DATALU(base, value) (CRC_DATALU_REG(base) = (value))
#define CRC_RMW_DATALU(base, mask, value) (CRC_WR_DATALU(base, (CRC_RD_DATALU(base) & ~(mask)) | (value)))
#define CRC_SET_DATALU(base, value) (BME_OR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALU(base, value) (BME_AND8(&CRC_DATALU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALU(base, value) (BME_XOR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHL - CRC_DATAHL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHL - CRC_DATAHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHL register
 */
/*@{*/
#define CRC_RD_DATAHL(base)      (CRC_DATAHL_REG(base))
#define CRC_WR_DATAHL(base, value) (CRC_DATAHL_REG(base) = (value))
#define CRC_RMW_DATAHL(base, mask, value) (CRC_WR_DATAHL(base, (CRC_RD_DATAHL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHL(base, value) (BME_OR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHL(base, value) (BME_AND8(&CRC_DATAHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHL(base, value) (BME_XOR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAH - CRC_DATAH register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAH - CRC_DATAH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAH register
 */
/*@{*/
#define CRC_RD_DATAH(base)       (CRC_DATAH_REG(base))
#define CRC_WR_DATAH(base, value) (CRC_DATAH_REG(base) = (value))
#define CRC_RMW_DATAH(base, mask, value) (CRC_WR_DATAH(base, (CRC_RD_DATAH(base) & ~(mask)) | (value)))
#define CRC_SET_DATAH(base, value) (BME_OR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAH(base, value) (BME_AND16(&CRC_DATAH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAH(base, value) (BME_XOR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHU - CRC_DATAHU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHU - CRC_DATAHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHU register
 */
/*@{*/
#define CRC_RD_DATAHU(base)      (CRC_DATAHU_REG(base))
#define CRC_WR_DATAHU(base, value) (CRC_DATAHU_REG(base) = (value))
#define CRC_RMW_DATAHU(base, mask, value) (CRC_WR_DATAHU(base, (CRC_RD_DATAHU(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHU(base, value) (BME_OR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHU(base, value) (BME_AND8(&CRC_DATAHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHU(base, value) (BME_XOR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLL - CRC_GPOLYLL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLL - CRC_GPOLYLL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLL register
 */
/*@{*/
#define CRC_RD_GPOLYLL(base)     (CRC_GPOLYLL_REG(base))
#define CRC_WR_GPOLYLL(base, value) (CRC_GPOLYLL_REG(base) = (value))
#define CRC_RMW_GPOLYLL(base, mask, value) (CRC_WR_GPOLYLL(base, (CRC_RD_GPOLYLL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLL(base, value) (BME_OR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLL(base, value) (BME_AND8(&CRC_GPOLYLL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLL(base, value) (BME_XOR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLY - CRC Polynomial register
 ******************************************************************************/

/*!
 * @brief CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define CRC_RD_GPOLY(base)       (CRC_GPOLY_REG(base))
#define CRC_WR_GPOLY(base, value) (CRC_GPOLY_REG(base) = (value))
#define CRC_RMW_GPOLY(base, mask, value) (CRC_WR_GPOLY(base, (CRC_RD_GPOLY(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLY(base, value) (BME_OR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
#define CRC_CLR_GPOLY(base, value) (BME_AND32(&CRC_GPOLY_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_GPOLY(base, value) (BME_XOR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define CRC_RD_GPOLY_LOW(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_LOW_MASK) >> CRC_GPOLY_LOW_SHIFT)
#define CRC_BRD_GPOLY_LOW(base) (CRC_RD_GPOLY_LOW(base))

/*! @brief Set the LOW field to a new value. */
#define CRC_WR_GPOLY_LOW(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_LOW_MASK, CRC_GPOLY_LOW(value)))
#define CRC_BWR_GPOLY_LOW(base, value) (CRC_WR_GPOLY_LOW(base, value))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not
 * writable in 16-bit CRC mode (CTRL[TCRC] is 0).
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define CRC_RD_GPOLY_HIGH(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_HIGH_MASK) >> CRC_GPOLY_HIGH_SHIFT)
#define CRC_BRD_GPOLY_HIGH(base) (CRC_RD_GPOLY_HIGH(base))

/*! @brief Set the HIGH field to a new value. */
#define CRC_WR_GPOLY_HIGH(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_HIGH_MASK, CRC_GPOLY_HIGH(value)))
#define CRC_BWR_GPOLY_HIGH(base, value) (CRC_WR_GPOLY_HIGH(base, value))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYL - CRC_GPOLYL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYL - CRC_GPOLYL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYL register
 */
/*@{*/
#define CRC_RD_GPOLYL(base)      (CRC_GPOLYL_REG(base))
#define CRC_WR_GPOLYL(base, value) (CRC_GPOLYL_REG(base) = (value))
#define CRC_RMW_GPOLYL(base, mask, value) (CRC_WR_GPOLYL(base, (CRC_RD_GPOLYL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYL(base, value) (BME_OR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYL(base, value) (BME_AND16(&CRC_GPOLYL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYL(base, value) (BME_XOR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLU - CRC_GPOLYLU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLU - CRC_GPOLYLU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLU register
 */
/*@{*/
#define CRC_RD_GPOLYLU(base)     (CRC_GPOLYLU_REG(base))
#define CRC_WR_GPOLYLU(base, value) (CRC_GPOLYLU_REG(base) = (value))
#define CRC_RMW_GPOLYLU(base, mask, value) (CRC_WR_GPOLYLU(base, (CRC_RD_GPOLYLU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLU(base, value) (BME_OR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLU(base, value) (BME_AND8(&CRC_GPOLYLU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLU(base, value) (BME_XOR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYH - CRC_GPOLYH register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYH - CRC_GPOLYH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYH register
 */
/*@{*/
#define CRC_RD_GPOLYH(base)      (CRC_GPOLYH_REG(base))
#define CRC_WR_GPOLYH(base, value) (CRC_GPOLYH_REG(base) = (value))
#define CRC_RMW_GPOLYH(base, mask, value) (CRC_WR_GPOLYH(base, (CRC_RD_GPOLYH(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYH(base, value) (BME_OR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYH(base, value) (BME_AND16(&CRC_GPOLYH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYH(base, value) (BME_XOR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHL - CRC_GPOLYHL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHL - CRC_GPOLYHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHL register
 */
/*@{*/
#define CRC_RD_GPOLYHL(base)     (CRC_GPOLYHL_REG(base))
#define CRC_WR_GPOLYHL(base, value) (CRC_GPOLYHL_REG(base) = (value))
#define CRC_RMW_GPOLYHL(base, mask, value) (CRC_WR_GPOLYHL(base, (CRC_RD_GPOLYHL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHL(base, value) (BME_OR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHL(base, value) (BME_AND8(&CRC_GPOLYHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHL(base, value) (BME_XOR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHU - CRC_GPOLYHU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHU - CRC_GPOLYHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHU register
 */
/*@{*/
#define CRC_RD_GPOLYHU(base)     (CRC_GPOLYHU_REG(base))
#define CRC_WR_GPOLYHU(base, value) (CRC_GPOLYHU_REG(base) = (value))
#define CRC_RMW_GPOLYHU(base, mask, value) (CRC_WR_GPOLYHU(base, (CRC_RD_GPOLYHU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHU(base, value) (BME_OR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHU(base, value) (BME_AND8(&CRC_GPOLYHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHU(base, value) (BME_XOR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_CTRL - CRC Control register
 ******************************************************************************/

/*!
 * @brief CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting CTRL[WAS] and then writing the seed into
 * the CRC data register.
 */
/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define CRC_RD_CTRL(base)        (CRC_CTRL_REG(base))
#define CRC_WR_CTRL(base, value) (CRC_CTRL_REG(base) = (value))
#define CRC_RMW_CTRL(base, mask, value) (CRC_WR_CTRL(base, (CRC_RD_CTRL(base) & ~(mask)) | (value)))
#define CRC_SET_CTRL(base, value) (BME_OR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
#define CRC_CLR_CTRL(base, value) (BME_AND32(&CRC_CTRL_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_CTRL(base, value) (BME_XOR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0b0 - 16-bit CRC protocol.
 * - 0b1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define CRC_RD_CTRL_TCRC(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TCRC_MASK) >> CRC_CTRL_TCRC_SHIFT)
#define CRC_BRD_CTRL_TCRC(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRL_TCRC(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TCRC_MASK, CRC_CTRL_TCRC(value)))
#define CRC_BWR_CTRL_TCRC(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TCRC_SHIFT), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed
 * value. When deasserted, a value written to the CRC data register is taken as
 * data for CRC computation.
 *
 * Values:
 * - 0b0 - Writes to the CRC data register are data values.
 * - 0b1 - Writes to the CRC data register are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define CRC_RD_CTRL_WAS(base) ((CRC_CTRL_REG(base) & CRC_CTRL_WAS_MASK) >> CRC_CTRL_WAS_SHIFT)
#define CRC_BRD_CTRL_WAS(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRL_WAS(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_WAS_MASK, CRC_CTRL_WAS(value)))
#define CRC_BWR_CTRL_WAS(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_WAS_SHIFT), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0b0 - No XOR on reading.
 * - 0b1 - Invert or complement the read value of the CRC Data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define CRC_RD_CTRL_FXOR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_FXOR_MASK) >> CRC_CTRL_FXOR_SHIFT)
#define CRC_BRD_CTRL_FXOR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRL_FXOR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_FXOR_MASK, CRC_CTRL_FXOR(value)))
#define CRC_BWR_CTRL_FXOR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_FXOR_SHIFT), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * Identifies the transpose configuration of the value read from the CRC Data
 * register. See the description of the transpose feature for the available
 * transpose options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define CRC_RD_CTRL_TOTR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT)
#define CRC_BRD_CTRL_TOTR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRL_TOTR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOTR_MASK, CRC_CTRL_TOTR(value)))
#define CRC_BWR_CTRL_TOTR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOTR_SHIFT), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * Defines the transpose configuration of the data written to the CRC data
 * register. See the description of the transpose feature for the available transpose
 * options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define CRC_RD_CTRL_TOT(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOT_MASK) >> CRC_CTRL_TOT_SHIFT)
#define CRC_BRD_CTRL_TOT(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRL_TOT(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOT_MASK, CRC_CTRL_TOT(value)))
#define CRC_BWR_CTRL_TOT(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOT_SHIFT), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_CTRLHU - CRC_CTRLHU register.
 ******************************************************************************/

/*!
 * @brief CRC_CTRLHU - CRC_CTRLHU register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CRC_CTRLHU register
 */
/*@{*/
#define CRC_RD_CTRLHU(base)      (CRC_CTRLHU_REG(base))
#define CRC_WR_CTRLHU(base, value) (CRC_CTRLHU_REG(base) = (value))
#define CRC_RMW_CTRLHU(base, mask, value) (CRC_WR_CTRLHU(base, (CRC_RD_CTRLHU(base) & ~(mask)) | (value)))
#define CRC_SET_CTRLHU(base, value) (BME_OR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_CTRLHU(base, value) (BME_AND8(&CRC_CTRLHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_CTRLHU(base, value) (BME_XOR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRLHU bitfields
 */

/*!
 * @name Register CRC_CTRLHU, field TCRC[0] (RW)
 *
 * Values:
 * - 0b0 - 16-bit CRC protocol.
 * - 0b1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TCRC field. */
#define CRC_RD_CTRLHU_TCRC(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TCRC_MASK) >> CRC_CTRLHU_TCRC_SHIFT)
#define CRC_BRD_CTRLHU_TCRC(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRLHU_TCRC(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TCRC_MASK, CRC_CTRLHU_TCRC(value)))
#define CRC_BWR_CTRLHU_TCRC(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TCRC_SHIFT), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field WAS[1] (RW)
 *
 * Values:
 * - 0b0 - Writes to CRC data register are data values.
 * - 0b1 - Writes to CRC data reguster are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_WAS field. */
#define CRC_RD_CTRLHU_WAS(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_WAS_MASK) >> CRC_CTRLHU_WAS_SHIFT)
#define CRC_BRD_CTRLHU_WAS(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRLHU_WAS(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_WAS_MASK, CRC_CTRLHU_WAS(value)))
#define CRC_BWR_CTRLHU_WAS(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_WAS_SHIFT), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field FXOR[2] (RW)
 *
 * Values:
 * - 0b0 - No XOR on reading.
 * - 0b1 - Invert or complement the read value of CRC data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_FXOR field. */
#define CRC_RD_CTRLHU_FXOR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_FXOR_MASK) >> CRC_CTRLHU_FXOR_SHIFT)
#define CRC_BRD_CTRLHU_FXOR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRLHU_FXOR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_FXOR_MASK, CRC_CTRLHU_FXOR(value)))
#define CRC_BWR_CTRLHU_FXOR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_FXOR_SHIFT), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOTR[5:4] (RW)
 *
 * Values:
 * - 0b00 - No Transposition.
 * - 0b01 - Bits in bytes are transposed, bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOTR field. */
#define CRC_RD_CTRLHU_TOTR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOTR_MASK) >> CRC_CTRLHU_TOTR_SHIFT)
#define CRC_BRD_CTRLHU_TOTR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRLHU_TOTR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOTR_MASK, CRC_CTRLHU_TOTR(value)))
#define CRC_BWR_CTRLHU_TOTR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOTR_SHIFT), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOT[7:6] (RW)
 *
 * Values:
 * - 0b00 - No Transposition.
 * - 0b01 - Bits in bytes are transposed, bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOT field. */
#define CRC_RD_CTRLHU_TOT(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOT_MASK) >> CRC_CTRLHU_TOT_SHIFT)
#define CRC_BRD_CTRLHU_TOT(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRLHU_TOT(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOT_MASK, CRC_CTRLHU_TOT(value)))
#define CRC_BWR_CTRLHU_TOT(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOT_SHIFT), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))
/*@}*/

/*
 * MKL28Z7 DAC
 *
 * 12-Bit Digital-to-Analog Converter
 *
 * Registers defined in this header file:
 * - DAC_DATL - DAC Data Low Register
 * - DAC_DATH - DAC Data High Register
 * - DAC_SR - DAC Status Register
 * - DAC_C0 - DAC Control Register
 * - DAC_C1 - DAC Control Register 1
 * - DAC_C2 - DAC Control Register 2
 */

#define DAC_INSTANCE_COUNT (1U) /*!< Number of instances of the DAC module. */
#define DAC0_IDX (0U) /*!< Instance number for DAC0. */

/*******************************************************************************
 * DAC_DATL - DAC Data Low Register
 ******************************************************************************/

/*!
 * @brief DAC_DATL - DAC Data Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATL register
 */
/*@{*/
#define DAC_RD_DATL(base, index) (DAC_DATL_REG(base, index))
#define DAC_WR_DATL(base, index, value) (DAC_DATL_REG(base, index) = (value))
#define DAC_RMW_DATL(base, index, mask, value) (DAC_WR_DATL(base, index, (DAC_RD_DATL(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATL(base, index, value) (BME_OR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATL(base, index, value) (BME_AND8(&DAC_DATL_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATL(base, index, value) (BME_XOR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * DAC_DATH - DAC Data High Register
 ******************************************************************************/

/*!
 * @brief DAC_DATH - DAC Data High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATH register
 */
/*@{*/
#define DAC_RD_DATH(base, index) (DAC_DATH_REG(base, index))
#define DAC_WR_DATH(base, index, value) (DAC_DATH_REG(base, index) = (value))
#define DAC_RMW_DATH(base, index, mask, value) (DAC_WR_DATH(base, index, (DAC_RD_DATH(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATH(base, index, value) (BME_OR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATH(base, index, value) (BME_AND8(&DAC_DATH_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATH(base, index, value) (BME_XOR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATH bitfields
 */

/*!
 * @name Register DAC_DATH, field DATA1[3:0] (RW)
 *
 * When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula. V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA[11:0] is mapped to the 16-word buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_DATH_DATA1 field. */
#define DAC_RD_DATH_DATA1(base, index) ((DAC_DATH_REG(base, index) & DAC_DATH_DATA1_MASK) >> DAC_DATH_DATA1_SHIFT)
#define DAC_BRD_DATH_DATA1(base, index) (BME_UBFX8(&DAC_DATH_REG(base, index), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))

/*! @brief Set the DATA1 field to a new value. */
#define DAC_WR_DATH_DATA1(base, index, value) (DAC_RMW_DATH(base, index, DAC_DATH_DATA1_MASK, DAC_DATH_DATA1(value)))
#define DAC_BWR_DATH_DATA1(base, index, value) (BME_BFI8(&DAC_DATH_REG(base, index), ((uint8_t)(value) << DAC_DATH_DATA1_SHIFT), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_SR - DAC Status Register
 ******************************************************************************/

/*!
 * @brief DAC_SR - DAC Status Register (RW)
 *
 * Reset value: 0x02U
 *
 * If DMA is enabled, the flags can be cleared automatically by DMA when the DMA
 * request is done. Writing 0 to a field clears it whereas writing 1 has no
 * effect. After reset, DACBFRPTF is set and can be cleared by software, if needed.
 * The flags are set only when the data buffer status is changed. Do not use
 * 32/16-bit accesses to this register.
 */
/*!
 * @name Constants and macros for entire DAC_SR register
 */
/*@{*/
#define DAC_RD_SR(base)          (DAC_SR_REG(base))
#define DAC_WR_SR(base, value)   (DAC_SR_REG(base) = (value))
#define DAC_RMW_SR(base, mask, value) (DAC_WR_SR(base, (DAC_RD_SR(base) & ~(mask)) | (value)))
#define DAC_SET_SR(base, value)  (BME_OR8(&DAC_SR_REG(base), (uint8_t)(value)))
#define DAC_CLR_SR(base, value)  (BME_AND8(&DAC_SR_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_SR(base, value)  (BME_XOR8(&DAC_SR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_SR bitfields
 */

/*!
 * @name Register DAC_SR, field DACBFRPBF[0] (RW)
 *
 * In FIFO mode, it is FIFO FULL status bit. It means FIFO read pointer equals
 * Write Pointer because of Write Pointer increase. If this bit is set, any write
 * to FIFO from either DMA or CPU is ignored by DAC. It is cleared if there is
 * any DAC trigger making the DAC read pointer increase. Write to this bit is
 * ignored in FIFO mode.
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer is not equal to C2[DACBFUP].
 * - 0b1 - The DAC buffer read pointer is equal to C2[DACBFUP].
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPBF field. */
#define DAC_RD_SR_DACBFRPBF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPBF_MASK) >> DAC_SR_DACBFRPBF_SHIFT)
#define DAC_BRD_SR_DACBFRPBF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))

/*! @brief Set the DACBFRPBF field to a new value. */
#define DAC_WR_SR_DACBFRPBF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPBF_MASK, DAC_SR_DACBFRPBF(value)))
#define DAC_BWR_SR_DACBFRPBF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPBF_SHIFT), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFRPTF[1] (RW)
 *
 * In FIFO mode, it is FIFO nearly empty flag. It is set when only one data
 * remains in FIFO. Any DAC trigger does not increase the Read Pointer if this bit is
 * set to avoid any possible glitch or abrupt change at DAC output. It is
 * cleared automatically if FIFO is not empty.
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer is not zero.
 * - 0b1 - The DAC buffer read pointer is zero.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPTF field. */
#define DAC_RD_SR_DACBFRPTF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPTF_MASK) >> DAC_SR_DACBFRPTF_SHIFT)
#define DAC_BRD_SR_DACBFRPTF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))

/*! @brief Set the DACBFRPTF field to a new value. */
#define DAC_WR_SR_DACBFRPTF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPTF_MASK, DAC_SR_DACBFRPTF(value)))
#define DAC_BWR_SR_DACBFRPTF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPTF_SHIFT), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFWMF[2] (RW)
 *
 * This bit is set if the remaining FIFO data is less than the watermark
 * setting. It is cleared automatically by writing data into FIFO by DMA or CPU. Write
 * to this bit is ignored in FIFO mode.
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer has not reached the watermark level.
 * - 0b1 - The DAC buffer read pointer has reached the watermark level.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFWMF field. */
#define DAC_RD_SR_DACBFWMF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFWMF_MASK) >> DAC_SR_DACBFWMF_SHIFT)
#define DAC_BRD_SR_DACBFWMF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFWMF_SHIFT, DAC_SR_DACBFWMF_WIDTH))

/*! @brief Set the DACBFWMF field to a new value. */
#define DAC_WR_SR_DACBFWMF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFWMF_MASK, DAC_SR_DACBFWMF(value)))
#define DAC_BWR_SR_DACBFWMF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFWMF_SHIFT), DAC_SR_DACBFWMF_SHIFT, DAC_SR_DACBFWMF_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C0 - DAC Control Register
 ******************************************************************************/

/*!
 * @brief DAC_C0 - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register.
 */
/*!
 * @name Constants and macros for entire DAC_C0 register
 */
/*@{*/
#define DAC_RD_C0(base)          (DAC_C0_REG(base))
#define DAC_WR_C0(base, value)   (DAC_C0_REG(base) = (value))
#define DAC_RMW_C0(base, mask, value) (DAC_WR_C0(base, (DAC_RD_C0(base) & ~(mask)) | (value)))
#define DAC_SET_C0(base, value)  (BME_OR8(&DAC_C0_REG(base), (uint8_t)(value)))
#define DAC_CLR_C0(base, value)  (BME_AND8(&DAC_C0_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C0(base, value)  (BME_XOR8(&DAC_C0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C0 bitfields
 */

/*!
 * @name Register DAC_C0, field DACBBIEN[0] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer bottom flag interrupt is disabled.
 * - 0b1 - The DAC buffer read pointer bottom flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBBIEN field. */
#define DAC_RD_C0_DACBBIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBBIEN_MASK) >> DAC_C0_DACBBIEN_SHIFT)
#define DAC_BRD_C0_DACBBIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))

/*! @brief Set the DACBBIEN field to a new value. */
#define DAC_WR_C0_DACBBIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBBIEN_MASK, DAC_C0_DACBBIEN(value)))
#define DAC_BWR_C0_DACBBIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBBIEN_SHIFT), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBTIEN[1] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer top flag interrupt is disabled.
 * - 0b1 - The DAC buffer read pointer top flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBTIEN field. */
#define DAC_RD_C0_DACBTIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBTIEN_MASK) >> DAC_C0_DACBTIEN_SHIFT)
#define DAC_BRD_C0_DACBTIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))

/*! @brief Set the DACBTIEN field to a new value. */
#define DAC_WR_C0_DACBTIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBTIEN_MASK, DAC_C0_DACBTIEN(value)))
#define DAC_BWR_C0_DACBTIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBTIEN_SHIFT), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBWIEN[2] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer watermark interrupt is disabled.
 * - 0b1 - The DAC buffer watermark interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBWIEN field. */
#define DAC_RD_C0_DACBWIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBWIEN_MASK) >> DAC_C0_DACBWIEN_SHIFT)
#define DAC_BRD_C0_DACBWIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBWIEN_SHIFT, DAC_C0_DACBWIEN_WIDTH))

/*! @brief Set the DACBWIEN field to a new value. */
#define DAC_WR_C0_DACBWIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBWIEN_MASK, DAC_C0_DACBWIEN(value)))
#define DAC_BWR_C0_DACBWIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBWIEN_SHIFT), DAC_C0_DACBWIEN_SHIFT, DAC_C0_DACBWIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field LPEN[3] (RW)
 *
 * See the 12-bit DAC electrical characteristics of the device data sheet for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0b0 - High-Power mode
 * - 0b1 - Low-Power mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_LPEN field. */
#define DAC_RD_C0_LPEN(base) ((DAC_C0_REG(base) & DAC_C0_LPEN_MASK) >> DAC_C0_LPEN_SHIFT)
#define DAC_BRD_C0_LPEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))

/*! @brief Set the LPEN field to a new value. */
#define DAC_WR_C0_LPEN(base, value) (DAC_RMW_C0(base, DAC_C0_LPEN_MASK, DAC_C0_LPEN(value)))
#define DAC_BWR_C0_LPEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_LPEN_SHIFT), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACSWTRG[4] (WORZ)
 *
 * Active high. This is a write-only field, which always reads 0. If DAC
 * software trigger is selected and buffer is enabled, writing 1 to this field will
 * advance the buffer read pointer once.
 *
 * Values:
 * - 0b0 - The DAC soft trigger is not valid.
 * - 0b1 - The DAC soft trigger is valid.
 */
/*@{*/
/*! @brief Set the DACSWTRG field to a new value. */
#define DAC_WR_C0_DACSWTRG(base, value) (DAC_RMW_C0(base, DAC_C0_DACSWTRG_MASK, DAC_C0_DACSWTRG(value)))
#define DAC_BWR_C0_DACSWTRG(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACSWTRG_SHIFT), DAC_C0_DACSWTRG_SHIFT, DAC_C0_DACSWTRG_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACTRGSEL[5] (RW)
 *
 * Values:
 * - 0b0 - The DAC hardware trigger is selected.
 * - 0b1 - The DAC software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACTRGSEL field. */
#define DAC_RD_C0_DACTRGSEL(base) ((DAC_C0_REG(base) & DAC_C0_DACTRGSEL_MASK) >> DAC_C0_DACTRGSEL_SHIFT)
#define DAC_BRD_C0_DACTRGSEL(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))

/*! @brief Set the DACTRGSEL field to a new value. */
#define DAC_WR_C0_DACTRGSEL(base, value) (DAC_RMW_C0(base, DAC_C0_DACTRGSEL_MASK, DAC_C0_DACTRGSEL(value)))
#define DAC_BWR_C0_DACTRGSEL(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACTRGSEL_SHIFT), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACRFS[6] (RW)
 *
 * Values:
 * - 0b0 - The DAC selects DACREF_1 as the reference voltage.
 * - 0b1 - The DAC selects DACREF_2 as the reference voltage.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACRFS field. */
#define DAC_RD_C0_DACRFS(base) ((DAC_C0_REG(base) & DAC_C0_DACRFS_MASK) >> DAC_C0_DACRFS_SHIFT)
#define DAC_BRD_C0_DACRFS(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))

/*! @brief Set the DACRFS field to a new value. */
#define DAC_WR_C0_DACRFS(base, value) (DAC_RMW_C0(base, DAC_C0_DACRFS_MASK, DAC_C0_DACRFS(value)))
#define DAC_BWR_C0_DACRFS(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACRFS_SHIFT), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACEN[7] (RW)
 *
 * Starts the Programmable Reference Generator operation.
 *
 * Values:
 * - 0b0 - The DAC system is disabled.
 * - 0b1 - The DAC system is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACEN field. */
#define DAC_RD_C0_DACEN(base) ((DAC_C0_REG(base) & DAC_C0_DACEN_MASK) >> DAC_C0_DACEN_SHIFT)
#define DAC_BRD_C0_DACEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define DAC_WR_C0_DACEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACEN_MASK, DAC_C0_DACEN(value)))
#define DAC_BWR_C0_DACEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACEN_SHIFT), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C1 - DAC Control Register 1
 ******************************************************************************/

/*!
 * @brief DAC_C1 - DAC Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Do not use 32- or 16-bit accesses to this register.
 */
/*!
 * @name Constants and macros for entire DAC_C1 register
 */
/*@{*/
#define DAC_RD_C1(base)          (DAC_C1_REG(base))
#define DAC_WR_C1(base, value)   (DAC_C1_REG(base) = (value))
#define DAC_RMW_C1(base, mask, value) (DAC_WR_C1(base, (DAC_RD_C1(base) & ~(mask)) | (value)))
#define DAC_SET_C1(base, value)  (BME_OR8(&DAC_C1_REG(base), (uint8_t)(value)))
#define DAC_CLR_C1(base, value)  (BME_AND8(&DAC_C1_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C1(base, value)  (BME_XOR8(&DAC_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C1 bitfields
 */

/*!
 * @name Register DAC_C1, field DACBFEN[0] (RW)
 *
 * Values:
 * - 0b0 - Buffer read pointer is disabled. The converted data is always the
 *     first word of the buffer.
 * - 0b1 - Buffer read pointer is enabled. The converted data is the word that
 *     the read pointer points to. It means converted data can be from any word of
 *     the buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFEN field. */
#define DAC_RD_C1_DACBFEN(base) ((DAC_C1_REG(base) & DAC_C1_DACBFEN_MASK) >> DAC_C1_DACBFEN_SHIFT)
#define DAC_BRD_C1_DACBFEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))

/*! @brief Set the DACBFEN field to a new value. */
#define DAC_WR_C1_DACBFEN(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFEN_MASK, DAC_C1_DACBFEN(value)))
#define DAC_BWR_C1_DACBFEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFEN_SHIFT), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFMD[2:1] (RW)
 *
 * Values:
 * - 0b00 - Normal mode
 * - 0b01 - Swing mode
 * - 0b10 - One-Time Scan mode
 * - 0b11 - FIFO mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFMD field. */
#define DAC_RD_C1_DACBFMD(base) ((DAC_C1_REG(base) & DAC_C1_DACBFMD_MASK) >> DAC_C1_DACBFMD_SHIFT)
#define DAC_BRD_C1_DACBFMD(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))

/*! @brief Set the DACBFMD field to a new value. */
#define DAC_WR_C1_DACBFMD(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFMD_MASK, DAC_C1_DACBFMD(value)))
#define DAC_BWR_C1_DACBFMD(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFMD_SHIFT), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFWM[4:3] (RW)
 *
 * In normal mode it controls when SR[DACBFWMF] is set. When the DAC buffer read
 * pointer reaches the word defined by this field, which is 1-4 words away from
 * the upper limit (DACBUP), SR[DACBFWMF] will be set. This allows user
 * configuration of the watermark interrupt. In FIFO mode, it is FIFO watermark select
 * field.
 *
 * Values:
 * - 0b00 - In normal mode, 1 word . In FIFO mode, 2 or less than 2 data
 *     remaining in FIFO will set watermark status bit.
 * - 0b01 - In normal mode, 2 words . In FIFO mode, Max/4 or less than Max/4
 *     data remaining in FIFO will set watermark status bit.
 * - 0b10 - In normal mode, 3 words . In FIFO mode, Max/2 or less than Max/2
 *     data remaining in FIFO will set watermark status bit.
 * - 0b11 - In normal mode, 4 words . In FIFO mode, Max-2 or less than Max-2
 *     data remaining in FIFO will set watermark status bit.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFWM field. */
#define DAC_RD_C1_DACBFWM(base) ((DAC_C1_REG(base) & DAC_C1_DACBFWM_MASK) >> DAC_C1_DACBFWM_SHIFT)
#define DAC_BRD_C1_DACBFWM(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFWM_SHIFT, DAC_C1_DACBFWM_WIDTH))

/*! @brief Set the DACBFWM field to a new value. */
#define DAC_WR_C1_DACBFWM(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFWM_MASK, DAC_C1_DACBFWM(value)))
#define DAC_BWR_C1_DACBFWM(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFWM_SHIFT), DAC_C1_DACBFWM_SHIFT, DAC_C1_DACBFWM_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DMAEN[7] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled. When DMA is enabled, the DMA request will be
 *     generated by original interrupts. The interrupts will not be presented on this
 *     module at the same time.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DMAEN field. */
#define DAC_RD_C1_DMAEN(base) ((DAC_C1_REG(base) & DAC_C1_DMAEN_MASK) >> DAC_C1_DMAEN_SHIFT)
#define DAC_BRD_C1_DMAEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define DAC_WR_C1_DMAEN(base, value) (DAC_RMW_C1(base, DAC_C1_DMAEN_MASK, DAC_C1_DMAEN(value)))
#define DAC_BWR_C1_DMAEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DMAEN_SHIFT), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C2 - DAC Control Register 2
 ******************************************************************************/

/*!
 * @brief DAC_C2 - DAC Control Register 2 (RW)
 *
 * Reset value: 0x0FU
 */
/*!
 * @name Constants and macros for entire DAC_C2 register
 */
/*@{*/
#define DAC_RD_C2(base)          (DAC_C2_REG(base))
#define DAC_WR_C2(base, value)   (DAC_C2_REG(base) = (value))
#define DAC_RMW_C2(base, mask, value) (DAC_WR_C2(base, (DAC_RD_C2(base) & ~(mask)) | (value)))
#define DAC_SET_C2(base, value)  (BME_OR8(&DAC_C2_REG(base), (uint8_t)(value)))
#define DAC_CLR_C2(base, value)  (BME_AND8(&DAC_C2_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C2(base, value)  (BME_XOR8(&DAC_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C2 bitfields
 */

/*!
 * @name Register DAC_C2, field DACBFUP[3:0] (RW)
 *
 * In normal mode it selects the upper limit of the DAC buffer. The buffer read
 * pointer cannot exceed it. In FIFO mode it is the FIFO write pointer. User
 * cannot set Buffer Up limit in FIFO mode. In Normal mode its reset value is MAX.
 * When IP is configured to FIFO mode, this register becomes Write_Pointer, and its
 * value is initially set to equal READ_POINTER automatically, and the FIFO
 * status is empty. It is writable and user can configure it to the same address to
 * reset FIFO as empty.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFUP field. */
#define DAC_RD_C2_DACBFUP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFUP_MASK) >> DAC_C2_DACBFUP_SHIFT)
#define DAC_BRD_C2_DACBFUP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))

/*! @brief Set the DACBFUP field to a new value. */
#define DAC_WR_C2_DACBFUP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFUP_MASK, DAC_C2_DACBFUP(value)))
#define DAC_BWR_C2_DACBFUP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFUP_SHIFT), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C2, field DACBFRP[7:4] (RW)
 *
 * In normal mode it keeps the current value of the buffer read pointer. FIFO
 * mode, it is the FIFO read pointer. It is writable in FIFO mode. User can
 * configure it to same address to reset FIFO as empty.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFRP field. */
#define DAC_RD_C2_DACBFRP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFRP_MASK) >> DAC_C2_DACBFRP_SHIFT)
#define DAC_BRD_C2_DACBFRP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))

/*! @brief Set the DACBFRP field to a new value. */
#define DAC_WR_C2_DACBFRP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFRP_MASK, DAC_C2_DACBFRP(value)))
#define DAC_BWR_C2_DACBFRP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFRP_SHIFT), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))
/*@}*/

/*
 * MKL28Z7 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - DMA_CR - Control Register
 * - DMA_ES - Error Status Register
 * - DMA_ERQ - Enable Request Register
 * - DMA_EEI - Enable Error Interrupt Register
 * - DMA_CEEI - Clear Enable Error Interrupt Register
 * - DMA_SEEI - Set Enable Error Interrupt Register
 * - DMA_CERQ - Clear Enable Request Register
 * - DMA_SERQ - Set Enable Request Register
 * - DMA_CDNE - Clear DONE Status Bit Register
 * - DMA_SSRT - Set START Bit Register
 * - DMA_CERR - Clear Error Register
 * - DMA_CINT - Clear Interrupt Request Register
 * - DMA_INT - Interrupt Request Register
 * - DMA_ERR - Error Register
 * - DMA_HRS - Hardware Request Status Register
 * - DMA_EARS - Enable Asynchronous Request in Stop Register
 * - DMA_DCHPRI3 - Channel n Priority Register
 * - DMA_DCHPRI2 - Channel n Priority Register
 * - DMA_DCHPRI1 - Channel n Priority Register
 * - DMA_DCHPRI0 - Channel n Priority Register
 * - DMA_DCHPRI7 - Channel n Priority Register
 * - DMA_DCHPRI6 - Channel n Priority Register
 * - DMA_DCHPRI5 - Channel n Priority Register
 * - DMA_DCHPRI4 - Channel n Priority Register
 * - DMA_SADDR - TCD Source Address
 * - DMA_SOFF - TCD Signed Source Address Offset
 * - DMA_ATTR - TCD Transfer Attributes
 * - DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_SLAST - TCD Last Source Address Adjustment
 * - DMA_DADDR - TCD Destination Address
 * - DMA_DOFF - TCD Signed Destination Address Offset
 * - DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_CSR - TCD Control and Status
 * - DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 */

#define DMA_INSTANCE_COUNT (2U) /*!< Number of instances of the DMA module. */
#define DMA0_IDX (0U) /*!< Instance number for DMA0. */
#define DMA1_IDX (1U) /*!< Instance number for DMA1. */

/*******************************************************************************
 * DMA_CR - Control Register
 ******************************************************************************/

/*!
 * @brief DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CR defines the basic operating configuration of the DMA. Arbitration can
 * be configured to use either a fixed-priority or a round-robin scheme. For
 * fixed-priority arbitration, the highest priority channel requesting service is
 * selected to execute. The channel priority registers assign the priorities; see
 * the DCHPRIn registers. For round-robin arbitration, the channel priorities are
 * ignored and channels are cycled through (from high to low channel number)
 * without regard to priority. For correct operation, writes to the CR register must
 * be performed only when the DMA channels are inactive; that is, when
 * TCDn_CSR[ACTIVE] bits are cleared. Minor loop offsets are address offset values added to
 * the final source address (TCDn_SADDR) or destination address (TCDn_DADDR) upon
 * minor loop completion. When minor loop offsets are enabled, the minor loop
 * offset (MLOFF) is added to the final source address (TCDn_SADDR), to the final
 * destination address (TCDn_DADDR), or to both prior to the addresses being
 * written back into the TCD. If the major loop is complete, the minor loop offset is
 * ignored and the major loop address offsets (TCDn_SLAST and TCDn_DLAST_SGA) are
 * used to compute the next TCDn_SADDR and TCDn_DADDR values. When minor loop
 * mapping is enabled (EMLM is 1), TCDn word2 is redefined. A portion of TCDn word2
 * is used to specify multiple fields: a source enable bit (SMLOE) to specify
 * the minor loop offset should be applied to the source address (TCDn_SADDR) upon
 * minor loop completion, a destination enable bit (DMLOE) to specify the minor
 * loop offset should be applied to the destination address (TCDn_DADDR) upon
 * minor loop completion, and the sign extended minor loop offset value (MLOFF). The
 * same offset value (MLOFF) is used for both source and destination minor loop
 * offsets. When either minor loop offset is enabled (SMLOE set or DMLOE set), the
 * NBYTES field is reduced to 10 bits. When both minor loop offsets are disabled
 * (SMLOE cleared and DMLOE cleared), the NBYTES field is a 30-bit vector. When
 * minor loop mapping is disabled (EMLM is 0), all 32 bits of TCDn word2 are
 * assigned to the NBYTES field.
 */
/*!
 * @name Constants and macros for entire DMA_CR register
 */
/*@{*/
#define DMA_RD_CR(base)          (DMA_CR_REG(base))
#define DMA_WR_CR(base, value)   (DMA_CR_REG(base) = (value))
#define DMA_RMW_CR(base, mask, value) (DMA_WR_CR(base, (DMA_RD_CR(base) & ~(mask)) | (value)))
#define DMA_SET_CR(base, value)  (BME_OR32(&DMA_CR_REG(base), (uint32_t)(value)))
#define DMA_CLR_CR(base, value)  (BME_AND32(&DMA_CR_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_CR(base, value)  (BME_XOR32(&DMA_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CR bitfields
 */

/*!
 * @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0b0 - When in debug mode, the DMA continues to operate.
 * - 0b1 - When in debug mode, the DMA stalls the start of a new channel.
 *     Executing channels are allowed to complete. Channel execution resumes when the
 *     system exits debug mode or the EDBG bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EDBG field. */
#define DMA_RD_CR_EDBG(base) ((DMA_CR_REG(base) & DMA_CR_EDBG_MASK) >> DMA_CR_EDBG_SHIFT)
#define DMA_BRD_CR_EDBG(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT, DMA_CR_EDBG_WIDTH))

/*! @brief Set the EDBG field to a new value. */
#define DMA_WR_CR_EDBG(base, value) (DMA_RMW_CR(base, DMA_CR_EDBG_MASK, DMA_CR_EDBG(value)))
#define DMA_BWR_CR_EDBG(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_EDBG_SHIFT), DMA_CR_EDBG_SHIFT, DMA_CR_EDBG_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0b0 - Fixed priority arbitration is used for channel selection .
 * - 0b1 - Round robin arbitration is used for channel selection .
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ERCA field. */
#define DMA_RD_CR_ERCA(base) ((DMA_CR_REG(base) & DMA_CR_ERCA_MASK) >> DMA_CR_ERCA_SHIFT)
#define DMA_BRD_CR_ERCA(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT, DMA_CR_ERCA_WIDTH))

/*! @brief Set the ERCA field to a new value. */
#define DMA_WR_CR_ERCA(base, value) (DMA_RMW_CR(base, DMA_CR_ERCA_MASK, DMA_CR_ERCA(value)))
#define DMA_BWR_CR_ERCA(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_ERCA_SHIFT), DMA_CR_ERCA_SHIFT, DMA_CR_ERCA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Any error causes the HALT bit to set. Subsequently, all service
 *     requests are ignored until the HALT bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HOE field. */
#define DMA_RD_CR_HOE(base)  ((DMA_CR_REG(base) & DMA_CR_HOE_MASK) >> DMA_CR_HOE_SHIFT)
#define DMA_BRD_CR_HOE(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT, DMA_CR_HOE_WIDTH))

/*! @brief Set the HOE field to a new value. */
#define DMA_WR_CR_HOE(base, value) (DMA_RMW_CR(base, DMA_CR_HOE_MASK, DMA_CR_HOE(value)))
#define DMA_BWR_CR_HOE(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_HOE_SHIFT), DMA_CR_HOE_SHIFT, DMA_CR_HOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Stall the start of any new channels. Executing channels are allowed
 *     to complete. Channel execution resumes when this bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HALT field. */
#define DMA_RD_CR_HALT(base) ((DMA_CR_REG(base) & DMA_CR_HALT_MASK) >> DMA_CR_HALT_SHIFT)
#define DMA_BRD_CR_HALT(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT, DMA_CR_HALT_WIDTH))

/*! @brief Set the HALT field to a new value. */
#define DMA_WR_CR_HALT(base, value) (DMA_RMW_CR(base, DMA_CR_HALT_MASK, DMA_CR_HALT(value)))
#define DMA_BWR_CR_HALT(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_HALT_SHIFT), DMA_CR_HALT_SHIFT, DMA_CR_HALT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field CLM[6] (RW)
 *
 * Do not use continuous link mode with a channel linking to itself if there is
 * only one minor loop iteration per service request. If the channel's NBYTES
 * value is the same as either the source or destination size, do not use channel
 * linking to itself. The same data transfer profile can be achieved by simply
 * increasing the NBYTES value. A larger NBYTES value provides more efficient, faster
 * processing.
 *
 * Values:
 * - 0b0 - A minor loop channel link made to itself goes through channel
 *     arbitration before being activated again.
 * - 0b1 - A minor loop channel link made to itself does not go through channel
 *     arbitration before being activated again. Upon minor loop completion, the
 *     channel activates again if that channel has a minor loop channel link
 *     enabled and the link channel is itself. This effectively applies the minor
 *     loop offsets and restarts the next minor loop.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CLM field. */
#define DMA_RD_CR_CLM(base)  ((DMA_CR_REG(base) & DMA_CR_CLM_MASK) >> DMA_CR_CLM_SHIFT)
#define DMA_BRD_CR_CLM(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT, DMA_CR_CLM_WIDTH))

/*! @brief Set the CLM field to a new value. */
#define DMA_WR_CR_CLM(base, value) (DMA_RMW_CR(base, DMA_CR_CLM_MASK, DMA_CR_CLM(value)))
#define DMA_BWR_CR_CLM(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_CLM_SHIFT), DMA_CR_CLM_SHIFT, DMA_CR_CLM_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0b0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 0b1 - Enabled. TCDn.word2 is redefined to include individual enable fields,
 *     an offset field, and the NBYTES field. The individual enable fields allow
 *     the minor loop offset to be applied to the source address, the
 *     destination address, or both. The NBYTES field is reduced when either offset is
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EMLM field. */
#define DMA_RD_CR_EMLM(base) ((DMA_CR_REG(base) & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT)
#define DMA_BRD_CR_EMLM(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT, DMA_CR_EMLM_WIDTH))

/*! @brief Set the EMLM field to a new value. */
#define DMA_WR_CR_EMLM(base, value) (DMA_RMW_CR(base, DMA_CR_EMLM_MASK, DMA_CR_EMLM(value)))
#define DMA_BWR_CR_EMLM(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_EMLM_SHIFT), DMA_CR_EMLM_SHIFT, DMA_CR_EMLM_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Cancel the remaining data transfer in the same fashion as the CX bit.
 *     Stop the executing channel and force the minor loop to finish. The cancel
 *     takes effect after the last write of the current read/write sequence. The
 *     ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus
 *     updating the Error Status register (DMAx_ES) and generating an optional error
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ECX field. */
#define DMA_RD_CR_ECX(base)  ((DMA_CR_REG(base) & DMA_CR_ECX_MASK) >> DMA_CR_ECX_SHIFT)
#define DMA_BRD_CR_ECX(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT, DMA_CR_ECX_WIDTH))

/*! @brief Set the ECX field to a new value. */
#define DMA_WR_CR_ECX(base, value) (DMA_RMW_CR(base, DMA_CR_ECX_MASK, DMA_CR_ECX(value)))
#define DMA_BWR_CR_ECX(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_ECX_SHIFT), DMA_CR_ECX_SHIFT, DMA_CR_ECX_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Cancel the remaining data transfer. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write
 *     of the current read/write sequence. The CX bit clears itself after the
 *     cancel has been honored. This cancel retires the channel normally as if the
 *     minor loop was completed.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CX field. */
#define DMA_RD_CR_CX(base)   ((DMA_CR_REG(base) & DMA_CR_CX_MASK) >> DMA_CR_CX_SHIFT)
#define DMA_BRD_CR_CX(base)  (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT, DMA_CR_CX_WIDTH))

/*! @brief Set the CX field to a new value. */
#define DMA_WR_CR_CX(base, value) (DMA_RMW_CR(base, DMA_CR_CX_MASK, DMA_CR_CX(value)))
#define DMA_BWR_CR_CX(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_CX_SHIFT), DMA_CR_CX_SHIFT, DMA_CR_CX_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ACTIVE[31] (RO)
 *
 * Values:
 * - 0b0 - eDMA is idle.
 * - 0b1 - eDMA is executing a channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ACTIVE field. */
#define DMA_RD_CR_ACTIVE(base) ((DMA_CR_REG(base) & DMA_CR_ACTIVE_MASK) >> DMA_CR_ACTIVE_SHIFT)
#define DMA_BRD_CR_ACTIVE(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ACTIVE_SHIFT, DMA_CR_ACTIVE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ES - Error Status Register
 ******************************************************************************/

/*!
 * @brief DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error.
 * Channel errors can be caused by: A configuration error, that is: An illegal setting
 * in the transfer-control descriptor, or An illegal priority register setting
 * in fixed-arbitration An error termination to a bus master read or write cycle
 * See the Error Reporting and Handling section for more details.
 */
/*!
 * @name Constants and macros for entire DMA_ES register
 */
/*@{*/
#define DMA_RD_ES(base)          (DMA_ES_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_ES bitfields
 */

/*!
 * @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0b0 - No destination bus error
 * - 0b1 - The last recorded error was a bus error on a destination write
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DBE field. */
#define DMA_RD_ES_DBE(base)  ((DMA_ES_REG(base) & DMA_ES_DBE_MASK) >> DMA_ES_DBE_SHIFT)
#define DMA_BRD_ES_DBE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DBE_SHIFT, DMA_ES_DBE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0b0 - No source bus error
 * - 0b1 - The last recorded error was a bus error on a source read
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SBE field. */
#define DMA_RD_ES_SBE(base)  ((DMA_ES_REG(base) & DMA_ES_SBE_MASK) >> DMA_ES_SBE_SHIFT)
#define DMA_BRD_ES_SBE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SBE_SHIFT, DMA_ES_SBE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0b0 - No scatter/gather configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DLASTSGA field. This field is checked at the beginning of a
 *     scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled.
 *     TCDn_DLASTSGA is not on a 32 byte boundary.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SGE field. */
#define DMA_RD_ES_SGE(base)  ((DMA_ES_REG(base) & DMA_ES_SGE_MASK) >> DMA_ES_SGE_SHIFT)
#define DMA_BRD_ES_SGE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SGE_SHIFT, DMA_ES_SGE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0b0 - No NBYTES/CITER configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of
 *     TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or
 *     TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_NCE field. */
#define DMA_RD_ES_NCE(base)  ((DMA_ES_REG(base) & DMA_ES_NCE_MASK) >> DMA_ES_NCE_SHIFT)
#define DMA_BRD_ES_NCE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_NCE_SHIFT, DMA_ES_NCE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0b0 - No destination offset configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DOE field. */
#define DMA_RD_ES_DOE(base)  ((DMA_ES_REG(base) & DMA_ES_DOE_MASK) >> DMA_ES_DOE_SHIFT)
#define DMA_BRD_ES_DOE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DOE_SHIFT, DMA_ES_DOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0b0 - No destination address configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DAE field. */
#define DMA_RD_ES_DAE(base)  ((DMA_ES_REG(base) & DMA_ES_DAE_MASK) >> DMA_ES_DAE_SHIFT)
#define DMA_BRD_ES_DAE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DAE_SHIFT, DMA_ES_DAE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0b0 - No source offset configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SOE field. */
#define DMA_RD_ES_SOE(base)  ((DMA_ES_REG(base) & DMA_ES_SOE_MASK) >> DMA_ES_SOE_SHIFT)
#define DMA_BRD_ES_SOE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SOE_SHIFT, DMA_ES_SOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0b0 - No source address configuration error.
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SAE field. */
#define DMA_RD_ES_SAE(base)  ((DMA_ES_REG(base) & DMA_ES_SAE_MASK) >> DMA_ES_SAE_SHIFT)
#define DMA_BRD_ES_SAE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SAE_SHIFT, DMA_ES_SAE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field ERRCHN[10:8] (RO)
 *
 * The channel number of the last recorded error, excluding CPE errors, or last
 * recorded error canceled transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ERRCHN field. */
#define DMA_RD_ES_ERRCHN(base) ((DMA_ES_REG(base) & DMA_ES_ERRCHN_MASK) >> DMA_ES_ERRCHN_SHIFT)
#define DMA_BRD_ES_ERRCHN(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_ERRCHN_SHIFT, DMA_ES_ERRCHN_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0b0 - No channel priority error
 * - 0b1 - The last recorded error was a configuration error in the channel
 *     priorities . Channel priorities are not unique.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_CPE field. */
#define DMA_RD_ES_CPE(base)  ((DMA_ES_REG(base) & DMA_ES_CPE_MASK) >> DMA_ES_CPE_SHIFT)
#define DMA_BRD_ES_CPE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_CPE_SHIFT, DMA_ES_CPE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0b0 - No canceled transfers
 * - 0b1 - The last recorded entry was a canceled transfer by the error cancel
 *     transfer input
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ECX field. */
#define DMA_RD_ES_ECX(base)  ((DMA_ES_REG(base) & DMA_ES_ECX_MASK) >> DMA_ES_ECX_SHIFT)
#define DMA_BRD_ES_ECX(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_ECX_SHIFT, DMA_ES_ECX_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0b0 - No ERR bits are set.
 * - 0b1 - At least one ERR bit is set indicating a valid error exists that has
 *     not been cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_VLD field. */
#define DMA_RD_ES_VLD(base)  ((DMA_ES_REG(base) & DMA_ES_VLD_MASK) >> DMA_ES_VLD_SHIFT)
#define DMA_BRD_ES_VLD(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_VLD_SHIFT, DMA_ES_VLD_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ERQ - Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provides a bit map for the 8 channels to enable the request
 * signal for each channel. The state of any given channel enable is directly
 * affected by writes to this register; it is also affected by writes to the SERQ
 * and CERQ registers. These registers are provided so the request enable for a
 * single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable request
 * flag must be asserted before a channel's hardware service request is accepted.
 * The state of the DMA enable request flag does not affect a channel service
 * request made explicitly through software or a linked channel request.
 */
/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
/*@{*/
#define DMA_RD_ERQ(base)         (DMA_ERQ_REG(base))
#define DMA_WR_ERQ(base, value)  (DMA_ERQ_REG(base) = (value))
#define DMA_RMW_ERQ(base, mask, value) (DMA_WR_ERQ(base, (DMA_RD_ERQ(base) & ~(mask)) | (value)))
#define DMA_SET_ERQ(base, value) (BME_OR32(&DMA_ERQ_REG(base), (uint32_t)(value)))
#define DMA_CLR_ERQ(base, value) (BME_AND32(&DMA_ERQ_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_ERQ(base, value) (BME_XOR32(&DMA_ERQ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERQ bitfields
 */

/*!
 * @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ0 field. */
#define DMA_RD_ERQ_ERQ0(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ0_MASK) >> DMA_ERQ_ERQ0_SHIFT)
#define DMA_BRD_ERQ_ERQ0(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT, DMA_ERQ_ERQ0_WIDTH))

/*! @brief Set the ERQ0 field to a new value. */
#define DMA_WR_ERQ_ERQ0(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ0_MASK, DMA_ERQ_ERQ0(value)))
#define DMA_BWR_ERQ_ERQ0(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ0_SHIFT), DMA_ERQ_ERQ0_SHIFT, DMA_ERQ_ERQ0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ1 field. */
#define DMA_RD_ERQ_ERQ1(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ1_MASK) >> DMA_ERQ_ERQ1_SHIFT)
#define DMA_BRD_ERQ_ERQ1(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT, DMA_ERQ_ERQ1_WIDTH))

/*! @brief Set the ERQ1 field to a new value. */
#define DMA_WR_ERQ_ERQ1(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ1_MASK, DMA_ERQ_ERQ1(value)))
#define DMA_BWR_ERQ_ERQ1(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ1_SHIFT), DMA_ERQ_ERQ1_SHIFT, DMA_ERQ_ERQ1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ2 field. */
#define DMA_RD_ERQ_ERQ2(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ2_MASK) >> DMA_ERQ_ERQ2_SHIFT)
#define DMA_BRD_ERQ_ERQ2(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT, DMA_ERQ_ERQ2_WIDTH))

/*! @brief Set the ERQ2 field to a new value. */
#define DMA_WR_ERQ_ERQ2(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ2_MASK, DMA_ERQ_ERQ2(value)))
#define DMA_BWR_ERQ_ERQ2(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ2_SHIFT), DMA_ERQ_ERQ2_SHIFT, DMA_ERQ_ERQ2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ3 field. */
#define DMA_RD_ERQ_ERQ3(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ3_MASK) >> DMA_ERQ_ERQ3_SHIFT)
#define DMA_BRD_ERQ_ERQ3(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT, DMA_ERQ_ERQ3_WIDTH))

/*! @brief Set the ERQ3 field to a new value. */
#define DMA_WR_ERQ_ERQ3(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ3_MASK, DMA_ERQ_ERQ3(value)))
#define DMA_BWR_ERQ_ERQ3(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ3_SHIFT), DMA_ERQ_ERQ3_SHIFT, DMA_ERQ_ERQ3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ4[4] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ4 field. */
#define DMA_RD_ERQ_ERQ4(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ4_MASK) >> DMA_ERQ_ERQ4_SHIFT)
#define DMA_BRD_ERQ_ERQ4(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ4_SHIFT, DMA_ERQ_ERQ4_WIDTH))

/*! @brief Set the ERQ4 field to a new value. */
#define DMA_WR_ERQ_ERQ4(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ4_MASK, DMA_ERQ_ERQ4(value)))
#define DMA_BWR_ERQ_ERQ4(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ4_SHIFT), DMA_ERQ_ERQ4_SHIFT, DMA_ERQ_ERQ4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ5[5] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ5 field. */
#define DMA_RD_ERQ_ERQ5(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ5_MASK) >> DMA_ERQ_ERQ5_SHIFT)
#define DMA_BRD_ERQ_ERQ5(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ5_SHIFT, DMA_ERQ_ERQ5_WIDTH))

/*! @brief Set the ERQ5 field to a new value. */
#define DMA_WR_ERQ_ERQ5(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ5_MASK, DMA_ERQ_ERQ5(value)))
#define DMA_BWR_ERQ_ERQ5(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ5_SHIFT), DMA_ERQ_ERQ5_SHIFT, DMA_ERQ_ERQ5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ6[6] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ6 field. */
#define DMA_RD_ERQ_ERQ6(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ6_MASK) >> DMA_ERQ_ERQ6_SHIFT)
#define DMA_BRD_ERQ_ERQ6(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ6_SHIFT, DMA_ERQ_ERQ6_WIDTH))

/*! @brief Set the ERQ6 field to a new value. */
#define DMA_WR_ERQ_ERQ6(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ6_MASK, DMA_ERQ_ERQ6(value)))
#define DMA_BWR_ERQ_ERQ6(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ6_SHIFT), DMA_ERQ_ERQ6_SHIFT, DMA_ERQ_ERQ6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ7[7] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ7 field. */
#define DMA_RD_ERQ_ERQ7(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ7_MASK) >> DMA_ERQ_ERQ7_SHIFT)
#define DMA_BRD_ERQ_ERQ7(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ7_SHIFT, DMA_ERQ_ERQ7_WIDTH))

/*! @brief Set the ERQ7 field to a new value. */
#define DMA_WR_ERQ_ERQ7(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ7_MASK, DMA_ERQ_ERQ7(value)))
#define DMA_BWR_ERQ_ERQ7(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ7_SHIFT), DMA_ERQ_ERQ7_SHIFT, DMA_ERQ_ERQ7_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_EEI - Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 8 channels to enable the error
 * interrupt signal for each channel. The state of any given channel's error
 * interrupt enable is directly affected by writes to this register; it is also
 * affected by writes to the SEEI and CEEI. These registers are provided so that the
 * error interrupt enable for a single channel can easily be modified without the
 * need to perform a read-modify-write sequence to the EEI register. The DMA error
 * indicator and the error interrupt enable flag must be asserted before an error
 * interrupt request for a given channel is asserted to the interrupt controller.
 */
/*!
 * @name Constants and macros for entire DMA_EEI register
 */
/*@{*/
#define DMA_RD_EEI(base)         (DMA_EEI_REG(base))
#define DMA_WR_EEI(base, value)  (DMA_EEI_REG(base) = (value))
#define DMA_RMW_EEI(base, mask, value) (DMA_WR_EEI(base, (DMA_RD_EEI(base) & ~(mask)) | (value)))
#define DMA_SET_EEI(base, value) (BME_OR32(&DMA_EEI_REG(base), (uint32_t)(value)))
#define DMA_CLR_EEI(base, value) (BME_AND32(&DMA_EEI_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_EEI(base, value) (BME_XOR32(&DMA_EEI_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EEI bitfields
 */

/*!
 * @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI0 field. */
#define DMA_RD_EEI_EEI0(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI0_MASK) >> DMA_EEI_EEI0_SHIFT)
#define DMA_BRD_EEI_EEI0(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT, DMA_EEI_EEI0_WIDTH))

/*! @brief Set the EEI0 field to a new value. */
#define DMA_WR_EEI_EEI0(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI0_MASK, DMA_EEI_EEI0(value)))
#define DMA_BWR_EEI_EEI0(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI0_SHIFT), DMA_EEI_EEI0_SHIFT, DMA_EEI_EEI0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI1 field. */
#define DMA_RD_EEI_EEI1(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI1_MASK) >> DMA_EEI_EEI1_SHIFT)
#define DMA_BRD_EEI_EEI1(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT, DMA_EEI_EEI1_WIDTH))

/*! @brief Set the EEI1 field to a new value. */
#define DMA_WR_EEI_EEI1(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI1_MASK, DMA_EEI_EEI1(value)))
#define DMA_BWR_EEI_EEI1(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI1_SHIFT), DMA_EEI_EEI1_SHIFT, DMA_EEI_EEI1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI2 field. */
#define DMA_RD_EEI_EEI2(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI2_MASK) >> DMA_EEI_EEI2_SHIFT)
#define DMA_BRD_EEI_EEI2(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT, DMA_EEI_EEI2_WIDTH))

/*! @brief Set the EEI2 field to a new value. */
#define DMA_WR_EEI_EEI2(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI2_MASK, DMA_EEI_EEI2(value)))
#define DMA_BWR_EEI_EEI2(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI2_SHIFT), DMA_EEI_EEI2_SHIFT, DMA_EEI_EEI2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI3 field. */
#define DMA_RD_EEI_EEI3(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI3_MASK) >> DMA_EEI_EEI3_SHIFT)
#define DMA_BRD_EEI_EEI3(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT, DMA_EEI_EEI3_WIDTH))

/*! @brief Set the EEI3 field to a new value. */
#define DMA_WR_EEI_EEI3(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI3_MASK, DMA_EEI_EEI3(value)))
#define DMA_BWR_EEI_EEI3(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI3_SHIFT), DMA_EEI_EEI3_SHIFT, DMA_EEI_EEI3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI4[4] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI4 field. */
#define DMA_RD_EEI_EEI4(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI4_MASK) >> DMA_EEI_EEI4_SHIFT)
#define DMA_BRD_EEI_EEI4(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI4_SHIFT, DMA_EEI_EEI4_WIDTH))

/*! @brief Set the EEI4 field to a new value. */
#define DMA_WR_EEI_EEI4(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI4_MASK, DMA_EEI_EEI4(value)))
#define DMA_BWR_EEI_EEI4(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI4_SHIFT), DMA_EEI_EEI4_SHIFT, DMA_EEI_EEI4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI5[5] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI5 field. */
#define DMA_RD_EEI_EEI5(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI5_MASK) >> DMA_EEI_EEI5_SHIFT)
#define DMA_BRD_EEI_EEI5(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI5_SHIFT, DMA_EEI_EEI5_WIDTH))

/*! @brief Set the EEI5 field to a new value. */
#define DMA_WR_EEI_EEI5(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI5_MASK, DMA_EEI_EEI5(value)))
#define DMA_BWR_EEI_EEI5(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI5_SHIFT), DMA_EEI_EEI5_SHIFT, DMA_EEI_EEI5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI6[6] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI6 field. */
#define DMA_RD_EEI_EEI6(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI6_MASK) >> DMA_EEI_EEI6_SHIFT)
#define DMA_BRD_EEI_EEI6(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI6_SHIFT, DMA_EEI_EEI6_WIDTH))

/*! @brief Set the EEI6 field to a new value. */
#define DMA_WR_EEI_EEI6(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI6_MASK, DMA_EEI_EEI6(value)))
#define DMA_BWR_EEI_EEI6(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI6_SHIFT), DMA_EEI_EEI6_SHIFT, DMA_EEI_EEI6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI7[7] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI7 field. */
#define DMA_RD_EEI_EEI7(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI7_MASK) >> DMA_EEI_EEI7_SHIFT)
#define DMA_BRD_EEI_EEI7(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI7_SHIFT, DMA_EEI_EEI7_WIDTH))

/*! @brief Set the EEI7 field to a new value. */
#define DMA_WR_EEI_EEI7(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI7_MASK, DMA_EEI_EEI7(value)))
#define DMA_BWR_EEI_EEI7(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI7_SHIFT), DMA_EEI_EEI7_SHIFT, DMA_EEI_EEI7_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CEEI - Clear Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_CEEI - Clear Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in
 * the EEI to disable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be cleared. Setting
 * the CAEE bit provides a global clear function, forcing the EEI contents to be
 * cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word.
 * Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
/*@{*/
#define DMA_RD_CEEI(base)        (DMA_CEEI_REG(base))
#define DMA_WR_CEEI(base, value) (DMA_CEEI_REG(base) = (value))
#define DMA_RMW_CEEI(base, mask, value) (DMA_WR_CEEI(base, (DMA_RD_CEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CEEI bitfields
 */

/*!
 * @name Register DMA_CEEI, field CEEI[2:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the CEEI field to a new value. */
#define DMA_WR_CEEI_CEEI(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CEEI_MASK, DMA_CEEI_CEEI(value)))
#define DMA_BWR_CEEI_CEEI(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_CEEI_SHIFT), DMA_CEEI_CEEI_SHIFT, DMA_CEEI_CEEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the EEI bit specified in the CEEI field
 * - 0b1 - Clear all bits in EEI
 */
/*@{*/
/*! @brief Set the CAEE field to a new value. */
#define DMA_WR_CEEI_CAEE(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CAEE_MASK, DMA_CEEI_CAEE(value)))
#define DMA_BWR_CEEI_CAEE(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_CAEE_SHIFT), DMA_CEEI_CAEE_SHIFT, DMA_CEEI_CAEE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CEEI_NOP(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_NOP_MASK, DMA_CEEI_NOP(value)))
#define DMA_BWR_CEEI_NOP(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_NOP_SHIFT), DMA_CEEI_NOP_SHIFT, DMA_CEEI_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SEEI - Set Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_SEEI - Set Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the
 * EEI to enable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be set. Setting the
 * SAEE bit provides a global set function, forcing the entire EEI contents to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
/*@{*/
#define DMA_RD_SEEI(base)        (DMA_SEEI_REG(base))
#define DMA_WR_SEEI(base, value) (DMA_SEEI_REG(base) = (value))
#define DMA_RMW_SEEI(base, mask, value) (DMA_WR_SEEI(base, (DMA_RD_SEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SEEI bitfields
 */

/*!
 * @name Register DMA_SEEI, field SEEI[2:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the SEEI field to a new value. */
#define DMA_WR_SEEI_SEEI(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SEEI_MASK, DMA_SEEI_SEEI(value)))
#define DMA_BWR_SEEI_SEEI(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_SEEI_SHIFT), DMA_SEEI_SEEI_SHIFT, DMA_SEEI_SEEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the EEI bit specified in the SEEI field.
 * - 0b1 - Sets all bits in EEI
 */
/*@{*/
/*! @brief Set the SAEE field to a new value. */
#define DMA_WR_SEEI_SAEE(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SAEE_MASK, DMA_SEEI_SAEE(value)))
#define DMA_BWR_SEEI_SAEE(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_SAEE_SHIFT), DMA_SEEI_SAEE_SHIFT, DMA_SEEI_SAEE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SEEI_NOP(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_NOP_MASK, DMA_SEEI_NOP(value)))
#define DMA_BWR_SEEI_NOP(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_NOP_SHIFT), DMA_SEEI_NOP_SHIFT, DMA_SEEI_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CERQ - Clear Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CERQ - Clear Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in
 * the ERQ to disable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be cleared. Setting the
 * CAER bit provides a global clear function, forcing the entire contents of the
 * ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit
 * word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
/*@{*/
#define DMA_RD_CERQ(base)        (DMA_CERQ_REG(base))
#define DMA_WR_CERQ(base, value) (DMA_CERQ_REG(base) = (value))
#define DMA_RMW_CERQ(base, mask, value) (DMA_WR_CERQ(base, (DMA_RD_CERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERQ bitfields
 */

/*!
 * @name Register DMA_CERQ, field CERQ[2:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the CERQ field to a new value. */
#define DMA_WR_CERQ_CERQ(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CERQ_MASK, DMA_CERQ_CERQ(value)))
#define DMA_BWR_CERQ_CERQ(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_CERQ_SHIFT), DMA_CERQ_CERQ_SHIFT, DMA_CERQ_CERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the ERQ bit specified in the CERQ field
 * - 0b1 - Clear all bits in ERQ
 */
/*@{*/
/*! @brief Set the CAER field to a new value. */
#define DMA_WR_CERQ_CAER(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CAER_MASK, DMA_CERQ_CAER(value)))
#define DMA_BWR_CERQ_CAER(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_CAER_SHIFT), DMA_CERQ_CAER_SHIFT, DMA_CERQ_CAER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERQ_NOP(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_NOP_MASK, DMA_CERQ_NOP(value)))
#define DMA_BWR_CERQ_NOP(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_NOP_SHIFT), DMA_CERQ_NOP_SHIFT, DMA_CERQ_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SERQ - Set Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_SERQ - Set Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the
 * ERQ to enable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be set. Setting the SAER
 * bit provides a global set function, forcing the entire contents of ERQ to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
/*@{*/
#define DMA_RD_SERQ(base)        (DMA_SERQ_REG(base))
#define DMA_WR_SERQ(base, value) (DMA_SERQ_REG(base) = (value))
#define DMA_RMW_SERQ(base, mask, value) (DMA_WR_SERQ(base, (DMA_RD_SERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SERQ bitfields
 */

/*!
 * @name Register DMA_SERQ, field SERQ[2:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the SERQ field to a new value. */
#define DMA_WR_SERQ_SERQ(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SERQ_MASK, DMA_SERQ_SERQ(value)))
#define DMA_BWR_SERQ_SERQ(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_SERQ_SHIFT), DMA_SERQ_SERQ_SHIFT, DMA_SERQ_SERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the ERQ bit specified in the SERQ field
 * - 0b1 - Set all bits in ERQ
 */
/*@{*/
/*! @brief Set the SAER field to a new value. */
#define DMA_WR_SERQ_SAER(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SAER_MASK, DMA_SERQ_SAER(value)))
#define DMA_BWR_SERQ_SAER(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_SAER_SHIFT), DMA_SERQ_SAER_SHIFT, DMA_SERQ_SAER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SERQ_NOP(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_NOP_MASK, DMA_SERQ_NOP(value)))
#define DMA_BWR_SERQ_NOP(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_NOP_SHIFT), DMA_SERQ_NOP_SHIFT, DMA_SERQ_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CDNE - Clear DONE Status Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_CDNE - Clear DONE Status Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in
 * the TCD of the given channel. The data value on a register write causes the
 * DONE bit in the corresponding transfer control descriptor to be cleared. Setting
 * the CADN bit provides a global clear function, forcing all DONE bits to be
 * cleared. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
/*@{*/
#define DMA_RD_CDNE(base)        (DMA_CDNE_REG(base))
#define DMA_WR_CDNE(base, value) (DMA_CDNE_REG(base) = (value))
#define DMA_RMW_CDNE(base, mask, value) (DMA_WR_CDNE(base, (DMA_RD_CDNE(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CDNE bitfields
 */

/*!
 * @name Register DMA_CDNE, field CDNE[2:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CDNE field to a new value. */
#define DMA_WR_CDNE_CDNE(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CDNE_MASK, DMA_CDNE_CDNE(value)))
#define DMA_BWR_CDNE_CDNE(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_CDNE_SHIFT), DMA_CDNE_CDNE_SHIFT, DMA_CDNE_CDNE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 0b1 - Clears all bits in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CADN field to a new value. */
#define DMA_WR_CDNE_CADN(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CADN_MASK, DMA_CDNE_CADN(value)))
#define DMA_BWR_CDNE_CADN(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_CADN_SHIFT), DMA_CDNE_CADN_SHIFT, DMA_CDNE_CADN_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CDNE_NOP(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_NOP_MASK, DMA_CDNE_NOP(value)))
#define DMA_BWR_CDNE_NOP(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_NOP_SHIFT), DMA_CDNE_NOP_SHIFT, DMA_CDNE_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SSRT - Set START Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_SSRT - Set START Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in
 * the TCD of the given channel. The data value on a register write causes the
 * START bit in the corresponding transfer control descriptor to be set. Setting the
 * SAST bit provides a global set function, forcing all START bits to be set. If
 * the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
/*@{*/
#define DMA_RD_SSRT(base)        (DMA_SSRT_REG(base))
#define DMA_WR_SSRT(base, value) (DMA_SSRT_REG(base) = (value))
#define DMA_RMW_SSRT(base, mask, value) (DMA_WR_SSRT(base, (DMA_RD_SSRT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SSRT bitfields
 */

/*!
 * @name Register DMA_SSRT, field SSRT[2:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SSRT field to a new value. */
#define DMA_WR_SSRT_SSRT(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SSRT_MASK, DMA_SSRT_SSRT(value)))
#define DMA_BWR_SSRT_SSRT(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_SSRT_SHIFT), DMA_SSRT_SSRT_SHIFT, DMA_SSRT_SSRT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 0b1 - Set all bits in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SAST field to a new value. */
#define DMA_WR_SSRT_SAST(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SAST_MASK, DMA_SSRT_SAST(value)))
#define DMA_BWR_SSRT_SAST(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_SAST_SHIFT), DMA_SSRT_SAST_SHIFT, DMA_SSRT_SAST_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SSRT_NOP(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_NOP_MASK, DMA_SSRT_NOP(value)))
#define DMA_BWR_SSRT_NOP(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_NOP_SHIFT), DMA_SSRT_NOP_SHIFT, DMA_SSRT_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CERR - Clear Error Register
 ******************************************************************************/

/*!
 * @brief DMA_CERR - Clear Error Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in
 * the ERR to disable the error condition flag for a given channel. The given value
 * on a register write causes the corresponding bit in the ERR to be cleared.
 * Setting the CAEI bit provides a global clear function, forcing the ERR contents
 * to be cleared, clearing all channel error indicators. If the NOP bit is set,
 * the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERR register
 */
/*@{*/
#define DMA_RD_CERR(base)        (DMA_CERR_REG(base))
#define DMA_WR_CERR(base, value) (DMA_CERR_REG(base) = (value))
#define DMA_RMW_CERR(base, mask, value) (DMA_WR_CERR(base, (DMA_RD_CERR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERR bitfields
 */

/*!
 * @name Register DMA_CERR, field CERR[2:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
/*@{*/
/*! @brief Set the CERR field to a new value. */
#define DMA_WR_CERR_CERR(base, value) (DMA_RMW_CERR(base, DMA_CERR_CERR_MASK, DMA_CERR_CERR(value)))
#define DMA_BWR_CERR_CERR(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_CERR_SHIFT), DMA_CERR_CERR_SHIFT, DMA_CERR_CERR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the ERR bit specified in the CERR field
 * - 0b1 - Clear all bits in ERR
 */
/*@{*/
/*! @brief Set the CAEI field to a new value. */
#define DMA_WR_CERR_CAEI(base, value) (DMA_RMW_CERR(base, DMA_CERR_CAEI_MASK, DMA_CERR_CAEI(value)))
#define DMA_BWR_CERR_CAEI(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_CAEI_SHIFT), DMA_CERR_CAEI_SHIFT, DMA_CERR_CAEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERR_NOP(base, value) (DMA_RMW_CERR(base, DMA_CERR_NOP_MASK, DMA_CERR_NOP(value)))
#define DMA_BWR_CERR_NOP(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_NOP_SHIFT), DMA_CERR_NOP_SHIFT, DMA_CERR_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CINT - Clear Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CINT - Clear Interrupt Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in
 * the INT to disable the interrupt request for a given channel. The given value
 * on a register write causes the corresponding bit in the INT to be cleared.
 * Setting the CAIR bit provides a global clear function, forcing the entire contents
 * of the INT to be cleared, disabling all DMA interrupt requests. If the NOP
 * bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CINT register
 */
/*@{*/
#define DMA_RD_CINT(base)        (DMA_CINT_REG(base))
#define DMA_WR_CINT(base, value) (DMA_CINT_REG(base) = (value))
#define DMA_RMW_CINT(base, mask, value) (DMA_WR_CINT(base, (DMA_RD_CINT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CINT bitfields
 */

/*!
 * @name Register DMA_CINT, field CINT[2:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
/*@{*/
/*! @brief Set the CINT field to a new value. */
#define DMA_WR_CINT_CINT(base, value) (DMA_RMW_CINT(base, DMA_CINT_CINT_MASK, DMA_CINT_CINT(value)))
#define DMA_BWR_CINT_CINT(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_CINT_SHIFT), DMA_CINT_CINT_SHIFT, DMA_CINT_CINT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the INT bit specified in the CINT field
 * - 0b1 - Clear all bits in INT
 */
/*@{*/
/*! @brief Set the CAIR field to a new value. */
#define DMA_WR_CINT_CAIR(base, value) (DMA_RMW_CINT(base, DMA_CINT_CAIR_MASK, DMA_CINT_CAIR(value)))
#define DMA_BWR_CINT_CAIR(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_CAIR_SHIFT), DMA_CINT_CAIR_SHIFT, DMA_CINT_CAIR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CINT_NOP(base, value) (DMA_RMW_CINT(base, DMA_CINT_NOP_MASK, DMA_CINT_NOP(value)))
#define DMA_BWR_CINT_NOP(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_NOP_SHIFT), DMA_CINT_NOP_SHIFT, DMA_CINT_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_INT - Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_INT - Interrupt Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 8 channels signaling the presence
 * of an interrupt request for each channel. Depending on the appropriate bit
 * setting in the transfer-control descriptors, the eDMA engine generates an
 * interrupt on data transfer completion. The outputs of this register are directly
 * routed to the interrupt controller. During the interrupt-service routine
 * associated with any given channel, it is the software's responsibility to clear the
 * appropriate bit, negating the interrupt request. Typically, a write to the CINT
 * register in the interrupt service routine is used for this purpose. The state
 * of any given channel's interrupt request is directly affected by writes to
 * this register; it is also affected by writes to the CINT register. On writes to
 * INT, a 1 in any bit position clears the corresponding channel's interrupt
 * request. A zero in any bit position has no affect on the corresponding channel's
 * current interrupt status. The CINT register is provided so the interrupt request
 * for a single channel can easily be cleared without the need to perform a
 * read-modify-write sequence to the INT register.
 */
/*!
 * @name Constants and macros for entire DMA_INT register
 */
/*@{*/
#define DMA_RD_INT(base)         (DMA_INT_REG(base))
#define DMA_WR_INT(base, value)  (DMA_INT_REG(base) = (value))
#define DMA_RMW_INT(base, mask, value) (DMA_WR_INT(base, (DMA_RD_INT(base) & ~(mask)) | (value)))
#define DMA_SET_INT(base, value) (BME_OR32(&DMA_INT_REG(base), (uint32_t)(value)))
#define DMA_CLR_INT(base, value) (BME_AND32(&DMA_INT_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_INT(base, value) (BME_XOR32(&DMA_INT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_INT bitfields
 */

/*!
 * @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT0 field. */
#define DMA_RD_INT_INT0(base) ((DMA_INT_REG(base) & DMA_INT_INT0_MASK) >> DMA_INT_INT0_SHIFT)
#define DMA_BRD_INT_INT0(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT, DMA_INT_INT0_WIDTH))

/*! @brief Set the INT0 field to a new value. */
#define DMA_WR_INT_INT0(base, value) (DMA_RMW_INT(base, (DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK), DMA_INT_INT0(value)))
#define DMA_BWR_INT_INT0(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT0_SHIFT), DMA_INT_INT0_SHIFT, DMA_INT_INT0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT1 field. */
#define DMA_RD_INT_INT1(base) ((DMA_INT_REG(base) & DMA_INT_INT1_MASK) >> DMA_INT_INT1_SHIFT)
#define DMA_BRD_INT_INT1(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT, DMA_INT_INT1_WIDTH))

/*! @brief Set the INT1 field to a new value. */
#define DMA_WR_INT_INT1(base, value) (DMA_RMW_INT(base, (DMA_INT_INT1_MASK | DMA_INT_INT0_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK), DMA_INT_INT1(value)))
#define DMA_BWR_INT_INT1(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT1_SHIFT), DMA_INT_INT1_SHIFT, DMA_INT_INT1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT2 field. */
#define DMA_RD_INT_INT2(base) ((DMA_INT_REG(base) & DMA_INT_INT2_MASK) >> DMA_INT_INT2_SHIFT)
#define DMA_BRD_INT_INT2(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT, DMA_INT_INT2_WIDTH))

/*! @brief Set the INT2 field to a new value. */
#define DMA_WR_INT_INT2(base, value) (DMA_RMW_INT(base, (DMA_INT_INT2_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK), DMA_INT_INT2(value)))
#define DMA_BWR_INT_INT2(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT2_SHIFT), DMA_INT_INT2_SHIFT, DMA_INT_INT2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT3 field. */
#define DMA_RD_INT_INT3(base) ((DMA_INT_REG(base) & DMA_INT_INT3_MASK) >> DMA_INT_INT3_SHIFT)
#define DMA_BRD_INT_INT3(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT, DMA_INT_INT3_WIDTH))

/*! @brief Set the INT3 field to a new value. */
#define DMA_WR_INT_INT3(base, value) (DMA_RMW_INT(base, (DMA_INT_INT3_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK), DMA_INT_INT3(value)))
#define DMA_BWR_INT_INT3(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT3_SHIFT), DMA_INT_INT3_SHIFT, DMA_INT_INT3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT4[4] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT4 field. */
#define DMA_RD_INT_INT4(base) ((DMA_INT_REG(base) & DMA_INT_INT4_MASK) >> DMA_INT_INT4_SHIFT)
#define DMA_BRD_INT_INT4(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT4_SHIFT, DMA_INT_INT4_WIDTH))

/*! @brief Set the INT4 field to a new value. */
#define DMA_WR_INT_INT4(base, value) (DMA_RMW_INT(base, (DMA_INT_INT4_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK), DMA_INT_INT4(value)))
#define DMA_BWR_INT_INT4(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT4_SHIFT), DMA_INT_INT4_SHIFT, DMA_INT_INT4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT5[5] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT5 field. */
#define DMA_RD_INT_INT5(base) ((DMA_INT_REG(base) & DMA_INT_INT5_MASK) >> DMA_INT_INT5_SHIFT)
#define DMA_BRD_INT_INT5(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT5_SHIFT, DMA_INT_INT5_WIDTH))

/*! @brief Set the INT5 field to a new value. */
#define DMA_WR_INT_INT5(base, value) (DMA_RMW_INT(base, (DMA_INT_INT5_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK), DMA_INT_INT5(value)))
#define DMA_BWR_INT_INT5(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT5_SHIFT), DMA_INT_INT5_SHIFT, DMA_INT_INT5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT6[6] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT6 field. */
#define DMA_RD_INT_INT6(base) ((DMA_INT_REG(base) & DMA_INT_INT6_MASK) >> DMA_INT_INT6_SHIFT)
#define DMA_BRD_INT_INT6(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT6_SHIFT, DMA_INT_INT6_WIDTH))

/*! @brief Set the INT6 field to a new value. */
#define DMA_WR_INT_INT6(base, value) (DMA_RMW_INT(base, (DMA_INT_INT6_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT7_MASK), DMA_INT_INT6(value)))
#define DMA_BWR_INT_INT6(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT6_SHIFT), DMA_INT_INT6_SHIFT, DMA_INT_INT6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT7[7] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT7 field. */
#define DMA_RD_INT_INT7(base) ((DMA_INT_REG(base) & DMA_INT_INT7_MASK) >> DMA_INT_INT7_SHIFT)
#define DMA_BRD_INT_INT7(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT7_SHIFT, DMA_INT_INT7_WIDTH))

/*! @brief Set the INT7 field to a new value. */
#define DMA_WR_INT_INT7(base, value) (DMA_RMW_INT(base, (DMA_INT_INT7_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK), DMA_INT_INT7(value)))
#define DMA_BWR_INT_INT7(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT7_SHIFT), DMA_INT_INT7_SHIFT, DMA_INT_INT7_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ERR - Error Register
 ******************************************************************************/

/*!
 * @brief DMA_ERR - Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the channels, signaling the presence of an
 * error for each channel. The eDMA engine signals the occurrence of an error
 * condition by setting the appropriate bit in this register. The outputs of this
 * register are enabled by the contents of the EEI, and then routed to the interrupt
 * controller. During the execution of the interrupt-service routine associated
 * with any DMA errors, it is software's responsibility to clear the appropriate
 * bit, negating the error-interrupt request. Typically, a write to the CERR in the
 * interrupt-service routine is used for this purpose. The normal DMA channel
 * completion indicators (setting the transfer control descriptor DONE flag and the
 * possible assertion of an interrupt request) are not affected when an error is
 * detected. The contents of this register can also be polled because a non-zero
 * value indicates the presence of a channel error regardless of the state of
 * the EEI. The state of any given channel's error indicators is affected by writes
 * to this register; it is also affected by writes to the CERR. On writes to the
 * ERR, a one in any bit position clears the corresponding channel's error
 * status. A zero in any bit position has no affect on the corresponding channel's
 * current error status. The CERR is provided so the error indicator for a single
 * channel can easily be cleared.
 */
/*!
 * @name Constants and macros for entire DMA_ERR register
 */
/*@{*/
#define DMA_RD_ERR(base)         (DMA_ERR_REG(base))
#define DMA_WR_ERR(base, value)  (DMA_ERR_REG(base) = (value))
#define DMA_RMW_ERR(base, mask, value) (DMA_WR_ERR(base, (DMA_RD_ERR(base) & ~(mask)) | (value)))
#define DMA_SET_ERR(base, value) (BME_OR32(&DMA_ERR_REG(base), (uint32_t)(value)))
#define DMA_CLR_ERR(base, value) (BME_AND32(&DMA_ERR_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_ERR(base, value) (BME_XOR32(&DMA_ERR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERR bitfields
 */

/*!
 * @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR0 field. */
#define DMA_RD_ERR_ERR0(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR0_MASK) >> DMA_ERR_ERR0_SHIFT)
#define DMA_BRD_ERR_ERR0(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT, DMA_ERR_ERR0_WIDTH))

/*! @brief Set the ERR0 field to a new value. */
#define DMA_WR_ERR_ERR0(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK), DMA_ERR_ERR0(value)))
#define DMA_BWR_ERR_ERR0(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR0_SHIFT), DMA_ERR_ERR0_SHIFT, DMA_ERR_ERR0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR1 field. */
#define DMA_RD_ERR_ERR1(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR1_MASK) >> DMA_ERR_ERR1_SHIFT)
#define DMA_BRD_ERR_ERR1(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT, DMA_ERR_ERR1_WIDTH))

/*! @brief Set the ERR1 field to a new value. */
#define DMA_WR_ERR_ERR1(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR1_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK), DMA_ERR_ERR1(value)))
#define DMA_BWR_ERR_ERR1(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR1_SHIFT), DMA_ERR_ERR1_SHIFT, DMA_ERR_ERR1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR2 field. */
#define DMA_RD_ERR_ERR2(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR2_MASK) >> DMA_ERR_ERR2_SHIFT)
#define DMA_BRD_ERR_ERR2(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT, DMA_ERR_ERR2_WIDTH))

/*! @brief Set the ERR2 field to a new value. */
#define DMA_WR_ERR_ERR2(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR2_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK), DMA_ERR_ERR2(value)))
#define DMA_BWR_ERR_ERR2(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR2_SHIFT), DMA_ERR_ERR2_SHIFT, DMA_ERR_ERR2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR3 field. */
#define DMA_RD_ERR_ERR3(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR3_MASK) >> DMA_ERR_ERR3_SHIFT)
#define DMA_BRD_ERR_ERR3(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT, DMA_ERR_ERR3_WIDTH))

/*! @brief Set the ERR3 field to a new value. */
#define DMA_WR_ERR_ERR3(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR3_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK), DMA_ERR_ERR3(value)))
#define DMA_BWR_ERR_ERR3(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR3_SHIFT), DMA_ERR_ERR3_SHIFT, DMA_ERR_ERR3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR4[4] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR4 field. */
#define DMA_RD_ERR_ERR4(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR4_MASK) >> DMA_ERR_ERR4_SHIFT)
#define DMA_BRD_ERR_ERR4(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR4_SHIFT, DMA_ERR_ERR4_WIDTH))

/*! @brief Set the ERR4 field to a new value. */
#define DMA_WR_ERR_ERR4(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR4_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK), DMA_ERR_ERR4(value)))
#define DMA_BWR_ERR_ERR4(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR4_SHIFT), DMA_ERR_ERR4_SHIFT, DMA_ERR_ERR4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR5[5] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR5 field. */
#define DMA_RD_ERR_ERR5(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR5_MASK) >> DMA_ERR_ERR5_SHIFT)
#define DMA_BRD_ERR_ERR5(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR5_SHIFT, DMA_ERR_ERR5_WIDTH))

/*! @brief Set the ERR5 field to a new value. */
#define DMA_WR_ERR_ERR5(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR5_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK), DMA_ERR_ERR5(value)))
#define DMA_BWR_ERR_ERR5(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR5_SHIFT), DMA_ERR_ERR5_SHIFT, DMA_ERR_ERR5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR6[6] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR6 field. */
#define DMA_RD_ERR_ERR6(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR6_MASK) >> DMA_ERR_ERR6_SHIFT)
#define DMA_BRD_ERR_ERR6(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR6_SHIFT, DMA_ERR_ERR6_WIDTH))

/*! @brief Set the ERR6 field to a new value. */
#define DMA_WR_ERR_ERR6(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR6_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR7_MASK), DMA_ERR_ERR6(value)))
#define DMA_BWR_ERR_ERR6(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR6_SHIFT), DMA_ERR_ERR6_SHIFT, DMA_ERR_ERR6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR7[7] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR7 field. */
#define DMA_RD_ERR_ERR7(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR7_MASK) >> DMA_ERR_ERR7_SHIFT)
#define DMA_BRD_ERR_ERR7(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR7_SHIFT, DMA_ERR_ERR7_WIDTH))

/*! @brief Set the ERR7 field to a new value. */
#define DMA_WR_ERR_ERR7(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR7_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK), DMA_ERR_ERR7(value)))
#define DMA_BWR_ERR_ERR7(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR7_SHIFT), DMA_ERR_ERR7_SHIFT, DMA_ERR_ERR7_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_HRS - Hardware Request Status Register
 ******************************************************************************/

/*!
 * @brief DMA_HRS - Hardware Request Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The HRS register provides a bit map for the DMA channels, signaling the
 * presence of a hardware request for each channel. The hardware request status bits
 * reflect the current state of the register and qualified (via the ERQ fields)
 * DMA request signals as seen by the DMA's arbitration logic. This view into the
 * hardware request signals may be used for debug purposes. These bits reflect the
 * state of the request as seen by the arbitration logic. Therefore, this status
 * is affected by the ERQ bits.
 */
/*!
 * @name Constants and macros for entire DMA_HRS register
 */
/*@{*/
#define DMA_RD_HRS(base)         (DMA_HRS_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_HRS bitfields
 */

/*!
 * @name Register DMA_HRS, field HRS0[0] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 0 is not present
 * - 0b1 - A hardware service request for channel 0 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS0 field. */
#define DMA_RD_HRS_HRS0(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS0_MASK) >> DMA_HRS_HRS0_SHIFT)
#define DMA_BRD_HRS_HRS0(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS0_SHIFT, DMA_HRS_HRS0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS1[1] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 1 is not present
 * - 0b1 - A hardware service request for channel 1 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS1 field. */
#define DMA_RD_HRS_HRS1(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS1_MASK) >> DMA_HRS_HRS1_SHIFT)
#define DMA_BRD_HRS_HRS1(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS1_SHIFT, DMA_HRS_HRS1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS2[2] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 2 is not present
 * - 0b1 - A hardware service request for channel 2 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS2 field. */
#define DMA_RD_HRS_HRS2(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS2_MASK) >> DMA_HRS_HRS2_SHIFT)
#define DMA_BRD_HRS_HRS2(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS2_SHIFT, DMA_HRS_HRS2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS3[3] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 3 is not present
 * - 0b1 - A hardware service request for channel 3 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS3 field. */
#define DMA_RD_HRS_HRS3(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS3_MASK) >> DMA_HRS_HRS3_SHIFT)
#define DMA_BRD_HRS_HRS3(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS3_SHIFT, DMA_HRS_HRS3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS4[4] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 4 is not present
 * - 0b1 - A hardware service request for channel 4 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS4 field. */
#define DMA_RD_HRS_HRS4(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS4_MASK) >> DMA_HRS_HRS4_SHIFT)
#define DMA_BRD_HRS_HRS4(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS4_SHIFT, DMA_HRS_HRS4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS5[5] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 5 is not present
 * - 0b1 - A hardware service request for channel 5 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS5 field. */
#define DMA_RD_HRS_HRS5(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS5_MASK) >> DMA_HRS_HRS5_SHIFT)
#define DMA_BRD_HRS_HRS5(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS5_SHIFT, DMA_HRS_HRS5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS6[6] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 6 is not present
 * - 0b1 - A hardware service request for channel 6 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS6 field. */
#define DMA_RD_HRS_HRS6(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS6_MASK) >> DMA_HRS_HRS6_SHIFT)
#define DMA_BRD_HRS_HRS6(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS6_SHIFT, DMA_HRS_HRS6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS7[7] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 7 is not present
 * - 0b1 - A hardware service request for channel 7 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS7 field. */
#define DMA_RD_HRS_HRS7(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS7_MASK) >> DMA_HRS_HRS7_SHIFT)
#define DMA_BRD_HRS_HRS7(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS7_SHIFT, DMA_HRS_HRS7_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_EARS - Enable Asynchronous Request in Stop Register
 ******************************************************************************/

/*!
 * @brief DMA_EARS - Enable Asynchronous Request in Stop Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_EARS register
 */
/*@{*/
#define DMA_RD_EARS(base)        (DMA_EARS_REG(base))
#define DMA_WR_EARS(base, value) (DMA_EARS_REG(base) = (value))
#define DMA_RMW_EARS(base, mask, value) (DMA_WR_EARS(base, (DMA_RD_EARS(base) & ~(mask)) | (value)))
#define DMA_SET_EARS(base, value) (BME_OR32(&DMA_EARS_REG(base), (uint32_t)(value)))
#define DMA_CLR_EARS(base, value) (BME_AND32(&DMA_EARS_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_EARS(base, value) (BME_XOR32(&DMA_EARS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EARS bitfields
 */

/*!
 * @name Register DMA_EARS, field EDREQ_0[0] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 0.
 * - 0b1 - Enable asynchronous DMA request for channel 0.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_0 field. */
#define DMA_RD_EARS_EDREQ_0(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_0_MASK) >> DMA_EARS_EDREQ_0_SHIFT)
#define DMA_BRD_EARS_EDREQ_0(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_0_SHIFT, DMA_EARS_EDREQ_0_WIDTH))

/*! @brief Set the EDREQ_0 field to a new value. */
#define DMA_WR_EARS_EDREQ_0(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_0_MASK, DMA_EARS_EDREQ_0(value)))
#define DMA_BWR_EARS_EDREQ_0(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_0_SHIFT), DMA_EARS_EDREQ_0_SHIFT, DMA_EARS_EDREQ_0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_1[1] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 1
 * - 0b1 - Enable asynchronous DMA request for channel 1.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_1 field. */
#define DMA_RD_EARS_EDREQ_1(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_1_MASK) >> DMA_EARS_EDREQ_1_SHIFT)
#define DMA_BRD_EARS_EDREQ_1(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_1_SHIFT, DMA_EARS_EDREQ_1_WIDTH))

/*! @brief Set the EDREQ_1 field to a new value. */
#define DMA_WR_EARS_EDREQ_1(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_1_MASK, DMA_EARS_EDREQ_1(value)))
#define DMA_BWR_EARS_EDREQ_1(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_1_SHIFT), DMA_EARS_EDREQ_1_SHIFT, DMA_EARS_EDREQ_1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_2[2] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 2.
 * - 0b1 - Enable asynchronous DMA request for channel 2.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_2 field. */
#define DMA_RD_EARS_EDREQ_2(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_2_MASK) >> DMA_EARS_EDREQ_2_SHIFT)
#define DMA_BRD_EARS_EDREQ_2(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_2_SHIFT, DMA_EARS_EDREQ_2_WIDTH))

/*! @brief Set the EDREQ_2 field to a new value. */
#define DMA_WR_EARS_EDREQ_2(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_2_MASK, DMA_EARS_EDREQ_2(value)))
#define DMA_BWR_EARS_EDREQ_2(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_2_SHIFT), DMA_EARS_EDREQ_2_SHIFT, DMA_EARS_EDREQ_2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_3[3] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 3.
 * - 0b1 - Enable asynchronous DMA request for channel 3.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_3 field. */
#define DMA_RD_EARS_EDREQ_3(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_3_MASK) >> DMA_EARS_EDREQ_3_SHIFT)
#define DMA_BRD_EARS_EDREQ_3(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_3_SHIFT, DMA_EARS_EDREQ_3_WIDTH))

/*! @brief Set the EDREQ_3 field to a new value. */
#define DMA_WR_EARS_EDREQ_3(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_3_MASK, DMA_EARS_EDREQ_3(value)))
#define DMA_BWR_EARS_EDREQ_3(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_3_SHIFT), DMA_EARS_EDREQ_3_SHIFT, DMA_EARS_EDREQ_3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_4[4] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 4.
 * - 0b1 - Enable asynchronous DMA request for channel 4.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_4 field. */
#define DMA_RD_EARS_EDREQ_4(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_4_MASK) >> DMA_EARS_EDREQ_4_SHIFT)
#define DMA_BRD_EARS_EDREQ_4(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_4_SHIFT, DMA_EARS_EDREQ_4_WIDTH))

/*! @brief Set the EDREQ_4 field to a new value. */
#define DMA_WR_EARS_EDREQ_4(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_4_MASK, DMA_EARS_EDREQ_4(value)))
#define DMA_BWR_EARS_EDREQ_4(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_4_SHIFT), DMA_EARS_EDREQ_4_SHIFT, DMA_EARS_EDREQ_4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_5[5] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 5.
 * - 0b1 - Enable asynchronous DMA request for channel 5.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_5 field. */
#define DMA_RD_EARS_EDREQ_5(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_5_MASK) >> DMA_EARS_EDREQ_5_SHIFT)
#define DMA_BRD_EARS_EDREQ_5(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_5_SHIFT, DMA_EARS_EDREQ_5_WIDTH))

/*! @brief Set the EDREQ_5 field to a new value. */
#define DMA_WR_EARS_EDREQ_5(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_5_MASK, DMA_EARS_EDREQ_5(value)))
#define DMA_BWR_EARS_EDREQ_5(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_5_SHIFT), DMA_EARS_EDREQ_5_SHIFT, DMA_EARS_EDREQ_5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_6[6] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 6.
 * - 0b1 - Enable asynchronous DMA request for channel 6.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_6 field. */
#define DMA_RD_EARS_EDREQ_6(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_6_MASK) >> DMA_EARS_EDREQ_6_SHIFT)
#define DMA_BRD_EARS_EDREQ_6(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_6_SHIFT, DMA_EARS_EDREQ_6_WIDTH))

/*! @brief Set the EDREQ_6 field to a new value. */
#define DMA_WR_EARS_EDREQ_6(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_6_MASK, DMA_EARS_EDREQ_6(value)))
#define DMA_BWR_EARS_EDREQ_6(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_6_SHIFT), DMA_EARS_EDREQ_6_SHIFT, DMA_EARS_EDREQ_6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_7[7] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 7.
 * - 0b1 - Enable asynchronous DMA request for channel 7.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_7 field. */
#define DMA_RD_EARS_EDREQ_7(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_7_MASK) >> DMA_EARS_EDREQ_7_SHIFT)
#define DMA_BRD_EARS_EDREQ_7(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_7_SHIFT, DMA_EARS_EDREQ_7_WIDTH))

/*! @brief Set the EDREQ_7 field to a new value. */
#define DMA_WR_EARS_EDREQ_7(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_7_MASK, DMA_EARS_EDREQ_7(value)))
#define DMA_BWR_EARS_EDREQ_7(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_7_SHIFT), DMA_EARS_EDREQ_7_SHIFT, DMA_EARS_EDREQ_7_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI3 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI3 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI3 register
 */
/*@{*/
#define DMA_RD_DCHPRI3(base)     (DMA_DCHPRI3_REG(base))
#define DMA_WR_DCHPRI3(base, value) (DMA_DCHPRI3_REG(base) = (value))
#define DMA_RMW_DCHPRI3(base, mask, value) (DMA_WR_DCHPRI3(base, (DMA_RD_DCHPRI3(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI3(base, value) (BME_OR8(&DMA_DCHPRI3_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI3(base, value) (BME_AND8(&DMA_DCHPRI3_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI3(base, value) (BME_XOR8(&DMA_DCHPRI3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI3 bitfields
 */

/*!
 * @name Register DMA_DCHPRI3, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_CHPRI field. */
#define DMA_RD_DCHPRI3_CHPRI(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_CHPRI_MASK) >> DMA_DCHPRI3_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI3_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_CHPRI_SHIFT, DMA_DCHPRI3_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI3_CHPRI(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_CHPRI_MASK, DMA_DCHPRI3_CHPRI(value)))
#define DMA_BWR_DCHPRI3_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_CHPRI_SHIFT), DMA_DCHPRI3_CHPRI_SHIFT, DMA_DCHPRI3_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_DPA field. */
#define DMA_RD_DCHPRI3_DPA(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_DPA_MASK) >> DMA_DCHPRI3_DPA_SHIFT)
#define DMA_BRD_DCHPRI3_DPA(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_DPA_SHIFT, DMA_DCHPRI3_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI3_DPA(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_DPA_MASK, DMA_DCHPRI3_DPA(value)))
#define DMA_BWR_DCHPRI3_DPA(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_DPA_SHIFT), DMA_DCHPRI3_DPA_SHIFT, DMA_DCHPRI3_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_ECP field. */
#define DMA_RD_DCHPRI3_ECP(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_ECP_MASK) >> DMA_DCHPRI3_ECP_SHIFT)
#define DMA_BRD_DCHPRI3_ECP(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_ECP_SHIFT, DMA_DCHPRI3_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI3_ECP(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_ECP_MASK, DMA_DCHPRI3_ECP(value)))
#define DMA_BWR_DCHPRI3_ECP(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_ECP_SHIFT), DMA_DCHPRI3_ECP_SHIFT, DMA_DCHPRI3_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI2 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI2 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI2 register
 */
/*@{*/
#define DMA_RD_DCHPRI2(base)     (DMA_DCHPRI2_REG(base))
#define DMA_WR_DCHPRI2(base, value) (DMA_DCHPRI2_REG(base) = (value))
#define DMA_RMW_DCHPRI2(base, mask, value) (DMA_WR_DCHPRI2(base, (DMA_RD_DCHPRI2(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI2(base, value) (BME_OR8(&DMA_DCHPRI2_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI2(base, value) (BME_AND8(&DMA_DCHPRI2_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI2(base, value) (BME_XOR8(&DMA_DCHPRI2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI2 bitfields
 */

/*!
 * @name Register DMA_DCHPRI2, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_CHPRI field. */
#define DMA_RD_DCHPRI2_CHPRI(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_CHPRI_MASK) >> DMA_DCHPRI2_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI2_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_CHPRI_SHIFT, DMA_DCHPRI2_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI2_CHPRI(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_CHPRI_MASK, DMA_DCHPRI2_CHPRI(value)))
#define DMA_BWR_DCHPRI2_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_CHPRI_SHIFT), DMA_DCHPRI2_CHPRI_SHIFT, DMA_DCHPRI2_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_DPA field. */
#define DMA_RD_DCHPRI2_DPA(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_DPA_MASK) >> DMA_DCHPRI2_DPA_SHIFT)
#define DMA_BRD_DCHPRI2_DPA(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_DPA_SHIFT, DMA_DCHPRI2_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI2_DPA(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_DPA_MASK, DMA_DCHPRI2_DPA(value)))
#define DMA_BWR_DCHPRI2_DPA(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_DPA_SHIFT), DMA_DCHPRI2_DPA_SHIFT, DMA_DCHPRI2_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_ECP field. */
#define DMA_RD_DCHPRI2_ECP(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_ECP_MASK) >> DMA_DCHPRI2_ECP_SHIFT)
#define DMA_BRD_DCHPRI2_ECP(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_ECP_SHIFT, DMA_DCHPRI2_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI2_ECP(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_ECP_MASK, DMA_DCHPRI2_ECP(value)))
#define DMA_BWR_DCHPRI2_ECP(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_ECP_SHIFT), DMA_DCHPRI2_ECP_SHIFT, DMA_DCHPRI2_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI1 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI1 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI1 register
 */
/*@{*/
#define DMA_RD_DCHPRI1(base)     (DMA_DCHPRI1_REG(base))
#define DMA_WR_DCHPRI1(base, value) (DMA_DCHPRI1_REG(base) = (value))
#define DMA_RMW_DCHPRI1(base, mask, value) (DMA_WR_DCHPRI1(base, (DMA_RD_DCHPRI1(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI1(base, value) (BME_OR8(&DMA_DCHPRI1_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI1(base, value) (BME_AND8(&DMA_DCHPRI1_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI1(base, value) (BME_XOR8(&DMA_DCHPRI1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI1 bitfields
 */

/*!
 * @name Register DMA_DCHPRI1, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_CHPRI field. */
#define DMA_RD_DCHPRI1_CHPRI(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_CHPRI_MASK) >> DMA_DCHPRI1_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI1_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_CHPRI_SHIFT, DMA_DCHPRI1_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI1_CHPRI(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_CHPRI_MASK, DMA_DCHPRI1_CHPRI(value)))
#define DMA_BWR_DCHPRI1_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_CHPRI_SHIFT), DMA_DCHPRI1_CHPRI_SHIFT, DMA_DCHPRI1_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_DPA field. */
#define DMA_RD_DCHPRI1_DPA(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_DPA_MASK) >> DMA_DCHPRI1_DPA_SHIFT)
#define DMA_BRD_DCHPRI1_DPA(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_DPA_SHIFT, DMA_DCHPRI1_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI1_DPA(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_DPA_MASK, DMA_DCHPRI1_DPA(value)))
#define DMA_BWR_DCHPRI1_DPA(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_DPA_SHIFT), DMA_DCHPRI1_DPA_SHIFT, DMA_DCHPRI1_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_ECP field. */
#define DMA_RD_DCHPRI1_ECP(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_ECP_MASK) >> DMA_DCHPRI1_ECP_SHIFT)
#define DMA_BRD_DCHPRI1_ECP(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_ECP_SHIFT, DMA_DCHPRI1_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI1_ECP(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_ECP_MASK, DMA_DCHPRI1_ECP(value)))
#define DMA_BWR_DCHPRI1_ECP(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_ECP_SHIFT), DMA_DCHPRI1_ECP_SHIFT, DMA_DCHPRI1_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI0 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI0 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI0 register
 */
/*@{*/
#define DMA_RD_DCHPRI0(base)     (DMA_DCHPRI0_REG(base))
#define DMA_WR_DCHPRI0(base, value) (DMA_DCHPRI0_REG(base) = (value))
#define DMA_RMW_DCHPRI0(base, mask, value) (DMA_WR_DCHPRI0(base, (DMA_RD_DCHPRI0(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI0(base, value) (BME_OR8(&DMA_DCHPRI0_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI0(base, value) (BME_AND8(&DMA_DCHPRI0_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI0(base, value) (BME_XOR8(&DMA_DCHPRI0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI0 bitfields
 */

/*!
 * @name Register DMA_DCHPRI0, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_CHPRI field. */
#define DMA_RD_DCHPRI0_CHPRI(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI0_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI0_CHPRI(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_CHPRI_MASK, DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRI0_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_CHPRI_SHIFT), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_DPA field. */
#define DMA_RD_DCHPRI0_DPA(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRI0_DPA(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI0_DPA(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_DPA_MASK, DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRI0_DPA(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_DPA_SHIFT), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_ECP field. */
#define DMA_RD_DCHPRI0_ECP(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRI0_ECP(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI0_ECP(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_ECP_MASK, DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRI0_ECP(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_ECP_SHIFT), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI7 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI7 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI7 register
 */
/*@{*/
#define DMA_RD_DCHPRI7(base)     (DMA_DCHPRI7_REG(base))
#define DMA_WR_DCHPRI7(base, value) (DMA_DCHPRI7_REG(base) = (value))
#define DMA_RMW_DCHPRI7(base, mask, value) (DMA_WR_DCHPRI7(base, (DMA_RD_DCHPRI7(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI7(base, value) (BME_OR8(&DMA_DCHPRI7_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI7(base, value) (BME_AND8(&DMA_DCHPRI7_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI7(base, value) (BME_XOR8(&DMA_DCHPRI7_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI7 bitfields
 */

/*!
 * @name Register DMA_DCHPRI7, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_CHPRI field. */
#define DMA_RD_DCHPRI7_CHPRI(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_CHPRI_MASK) >> DMA_DCHPRI7_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI7_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_CHPRI_SHIFT, DMA_DCHPRI7_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI7_CHPRI(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_CHPRI_MASK, DMA_DCHPRI7_CHPRI(value)))
#define DMA_BWR_DCHPRI7_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI7_REG(base), ((uint8_t)(value) << DMA_DCHPRI7_CHPRI_SHIFT), DMA_DCHPRI7_CHPRI_SHIFT, DMA_DCHPRI7_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI7, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_DPA field. */
#define DMA_RD_DCHPRI7_DPA(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_DPA_MASK) >> DMA_DCHPRI7_DPA_SHIFT)
#define DMA_BRD_DCHPRI7_DPA(base) (BME_UBFX8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_DPA_SHIFT, DMA_DCHPRI7_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI7_DPA(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_DPA_MASK, DMA_DCHPRI7_DPA(value)))
#define DMA_BWR_DCHPRI7_DPA(base, value) (BME_BFI8(&DMA_DCHPRI7_REG(base), ((uint8_t)(value) << DMA_DCHPRI7_DPA_SHIFT), DMA_DCHPRI7_DPA_SHIFT, DMA_DCHPRI7_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI7, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_ECP field. */
#define DMA_RD_DCHPRI7_ECP(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_ECP_MASK) >> DMA_DCHPRI7_ECP_SHIFT)
#define DMA_BRD_DCHPRI7_ECP(base) (BME_UBFX8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_ECP_SHIFT, DMA_DCHPRI7_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI7_ECP(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_ECP_MASK, DMA_DCHPRI7_ECP(value)))
#define DMA_BWR_DCHPRI7_ECP(base, value) (BME_BFI8(&DMA_DCHPRI7_REG(base), ((uint8_t)(value) << DMA_DCHPRI7_ECP_SHIFT), DMA_DCHPRI7_ECP_SHIFT, DMA_DCHPRI7_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI6 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI6 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI6 register
 */
/*@{*/
#define DMA_RD_DCHPRI6(base)     (DMA_DCHPRI6_REG(base))
#define DMA_WR_DCHPRI6(base, value) (DMA_DCHPRI6_REG(base) = (value))
#define DMA_RMW_DCHPRI6(base, mask, value) (DMA_WR_DCHPRI6(base, (DMA_RD_DCHPRI6(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI6(base, value) (BME_OR8(&DMA_DCHPRI6_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI6(base, value) (BME_AND8(&DMA_DCHPRI6_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI6(base, value) (BME_XOR8(&DMA_DCHPRI6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI6 bitfields
 */

/*!
 * @name Register DMA_DCHPRI6, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_CHPRI field. */
#define DMA_RD_DCHPRI6_CHPRI(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_CHPRI_MASK) >> DMA_DCHPRI6_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI6_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_CHPRI_SHIFT, DMA_DCHPRI6_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI6_CHPRI(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_CHPRI_MASK, DMA_DCHPRI6_CHPRI(value)))
#define DMA_BWR_DCHPRI6_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI6_REG(base), ((uint8_t)(value) << DMA_DCHPRI6_CHPRI_SHIFT), DMA_DCHPRI6_CHPRI_SHIFT, DMA_DCHPRI6_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI6, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_DPA field. */
#define DMA_RD_DCHPRI6_DPA(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_DPA_MASK) >> DMA_DCHPRI6_DPA_SHIFT)
#define DMA_BRD_DCHPRI6_DPA(base) (BME_UBFX8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_DPA_SHIFT, DMA_DCHPRI6_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI6_DPA(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_DPA_MASK, DMA_DCHPRI6_DPA(value)))
#define DMA_BWR_DCHPRI6_DPA(base, value) (BME_BFI8(&DMA_DCHPRI6_REG(base), ((uint8_t)(value) << DMA_DCHPRI6_DPA_SHIFT), DMA_DCHPRI6_DPA_SHIFT, DMA_DCHPRI6_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI6, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_ECP field. */
#define DMA_RD_DCHPRI6_ECP(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_ECP_MASK) >> DMA_DCHPRI6_ECP_SHIFT)
#define DMA_BRD_DCHPRI6_ECP(base) (BME_UBFX8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_ECP_SHIFT, DMA_DCHPRI6_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI6_ECP(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_ECP_MASK, DMA_DCHPRI6_ECP(value)))
#define DMA_BWR_DCHPRI6_ECP(base, value) (BME_BFI8(&DMA_DCHPRI6_REG(base), ((uint8_t)(value) << DMA_DCHPRI6_ECP_SHIFT), DMA_DCHPRI6_ECP_SHIFT, DMA_DCHPRI6_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI5 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI5 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI5 register
 */
/*@{*/
#define DMA_RD_DCHPRI5(base)     (DMA_DCHPRI5_REG(base))
#define DMA_WR_DCHPRI5(base, value) (DMA_DCHPRI5_REG(base) = (value))
#define DMA_RMW_DCHPRI5(base, mask, value) (DMA_WR_DCHPRI5(base, (DMA_RD_DCHPRI5(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI5(base, value) (BME_OR8(&DMA_DCHPRI5_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI5(base, value) (BME_AND8(&DMA_DCHPRI5_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI5(base, value) (BME_XOR8(&DMA_DCHPRI5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI5 bitfields
 */

/*!
 * @name Register DMA_DCHPRI5, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_CHPRI field. */
#define DMA_RD_DCHPRI5_CHPRI(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_CHPRI_MASK) >> DMA_DCHPRI5_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI5_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_CHPRI_SHIFT, DMA_DCHPRI5_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI5_CHPRI(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_CHPRI_MASK, DMA_DCHPRI5_CHPRI(value)))
#define DMA_BWR_DCHPRI5_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI5_REG(base), ((uint8_t)(value) << DMA_DCHPRI5_CHPRI_SHIFT), DMA_DCHPRI5_CHPRI_SHIFT, DMA_DCHPRI5_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI5, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_DPA field. */
#define DMA_RD_DCHPRI5_DPA(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_DPA_MASK) >> DMA_DCHPRI5_DPA_SHIFT)
#define DMA_BRD_DCHPRI5_DPA(base) (BME_UBFX8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_DPA_SHIFT, DMA_DCHPRI5_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI5_DPA(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_DPA_MASK, DMA_DCHPRI5_DPA(value)))
#define DMA_BWR_DCHPRI5_DPA(base, value) (BME_BFI8(&DMA_DCHPRI5_REG(base), ((uint8_t)(value) << DMA_DCHPRI5_DPA_SHIFT), DMA_DCHPRI5_DPA_SHIFT, DMA_DCHPRI5_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI5, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_ECP field. */
#define DMA_RD_DCHPRI5_ECP(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_ECP_MASK) >> DMA_DCHPRI5_ECP_SHIFT)
#define DMA_BRD_DCHPRI5_ECP(base) (BME_UBFX8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_ECP_SHIFT, DMA_DCHPRI5_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI5_ECP(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_ECP_MASK, DMA_DCHPRI5_ECP(value)))
#define DMA_BWR_DCHPRI5_ECP(base, value) (BME_BFI8(&DMA_DCHPRI5_REG(base), ((uint8_t)(value) << DMA_DCHPRI5_ECP_SHIFT), DMA_DCHPRI5_ECP_SHIFT, DMA_DCHPRI5_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI4 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI4 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 7.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI4 register
 */
/*@{*/
#define DMA_RD_DCHPRI4(base)     (DMA_DCHPRI4_REG(base))
#define DMA_WR_DCHPRI4(base, value) (DMA_DCHPRI4_REG(base) = (value))
#define DMA_RMW_DCHPRI4(base, mask, value) (DMA_WR_DCHPRI4(base, (DMA_RD_DCHPRI4(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI4(base, value) (BME_OR8(&DMA_DCHPRI4_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI4(base, value) (BME_AND8(&DMA_DCHPRI4_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI4(base, value) (BME_XOR8(&DMA_DCHPRI4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI4 bitfields
 */

/*!
 * @name Register DMA_DCHPRI4, field CHPRI[2:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI7[CHPRI] = 0b111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_CHPRI field. */
#define DMA_RD_DCHPRI4_CHPRI(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_CHPRI_MASK) >> DMA_DCHPRI4_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI4_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_CHPRI_SHIFT, DMA_DCHPRI4_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI4_CHPRI(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_CHPRI_MASK, DMA_DCHPRI4_CHPRI(value)))
#define DMA_BWR_DCHPRI4_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI4_REG(base), ((uint8_t)(value) << DMA_DCHPRI4_CHPRI_SHIFT), DMA_DCHPRI4_CHPRI_SHIFT, DMA_DCHPRI4_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI4, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_DPA field. */
#define DMA_RD_DCHPRI4_DPA(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_DPA_MASK) >> DMA_DCHPRI4_DPA_SHIFT)
#define DMA_BRD_DCHPRI4_DPA(base) (BME_UBFX8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_DPA_SHIFT, DMA_DCHPRI4_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI4_DPA(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_DPA_MASK, DMA_DCHPRI4_DPA(value)))
#define DMA_BWR_DCHPRI4_DPA(base, value) (BME_BFI8(&DMA_DCHPRI4_REG(base), ((uint8_t)(value) << DMA_DCHPRI4_DPA_SHIFT), DMA_DCHPRI4_DPA_SHIFT, DMA_DCHPRI4_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI4, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_ECP field. */
#define DMA_RD_DCHPRI4_ECP(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_ECP_MASK) >> DMA_DCHPRI4_ECP_SHIFT)
#define DMA_BRD_DCHPRI4_ECP(base) (BME_UBFX8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_ECP_SHIFT, DMA_DCHPRI4_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI4_ECP(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_ECP_MASK, DMA_DCHPRI4_ECP(value)))
#define DMA_BWR_DCHPRI4_ECP(base, value) (BME_BFI8(&DMA_DCHPRI4_REG(base), ((uint8_t)(value) << DMA_DCHPRI4_ECP_SHIFT), DMA_DCHPRI4_ECP_SHIFT, DMA_DCHPRI4_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SADDR register
 */
/*@{*/
#define DMA_RD_SADDR(base, index) (DMA_SADDR_REG(base, index))
#define DMA_WR_SADDR(base, index, value) (DMA_SADDR_REG(base, index) = (value))
#define DMA_RMW_SADDR(base, index, mask, value) (DMA_WR_SADDR(base, index, (DMA_RD_SADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_SADDR(base, index, value) (BME_OR32(&DMA_SADDR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SADDR(base, index, value) (BME_AND32(&DMA_SADDR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SADDR(base, index, value) (BME_XOR32(&DMA_SADDR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_SOFF register
 */
/*@{*/
#define DMA_RD_SOFF(base, index) (DMA_SOFF_REG(base, index))
#define DMA_WR_SOFF(base, index, value) (DMA_SOFF_REG(base, index) = (value))
#define DMA_RMW_SOFF(base, index, mask, value) (DMA_WR_SOFF(base, index, (DMA_RD_SOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_SOFF(base, index, value) (BME_OR16(&DMA_SOFF_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_SOFF(base, index, value) (BME_AND16(&DMA_SOFF_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_SOFF(base, index, value) (BME_XOR16(&DMA_SOFF_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_ATTR register
 */
/*@{*/
#define DMA_RD_ATTR(base, index) (DMA_ATTR_REG(base, index))
#define DMA_WR_ATTR(base, index, value) (DMA_ATTR_REG(base, index) = (value))
#define DMA_RMW_ATTR(base, index, mask, value) (DMA_WR_ATTR(base, index, (DMA_RD_ATTR(base, index) & ~(mask)) | (value)))
#define DMA_SET_ATTR(base, index, value) (BME_OR16(&DMA_ATTR_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_ATTR(base, index, value) (BME_AND16(&DMA_ATTR_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_ATTR(base, index, value) (BME_XOR16(&DMA_ATTR_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ATTR bitfields
 */

/*!
 * @name Register DMA_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DSIZE field. */
#define DMA_RD_ATTR_DSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DSIZE_MASK) >> DMA_ATTR_DSIZE_SHIFT)
#define DMA_BRD_ATTR_DSIZE(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_DSIZE_SHIFT, DMA_ATTR_DSIZE_WIDTH))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_ATTR_DSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DSIZE_MASK, DMA_ATTR_DSIZE(value)))
#define DMA_BWR_ATTR_DSIZE(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_DSIZE_SHIFT), DMA_ATTR_DSIZE_SHIFT, DMA_ATTR_DSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DMOD field. */
#define DMA_RD_ATTR_DMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DMOD_MASK) >> DMA_ATTR_DMOD_SHIFT)
#define DMA_BRD_ATTR_DMOD(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_DMOD_SHIFT, DMA_ATTR_DMOD_WIDTH))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_ATTR_DMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DMOD_MASK, DMA_ATTR_DMOD(value)))
#define DMA_BWR_ATTR_DMOD(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_DMOD_SHIFT), DMA_ATTR_DMOD_SHIFT, DMA_ATTR_DMOD_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte
 * - 0b101 - 32-byte
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SSIZE field. */
#define DMA_RD_ATTR_SSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SSIZE_MASK) >> DMA_ATTR_SSIZE_SHIFT)
#define DMA_BRD_ATTR_SSIZE(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_SSIZE_SHIFT, DMA_ATTR_SSIZE_WIDTH))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_ATTR_SSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SSIZE_MASK, DMA_ATTR_SSIZE(value)))
#define DMA_BWR_ATTR_SSIZE(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_SSIZE_SHIFT), DMA_ATTR_SSIZE_SHIFT, DMA_ATTR_SSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SMOD field. */
#define DMA_RD_ATTR_SMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SMOD_MASK) >> DMA_ATTR_SMOD_SHIFT)
#define DMA_BRD_ATTR_SMOD(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_SMOD_SHIFT, DMA_ATTR_SMOD_WIDTH))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_ATTR_SMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SMOD_MASK, DMA_ATTR_SMOD(value)))
#define DMA_BWR_ATTR_SMOD(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_SMOD_SHIFT), DMA_ATTR_SMOD_SHIFT, DMA_ATTR_SMOD_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFNO(base, index) (DMA_NBYTES_MLOFFNO_REG(base, index))
#define DMA_WR_NBYTES_MLOFFNO(base, index, value) (DMA_NBYTES_MLOFFNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFNO(base, index, mask, value) (DMA_WR_NBYTES_MLOFFNO(base, index, (DMA_RD_NBYTES_MLOFFNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFNO(base, index, value) (BME_OR32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLOFFNO(base, index, value) (BME_AND32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLOFFNO(base, index, value) (BME_XOR32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_NBYTES_MASK, DMA_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_DMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_DMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT, DMA_NBYTES_MLOFFNO_DMLOE_WIDTH))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_DMLOE_MASK, DMA_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_DMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFNO_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFNO_DMLOE_SHIFT), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT, DMA_NBYTES_MLOFFNO_DMLOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_SMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_SMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT, DMA_NBYTES_MLOFFNO_SMLOE_WIDTH))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_SMLOE_MASK, DMA_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_SMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFNO_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFNO_SMLOE_SHIFT), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT, DMA_NBYTES_MLOFFNO_SMLOE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLNO(base, index) (DMA_NBYTES_MLNO_REG(base, index))
#define DMA_WR_NBYTES_MLNO(base, index, value) (DMA_NBYTES_MLNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLNO(base, index, mask, value) (DMA_WR_NBYTES_MLNO(base, index, (DMA_RD_NBYTES_MLNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLNO(base, index, value) (BME_OR32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLNO(base, index, value) (BME_AND32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLNO(base, index, value) (BME_XOR32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFYES(base, index) (DMA_NBYTES_MLOFFYES_REG(base, index))
#define DMA_WR_NBYTES_MLOFFYES(base, index, value) (DMA_NBYTES_MLOFFYES_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFYES(base, index, mask, value) (DMA_WR_NBYTES_MLOFFYES(base, index, (DMA_RD_NBYTES_MLOFFYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFYES(base, index, value) (BME_OR32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLOFFYES(base, index, value) (BME_AND32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLOFFYES(base, index, value) (BME_XOR32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_NBYTES_MASK, DMA_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_MLOFF(base, index) (DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_MLOFF_MASK, DMA_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_DMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_DMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT, DMA_NBYTES_MLOFFYES_DMLOE_WIDTH))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_DMLOE_MASK, DMA_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_DMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFYES_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFYES_DMLOE_SHIFT), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT, DMA_NBYTES_MLOFFYES_DMLOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_SMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_SMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT, DMA_NBYTES_MLOFFYES_SMLOE_WIDTH))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_SMLOE_MASK, DMA_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_SMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFYES_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFYES_SMLOE_SHIFT), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT, DMA_NBYTES_MLOFFYES_SMLOE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SLAST register
 */
/*@{*/
#define DMA_RD_SLAST(base, index) (DMA_SLAST_REG(base, index))
#define DMA_WR_SLAST(base, index, value) (DMA_SLAST_REG(base, index) = (value))
#define DMA_RMW_SLAST(base, index, mask, value) (DMA_WR_SLAST(base, index, (DMA_RD_SLAST(base, index) & ~(mask)) | (value)))
#define DMA_SET_SLAST(base, index, value) (BME_OR32(&DMA_SLAST_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SLAST(base, index, value) (BME_AND32(&DMA_SLAST_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SLAST(base, index, value) (BME_XOR32(&DMA_SLAST_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DADDR register
 */
/*@{*/
#define DMA_RD_DADDR(base, index) (DMA_DADDR_REG(base, index))
#define DMA_WR_DADDR(base, index, value) (DMA_DADDR_REG(base, index) = (value))
#define DMA_RMW_DADDR(base, index, mask, value) (DMA_WR_DADDR(base, index, (DMA_RD_DADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DADDR(base, index, value) (BME_OR32(&DMA_DADDR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DADDR(base, index, value) (BME_AND32(&DMA_DADDR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DADDR(base, index, value) (BME_XOR32(&DMA_DADDR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_DOFF register
 */
/*@{*/
#define DMA_RD_DOFF(base, index) (DMA_DOFF_REG(base, index))
#define DMA_WR_DOFF(base, index, value) (DMA_DOFF_REG(base, index) = (value))
#define DMA_RMW_DOFF(base, index, mask, value) (DMA_WR_DOFF(base, index, (DMA_RD_DOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_DOFF(base, index, value) (BME_OR16(&DMA_DOFF_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_DOFF(base, index, value) (BME_AND16(&DMA_DOFF_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_DOFF(base, index, value) (BME_XOR16(&DMA_DOFF_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_CITER_ELINKNO(base, index) (DMA_CITER_ELINKNO_REG(base, index))
#define DMA_WR_CITER_ELINKNO(base, index, value) (DMA_CITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKNO(base, index, mask, value) (DMA_WR_CITER_ELINKNO(base, index, (DMA_RD_CITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKNO(base, index, value) (BME_OR16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CITER_ELINKNO(base, index, value) (BME_AND16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CITER_ELINKNO(base, index, value) (BME_XOR16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_CITER field. */
#define DMA_RD_CITER_ELINKNO_CITER(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_CITER_MASK) >> DMA_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKNO_CITER(base, index) (DMA_RD_CITER_ELINKNO_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKNO_CITER(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_CITER_MASK, DMA_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_CITER_ELINKNO_CITER(base, index, value) (DMA_WR_CITER_ELINKNO_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_ELINK field. */
#define DMA_RD_CITER_ELINKNO_ELINK(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_ELINK_MASK) >> DMA_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKNO_ELINK(base, index) (BME_UBFX16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_ELINK_SHIFT, DMA_CITER_ELINKNO_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_ELINK_MASK, DMA_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_CITER_ELINKNO_ELINK(base, index, value) (BME_BFI16(&DMA_CITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKNO_ELINK_SHIFT), DMA_CITER_ELINKNO_ELINK_SHIFT, DMA_CITER_ELINKNO_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_CITER_ELINKYES(base, index) (DMA_CITER_ELINKYES_REG(base, index))
#define DMA_WR_CITER_ELINKYES(base, index, value) (DMA_CITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKYES(base, index, mask, value) (DMA_WR_CITER_ELINKYES(base, index, (DMA_RD_CITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKYES(base, index, value) (BME_OR16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CITER_ELINKYES(base, index, value) (BME_AND16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CITER_ELINKYES(base, index, value) (BME_XOR16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_CITER field. */
#define DMA_RD_CITER_ELINKYES_CITER(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_CITER_MASK) >> DMA_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKYES_CITER(base, index) (DMA_RD_CITER_ELINKYES_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKYES_CITER(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_CITER_MASK, DMA_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_CITER_ELINKYES_CITER(base, index, value) (DMA_WR_CITER_ELINKYES_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field LINKCH[11:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_CITER_ELINKYES_LINKCH(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_LINKCH_MASK) >> DMA_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_CITER_ELINKYES_LINKCH(base, index) (BME_UBFX16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_LINKCH_SHIFT, DMA_CITER_ELINKYES_LINKCH_WIDTH))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_CITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_LINKCH_MASK, DMA_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_CITER_ELINKYES_LINKCH(base, index, value) (BME_BFI16(&DMA_CITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKYES_LINKCH_SHIFT), DMA_CITER_ELINKYES_LINKCH_SHIFT, DMA_CITER_ELINKYES_LINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_ELINK field. */
#define DMA_RD_CITER_ELINKYES_ELINK(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_ELINK_MASK) >> DMA_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKYES_ELINK(base, index) (BME_UBFX16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_ELINK_SHIFT, DMA_CITER_ELINKYES_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_ELINK_MASK, DMA_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_CITER_ELINKYES_ELINK(base, index, value) (BME_BFI16(&DMA_CITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKYES_ELINK_SHIFT), DMA_CITER_ELINKYES_ELINK_SHIFT, DMA_CITER_ELINKYES_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DLAST_SGA register
 */
/*@{*/
#define DMA_RD_DLAST_SGA(base, index) (DMA_DLAST_SGA_REG(base, index))
#define DMA_WR_DLAST_SGA(base, index, value) (DMA_DLAST_SGA_REG(base, index) = (value))
#define DMA_RMW_DLAST_SGA(base, index, mask, value) (DMA_WR_DLAST_SGA(base, index, (DMA_RD_DLAST_SGA(base, index) & ~(mask)) | (value)))
#define DMA_SET_DLAST_SGA(base, index, value) (BME_OR32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DLAST_SGA(base, index, value) (BME_AND32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DLAST_SGA(base, index, value) (BME_XOR32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_CSR register
 */
/*@{*/
#define DMA_RD_CSR(base, index)  (DMA_CSR_REG(base, index))
#define DMA_WR_CSR(base, index, value) (DMA_CSR_REG(base, index) = (value))
#define DMA_RMW_CSR(base, index, mask, value) (DMA_WR_CSR(base, index, (DMA_RD_CSR(base, index) & ~(mask)) | (value)))
#define DMA_SET_CSR(base, index, value) (BME_OR16(&DMA_CSR_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CSR(base, index, value) (BME_AND16(&DMA_CSR_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CSR(base, index, value) (BME_XOR16(&DMA_CSR_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CSR bitfields
 */

/*!
 * @name Register DMA_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_START field. */
#define DMA_RD_CSR_START(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_START_MASK) >> DMA_CSR_START_SHIFT)
#define DMA_BRD_CSR_START(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_START_SHIFT, DMA_CSR_START_WIDTH))

/*! @brief Set the START field to a new value. */
#define DMA_WR_CSR_START(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_START_MASK, DMA_CSR_START(value)))
#define DMA_BWR_CSR_START(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_START_SHIFT), DMA_CSR_START_SHIFT, DMA_CSR_START_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTMAJOR field. */
#define DMA_RD_CSR_INTMAJOR(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTMAJOR_MASK) >> DMA_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_CSR_INTMAJOR(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_INTMAJOR_SHIFT, DMA_CSR_INTMAJOR_WIDTH))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_CSR_INTMAJOR(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTMAJOR_MASK, DMA_CSR_INTMAJOR(value)))
#define DMA_BWR_CSR_INTMAJOR(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_INTMAJOR_SHIFT), DMA_CSR_INTMAJOR_SHIFT, DMA_CSR_INTMAJOR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTHALF field. */
#define DMA_RD_CSR_INTHALF(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTHALF_MASK) >> DMA_CSR_INTHALF_SHIFT)
#define DMA_BRD_CSR_INTHALF(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_INTHALF_SHIFT, DMA_CSR_INTHALF_WIDTH))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_CSR_INTHALF(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTHALF_MASK, DMA_CSR_INTHALF(value)))
#define DMA_BWR_CSR_INTHALF(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_INTHALF_SHIFT), DMA_CSR_INTHALF_SHIFT, DMA_CSR_INTHALF_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DREQ field. */
#define DMA_RD_CSR_DREQ(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DREQ_MASK) >> DMA_CSR_DREQ_SHIFT)
#define DMA_BRD_CSR_DREQ(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_DREQ_SHIFT, DMA_CSR_DREQ_WIDTH))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_CSR_DREQ(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DREQ_MASK, DMA_CSR_DREQ(value)))
#define DMA_BWR_CSR_DREQ(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_DREQ_SHIFT), DMA_CSR_DREQ_SHIFT, DMA_CSR_DREQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ESG field. */
#define DMA_RD_CSR_ESG(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ESG_MASK) >> DMA_CSR_ESG_SHIFT)
#define DMA_BRD_CSR_ESG(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_ESG_SHIFT, DMA_CSR_ESG_WIDTH))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_CSR_ESG(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ESG_MASK, DMA_CSR_ESG(value)))
#define DMA_BWR_CSR_ESG(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_ESG_SHIFT), DMA_CSR_ESG_SHIFT, DMA_CSR_ESG_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORELINK field. */
#define DMA_RD_CSR_MAJORELINK(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORELINK_MASK) >> DMA_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_CSR_MAJORELINK(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORELINK_SHIFT, DMA_CSR_MAJORELINK_WIDTH))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_CSR_MAJORELINK(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORELINK_MASK, DMA_CSR_MAJORELINK(value)))
#define DMA_BWR_CSR_MAJORELINK(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_MAJORELINK_SHIFT), DMA_CSR_MAJORELINK_SHIFT, DMA_CSR_MAJORELINK_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ACTIVE field. */
#define DMA_RD_CSR_ACTIVE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ACTIVE_MASK) >> DMA_CSR_ACTIVE_SHIFT)
#define DMA_BRD_CSR_ACTIVE(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_ACTIVE_SHIFT, DMA_CSR_ACTIVE_WIDTH))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_CSR_ACTIVE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ACTIVE_MASK, DMA_CSR_ACTIVE(value)))
#define DMA_BWR_CSR_ACTIVE(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_ACTIVE_SHIFT), DMA_CSR_ACTIVE_SHIFT, DMA_CSR_ACTIVE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DONE field. */
#define DMA_RD_CSR_DONE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT)
#define DMA_BRD_CSR_DONE(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_DONE_SHIFT, DMA_CSR_DONE_WIDTH))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_CSR_DONE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DONE_MASK, DMA_CSR_DONE(value)))
#define DMA_BWR_CSR_DONE(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_DONE_SHIFT), DMA_CSR_DONE_SHIFT, DMA_CSR_DONE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORLINKCH[10:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORLINKCH field. */
#define DMA_RD_CSR_MAJORLINKCH(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORLINKCH_MASK) >> DMA_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_CSR_MAJORLINKCH(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORLINKCH_SHIFT, DMA_CSR_MAJORLINKCH_WIDTH))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_CSR_MAJORLINKCH(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORLINKCH_MASK, DMA_CSR_MAJORLINKCH(value)))
#define DMA_BWR_CSR_MAJORLINKCH(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_MAJORLINKCH_SHIFT), DMA_CSR_MAJORLINKCH_SHIFT, DMA_CSR_MAJORLINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls.
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_BWC field. */
#define DMA_RD_CSR_BWC(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_BWC_MASK) >> DMA_CSR_BWC_SHIFT)
#define DMA_BRD_CSR_BWC(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_BWC_SHIFT, DMA_CSR_BWC_WIDTH))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_CSR_BWC(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_BWC_MASK, DMA_CSR_BWC(value)))
#define DMA_BWR_CSR_BWC(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_BWC_SHIFT), DMA_CSR_BWC_SHIFT, DMA_CSR_BWC_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_BITER_ELINKYES(base, index) (DMA_BITER_ELINKYES_REG(base, index))
#define DMA_WR_BITER_ELINKYES(base, index, value) (DMA_BITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKYES(base, index, mask, value) (DMA_WR_BITER_ELINKYES(base, index, (DMA_RD_BITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKYES(base, index, value) (BME_OR16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_BITER_ELINKYES(base, index, value) (BME_AND16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_BITER_ELINKYES(base, index, value) (BME_XOR16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_BITER field. */
#define DMA_RD_BITER_ELINKYES_BITER(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_BITER_MASK) >> DMA_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKYES_BITER(base, index) (DMA_RD_BITER_ELINKYES_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKYES_BITER(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_BITER_MASK, DMA_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_BITER_ELINKYES_BITER(base, index, value) (DMA_WR_BITER_ELINKYES_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field LINKCH[11:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_BITER_ELINKYES_LINKCH(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_LINKCH_MASK) >> DMA_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_BITER_ELINKYES_LINKCH(base, index) (BME_UBFX16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_LINKCH_SHIFT, DMA_BITER_ELINKYES_LINKCH_WIDTH))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_BITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_LINKCH_MASK, DMA_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_BITER_ELINKYES_LINKCH(base, index, value) (BME_BFI16(&DMA_BITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKYES_LINKCH_SHIFT), DMA_BITER_ELINKYES_LINKCH_SHIFT, DMA_BITER_ELINKYES_LINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_ELINK field. */
#define DMA_RD_BITER_ELINKYES_ELINK(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_ELINK_MASK) >> DMA_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKYES_ELINK(base, index) (BME_UBFX16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_ELINK_SHIFT, DMA_BITER_ELINKYES_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_ELINK_MASK, DMA_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_BITER_ELINKYES_ELINK(base, index, value) (BME_BFI16(&DMA_BITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKYES_ELINK_SHIFT), DMA_BITER_ELINKYES_ELINK_SHIFT, DMA_BITER_ELINKYES_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_BITER_ELINKNO(base, index) (DMA_BITER_ELINKNO_REG(base, index))
#define DMA_WR_BITER_ELINKNO(base, index, value) (DMA_BITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKNO(base, index, mask, value) (DMA_WR_BITER_ELINKNO(base, index, (DMA_RD_BITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKNO(base, index, value) (BME_OR16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_BITER_ELINKNO(base, index, value) (BME_AND16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_BITER_ELINKNO(base, index, value) (BME_XOR16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_BITER field. */
#define DMA_RD_BITER_ELINKNO_BITER(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_BITER_MASK) >> DMA_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKNO_BITER(base, index) (DMA_RD_BITER_ELINKNO_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKNO_BITER(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_BITER_MASK, DMA_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_BITER_ELINKNO_BITER(base, index, value) (DMA_WR_BITER_ELINKNO_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_ELINK field. */
#define DMA_RD_BITER_ELINKNO_ELINK(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_ELINK_MASK) >> DMA_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKNO_ELINK(base, index) (BME_UBFX16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_ELINK_SHIFT, DMA_BITER_ELINKNO_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_ELINK_MASK, DMA_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_BITER_ELINKNO_ELINK(base, index, value) (BME_BFI16(&DMA_BITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKNO_ELINK_SHIFT), DMA_BITER_ELINKNO_ELINK_SHIFT, DMA_BITER_ELINKNO_ELINK_WIDTH))
/*@}*/

/* Register macros for indexed access to DMA channel priority registers */
/*
 * Constants and macros for entire DMA_DCHPRIn register
 */
#define DMA_DCHPRIn_INDEX(channel)          (((channel) & ~0x03U) | (3 - ((channel) & 0x03U)))
#define DMA_DCHPRIn_REG(base, index)        (((volatile uint8_t *)&DMA_DCHPRI3_REG(base))[DMA_DCHPRIn_INDEX(index)])
#define DMA_RD_DCHPRIn(base, index)         (DMA_DCHPRIn_REG((base), (index)))
#define DMA_WR_DCHPRIn(base, index, value)  (DMA_DCHPRIn_REG((base), (index)) = (value))
#define DMA_SET_DCHPRIn(base, index, value) (BME_OR8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(value)))
#define DMA_CLR_DCHPRIn(base, index, value) (BME_AND8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRIn(base, index, value) (BME_XOR8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(value)))

/*
 * Register DMA_DCHPRIn, bit field CHPRI
 */
/* Read current value of the CHPRI bit field. */
#define DMA_RD_DCHPRIn_CHPRI(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRIn_CHPRI(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/* Set the CHPRI bit field to a new value. */
#define DMA_WR_DCHPRIn_CHPRI(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_CHPRI_MASK) | DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRIn_CHPRI(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_CHPRI_SHIFT), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/*
 * Register DMA_DCHPRIn, bit field DPA
 */
/* Read current value of the DPA bit field. */
#define DMA_RD_DCHPRIn_DPA(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRIn_DPA(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/* Set the DPA bit field to a new value. */
#define DMA_WR_DCHPRIn_DPA(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_DPA_MASK) | DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRIn_DPA(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_DPA_SHIFT), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/*
 * Register DMA_DCHPRIn, bit field ECP
 */
/* Read current value of the ECP bit field. */
#define DMA_RD_DCHPRIn_ECP(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRIn_ECP(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/* Set the ECP bit field to a new value. */
#define DMA_WR_DCHPRIn_ECP(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_ECP_MASK) | DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRIn_ECP(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_ECP_SHIFT), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/*
 * MKL28Z7 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration register
 */

#define DMAMUX_INSTANCE_COUNT (2U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX0_IDX (0U) /*!< Instance number for DMAMUX0. */
#define DMAMUX1_IDX (1U) /*!< Instance number for DMAMUX1. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (BME_OR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (BME_AND8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(~(value))))
#define DMAMUX_TOG_CHCFG(base, index, value) (BME_XOR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_SOURCE_SHIFT), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0b0 - Triggering is disabled. If triggering is disabled and ENBL is set,
 *     the DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 0b1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_TRIG field. */
#define DMAMUX_RD_CHCFG_TRIG(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_TRIG_MASK) >> DMAMUX_CHCFG_TRIG_SHIFT)
#define DMAMUX_BRD_CHCFG_TRIG(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))

/*! @brief Set the TRIG field to a new value. */
#define DMAMUX_WR_CHCFG_TRIG(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_TRIG_MASK, DMAMUX_CHCFG_TRIG(value)))
#define DMAMUX_BWR_CHCFG_TRIG(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_TRIG_SHIFT), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0b0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 0b1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_ENBL_SHIFT), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))
/*@}*/

/*
 * MKL28Z7 EMVSIM
 *
 * EMVSIM
 *
 * Registers defined in this header file:
 * - EMVSIM_VER_ID - Version ID Register
 * - EMVSIM_PARAM - Parameter Register
 * - EMVSIM_CLKCFG - Clock Configuration Register
 * - EMVSIM_DIVISOR - Baud Rate Divisor Register
 * - EMVSIM_CTRL - Control Register
 * - EMVSIM_INT_MASK - Interrupt Mask Register
 * - EMVSIM_RX_THD - Receiver Threshold Register
 * - EMVSIM_TX_THD - Transmitter Threshold Register
 * - EMVSIM_RX_STATUS - Receive Status Register
 * - EMVSIM_TX_STATUS - Transmitter Status Register
 * - EMVSIM_PCSR - Port Control and Status Register
 * - EMVSIM_RX_BUF - Receive Data Read Buffer
 * - EMVSIM_TX_BUF - Transmit Data Buffer
 * - EMVSIM_TX_GETU - Transmitter Guard ETU Value Register
 * - EMVSIM_CWT_VAL - Character Wait Time Value Register
 * - EMVSIM_BWT_VAL - Block Wait Time Value Register
 * - EMVSIM_BGT_VAL - Block Guard Time Value Register
 * - EMVSIM_GPCNT0_VAL - General Purpose Counter 0 Timeout Value Register
 * - EMVSIM_GPCNT1_VAL - General Purpose Counter 1 Timeout Value
 */

#define EMVSIM_INSTANCE_COUNT (1U) /*!< Number of instances of the EMVSIM module. */
#define EMVSIM0_IDX (0U) /*!< Instance number for EMVSIM0. */

/*******************************************************************************
 * EMVSIM_VER_ID - Version ID Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_VER_ID - Version ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Version ID for the IP. It corresponds to the version of IP being used.
 */
/*!
 * @name Constants and macros for entire EMVSIM_VER_ID register
 */
/*@{*/
#define EMVSIM_RD_VER_ID(base)   (EMVSIM_VER_ID_REG(base))
/*@}*/

/*******************************************************************************
 * EMVSIM_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00001010U
 *
 * This register provides details on the parameter settings that were used while
 * including this module in the chip.
 */
/*!
 * @name Constants and macros for entire EMVSIM_PARAM register
 */
/*@{*/
#define EMVSIM_RD_PARAM(base)    (EMVSIM_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_PARAM bitfields
 */

/*!
 * @name Register EMVSIM_PARAM, field RX_FIFO_DEPTH[7:0] (RO)
 *
 * Value of parameter for Receive FIFO Depth (in Bytes)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PARAM_RX_FIFO_DEPTH field. */
#define EMVSIM_RD_PARAM_RX_FIFO_DEPTH(base) ((EMVSIM_PARAM_REG(base) & EMVSIM_PARAM_RX_FIFO_DEPTH_MASK) >> EMVSIM_PARAM_RX_FIFO_DEPTH_SHIFT)
#define EMVSIM_BRD_PARAM_RX_FIFO_DEPTH(base) (BME_UBFX32(&EMVSIM_PARAM_REG(base), EMVSIM_PARAM_RX_FIFO_DEPTH_SHIFT, EMVSIM_PARAM_RX_FIFO_DEPTH_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PARAM, field TX_FIFO_DEPTH[15:8] (RO)
 *
 * Value of parameter for Transmit FIFO Depth (in Bytes)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PARAM_TX_FIFO_DEPTH field. */
#define EMVSIM_RD_PARAM_TX_FIFO_DEPTH(base) ((EMVSIM_PARAM_REG(base) & EMVSIM_PARAM_TX_FIFO_DEPTH_MASK) >> EMVSIM_PARAM_TX_FIFO_DEPTH_SHIFT)
#define EMVSIM_BRD_PARAM_TX_FIFO_DEPTH(base) (BME_UBFX32(&EMVSIM_PARAM_REG(base), EMVSIM_PARAM_TX_FIFO_DEPTH_SHIFT, EMVSIM_PARAM_TX_FIFO_DEPTH_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_CLKCFG - Clock Configuration Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_CLKCFG - Clock Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides configuration details to enable the right clock
 * frequency of clocks used by EMV SIM module.
 */
/*!
 * @name Constants and macros for entire EMVSIM_CLKCFG register
 */
/*@{*/
#define EMVSIM_RD_CLKCFG(base)   (EMVSIM_CLKCFG_REG(base))
#define EMVSIM_WR_CLKCFG(base, value) (EMVSIM_CLKCFG_REG(base) = (value))
#define EMVSIM_RMW_CLKCFG(base, mask, value) (EMVSIM_WR_CLKCFG(base, (EMVSIM_RD_CLKCFG(base) & ~(mask)) | (value)))
#define EMVSIM_SET_CLKCFG(base, value) (BME_OR32(&EMVSIM_CLKCFG_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_CLKCFG(base, value) (BME_AND32(&EMVSIM_CLKCFG_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_CLKCFG(base, value) (BME_XOR32(&EMVSIM_CLKCFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_CLKCFG bitfields
 */

/*!
 * @name Register EMVSIM_CLKCFG, field CLK_PRSC[7:0] (RW)
 *
 * The value written to this register will determine the desired card clock
 * frequency. The Card Clock frequency is the EMV SIM Protocol (or logic) clock
 * divided by this prescaler value. The prescaler value should be updated only when
 * card clock is disabled and transmitter and receiver are not operational.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CLKCFG_CLK_PRSC field. */
#define EMVSIM_RD_CLKCFG_CLK_PRSC(base) ((EMVSIM_CLKCFG_REG(base) & EMVSIM_CLKCFG_CLK_PRSC_MASK) >> EMVSIM_CLKCFG_CLK_PRSC_SHIFT)
#define EMVSIM_BRD_CLKCFG_CLK_PRSC(base) (BME_UBFX32(&EMVSIM_CLKCFG_REG(base), EMVSIM_CLKCFG_CLK_PRSC_SHIFT, EMVSIM_CLKCFG_CLK_PRSC_WIDTH))

/*! @brief Set the CLK_PRSC field to a new value. */
#define EMVSIM_WR_CLKCFG_CLK_PRSC(base, value) (EMVSIM_RMW_CLKCFG(base, EMVSIM_CLKCFG_CLK_PRSC_MASK, EMVSIM_CLKCFG_CLK_PRSC(value)))
#define EMVSIM_BWR_CLKCFG_CLK_PRSC(base, value) (BME_BFI32(&EMVSIM_CLKCFG_REG(base), ((uint32_t)(value) << EMVSIM_CLKCFG_CLK_PRSC_SHIFT), EMVSIM_CLKCFG_CLK_PRSC_SHIFT, EMVSIM_CLKCFG_CLK_PRSC_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CLKCFG, field GPCNT1_CLK_SEL[9:8] (RW)
 *
 * Selects which clock source is used by EMV SIM Module general purpose counter
 * 1. The only way to reset the counter is to set these bits to zero. The counter
 * will begin counting as soon as the clock input is selected and the clocks are
 * active. These input clocks are enabled through other register bits of the EMV
 * SIM module (KILL_CLOCK, RCV_EN, and XMT_EN). Counter is active while RCV_EN
 * or XMT_EN are set.
 *
 * Values:
 * - 0b00 - Disabled / Reset (default)
 * - 0b01 - Card Clock
 * - 0b10 - Receive Clock
 * - 0b11 - ETU Clock (transmit clock)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CLKCFG_GPCNT1_CLK_SEL field. */
#define EMVSIM_RD_CLKCFG_GPCNT1_CLK_SEL(base) ((EMVSIM_CLKCFG_REG(base) & EMVSIM_CLKCFG_GPCNT1_CLK_SEL_MASK) >> EMVSIM_CLKCFG_GPCNT1_CLK_SEL_SHIFT)
#define EMVSIM_BRD_CLKCFG_GPCNT1_CLK_SEL(base) (BME_UBFX32(&EMVSIM_CLKCFG_REG(base), EMVSIM_CLKCFG_GPCNT1_CLK_SEL_SHIFT, EMVSIM_CLKCFG_GPCNT1_CLK_SEL_WIDTH))

/*! @brief Set the GPCNT1_CLK_SEL field to a new value. */
#define EMVSIM_WR_CLKCFG_GPCNT1_CLK_SEL(base, value) (EMVSIM_RMW_CLKCFG(base, EMVSIM_CLKCFG_GPCNT1_CLK_SEL_MASK, EMVSIM_CLKCFG_GPCNT1_CLK_SEL(value)))
#define EMVSIM_BWR_CLKCFG_GPCNT1_CLK_SEL(base, value) (BME_BFI32(&EMVSIM_CLKCFG_REG(base), ((uint32_t)(value) << EMVSIM_CLKCFG_GPCNT1_CLK_SEL_SHIFT), EMVSIM_CLKCFG_GPCNT1_CLK_SEL_SHIFT, EMVSIM_CLKCFG_GPCNT1_CLK_SEL_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CLKCFG, field GPCNT0_CLK_SEL[11:10] (RW)
 *
 * Selects which clock source is used by EMV SIM Module general purpose counter
 * 0. The only way to reset the counter is to set these bits to zero. The counter
 * will begin counting as soon as the clock input is selected and the clocks are
 * active. These input clocks are enabled through other register bits of the EMV
 * SIM module (KILL_CLOCK, RCV_EN, and XMT_EN). Counter is active while RCV_EN
 * or XMT_EN are set.
 *
 * Values:
 * - 0b00 - Disabled / Reset (default)
 * - 0b01 - Card Clock
 * - 0b10 - Receive Clock
 * - 0b11 - ETU Clock (transmit clock)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CLKCFG_GPCNT0_CLK_SEL field. */
#define EMVSIM_RD_CLKCFG_GPCNT0_CLK_SEL(base) ((EMVSIM_CLKCFG_REG(base) & EMVSIM_CLKCFG_GPCNT0_CLK_SEL_MASK) >> EMVSIM_CLKCFG_GPCNT0_CLK_SEL_SHIFT)
#define EMVSIM_BRD_CLKCFG_GPCNT0_CLK_SEL(base) (BME_UBFX32(&EMVSIM_CLKCFG_REG(base), EMVSIM_CLKCFG_GPCNT0_CLK_SEL_SHIFT, EMVSIM_CLKCFG_GPCNT0_CLK_SEL_WIDTH))

/*! @brief Set the GPCNT0_CLK_SEL field to a new value. */
#define EMVSIM_WR_CLKCFG_GPCNT0_CLK_SEL(base, value) (EMVSIM_RMW_CLKCFG(base, EMVSIM_CLKCFG_GPCNT0_CLK_SEL_MASK, EMVSIM_CLKCFG_GPCNT0_CLK_SEL(value)))
#define EMVSIM_BWR_CLKCFG_GPCNT0_CLK_SEL(base, value) (BME_BFI32(&EMVSIM_CLKCFG_REG(base), ((uint32_t)(value) << EMVSIM_CLKCFG_GPCNT0_CLK_SEL_SHIFT), EMVSIM_CLKCFG_GPCNT0_CLK_SEL_SHIFT, EMVSIM_CLKCFG_GPCNT0_CLK_SEL_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_DIVISOR - Baud Rate Divisor Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_DIVISOR - Baud Rate Divisor Register (RW)
 *
 * Reset value: 0x00000174U
 *
 * This regiter configures the divisor value to generate the baud clock which
 * will drive the card clock and also generate the transmit and receive clocks and
 * respective ETUs.
 */
/*!
 * @name Constants and macros for entire EMVSIM_DIVISOR register
 */
/*@{*/
#define EMVSIM_RD_DIVISOR(base)  (EMVSIM_DIVISOR_REG(base))
#define EMVSIM_WR_DIVISOR(base, value) (EMVSIM_DIVISOR_REG(base) = (value))
#define EMVSIM_RMW_DIVISOR(base, mask, value) (EMVSIM_WR_DIVISOR(base, (EMVSIM_RD_DIVISOR(base) & ~(mask)) | (value)))
#define EMVSIM_SET_DIVISOR(base, value) (BME_OR32(&EMVSIM_DIVISOR_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_DIVISOR(base, value) (BME_AND32(&EMVSIM_DIVISOR_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_DIVISOR(base, value) (BME_XOR32(&EMVSIM_DIVISOR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_DIVISOR bitfields
 */

/*!
 * @name Register EMVSIM_DIVISOR, field DIVISOR_VALUE[8:0] (RW)
 *
 * The value written to this register will be used to generate the ETU bit
 * period that will be used by the transmitter and receiver. The divisor value is the
 * integer result of F/D value; where F and D are the clock rate conversion
 * integer and baud rate adjustment integer, respectively, that required for the
 * desired operation. The value in this register can be changed when no transaction is
 * active with the smart card. When programming this field, the fractional part
 * of F/D should be rounded off the nearest integer.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_DIVISOR_DIVISOR_VALUE field. */
#define EMVSIM_RD_DIVISOR_DIVISOR_VALUE(base) ((EMVSIM_DIVISOR_REG(base) & EMVSIM_DIVISOR_DIVISOR_VALUE_MASK) >> EMVSIM_DIVISOR_DIVISOR_VALUE_SHIFT)
#define EMVSIM_BRD_DIVISOR_DIVISOR_VALUE(base) (EMVSIM_RD_DIVISOR_DIVISOR_VALUE(base))

/*! @brief Set the DIVISOR_VALUE field to a new value. */
#define EMVSIM_WR_DIVISOR_DIVISOR_VALUE(base, value) (EMVSIM_RMW_DIVISOR(base, EMVSIM_DIVISOR_DIVISOR_VALUE_MASK, EMVSIM_DIVISOR_DIVISOR_VALUE(value)))
#define EMVSIM_BWR_DIVISOR_DIVISOR_VALUE(base, value) (EMVSIM_WR_DIVISOR_DIVISOR_VALUE(base, value))
/*@}*/

/*******************************************************************************
 * EMVSIM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_CTRL - Control Register (RW)
 *
 * Reset value: 0x01000006U
 */
/*!
 * @name Constants and macros for entire EMVSIM_CTRL register
 */
/*@{*/
#define EMVSIM_RD_CTRL(base)     (EMVSIM_CTRL_REG(base))
#define EMVSIM_WR_CTRL(base, value) (EMVSIM_CTRL_REG(base) = (value))
#define EMVSIM_RMW_CTRL(base, mask, value) (EMVSIM_WR_CTRL(base, (EMVSIM_RD_CTRL(base) & ~(mask)) | (value)))
#define EMVSIM_SET_CTRL(base, value) (BME_OR32(&EMVSIM_CTRL_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_CTRL(base, value) (BME_AND32(&EMVSIM_CTRL_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_CTRL(base, value) (BME_XOR32(&EMVSIM_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_CTRL bitfields
 */

/*!
 * @name Register EMVSIM_CTRL, field IC[0] (RW)
 *
 * Used to configure the EMV SIM to use either inverse convention or direct
 * convention for its data format. The IC bit can be controlled by software, but it
 * is normally set by hardware as a result of the interpretation of the initial
 * character when in ICM mode.
 *
 * Values:
 * - 0b0 - Direction convention transfers enabled (default)
 * - 0b1 - Inverse convention transfers enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_IC field. */
#define EMVSIM_RD_CTRL_IC(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_IC_MASK) >> EMVSIM_CTRL_IC_SHIFT)
#define EMVSIM_BRD_CTRL_IC(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_IC_SHIFT, EMVSIM_CTRL_IC_WIDTH))

/*! @brief Set the IC field to a new value. */
#define EMVSIM_WR_CTRL_IC(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_IC_MASK, EMVSIM_CTRL_IC(value)))
#define EMVSIM_BWR_CTRL_IC(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_IC_SHIFT), EMVSIM_CTRL_IC_SHIFT, EMVSIM_CTRL_IC_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field ICM[1] (RW)
 *
 * Enables initial character mode. Will be automatically cleared by hardware
 * once a valid initial character is received.
 *
 * Values:
 * - 0b0 - Initial Character Mode disabled
 * - 0b1 - Initial Character Mode enabled (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_ICM field. */
#define EMVSIM_RD_CTRL_ICM(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_ICM_MASK) >> EMVSIM_CTRL_ICM_SHIFT)
#define EMVSIM_BRD_CTRL_ICM(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_ICM_SHIFT, EMVSIM_CTRL_ICM_WIDTH))

/*! @brief Set the ICM field to a new value. */
#define EMVSIM_WR_CTRL_ICM(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_ICM_MASK, EMVSIM_CTRL_ICM(value)))
#define EMVSIM_BWR_CTRL_ICM(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_ICM_SHIFT), EMVSIM_CTRL_ICM_SHIFT, EMVSIM_CTRL_ICM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field ANACK[2] (RW)
 *
 * Enables NACK generation for parity errors in receieved messages or when
 * invalid initial characters are received in ICM mode.
 *
 * Values:
 * - 0b0 - NACK generation on errors disabled
 * - 0b1 - NACK generation on errors enabled (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_ANACK field. */
#define EMVSIM_RD_CTRL_ANACK(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_ANACK_MASK) >> EMVSIM_CTRL_ANACK_SHIFT)
#define EMVSIM_BRD_CTRL_ANACK(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_ANACK_SHIFT, EMVSIM_CTRL_ANACK_WIDTH))

/*! @brief Set the ANACK field to a new value. */
#define EMVSIM_WR_CTRL_ANACK(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_ANACK_MASK, EMVSIM_CTRL_ANACK(value)))
#define EMVSIM_BWR_CTRL_ANACK(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_ANACK_SHIFT), EMVSIM_CTRL_ANACK_SHIFT, EMVSIM_CTRL_ANACK_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field ONACK[3] (RW)
 *
 * Enables NACK generation when Rx FIFO is full and another message is ready for
 * writing into the FIFO.
 *
 * Values:
 * - 0b0 - NACK generation on overrun is disabled (default)
 * - 0b1 - NACK generation on overrun is enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_ONACK field. */
#define EMVSIM_RD_CTRL_ONACK(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_ONACK_MASK) >> EMVSIM_CTRL_ONACK_SHIFT)
#define EMVSIM_BRD_CTRL_ONACK(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_ONACK_SHIFT, EMVSIM_CTRL_ONACK_WIDTH))

/*! @brief Set the ONACK field to a new value. */
#define EMVSIM_WR_CTRL_ONACK(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_ONACK_MASK, EMVSIM_CTRL_ONACK(value)))
#define EMVSIM_BWR_CTRL_ONACK(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_ONACK_SHIFT), EMVSIM_CTRL_ONACK_SHIFT, EMVSIM_CTRL_ONACK_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field FLSH_RX[8] (WORZ)
 *
 * This bit operates as an EMV SIM receiver reset. The transmit portion of the
 * EMV SIM module is not affected. This bits clears automatically and always reads
 * 0.
 *
 * Values:
 * - 0b0 - EMV SIM Receiver normal operation (default)
 * - 0b1 - EMV SIM Receiver held in Reset
 */
/*@{*/
/*! @brief Set the FLSH_RX field to a new value. */
#define EMVSIM_WR_CTRL_FLSH_RX(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_FLSH_RX_MASK, EMVSIM_CTRL_FLSH_RX(value)))
#define EMVSIM_BWR_CTRL_FLSH_RX(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_FLSH_RX_SHIFT), EMVSIM_CTRL_FLSH_RX_SHIFT, EMVSIM_CTRL_FLSH_RX_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field FLSH_TX[9] (WORZ)
 *
 * This bit operates as an EMV SIM transmitter reset. The receive portion of the
 * EMV SIM module is not affected. This bit clears automatically and always
 * reads 0.
 *
 * Values:
 * - 0b0 - EMV SIM Transmitter normal operation (default)
 * - 0b1 - EMV SIM Transmitter held in Reset
 */
/*@{*/
/*! @brief Set the FLSH_TX field to a new value. */
#define EMVSIM_WR_CTRL_FLSH_TX(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_FLSH_TX_MASK, EMVSIM_CTRL_FLSH_TX(value)))
#define EMVSIM_BWR_CTRL_FLSH_TX(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_FLSH_TX_SHIFT), EMVSIM_CTRL_FLSH_TX_SHIFT, EMVSIM_CTRL_FLSH_TX_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field SW_RST[10] (WORZ)
 *
 * Used to reset the entire EMV SIM module. This acts the same as a hardware
 * reset for the EMV SIM module. This bit is self-clearing and always reads 0. Note:
 * Software should allow a minimum of 4 Protocol clock cycles before attempting
 * to access the EMV SIM module after a software reset.
 *
 * Values:
 * - 0b0 - EMV SIM Normal operation (default)
 * - 0b1 - EMV SIM held in Reset
 */
/*@{*/
/*! @brief Set the SW_RST field to a new value. */
#define EMVSIM_WR_CTRL_SW_RST(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_SW_RST_MASK, EMVSIM_CTRL_SW_RST(value)))
#define EMVSIM_BWR_CTRL_SW_RST(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_SW_RST_SHIFT), EMVSIM_CTRL_SW_RST_SHIFT, EMVSIM_CTRL_SW_RST_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field KILL_CLOCKS[11] (RW)
 *
 * Used to enable/disable the clock input to the EMV SIM module. This bit will
 * gate all clocks including the Smart Card clock regardless of the state of the
 * STOP bit described above. Note: This bit will have no effect on the register
 * read write clock. Only EMV SIM logic clock is gated.
 *
 * Values:
 * - 0b0 - EMV SIM input clock enabled (default)
 * - 0b1 - EMV SIM input clock is disabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_KILL_CLOCKS field. */
#define EMVSIM_RD_CTRL_KILL_CLOCKS(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_KILL_CLOCKS_MASK) >> EMVSIM_CTRL_KILL_CLOCKS_SHIFT)
#define EMVSIM_BRD_CTRL_KILL_CLOCKS(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_KILL_CLOCKS_SHIFT, EMVSIM_CTRL_KILL_CLOCKS_WIDTH))

/*! @brief Set the KILL_CLOCKS field to a new value. */
#define EMVSIM_WR_CTRL_KILL_CLOCKS(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_KILL_CLOCKS_MASK, EMVSIM_CTRL_KILL_CLOCKS(value)))
#define EMVSIM_BWR_CTRL_KILL_CLOCKS(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_KILL_CLOCKS_SHIFT), EMVSIM_CTRL_KILL_CLOCKS_SHIFT, EMVSIM_CTRL_KILL_CLOCKS_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field DOZE_EN[12] (RW)
 *
 * Used to configure the operation of the EMV SIM module when a processor DOZE
 * instruction is executed.
 *
 * Values:
 * - 0b0 - DOZE instruction will gate all internal EMV SIM clocks as well as the
 *     Smart Card clock when the transmit FIFO is empty (default)
 * - 0b1 - DOZE instruction has no effect on EMV SIM module
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_DOZE_EN field. */
#define EMVSIM_RD_CTRL_DOZE_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_DOZE_EN_MASK) >> EMVSIM_CTRL_DOZE_EN_SHIFT)
#define EMVSIM_BRD_CTRL_DOZE_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_DOZE_EN_SHIFT, EMVSIM_CTRL_DOZE_EN_WIDTH))

/*! @brief Set the DOZE_EN field to a new value. */
#define EMVSIM_WR_CTRL_DOZE_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_DOZE_EN_MASK, EMVSIM_CTRL_DOZE_EN(value)))
#define EMVSIM_BWR_CTRL_DOZE_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_DOZE_EN_SHIFT), EMVSIM_CTRL_DOZE_EN_SHIFT, EMVSIM_CTRL_DOZE_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field STOP_EN[13] (RW)
 *
 * Used to configure the operation of the EMV SIM module when a processor STOP
 * instruction is executed. This bit is added to provide support for Smart Cards
 * that do not allow the Smart Card clock to be stopped while power is applied.
 *
 * Values:
 * - 0b0 - STOP instruction shuts down all EMV SIM clocks (default)
 * - 0b1 - STOP instruction shuts down all clocks except for the Smart Card
 *     Clock (SCK) (clock provided to Smart Card)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_STOP_EN field. */
#define EMVSIM_RD_CTRL_STOP_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_STOP_EN_MASK) >> EMVSIM_CTRL_STOP_EN_SHIFT)
#define EMVSIM_BRD_CTRL_STOP_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_STOP_EN_SHIFT, EMVSIM_CTRL_STOP_EN_WIDTH))

/*! @brief Set the STOP_EN field to a new value. */
#define EMVSIM_WR_CTRL_STOP_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_STOP_EN_MASK, EMVSIM_CTRL_STOP_EN(value)))
#define EMVSIM_BWR_CTRL_STOP_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_STOP_EN_SHIFT), EMVSIM_CTRL_STOP_EN_SHIFT, EMVSIM_CTRL_STOP_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field RCV_EN[16] (RW)
 *
 * Used to enable/disable the EMV SIM receiver block. Once the transmitter has
 * completed its operation, the software must enable the receiver using this bit.
 * It can be set to 0 during the auto power down sequence.
 *
 * Values:
 * - 0b0 - EMV SIM Receiver disabled (default)
 * - 0b1 - EMV SIM Receiver enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_RCV_EN field. */
#define EMVSIM_RD_CTRL_RCV_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_RCV_EN_MASK) >> EMVSIM_CTRL_RCV_EN_SHIFT)
#define EMVSIM_BRD_CTRL_RCV_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_RCV_EN_SHIFT, EMVSIM_CTRL_RCV_EN_WIDTH))

/*! @brief Set the RCV_EN field to a new value. */
#define EMVSIM_WR_CTRL_RCV_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_RCV_EN_MASK, EMVSIM_CTRL_RCV_EN(value)))
#define EMVSIM_BWR_CTRL_RCV_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_RCV_EN_SHIFT), EMVSIM_CTRL_RCV_EN_SHIFT, EMVSIM_CTRL_RCV_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field XMT_EN[17] (RW)
 *
 * Used to enable/disable the EMV SIM transmitter block. It can be set to 0
 * during the auto power down sequence. Note: Setting this bit (transition from 0 to
 * 1) will reset the CRC and LRC values.
 *
 * Values:
 * - 0b0 - EMV SIM Transmitter disabled (default)
 * - 0b1 - EMV SIM Transmitter enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_XMT_EN field. */
#define EMVSIM_RD_CTRL_XMT_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_XMT_EN_MASK) >> EMVSIM_CTRL_XMT_EN_SHIFT)
#define EMVSIM_BRD_CTRL_XMT_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_XMT_EN_SHIFT, EMVSIM_CTRL_XMT_EN_WIDTH))

/*! @brief Set the XMT_EN field to a new value. */
#define EMVSIM_WR_CTRL_XMT_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_XMT_EN_MASK, EMVSIM_CTRL_XMT_EN(value)))
#define EMVSIM_BWR_CTRL_XMT_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_XMT_EN_SHIFT), EMVSIM_CTRL_XMT_EN_SHIFT, EMVSIM_CTRL_XMT_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field RCVR_11[18] (RW)
 *
 * Used to configure the EMV SIM module receiver for 11 ETU operation (that is,
 * 1 Stop bit). This bit is provided for support of T=1 cards.
 *
 * Values:
 * - 0b0 - Receiver configured for 12 ETU operation mode (default)
 * - 0b1 - Receiver configured for 11 ETU operation mode
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_RCVR_11 field. */
#define EMVSIM_RD_CTRL_RCVR_11(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_RCVR_11_MASK) >> EMVSIM_CTRL_RCVR_11_SHIFT)
#define EMVSIM_BRD_CTRL_RCVR_11(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_RCVR_11_SHIFT, EMVSIM_CTRL_RCVR_11_WIDTH))

/*! @brief Set the RCVR_11 field to a new value. */
#define EMVSIM_WR_CTRL_RCVR_11(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_RCVR_11_MASK, EMVSIM_CTRL_RCVR_11(value)))
#define EMVSIM_BWR_CTRL_RCVR_11(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_RCVR_11_SHIFT), EMVSIM_CTRL_RCVR_11_SHIFT, EMVSIM_CTRL_RCVR_11_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field RX_DMA_EN[19] (RW)
 *
 * Enables assertion of DMA read request when Receive FIFO reaches the
 * programmed data threshold value. Request is held asserted till all the programmed
 * threshold bytes are read out. Receiver Data Interrupt will not be generated when
 * this bit is asserted.
 *
 * Values:
 * - 0b0 - No DMA Read Request asserted for Receiver (default)
 * - 0b1 - DMA Read Request asserted for Receiver
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_RX_DMA_EN field. */
#define EMVSIM_RD_CTRL_RX_DMA_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_RX_DMA_EN_MASK) >> EMVSIM_CTRL_RX_DMA_EN_SHIFT)
#define EMVSIM_BRD_CTRL_RX_DMA_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_RX_DMA_EN_SHIFT, EMVSIM_CTRL_RX_DMA_EN_WIDTH))

/*! @brief Set the RX_DMA_EN field to a new value. */
#define EMVSIM_WR_CTRL_RX_DMA_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_RX_DMA_EN_MASK, EMVSIM_CTRL_RX_DMA_EN(value)))
#define EMVSIM_BWR_CTRL_RX_DMA_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_RX_DMA_EN_SHIFT), EMVSIM_CTRL_RX_DMA_EN_SHIFT, EMVSIM_CTRL_RX_DMA_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field TX_DMA_EN[20] (RW)
 *
 * Enables assertion of DMA write request when Transmit FIFO is empty. Request
 * is held asserted till Transmit FIFO reaches the programmed data threshold
 * value. Transmit Data Threshold Interrupt will not be generated when this bit is
 * asserted.
 *
 * Values:
 * - 0b0 - No DMA Write Request asserted for Transmitter (default)
 * - 0b1 - DMA Write Request asserted for Transmitter
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_TX_DMA_EN field. */
#define EMVSIM_RD_CTRL_TX_DMA_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_TX_DMA_EN_MASK) >> EMVSIM_CTRL_TX_DMA_EN_SHIFT)
#define EMVSIM_BRD_CTRL_TX_DMA_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_TX_DMA_EN_SHIFT, EMVSIM_CTRL_TX_DMA_EN_WIDTH))

/*! @brief Set the TX_DMA_EN field to a new value. */
#define EMVSIM_WR_CTRL_TX_DMA_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_TX_DMA_EN_MASK, EMVSIM_CTRL_TX_DMA_EN(value)))
#define EMVSIM_BWR_CTRL_TX_DMA_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_TX_DMA_EN_SHIFT), EMVSIM_CTRL_TX_DMA_EN_SHIFT, EMVSIM_CTRL_TX_DMA_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field INV_CRC_VAL[24] (RW)
 *
 * This bit control whether the bits within the CRC Output value will be
 * inverted (1's complement) or not. For CCITT CRC calculation, this bit should be set
 * to '1'. For any other CRC using same polynomial, this bit can be set
 * accordingly.
 *
 * Values:
 * - 0b0 - Bits in CRC Output value will not be inverted.
 * - 0b1 - Bits in CRC Output value will be inverted. (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_INV_CRC_VAL field. */
#define EMVSIM_RD_CTRL_INV_CRC_VAL(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_INV_CRC_VAL_MASK) >> EMVSIM_CTRL_INV_CRC_VAL_SHIFT)
#define EMVSIM_BRD_CTRL_INV_CRC_VAL(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_INV_CRC_VAL_SHIFT, EMVSIM_CTRL_INV_CRC_VAL_WIDTH))

/*! @brief Set the INV_CRC_VAL field to a new value. */
#define EMVSIM_WR_CTRL_INV_CRC_VAL(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_INV_CRC_VAL_MASK, EMVSIM_CTRL_INV_CRC_VAL(value)))
#define EMVSIM_BWR_CTRL_INV_CRC_VAL(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_INV_CRC_VAL_SHIFT), EMVSIM_CTRL_INV_CRC_VAL_SHIFT, EMVSIM_CTRL_INV_CRC_VAL_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field CRC_OUT_FLIP[25] (RW)
 *
 * This bit control whether the bits in the CRC output bytes will be reversed or
 * not. When set to '1', the bits within the two bytes for CRC Output will
 * change from 15:0 to {8:15,0:7}. For CCITT CRC calculation, this bit should be set
 * to '1'. For any other CRC using same polynomial, this bit can be set
 * accordingly.
 *
 * Values:
 * - 0b0 - Bits within the CRC output bytes will not be reversed i.e. 15:0 will
 *     remain 15:0 (default)
 * - 0b1 - Bits within the CRC output bytes will be reversed i.e. 15:0 will
 *     become {8:15,0:7}
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_CRC_OUT_FLIP field. */
#define EMVSIM_RD_CTRL_CRC_OUT_FLIP(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_CRC_OUT_FLIP_MASK) >> EMVSIM_CTRL_CRC_OUT_FLIP_SHIFT)
#define EMVSIM_BRD_CTRL_CRC_OUT_FLIP(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_CRC_OUT_FLIP_SHIFT, EMVSIM_CTRL_CRC_OUT_FLIP_WIDTH))

/*! @brief Set the CRC_OUT_FLIP field to a new value. */
#define EMVSIM_WR_CTRL_CRC_OUT_FLIP(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_CRC_OUT_FLIP_MASK, EMVSIM_CTRL_CRC_OUT_FLIP(value)))
#define EMVSIM_BWR_CTRL_CRC_OUT_FLIP(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_CRC_OUT_FLIP_SHIFT), EMVSIM_CTRL_CRC_OUT_FLIP_SHIFT, EMVSIM_CTRL_CRC_OUT_FLIP_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field CRC_IN_FLIP[26] (RW)
 *
 * This bit control whether the bits in the CRC input byte will be reversed
 * before CRC calculation or not. When set to '1', the bits within the input byte for
 * CRC will change from 7:0 to 0:7. For CCITT CRC calculation, this bit should
 * be set to '1'. For any other CRC using same polynomial, this bit can be set
 * accordingly.
 *
 * Values:
 * - 0b0 - Bits in the input byte will not be reversed (i.e. 7:0 will remain
 *     7:0) before the CRC calculation (default)
 * - 0b1 - Bits in the input byte will be reversed (i.e. 7:0 will become 0:7)
 *     before CRC calculation
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_CRC_IN_FLIP field. */
#define EMVSIM_RD_CTRL_CRC_IN_FLIP(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_CRC_IN_FLIP_MASK) >> EMVSIM_CTRL_CRC_IN_FLIP_SHIFT)
#define EMVSIM_BRD_CTRL_CRC_IN_FLIP(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_CRC_IN_FLIP_SHIFT, EMVSIM_CTRL_CRC_IN_FLIP_WIDTH))

/*! @brief Set the CRC_IN_FLIP field to a new value. */
#define EMVSIM_WR_CTRL_CRC_IN_FLIP(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_CRC_IN_FLIP_MASK, EMVSIM_CTRL_CRC_IN_FLIP(value)))
#define EMVSIM_BWR_CTRL_CRC_IN_FLIP(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_CRC_IN_FLIP_SHIFT), EMVSIM_CTRL_CRC_IN_FLIP_SHIFT, EMVSIM_CTRL_CRC_IN_FLIP_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field CWT_EN[27] (RW)
 *
 * Enables the character wait time counter. Clearing this bit resets the counter
 * to zero.
 *
 * Values:
 * - 0b0 - Character Wait time Counter is disabled (default)
 * - 0b1 - Character Wait time counter is enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_CWT_EN field. */
#define EMVSIM_RD_CTRL_CWT_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_CWT_EN_MASK) >> EMVSIM_CTRL_CWT_EN_SHIFT)
#define EMVSIM_BRD_CTRL_CWT_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_CWT_EN_SHIFT, EMVSIM_CTRL_CWT_EN_WIDTH))

/*! @brief Set the CWT_EN field to a new value. */
#define EMVSIM_WR_CTRL_CWT_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_CWT_EN_MASK, EMVSIM_CTRL_CWT_EN(value)))
#define EMVSIM_BWR_CTRL_CWT_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_CWT_EN_SHIFT), EMVSIM_CTRL_CWT_EN_SHIFT, EMVSIM_CTRL_CWT_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field LRC_EN[28] (RW)
 *
 * This bit enables the calculation of the 8-bit LRC value for both receiver and
 * transmitter. The result of the calculation is continuously compared to zero
 * and reflected in the LRC_OK bit in the RX_STATUS register. Clearing this bit
 * resets the current LRC value in the EMV SIM hardware.
 *
 * Values:
 * - 0b0 - 8-bit Linear Redundancy Checking disabled (default)
 * - 0b1 - 8-bit Linear Redundancy Checking enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_LRC_EN field. */
#define EMVSIM_RD_CTRL_LRC_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_LRC_EN_MASK) >> EMVSIM_CTRL_LRC_EN_SHIFT)
#define EMVSIM_BRD_CTRL_LRC_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_LRC_EN_SHIFT, EMVSIM_CTRL_LRC_EN_WIDTH))

/*! @brief Set the LRC_EN field to a new value. */
#define EMVSIM_WR_CTRL_LRC_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_LRC_EN_MASK, EMVSIM_CTRL_LRC_EN(value)))
#define EMVSIM_BWR_CTRL_LRC_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_LRC_EN_SHIFT), EMVSIM_CTRL_LRC_EN_SHIFT, EMVSIM_CTRL_LRC_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field CRC_EN[29] (RW)
 *
 * This bit enables the calculation of the 16-bit CRC value for both receiver
 * and transmitter. The result of the calculation is continuously compared to the
 * expected remainder and reflected in the CRC_OK bit in the RX_STATUS register.
 * Clearing this bit resets the current CRC residual value in the EMV SIM hardware.
 *
 * Values:
 * - 0b0 - 16-bit Cyclic Redundancy Checking disabled (default)
 * - 0b1 - 16-bit Cyclic Redundancy Checking enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_CRC_EN field. */
#define EMVSIM_RD_CTRL_CRC_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_CRC_EN_MASK) >> EMVSIM_CTRL_CRC_EN_SHIFT)
#define EMVSIM_BRD_CTRL_CRC_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_CRC_EN_SHIFT, EMVSIM_CTRL_CRC_EN_WIDTH))

/*! @brief Set the CRC_EN field to a new value. */
#define EMVSIM_WR_CTRL_CRC_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_CRC_EN_MASK, EMVSIM_CTRL_CRC_EN(value)))
#define EMVSIM_BWR_CTRL_CRC_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_CRC_EN_SHIFT), EMVSIM_CTRL_CRC_EN_SHIFT, EMVSIM_CTRL_CRC_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field XMT_CRC_LRC[30] (RW)
 *
 * This bit specifies whether or not to transmit the redundancy checking data
 * (LRC or CRC) at the end of a transmission (that is, when the FIFO becomes empty).
 *
 * Values:
 * - 0b0 - No CRC or LRC value is transmitted (default)
 * - 0b1 - Transmit LRC or CRC info when FIFO empties (whichever is enabled)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_XMT_CRC_LRC field. */
#define EMVSIM_RD_CTRL_XMT_CRC_LRC(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_XMT_CRC_LRC_MASK) >> EMVSIM_CTRL_XMT_CRC_LRC_SHIFT)
#define EMVSIM_BRD_CTRL_XMT_CRC_LRC(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_XMT_CRC_LRC_SHIFT, EMVSIM_CTRL_XMT_CRC_LRC_WIDTH))

/*! @brief Set the XMT_CRC_LRC field to a new value. */
#define EMVSIM_WR_CTRL_XMT_CRC_LRC(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_XMT_CRC_LRC_MASK, EMVSIM_CTRL_XMT_CRC_LRC(value)))
#define EMVSIM_BWR_CTRL_XMT_CRC_LRC(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_XMT_CRC_LRC_SHIFT), EMVSIM_CTRL_XMT_CRC_LRC_SHIFT, EMVSIM_CTRL_XMT_CRC_LRC_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_CTRL, field BWT_EN[31] (RW)
 *
 * Writing a '1' to this bit will enable the BWT and BGT functions. The BWT and
 * BGT functions can then be individually selected using the interrupt mask.
 *
 * Values:
 * - 0b0 - Disable BWT, BGT Counters (default)
 * - 0b1 - Enable BWT, BGT Counters
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CTRL_BWT_EN field. */
#define EMVSIM_RD_CTRL_BWT_EN(base) ((EMVSIM_CTRL_REG(base) & EMVSIM_CTRL_BWT_EN_MASK) >> EMVSIM_CTRL_BWT_EN_SHIFT)
#define EMVSIM_BRD_CTRL_BWT_EN(base) (BME_UBFX32(&EMVSIM_CTRL_REG(base), EMVSIM_CTRL_BWT_EN_SHIFT, EMVSIM_CTRL_BWT_EN_WIDTH))

/*! @brief Set the BWT_EN field to a new value. */
#define EMVSIM_WR_CTRL_BWT_EN(base, value) (EMVSIM_RMW_CTRL(base, EMVSIM_CTRL_BWT_EN_MASK, EMVSIM_CTRL_BWT_EN(value)))
#define EMVSIM_BWR_CTRL_BWT_EN(base, value) (BME_BFI32(&EMVSIM_CTRL_REG(base), ((uint32_t)(value) << EMVSIM_CTRL_BWT_EN_SHIFT), EMVSIM_CTRL_BWT_EN_SHIFT, EMVSIM_CTRL_BWT_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_INT_MASK - Interrupt Mask Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_INT_MASK - Interrupt Mask Register (RW)
 *
 * Reset value: 0x00007FFFU
 */
/*!
 * @name Constants and macros for entire EMVSIM_INT_MASK register
 */
/*@{*/
#define EMVSIM_RD_INT_MASK(base) (EMVSIM_INT_MASK_REG(base))
#define EMVSIM_WR_INT_MASK(base, value) (EMVSIM_INT_MASK_REG(base) = (value))
#define EMVSIM_RMW_INT_MASK(base, mask, value) (EMVSIM_WR_INT_MASK(base, (EMVSIM_RD_INT_MASK(base) & ~(mask)) | (value)))
#define EMVSIM_SET_INT_MASK(base, value) (BME_OR32(&EMVSIM_INT_MASK_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_INT_MASK(base, value) (BME_AND32(&EMVSIM_INT_MASK_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_INT_MASK(base, value) (BME_XOR32(&EMVSIM_INT_MASK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_INT_MASK bitfields
 */

/*!
 * @name Register EMVSIM_INT_MASK, field RDT_IM[0] (RW)
 *
 * Used to enable/disable the ability of the RDTF flag in the RX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - RDTF interrupt enabled
 * - 0b1 - RDTF interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_RDT_IM field. */
#define EMVSIM_RD_INT_MASK_RDT_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_RDT_IM_MASK) >> EMVSIM_INT_MASK_RDT_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_RDT_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_RDT_IM_SHIFT, EMVSIM_INT_MASK_RDT_IM_WIDTH))

/*! @brief Set the RDT_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_RDT_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_RDT_IM_MASK, EMVSIM_INT_MASK_RDT_IM(value)))
#define EMVSIM_BWR_INT_MASK_RDT_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_RDT_IM_SHIFT), EMVSIM_INT_MASK_RDT_IM_SHIFT, EMVSIM_INT_MASK_RDT_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field TC_IM[1] (RW)
 *
 * Used to enable/disable the ability of the TCF flag in the TX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - TCF interrupt enabled
 * - 0b1 - TCF interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_TC_IM field. */
#define EMVSIM_RD_INT_MASK_TC_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_TC_IM_MASK) >> EMVSIM_INT_MASK_TC_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_TC_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_TC_IM_SHIFT, EMVSIM_INT_MASK_TC_IM_WIDTH))

/*! @brief Set the TC_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_TC_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_TC_IM_MASK, EMVSIM_INT_MASK_TC_IM(value)))
#define EMVSIM_BWR_INT_MASK_TC_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_TC_IM_SHIFT), EMVSIM_INT_MASK_TC_IM_SHIFT, EMVSIM_INT_MASK_TC_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field RFO_IM[2] (RW)
 *
 * Used to enable/disable the ability of the RFO flag in the RX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - RFO interrupt enabled
 * - 0b1 - RFO interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_RFO_IM field. */
#define EMVSIM_RD_INT_MASK_RFO_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_RFO_IM_MASK) >> EMVSIM_INT_MASK_RFO_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_RFO_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_RFO_IM_SHIFT, EMVSIM_INT_MASK_RFO_IM_WIDTH))

/*! @brief Set the RFO_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_RFO_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_RFO_IM_MASK, EMVSIM_INT_MASK_RFO_IM(value)))
#define EMVSIM_BWR_INT_MASK_RFO_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_RFO_IM_SHIFT), EMVSIM_INT_MASK_RFO_IM_SHIFT, EMVSIM_INT_MASK_RFO_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field ETC_IM[3] (RW)
 *
 * Used to enable/disable the ability of the ETC flag in the TX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - ETC interrupt enabled
 * - 0b1 - ETC interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_ETC_IM field. */
#define EMVSIM_RD_INT_MASK_ETC_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_ETC_IM_MASK) >> EMVSIM_INT_MASK_ETC_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_ETC_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_ETC_IM_SHIFT, EMVSIM_INT_MASK_ETC_IM_WIDTH))

/*! @brief Set the ETC_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_ETC_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_ETC_IM_MASK, EMVSIM_INT_MASK_ETC_IM(value)))
#define EMVSIM_BWR_INT_MASK_ETC_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_ETC_IM_SHIFT), EMVSIM_INT_MASK_ETC_IM_SHIFT, EMVSIM_INT_MASK_ETC_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field TFE_IM[4] (RW)
 *
 * Used to enable/disable the ability of the TFE flag in the TX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - TFE interrupt enabled
 * - 0b1 - TFE interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_TFE_IM field. */
#define EMVSIM_RD_INT_MASK_TFE_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_TFE_IM_MASK) >> EMVSIM_INT_MASK_TFE_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_TFE_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_TFE_IM_SHIFT, EMVSIM_INT_MASK_TFE_IM_WIDTH))

/*! @brief Set the TFE_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_TFE_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_TFE_IM_MASK, EMVSIM_INT_MASK_TFE_IM(value)))
#define EMVSIM_BWR_INT_MASK_TFE_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_TFE_IM_SHIFT), EMVSIM_INT_MASK_TFE_IM_SHIFT, EMVSIM_INT_MASK_TFE_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field TNACK_IM[5] (RW)
 *
 * Used to enable/disable the ability of the TNTE flag in the TX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - TNTE interrupt enabled
 * - 0b1 - TNTE interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_TNACK_IM field. */
#define EMVSIM_RD_INT_MASK_TNACK_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_TNACK_IM_MASK) >> EMVSIM_INT_MASK_TNACK_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_TNACK_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_TNACK_IM_SHIFT, EMVSIM_INT_MASK_TNACK_IM_WIDTH))

/*! @brief Set the TNACK_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_TNACK_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_TNACK_IM_MASK, EMVSIM_INT_MASK_TNACK_IM(value)))
#define EMVSIM_BWR_INT_MASK_TNACK_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_TNACK_IM_SHIFT), EMVSIM_INT_MASK_TNACK_IM_SHIFT, EMVSIM_INT_MASK_TNACK_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field TFF_IM[6] (RW)
 *
 * Used to enable/disable the ability of the TFF flag in the TX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - TFF interrupt enabled
 * - 0b1 - TFF interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_TFF_IM field. */
#define EMVSIM_RD_INT_MASK_TFF_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_TFF_IM_MASK) >> EMVSIM_INT_MASK_TFF_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_TFF_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_TFF_IM_SHIFT, EMVSIM_INT_MASK_TFF_IM_WIDTH))

/*! @brief Set the TFF_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_TFF_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_TFF_IM_MASK, EMVSIM_INT_MASK_TFF_IM(value)))
#define EMVSIM_BWR_INT_MASK_TFF_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_TFF_IM_SHIFT), EMVSIM_INT_MASK_TFF_IM_SHIFT, EMVSIM_INT_MASK_TFF_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field TDT_IM[7] (RW)
 *
 * Used to enable/disable the ability of the TDTF flag in the TX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - TDTF interrupt enabled
 * - 0b1 - TDTF interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_TDT_IM field. */
#define EMVSIM_RD_INT_MASK_TDT_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_TDT_IM_MASK) >> EMVSIM_INT_MASK_TDT_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_TDT_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_TDT_IM_SHIFT, EMVSIM_INT_MASK_TDT_IM_WIDTH))

/*! @brief Set the TDT_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_TDT_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_TDT_IM_MASK, EMVSIM_INT_MASK_TDT_IM(value)))
#define EMVSIM_BWR_INT_MASK_TDT_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_TDT_IM_SHIFT), EMVSIM_INT_MASK_TDT_IM_SHIFT, EMVSIM_INT_MASK_TDT_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field GPCNT0_IM[8] (RW)
 *
 * Used to enable/disable the ability of the GPCNT0_TO flag in the TX_STATUS
 * register to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - GPCNT0_TO interrupt enabled
 * - 0b1 - GPCNT0_TO interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_GPCNT0_IM field. */
#define EMVSIM_RD_INT_MASK_GPCNT0_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_GPCNT0_IM_MASK) >> EMVSIM_INT_MASK_GPCNT0_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_GPCNT0_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_GPCNT0_IM_SHIFT, EMVSIM_INT_MASK_GPCNT0_IM_WIDTH))

/*! @brief Set the GPCNT0_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_GPCNT0_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_GPCNT0_IM_MASK, EMVSIM_INT_MASK_GPCNT0_IM(value)))
#define EMVSIM_BWR_INT_MASK_GPCNT0_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_GPCNT0_IM_SHIFT), EMVSIM_INT_MASK_GPCNT0_IM_SHIFT, EMVSIM_INT_MASK_GPCNT0_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field CWT_ERR_IM[9] (RW)
 *
 * Used to enable/disable the ability of the CWT_ERR flag in the RX_STATUS
 * register to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - CWT_ERR interrupt enabled
 * - 0b1 - CWT_ERR interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_CWT_ERR_IM field. */
#define EMVSIM_RD_INT_MASK_CWT_ERR_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_CWT_ERR_IM_MASK) >> EMVSIM_INT_MASK_CWT_ERR_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_CWT_ERR_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_CWT_ERR_IM_SHIFT, EMVSIM_INT_MASK_CWT_ERR_IM_WIDTH))

/*! @brief Set the CWT_ERR_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_CWT_ERR_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_CWT_ERR_IM_MASK, EMVSIM_INT_MASK_CWT_ERR_IM(value)))
#define EMVSIM_BWR_INT_MASK_CWT_ERR_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_CWT_ERR_IM_SHIFT), EMVSIM_INT_MASK_CWT_ERR_IM_SHIFT, EMVSIM_INT_MASK_CWT_ERR_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field RNACK_IM[10] (RW)
 *
 * Used to enable/disable the ability of the RTE flag in the RX_STATUS register
 * to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - RTE interrupt enabled
 * - 0b1 - RTE interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_RNACK_IM field. */
#define EMVSIM_RD_INT_MASK_RNACK_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_RNACK_IM_MASK) >> EMVSIM_INT_MASK_RNACK_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_RNACK_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_RNACK_IM_SHIFT, EMVSIM_INT_MASK_RNACK_IM_WIDTH))

/*! @brief Set the RNACK_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_RNACK_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_RNACK_IM_MASK, EMVSIM_INT_MASK_RNACK_IM(value)))
#define EMVSIM_BWR_INT_MASK_RNACK_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_RNACK_IM_SHIFT), EMVSIM_INT_MASK_RNACK_IM_SHIFT, EMVSIM_INT_MASK_RNACK_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field BWT_ERR_IM[11] (RW)
 *
 * Used to enable/disable the ability of the BWT_ERR flag in the RX_STATUS
 * register to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - BWT_ERR interrupt enabled
 * - 0b1 - BWT_ERR interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_BWT_ERR_IM field. */
#define EMVSIM_RD_INT_MASK_BWT_ERR_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_BWT_ERR_IM_MASK) >> EMVSIM_INT_MASK_BWT_ERR_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_BWT_ERR_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_BWT_ERR_IM_SHIFT, EMVSIM_INT_MASK_BWT_ERR_IM_WIDTH))

/*! @brief Set the BWT_ERR_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_BWT_ERR_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_BWT_ERR_IM_MASK, EMVSIM_INT_MASK_BWT_ERR_IM(value)))
#define EMVSIM_BWR_INT_MASK_BWT_ERR_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_BWT_ERR_IM_SHIFT), EMVSIM_INT_MASK_BWT_ERR_IM_SHIFT, EMVSIM_INT_MASK_BWT_ERR_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field BGT_ERR_IM[12] (RW)
 *
 * Used to enable/disable the ability of the BGT_ERR flag in the RX_STATUS
 * register to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - BGT_ERR interrupt enabled
 * - 0b1 - BGT_ERR interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_BGT_ERR_IM field. */
#define EMVSIM_RD_INT_MASK_BGT_ERR_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_BGT_ERR_IM_MASK) >> EMVSIM_INT_MASK_BGT_ERR_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_BGT_ERR_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_BGT_ERR_IM_SHIFT, EMVSIM_INT_MASK_BGT_ERR_IM_WIDTH))

/*! @brief Set the BGT_ERR_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_BGT_ERR_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_BGT_ERR_IM_MASK, EMVSIM_INT_MASK_BGT_ERR_IM(value)))
#define EMVSIM_BWR_INT_MASK_BGT_ERR_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_BGT_ERR_IM_SHIFT), EMVSIM_INT_MASK_BGT_ERR_IM_SHIFT, EMVSIM_INT_MASK_BGT_ERR_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field GPCNT1_IM[13] (RW)
 *
 * Used to enable/disable the ability of the GPCNT1_TO flag in the TX_STATUS
 * register to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - GPCNT1_TO interrupt enabled
 * - 0b1 - GPCNT1_TO interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_GPCNT1_IM field. */
#define EMVSIM_RD_INT_MASK_GPCNT1_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_GPCNT1_IM_MASK) >> EMVSIM_INT_MASK_GPCNT1_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_GPCNT1_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_GPCNT1_IM_SHIFT, EMVSIM_INT_MASK_GPCNT1_IM_WIDTH))

/*! @brief Set the GPCNT1_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_GPCNT1_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_GPCNT1_IM_MASK, EMVSIM_INT_MASK_GPCNT1_IM(value)))
#define EMVSIM_BWR_INT_MASK_GPCNT1_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_GPCNT1_IM_SHIFT), EMVSIM_INT_MASK_GPCNT1_IM_SHIFT, EMVSIM_INT_MASK_GPCNT1_IM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_INT_MASK, field RX_DATA_IM[14] (RW)
 *
 * Used to enable/disable the ability of the RX_DATA flag in the RX_STATUS
 * register to generate EMV SIM interrupts.
 *
 * Values:
 * - 0b0 - RX_DATA interrupt enabled
 * - 0b1 - RX_DATA interrupt masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_INT_MASK_RX_DATA_IM field. */
#define EMVSIM_RD_INT_MASK_RX_DATA_IM(base) ((EMVSIM_INT_MASK_REG(base) & EMVSIM_INT_MASK_RX_DATA_IM_MASK) >> EMVSIM_INT_MASK_RX_DATA_IM_SHIFT)
#define EMVSIM_BRD_INT_MASK_RX_DATA_IM(base) (BME_UBFX32(&EMVSIM_INT_MASK_REG(base), EMVSIM_INT_MASK_RX_DATA_IM_SHIFT, EMVSIM_INT_MASK_RX_DATA_IM_WIDTH))

/*! @brief Set the RX_DATA_IM field to a new value. */
#define EMVSIM_WR_INT_MASK_RX_DATA_IM(base, value) (EMVSIM_RMW_INT_MASK(base, EMVSIM_INT_MASK_RX_DATA_IM_MASK, EMVSIM_INT_MASK_RX_DATA_IM(value)))
#define EMVSIM_BWR_INT_MASK_RX_DATA_IM(base, value) (BME_BFI32(&EMVSIM_INT_MASK_REG(base), ((uint32_t)(value) << EMVSIM_INT_MASK_RX_DATA_IM_SHIFT), EMVSIM_INT_MASK_RX_DATA_IM_SHIFT, EMVSIM_INT_MASK_RX_DATA_IM_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_RX_THD - Receiver Threshold Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_RX_THD - Receiver Threshold Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire EMVSIM_RX_THD register
 */
/*@{*/
#define EMVSIM_RD_RX_THD(base)   (EMVSIM_RX_THD_REG(base))
#define EMVSIM_WR_RX_THD(base, value) (EMVSIM_RX_THD_REG(base) = (value))
#define EMVSIM_RMW_RX_THD(base, mask, value) (EMVSIM_WR_RX_THD(base, (EMVSIM_RD_RX_THD(base) & ~(mask)) | (value)))
#define EMVSIM_SET_RX_THD(base, value) (BME_OR32(&EMVSIM_RX_THD_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_RX_THD(base, value) (BME_AND32(&EMVSIM_RX_THD_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_RX_THD(base, value) (BME_XOR32(&EMVSIM_RX_THD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_RX_THD bitfields
 */

/*!
 * @name Register EMVSIM_RX_THD, field RDT[3:0] (RW)
 *
 * Determines the number of bytes that must exist in the Receive FIFO to trigger
 * the receive data threshold interrupt flag (RDTF). Value must not exceed the
 * total bytes that can be stored in the Receive FIFO.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_THD_RDT field. */
#define EMVSIM_RD_RX_THD_RDT(base) ((EMVSIM_RX_THD_REG(base) & EMVSIM_RX_THD_RDT_MASK) >> EMVSIM_RX_THD_RDT_SHIFT)
#define EMVSIM_BRD_RX_THD_RDT(base) (BME_UBFX32(&EMVSIM_RX_THD_REG(base), EMVSIM_RX_THD_RDT_SHIFT, EMVSIM_RX_THD_RDT_WIDTH))

/*! @brief Set the RDT field to a new value. */
#define EMVSIM_WR_RX_THD_RDT(base, value) (EMVSIM_RMW_RX_THD(base, EMVSIM_RX_THD_RDT_MASK, EMVSIM_RX_THD_RDT(value)))
#define EMVSIM_BWR_RX_THD_RDT(base, value) (BME_BFI32(&EMVSIM_RX_THD_REG(base), ((uint32_t)(value) << EMVSIM_RX_THD_RDT_SHIFT), EMVSIM_RX_THD_RDT_SHIFT, EMVSIM_RX_THD_RDT_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_THD, field RNCK_THD[11:8] (RW)
 *
 * Used to specify the number of consecutive NACK's transmitted by the EMV SIM
 * module, for a given character, before the receive threshold error (RTE) flag is
 * triggered. A value of 0 indicates that RTE is never set. When a valid
 * character is received by the EMV SIM, the internal counter keeping track of the NACK
 * count resets to zero for the subsequent byte being received. If the ANACK bit
 * is clear in the CNTL register, RNCK_THD has no effect.
 *
 * Values:
 * - 0b0000 - Zero Threshold. RTE will not be set
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_THD_RNCK_THD field. */
#define EMVSIM_RD_RX_THD_RNCK_THD(base) ((EMVSIM_RX_THD_REG(base) & EMVSIM_RX_THD_RNCK_THD_MASK) >> EMVSIM_RX_THD_RNCK_THD_SHIFT)
#define EMVSIM_BRD_RX_THD_RNCK_THD(base) (BME_UBFX32(&EMVSIM_RX_THD_REG(base), EMVSIM_RX_THD_RNCK_THD_SHIFT, EMVSIM_RX_THD_RNCK_THD_WIDTH))

/*! @brief Set the RNCK_THD field to a new value. */
#define EMVSIM_WR_RX_THD_RNCK_THD(base, value) (EMVSIM_RMW_RX_THD(base, EMVSIM_RX_THD_RNCK_THD_MASK, EMVSIM_RX_THD_RNCK_THD(value)))
#define EMVSIM_BWR_RX_THD_RNCK_THD(base, value) (BME_BFI32(&EMVSIM_RX_THD_REG(base), ((uint32_t)(value) << EMVSIM_RX_THD_RNCK_THD_SHIFT), EMVSIM_RX_THD_RNCK_THD_SHIFT, EMVSIM_RX_THD_RNCK_THD_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_TX_THD - Transmitter Threshold Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_TX_THD - Transmitter Threshold Register (RW)
 *
 * Reset value: 0x0000000FU
 */
/*!
 * @name Constants and macros for entire EMVSIM_TX_THD register
 */
/*@{*/
#define EMVSIM_RD_TX_THD(base)   (EMVSIM_TX_THD_REG(base))
#define EMVSIM_WR_TX_THD(base, value) (EMVSIM_TX_THD_REG(base) = (value))
#define EMVSIM_RMW_TX_THD(base, mask, value) (EMVSIM_WR_TX_THD(base, (EMVSIM_RD_TX_THD(base) & ~(mask)) | (value)))
#define EMVSIM_SET_TX_THD(base, value) (BME_OR32(&EMVSIM_TX_THD_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_TX_THD(base, value) (BME_AND32(&EMVSIM_TX_THD_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_TX_THD(base, value) (BME_XOR32(&EMVSIM_TX_THD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_TX_THD bitfields
 */

/*!
 * @name Register EMVSIM_TX_THD, field TDT[3:0] (RW)
 *
 * Used to set the threshold value for the Transmit FIFO at which the TDTF bit
 * in the TX_STATUS register will be set. When the number of bytes in the Transmit
 * FIFO is less than or equal to TDT[3:0], TDTF will be set.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_THD_TDT field. */
#define EMVSIM_RD_TX_THD_TDT(base) ((EMVSIM_TX_THD_REG(base) & EMVSIM_TX_THD_TDT_MASK) >> EMVSIM_TX_THD_TDT_SHIFT)
#define EMVSIM_BRD_TX_THD_TDT(base) (BME_UBFX32(&EMVSIM_TX_THD_REG(base), EMVSIM_TX_THD_TDT_SHIFT, EMVSIM_TX_THD_TDT_WIDTH))

/*! @brief Set the TDT field to a new value. */
#define EMVSIM_WR_TX_THD_TDT(base, value) (EMVSIM_RMW_TX_THD(base, EMVSIM_TX_THD_TDT_MASK, EMVSIM_TX_THD_TDT(value)))
#define EMVSIM_BWR_TX_THD_TDT(base, value) (BME_BFI32(&EMVSIM_TX_THD_REG(base), ((uint32_t)(value) << EMVSIM_TX_THD_TDT_SHIFT), EMVSIM_TX_THD_TDT_SHIFT, EMVSIM_TX_THD_TDT_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_THD, field TNCK_THD[11:8] (RW)
 *
 * Used to set the NACK threshold for the transmitter. Once the threshold number
 * set by TNCK_THD has been reached for the current byte being transmitted, the
 * error flag TNTE in the TX_STATUS register will be set. Setting of TNTE causes
 * the remaining transmissions queued in the transmit FIFO to be aborted and no
 * more transmissions to occur until software clears TNTE. To trigger TNTE, a
 * given byte being transmitted must reach the TNCK_THD threshold itself. Transmit
 * NACKs accumulated on one byte are not carried over to the next.
 *
 * Values:
 * - 0b0000 - TNTE will never be set; retransmission after NACK reception is
 *     disabled.
 * - 0b0001 - TNTE will be set after 1 nack is received; 0 retransmissions
 *     occurs.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_THD_TNCK_THD field. */
#define EMVSIM_RD_TX_THD_TNCK_THD(base) ((EMVSIM_TX_THD_REG(base) & EMVSIM_TX_THD_TNCK_THD_MASK) >> EMVSIM_TX_THD_TNCK_THD_SHIFT)
#define EMVSIM_BRD_TX_THD_TNCK_THD(base) (BME_UBFX32(&EMVSIM_TX_THD_REG(base), EMVSIM_TX_THD_TNCK_THD_SHIFT, EMVSIM_TX_THD_TNCK_THD_WIDTH))

/*! @brief Set the TNCK_THD field to a new value. */
#define EMVSIM_WR_TX_THD_TNCK_THD(base, value) (EMVSIM_RMW_TX_THD(base, EMVSIM_TX_THD_TNCK_THD_MASK, EMVSIM_TX_THD_TNCK_THD(value)))
#define EMVSIM_BWR_TX_THD_TNCK_THD(base, value) (BME_BFI32(&EMVSIM_TX_THD_REG(base), ((uint32_t)(value) << EMVSIM_TX_THD_TNCK_THD_SHIFT), EMVSIM_TX_THD_TNCK_THD_SHIFT, EMVSIM_TX_THD_TNCK_THD_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_RX_STATUS - Receive Status Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_RX_STATUS - Receive Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire EMVSIM_RX_STATUS register
 */
/*@{*/
#define EMVSIM_RD_RX_STATUS(base) (EMVSIM_RX_STATUS_REG(base))
#define EMVSIM_WR_RX_STATUS(base, value) (EMVSIM_RX_STATUS_REG(base) = (value))
#define EMVSIM_RMW_RX_STATUS(base, mask, value) (EMVSIM_WR_RX_STATUS(base, (EMVSIM_RD_RX_STATUS(base) & ~(mask)) | (value)))
#define EMVSIM_SET_RX_STATUS(base, value) (BME_OR32(&EMVSIM_RX_STATUS_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_RX_STATUS(base, value) (BME_AND32(&EMVSIM_RX_STATUS_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_RX_STATUS(base, value) (BME_XOR32(&EMVSIM_RX_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_RX_STATUS bitfields
 */

/*!
 * @name Register EMVSIM_RX_STATUS, field RFO[0] (W1C)
 *
 * Used to indicate that the EMV SIM was unable to store received data due to
 * already unread bytes in the FIFO (FIFO full or almost full). It does not
 * necessarily indicate that data has been lost. If the ONACK control bit in the CNTL
 * register is set, there will be a NACK pulse generated on bytes that would
 * otherwise cause a loss of data due to a full FIFO. These bytes should be
 * retransmitted by the Smart Card which implies that no data has actually been lost. In
 * this case, the RFO flag is just an indicator that this situation has occurred
 * which may be helpful in system debug. For the case where ONACK is not set, a set
 * RFO flag does indicate a loss of data since all bytes received with the OEF
 * flag set will indeed be lost (including the byte that caused the bit to be set).
 * The RFO flag will cause an interrupt if the RFO_IM bit in the INT_MASK
 * register. The RFO flag is a write-one-to-clear bit.
 *
 * Values:
 * - 0b0 - No overrun error has occurred (default)
 * - 0b1 - A byte was received when the received FIFO was already full
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_RFO field. */
#define EMVSIM_RD_RX_STATUS_RFO(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_RFO_MASK) >> EMVSIM_RX_STATUS_RFO_SHIFT)
#define EMVSIM_BRD_RX_STATUS_RFO(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_RFO_SHIFT, EMVSIM_RX_STATUS_RFO_WIDTH))

/*! @brief Set the RFO field to a new value. */
#define EMVSIM_WR_RX_STATUS_RFO(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_PEF_MASK | EMVSIM_RX_STATUS_FEF_MASK), EMVSIM_RX_STATUS_RFO(value)))
#define EMVSIM_BWR_RX_STATUS_RFO(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_RFO_SHIFT), EMVSIM_RX_STATUS_RFO_SHIFT, EMVSIM_RX_STATUS_RFO_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field RX_DATA[4] (W1C)
 *
 * Interrupt asserted when a new data byte is received and entered into the
 * Receive FIFO.
 *
 * Values:
 * - 0b0 - No new byte is received
 * - 0b1 - New byte is received ans stored in Receive FIFO
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_RX_DATA field. */
#define EMVSIM_RD_RX_STATUS_RX_DATA(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_RX_DATA_MASK) >> EMVSIM_RX_STATUS_RX_DATA_SHIFT)
#define EMVSIM_BRD_RX_STATUS_RX_DATA(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_RX_DATA_SHIFT, EMVSIM_RX_STATUS_RX_DATA_WIDTH))

/*! @brief Set the RX_DATA field to a new value. */
#define EMVSIM_WR_RX_STATUS_RX_DATA(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_PEF_MASK | EMVSIM_RX_STATUS_FEF_MASK), EMVSIM_RX_STATUS_RX_DATA(value)))
#define EMVSIM_BWR_RX_STATUS_RX_DATA(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_RX_DATA_SHIFT), EMVSIM_RX_STATUS_RX_DATA_SHIFT, EMVSIM_RX_STATUS_RX_DATA_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field RDTF[5] (RO)
 *
 * Interrupt flag asserted when total bytes in the Receive FIFO equal or is
 * greater than the programmed receive threshold RDT[3:0]. The RDTF flag will be set
 * any time the number of unread bytes in the receive FIFO is equal to or greater
 * than the value set by RDT[3:0]. The flag can be cleared by reading enough
 * bytes out of the receive FIFO so as to bring the number of bytes left in the FIFO
 * below the RDT[3:0] level. Another way to clear the flag is to set the
 * RDT[3:0] level higher than the number of unread bytes currently in the FIFO. The RDTF
 * flag will create an interrupt if the RDT_IM bit in the INT_MASK register is
 * cleared.
 *
 * Values:
 * - 0b0 - Number of unread bytes in receive FIFO less than the value set by
 *     RDT[3:0] (default).
 * - 0b1 - Number of unread bytes in receive FIFO greater or than equal to value
 *     set by RDT[3:0].
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_RDTF field. */
#define EMVSIM_RD_RX_STATUS_RDTF(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_RDTF_MASK) >> EMVSIM_RX_STATUS_RDTF_SHIFT)
#define EMVSIM_BRD_RX_STATUS_RDTF(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_RDTF_SHIFT, EMVSIM_RX_STATUS_RDTF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field LRC_OK[6] (RO)
 *
 * Used to indicate when the calculated 8-bit LRC value is correct for the
 * current input data stream. The value is calculated across all received characters
 * from the point the LRC_EN bit is set in the CTRL register. The current LRC
 * residual can be reset by three mechanisms: Clear LRC_EN bit in CTRL register Set
 * XMT_EN bit in ENABLE register Automatically by hardware when ETC flag is set at
 * the end of a transmission.
 *
 * Values:
 * - 0b0 - Current LRC value does not match remainder.
 * - 0b1 - Current calculated LRC value matches the expected result (i.e. zero).
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_LRC_OK field. */
#define EMVSIM_RD_RX_STATUS_LRC_OK(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_LRC_OK_MASK) >> EMVSIM_RX_STATUS_LRC_OK_SHIFT)
#define EMVSIM_BRD_RX_STATUS_LRC_OK(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_LRC_OK_SHIFT, EMVSIM_RX_STATUS_LRC_OK_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field CRC_OK[7] (RO)
 *
 * Used to indicate when the calculated 16-bit CRC value matches the expected
 * value for the current input data stream. The value is calculated across all
 * received characters from the point the CRC_EN bit is set in the CTRL register. The
 * current CRC residual can be reset by three mechanisms: Clear CRC_EN bit in
 * CTRL register Set XMT_EN bit in ENABLE register Automatically by hardware when
 * ETC flag is set at the end of a transmission.
 *
 * Values:
 * - 0b0 - Current CRC value does not match remainder.
 * - 0b1 - Current calculated CRC value matches the expected result.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_CRC_OK field. */
#define EMVSIM_RD_RX_STATUS_CRC_OK(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_CRC_OK_MASK) >> EMVSIM_RX_STATUS_CRC_OK_SHIFT)
#define EMVSIM_BRD_RX_STATUS_CRC_OK(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_CRC_OK_SHIFT, EMVSIM_RX_STATUS_CRC_OK_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field CWT_ERR[8] (W1C)
 *
 * Used to indicate when the time between received characters is equal to or
 * greater than the value programmed in the CHAR_WAIT register.
 *
 * Values:
 * - 0b0 - No CWT violation has occurred (default).
 * - 0b1 - Time between two consecutive characters has exceeded the value in
 *     CHAR_WAIT.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_CWT_ERR field. */
#define EMVSIM_RD_RX_STATUS_CWT_ERR(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_CWT_ERR_MASK) >> EMVSIM_RX_STATUS_CWT_ERR_SHIFT)
#define EMVSIM_BRD_RX_STATUS_CWT_ERR(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_CWT_ERR_SHIFT, EMVSIM_RX_STATUS_CWT_ERR_WIDTH))

/*! @brief Set the CWT_ERR field to a new value. */
#define EMVSIM_WR_RX_STATUS_CWT_ERR(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_PEF_MASK | EMVSIM_RX_STATUS_FEF_MASK), EMVSIM_RX_STATUS_CWT_ERR(value)))
#define EMVSIM_BWR_RX_STATUS_CWT_ERR(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_CWT_ERR_SHIFT), EMVSIM_RX_STATUS_CWT_ERR_SHIFT, EMVSIM_RX_STATUS_CWT_ERR_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field RTE[9] (W1C)
 *
 * Used to indicate whether the number of consecutive NACK's generated by the
 * EMV SIM module in response to receive parity errors, for the byte being
 * received, equals the value programmed in the RTH[3:0] in the RX_THRESHOLD register.
 * This bit will never set unless the ANACK bit is set in the CNTL register. The
 * SAPDx bit in the CNTL resister must be set to enable the threshold error to
 * trigger the auto power down sequence. RTE is a write once to clear bit. Clearing
 * this bit also resets the internal counter for consecutive NACK's being
 * transmitted for a given byte.
 *
 * Values:
 * - 0b0 - Number of NACKs generated by the receiver is less than the value
 *     programmed in RTH[3:0]
 * - 0b1 - Number of NACKs generated by the receiver is equal to the value
 *     programmed in RTH[3:0]
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_RTE field. */
#define EMVSIM_RD_RX_STATUS_RTE(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_RTE_MASK) >> EMVSIM_RX_STATUS_RTE_SHIFT)
#define EMVSIM_BRD_RX_STATUS_RTE(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_RTE_SHIFT, EMVSIM_RX_STATUS_RTE_WIDTH))

/*! @brief Set the RTE field to a new value. */
#define EMVSIM_WR_RX_STATUS_RTE(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_PEF_MASK | EMVSIM_RX_STATUS_FEF_MASK), EMVSIM_RX_STATUS_RTE(value)))
#define EMVSIM_BWR_RX_STATUS_RTE(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_RTE_SHIFT), EMVSIM_RX_STATUS_RTE_SHIFT, EMVSIM_RX_STATUS_RTE_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field BWT_ERR[10] (W1C)
 *
 * Used to indicate if the block wait time has been exceeded. The threshold is
 * set by the block wait time registers.
 *
 * Values:
 * - 0b0 - Block wait time not exceeded
 * - 0b1 - Block wait time was exceeded
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_BWT_ERR field. */
#define EMVSIM_RD_RX_STATUS_BWT_ERR(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_BWT_ERR_MASK) >> EMVSIM_RX_STATUS_BWT_ERR_SHIFT)
#define EMVSIM_BRD_RX_STATUS_BWT_ERR(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_BWT_ERR_SHIFT, EMVSIM_RX_STATUS_BWT_ERR_WIDTH))

/*! @brief Set the BWT_ERR field to a new value. */
#define EMVSIM_WR_RX_STATUS_BWT_ERR(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_PEF_MASK | EMVSIM_RX_STATUS_FEF_MASK), EMVSIM_RX_STATUS_BWT_ERR(value)))
#define EMVSIM_BWR_RX_STATUS_BWT_ERR(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_BWT_ERR_SHIFT), EMVSIM_RX_STATUS_BWT_ERR_SHIFT, EMVSIM_RX_STATUS_BWT_ERR_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field BGT_ERR[11] (W1C)
 *
 * Used to indicate if the block guard time was too small. The threshold is set
 * by the block guard time register.
 *
 * Values:
 * - 0b0 - Block guard time was sufficient
 * - 0b1 - Block guard time was too small
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_BGT_ERR field. */
#define EMVSIM_RD_RX_STATUS_BGT_ERR(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_BGT_ERR_MASK) >> EMVSIM_RX_STATUS_BGT_ERR_SHIFT)
#define EMVSIM_BRD_RX_STATUS_BGT_ERR(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_BGT_ERR_SHIFT, EMVSIM_RX_STATUS_BGT_ERR_WIDTH))

/*! @brief Set the BGT_ERR field to a new value. */
#define EMVSIM_WR_RX_STATUS_BGT_ERR(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_PEF_MASK | EMVSIM_RX_STATUS_FEF_MASK), EMVSIM_RX_STATUS_BGT_ERR(value)))
#define EMVSIM_BWR_RX_STATUS_BGT_ERR(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_BGT_ERR_SHIFT), EMVSIM_RX_STATUS_BGT_ERR_SHIFT, EMVSIM_RX_STATUS_BGT_ERR_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field PEF[12] (W1C)
 *
 * Used to indicate if a received byte had a parity error or not. A parity error
 * will cause transmission of NACK if ANACK bit is set in CTRL register and PEF
 * bit will not be asserted. When ANACK is not set, PEF will be asserted. This
 * bit will not cause an interrupt assertion. It is simply an indication that a
 * parity error has occured.
 *
 * Values:
 * - 0b0 - No parity error detected
 * - 0b1 - Parity error detected
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_PEF field. */
#define EMVSIM_RD_RX_STATUS_PEF(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_PEF_MASK) >> EMVSIM_RX_STATUS_PEF_SHIFT)
#define EMVSIM_BRD_RX_STATUS_PEF(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_PEF_SHIFT, EMVSIM_RX_STATUS_PEF_WIDTH))

/*! @brief Set the PEF field to a new value. */
#define EMVSIM_WR_RX_STATUS_PEF(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_PEF_MASK | EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_FEF_MASK), EMVSIM_RX_STATUS_PEF(value)))
#define EMVSIM_BWR_RX_STATUS_PEF(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_PEF_SHIFT), EMVSIM_RX_STATUS_PEF_SHIFT, EMVSIM_RX_STATUS_PEF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field FEF[13] (W1C)
 *
 * Used to indicate if the current received byte did not have proper STOP bits.
 * This will not cause a NACK transmission. This bit will not cause an interrupt
 * assertion. It is simply an indication that a framing error has occured.
 *
 * Values:
 * - 0b0 - No frame error detected
 * - 0b1 - Frame error detected
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_FEF field. */
#define EMVSIM_RD_RX_STATUS_FEF(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_FEF_MASK) >> EMVSIM_RX_STATUS_FEF_SHIFT)
#define EMVSIM_BRD_RX_STATUS_FEF(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_FEF_SHIFT, EMVSIM_RX_STATUS_FEF_WIDTH))

/*! @brief Set the FEF field to a new value. */
#define EMVSIM_WR_RX_STATUS_FEF(base, value) (EMVSIM_RMW_RX_STATUS(base, (EMVSIM_RX_STATUS_FEF_MASK | EMVSIM_RX_STATUS_RFO_MASK | EMVSIM_RX_STATUS_RX_DATA_MASK | EMVSIM_RX_STATUS_CWT_ERR_MASK | EMVSIM_RX_STATUS_RTE_MASK | EMVSIM_RX_STATUS_BWT_ERR_MASK | EMVSIM_RX_STATUS_BGT_ERR_MASK | EMVSIM_RX_STATUS_PEF_MASK), EMVSIM_RX_STATUS_FEF(value)))
#define EMVSIM_BWR_RX_STATUS_FEF(base, value) (BME_BFI32(&EMVSIM_RX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_RX_STATUS_FEF_SHIFT), EMVSIM_RX_STATUS_FEF_SHIFT, EMVSIM_RX_STATUS_FEF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field RX_WPTR[19:16] (RO)
 *
 * Value of write pointer of Receive FIFO
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_RX_WPTR field. */
#define EMVSIM_RD_RX_STATUS_RX_WPTR(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_RX_WPTR_MASK) >> EMVSIM_RX_STATUS_RX_WPTR_SHIFT)
#define EMVSIM_BRD_RX_STATUS_RX_WPTR(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_RX_WPTR_SHIFT, EMVSIM_RX_STATUS_RX_WPTR_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_RX_STATUS, field RX_CNT[28:24] (RO)
 *
 * These bits indicate the number of bytes stored in the receive FIFO.
 *
 * Values:
 * - 0b00000 - FIFO is emtpy
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_STATUS_RX_CNT field. */
#define EMVSIM_RD_RX_STATUS_RX_CNT(base) ((EMVSIM_RX_STATUS_REG(base) & EMVSIM_RX_STATUS_RX_CNT_MASK) >> EMVSIM_RX_STATUS_RX_CNT_SHIFT)
#define EMVSIM_BRD_RX_STATUS_RX_CNT(base) (BME_UBFX32(&EMVSIM_RX_STATUS_REG(base), EMVSIM_RX_STATUS_RX_CNT_SHIFT, EMVSIM_RX_STATUS_RX_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_TX_STATUS - Transmitter Status Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_TX_STATUS - Transmitter Status Register (RW)
 *
 * Reset value: 0x000000B8U
 */
/*!
 * @name Constants and macros for entire EMVSIM_TX_STATUS register
 */
/*@{*/
#define EMVSIM_RD_TX_STATUS(base) (EMVSIM_TX_STATUS_REG(base))
#define EMVSIM_WR_TX_STATUS(base, value) (EMVSIM_TX_STATUS_REG(base) = (value))
#define EMVSIM_RMW_TX_STATUS(base, mask, value) (EMVSIM_WR_TX_STATUS(base, (EMVSIM_RD_TX_STATUS(base) & ~(mask)) | (value)))
#define EMVSIM_SET_TX_STATUS(base, value) (BME_OR32(&EMVSIM_TX_STATUS_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_TX_STATUS(base, value) (BME_AND32(&EMVSIM_TX_STATUS_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_TX_STATUS(base, value) (BME_XOR32(&EMVSIM_TX_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_TX_STATUS bitfields
 */

/*!
 * @name Register EMVSIM_TX_STATUS, field TNTE[0] (W1C)
 *
 * Used to indicate the transmit NACK threshold has been reached. When TNTE is
 * high, no further transmissions will be done until the TNTE flag is cleared. Any
 * data transmissions still pending in the transmit FIFO will be aborted, and
 * the TC, ETC, and TFE flags will be set. The TNTE flag will create an interrupt
 * if TNACK_IM in the INT_MASK register is low. The TNTE bit is a
 * write-one-to-clear bit.
 *
 * Values:
 * - 0b0 - Transmit NACK threshold has not been reached (default)
 * - 0b1 - Transmit NACK threshold reached; transmitter frozen
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_TNTE field. */
#define EMVSIM_RD_TX_STATUS_TNTE(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_TNTE_MASK) >> EMVSIM_TX_STATUS_TNTE_SHIFT)
#define EMVSIM_BRD_TX_STATUS_TNTE(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_TNTE_SHIFT, EMVSIM_TX_STATUS_TNTE_WIDTH))

/*! @brief Set the TNTE field to a new value. */
#define EMVSIM_WR_TX_STATUS_TNTE(base, value) (EMVSIM_RMW_TX_STATUS(base, (EMVSIM_TX_STATUS_TNTE_MASK | EMVSIM_TX_STATUS_TFE_MASK | EMVSIM_TX_STATUS_ETCF_MASK | EMVSIM_TX_STATUS_TCF_MASK | EMVSIM_TX_STATUS_TFF_MASK | EMVSIM_TX_STATUS_GPCNT0_TO_MASK | EMVSIM_TX_STATUS_GPCNT1_TO_MASK), EMVSIM_TX_STATUS_TNTE(value)))
#define EMVSIM_BWR_TX_STATUS_TNTE(base, value) (BME_BFI32(&EMVSIM_TX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_TX_STATUS_TNTE_SHIFT), EMVSIM_TX_STATUS_TNTE_SHIFT, EMVSIM_TX_STATUS_TNTE_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field TFE[3] (W1C)
 *
 * Used to indicate that the EMV SIM transmit FIFO has been emptied. This bit
 * will be set when the last byte in the transmit FIFO has been transferred out of
 * the EMV SIM transmitter to the Smart Card successfully. TFE will also be set
 * when the TNTE flag is set. The TFE flag will create an interrupt if TFE_IM in
 * the INT_MASK register is low. The TFE bit is a write-one-to-clear bit.
 *
 * Values:
 * - 0b0 - Transmit FIFO is not empty
 * - 0b1 - Transmit FIFO is empty (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_TFE field. */
#define EMVSIM_RD_TX_STATUS_TFE(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_TFE_MASK) >> EMVSIM_TX_STATUS_TFE_SHIFT)
#define EMVSIM_BRD_TX_STATUS_TFE(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_TFE_SHIFT, EMVSIM_TX_STATUS_TFE_WIDTH))

/*! @brief Set the TFE field to a new value. */
#define EMVSIM_WR_TX_STATUS_TFE(base, value) (EMVSIM_RMW_TX_STATUS(base, (EMVSIM_TX_STATUS_TFE_MASK | EMVSIM_TX_STATUS_TNTE_MASK | EMVSIM_TX_STATUS_ETCF_MASK | EMVSIM_TX_STATUS_TCF_MASK | EMVSIM_TX_STATUS_TFF_MASK | EMVSIM_TX_STATUS_GPCNT0_TO_MASK | EMVSIM_TX_STATUS_GPCNT1_TO_MASK), EMVSIM_TX_STATUS_TFE(value)))
#define EMVSIM_BWR_TX_STATUS_TFE(base, value) (BME_BFI32(&EMVSIM_TX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_TX_STATUS_TFE_SHIFT), EMVSIM_TX_STATUS_TFE_SHIFT, EMVSIM_TX_STATUS_TFE_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field ETCF[4] (W1C)
 *
 * Used to indicate that the EMV SIM transmitter has finished sending the last
 * byte in transmit FIFO (if XMT_CRC_LRC = 0) or finished sending the LRC or CRC
 * byte (if XMT_CRC_LRC = 1). This bit differs from the TC bit in that it is set
 * before the guard time of the last byte has elapsed. The ETC flag will create an
 * interrupt if ETC_IM in the INT_MASK register is low. The ETC bit is a
 * write-one-to-clear bit.
 *
 * Values:
 * - 0b0 - Transmit pending or in progress
 * - 0b1 - Transmit complete (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_ETCF field. */
#define EMVSIM_RD_TX_STATUS_ETCF(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_ETCF_MASK) >> EMVSIM_TX_STATUS_ETCF_SHIFT)
#define EMVSIM_BRD_TX_STATUS_ETCF(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_ETCF_SHIFT, EMVSIM_TX_STATUS_ETCF_WIDTH))

/*! @brief Set the ETCF field to a new value. */
#define EMVSIM_WR_TX_STATUS_ETCF(base, value) (EMVSIM_RMW_TX_STATUS(base, (EMVSIM_TX_STATUS_ETCF_MASK | EMVSIM_TX_STATUS_TNTE_MASK | EMVSIM_TX_STATUS_TFE_MASK | EMVSIM_TX_STATUS_TCF_MASK | EMVSIM_TX_STATUS_TFF_MASK | EMVSIM_TX_STATUS_GPCNT0_TO_MASK | EMVSIM_TX_STATUS_GPCNT1_TO_MASK), EMVSIM_TX_STATUS_ETCF(value)))
#define EMVSIM_BWR_TX_STATUS_ETCF(base, value) (BME_BFI32(&EMVSIM_TX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_TX_STATUS_ETCF_SHIFT), EMVSIM_TX_STATUS_ETCF_SHIFT, EMVSIM_TX_STATUS_ETCF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field TCF[5] (W1C)
 *
 * Used to indicate whether the EMV SIM transmitter is ready for a new
 * transmission. The TC flag becomes set when the guard time has expired after the last
 * byte in the transmit FIFO (if XMT_CRC_LRC = 0) or the LRC or CRC byte (if
 * XMT_CRC_LRC bit = 1) has been transmitted. The TC flag will create an interrupt if
 * TC_IM in the INT_MASK register is low. The TC bit is a write-one-to-clear bit.
 *
 * Values:
 * - 0b0 - Transmit pending or in progress
 * - 0b1 - Transmit complete (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_TCF field. */
#define EMVSIM_RD_TX_STATUS_TCF(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_TCF_MASK) >> EMVSIM_TX_STATUS_TCF_SHIFT)
#define EMVSIM_BRD_TX_STATUS_TCF(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_TCF_SHIFT, EMVSIM_TX_STATUS_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define EMVSIM_WR_TX_STATUS_TCF(base, value) (EMVSIM_RMW_TX_STATUS(base, (EMVSIM_TX_STATUS_TCF_MASK | EMVSIM_TX_STATUS_TNTE_MASK | EMVSIM_TX_STATUS_TFE_MASK | EMVSIM_TX_STATUS_ETCF_MASK | EMVSIM_TX_STATUS_TFF_MASK | EMVSIM_TX_STATUS_GPCNT0_TO_MASK | EMVSIM_TX_STATUS_GPCNT1_TO_MASK), EMVSIM_TX_STATUS_TCF(value)))
#define EMVSIM_BWR_TX_STATUS_TCF(base, value) (BME_BFI32(&EMVSIM_TX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_TX_STATUS_TCF_SHIFT), EMVSIM_TX_STATUS_TCF_SHIFT, EMVSIM_TX_STATUS_TCF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field TFF[6] (W1C)
 *
 * Used to indicate when the Transmit FIFO has been written with maximum number
 * of bytes that it can store. Subsequent writes may get ignored. The TFF bit can
 * only be cleared by writing 1 to this bit or setting the FLUSH_XMT or
 * SOFT_RESET bit in the RESET_CNTL register.
 *
 * Values:
 * - 0b0 - Transmit FIFO Full condition has not occurred (default)
 * - 0b1 - A Transmit FIFO Full condition has occurred
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_TFF field. */
#define EMVSIM_RD_TX_STATUS_TFF(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_TFF_MASK) >> EMVSIM_TX_STATUS_TFF_SHIFT)
#define EMVSIM_BRD_TX_STATUS_TFF(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_TFF_SHIFT, EMVSIM_TX_STATUS_TFF_WIDTH))

/*! @brief Set the TFF field to a new value. */
#define EMVSIM_WR_TX_STATUS_TFF(base, value) (EMVSIM_RMW_TX_STATUS(base, (EMVSIM_TX_STATUS_TFF_MASK | EMVSIM_TX_STATUS_TNTE_MASK | EMVSIM_TX_STATUS_TFE_MASK | EMVSIM_TX_STATUS_ETCF_MASK | EMVSIM_TX_STATUS_TCF_MASK | EMVSIM_TX_STATUS_GPCNT0_TO_MASK | EMVSIM_TX_STATUS_GPCNT1_TO_MASK), EMVSIM_TX_STATUS_TFF(value)))
#define EMVSIM_BWR_TX_STATUS_TFF(base, value) (BME_BFI32(&EMVSIM_TX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_TX_STATUS_TFF_SHIFT), EMVSIM_TX_STATUS_TFF_SHIFT, EMVSIM_TX_STATUS_TFF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field TDTF[7] (RO)
 *
 * Interrupt flag asserted when total bytes in the Transmit FIFO is less than or
 * equal to the programmed transmit data threshold TDT[3:0]. The TDTF flag will
 * be set any time the number of bytes in the transmit FIFO is less than or equal
 * to the value set by TDT[3:0]. The flag can be cleared by writing enough bytes
 * into the transmit FIFO so as to take the number of bytes in the FIFO above
 * the TDT[3:0] level. Another way to clear the flag is to set the TDT[3:0] level
 * lower than the number of bytes currently in the FIFO. The TDTF flag will create
 * an interrupt if the TDT_IM bit in the INT_MASK register is cleared.
 *
 * Values:
 * - 0b0 - Number of bytes in FIFO is greater than TDT[3:0], or bit has been
 *     cleared
 * - 0b1 - Number of bytes in FIFO is less than or equal to TDT[3:0] (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_TDTF field. */
#define EMVSIM_RD_TX_STATUS_TDTF(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_TDTF_MASK) >> EMVSIM_TX_STATUS_TDTF_SHIFT)
#define EMVSIM_BRD_TX_STATUS_TDTF(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_TDTF_SHIFT, EMVSIM_TX_STATUS_TDTF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field GPCNT0_TO[8] (W1C)
 *
 * Used to indicate when the General Purpose Counter 0 has reached the
 * GPCNT0_VAL value in the GPCNT_VAL register.
 *
 * Values:
 * - 0b0 - GPCNT0_VAL time not reached, or bit has been cleared. (default)
 * - 0b1 - General Purpose counter has reached the GPCNT0_VAL value
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_GPCNT0_TO field. */
#define EMVSIM_RD_TX_STATUS_GPCNT0_TO(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_GPCNT0_TO_MASK) >> EMVSIM_TX_STATUS_GPCNT0_TO_SHIFT)
#define EMVSIM_BRD_TX_STATUS_GPCNT0_TO(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_GPCNT0_TO_SHIFT, EMVSIM_TX_STATUS_GPCNT0_TO_WIDTH))

/*! @brief Set the GPCNT0_TO field to a new value. */
#define EMVSIM_WR_TX_STATUS_GPCNT0_TO(base, value) (EMVSIM_RMW_TX_STATUS(base, (EMVSIM_TX_STATUS_GPCNT0_TO_MASK | EMVSIM_TX_STATUS_TNTE_MASK | EMVSIM_TX_STATUS_TFE_MASK | EMVSIM_TX_STATUS_ETCF_MASK | EMVSIM_TX_STATUS_TCF_MASK | EMVSIM_TX_STATUS_TFF_MASK | EMVSIM_TX_STATUS_GPCNT1_TO_MASK), EMVSIM_TX_STATUS_GPCNT0_TO(value)))
#define EMVSIM_BWR_TX_STATUS_GPCNT0_TO(base, value) (BME_BFI32(&EMVSIM_TX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_TX_STATUS_GPCNT0_TO_SHIFT), EMVSIM_TX_STATUS_GPCNT0_TO_SHIFT, EMVSIM_TX_STATUS_GPCNT0_TO_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field GPCNT1_TO[9] (W1C)
 *
 * Used to indicate when the General Purpose Counter 1 has reached the
 * GPCNT1_VAL value in the GPCNT_VAL register.
 *
 * Values:
 * - 0b0 - GPCNT1_VAL time not reached, or bit has been cleared. (default)
 * - 0b1 - General Purpose counter has reached the GPCNT1_VAL value
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_GPCNT1_TO field. */
#define EMVSIM_RD_TX_STATUS_GPCNT1_TO(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_GPCNT1_TO_MASK) >> EMVSIM_TX_STATUS_GPCNT1_TO_SHIFT)
#define EMVSIM_BRD_TX_STATUS_GPCNT1_TO(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_GPCNT1_TO_SHIFT, EMVSIM_TX_STATUS_GPCNT1_TO_WIDTH))

/*! @brief Set the GPCNT1_TO field to a new value. */
#define EMVSIM_WR_TX_STATUS_GPCNT1_TO(base, value) (EMVSIM_RMW_TX_STATUS(base, (EMVSIM_TX_STATUS_GPCNT1_TO_MASK | EMVSIM_TX_STATUS_TNTE_MASK | EMVSIM_TX_STATUS_TFE_MASK | EMVSIM_TX_STATUS_ETCF_MASK | EMVSIM_TX_STATUS_TCF_MASK | EMVSIM_TX_STATUS_TFF_MASK | EMVSIM_TX_STATUS_GPCNT0_TO_MASK), EMVSIM_TX_STATUS_GPCNT1_TO(value)))
#define EMVSIM_BWR_TX_STATUS_GPCNT1_TO(base, value) (BME_BFI32(&EMVSIM_TX_STATUS_REG(base), ((uint32_t)(value) << EMVSIM_TX_STATUS_GPCNT1_TO_SHIFT), EMVSIM_TX_STATUS_GPCNT1_TO_SHIFT, EMVSIM_TX_STATUS_GPCNT1_TO_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field TX_RPTR[19:16] (RO)
 *
 * Value of the read pointer of transmit FIFO.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_TX_RPTR field. */
#define EMVSIM_RD_TX_STATUS_TX_RPTR(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_TX_RPTR_MASK) >> EMVSIM_TX_STATUS_TX_RPTR_SHIFT)
#define EMVSIM_BRD_TX_STATUS_TX_RPTR(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_TX_RPTR_SHIFT, EMVSIM_TX_STATUS_TX_RPTR_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_TX_STATUS, field TX_CNT[28:24] (RO)
 *
 * These bits indicate the number of bytes stored in the transmit FIFO.
 *
 * Values:
 * - 0b00000 - FIFO is emtpy
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_STATUS_TX_CNT field. */
#define EMVSIM_RD_TX_STATUS_TX_CNT(base) ((EMVSIM_TX_STATUS_REG(base) & EMVSIM_TX_STATUS_TX_CNT_MASK) >> EMVSIM_TX_STATUS_TX_CNT_SHIFT)
#define EMVSIM_BRD_TX_STATUS_TX_CNT(base) (BME_UBFX32(&EMVSIM_TX_STATUS_REG(base), EMVSIM_TX_STATUS_TX_CNT_SHIFT, EMVSIM_TX_STATUS_TX_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_PCSR - Port Control and Status Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_PCSR - Port Control and Status Register (RW)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire EMVSIM_PCSR register
 */
/*@{*/
#define EMVSIM_RD_PCSR(base)     (EMVSIM_PCSR_REG(base))
#define EMVSIM_WR_PCSR(base, value) (EMVSIM_PCSR_REG(base) = (value))
#define EMVSIM_RMW_PCSR(base, mask, value) (EMVSIM_WR_PCSR(base, (EMVSIM_RD_PCSR(base) & ~(mask)) | (value)))
#define EMVSIM_SET_PCSR(base, value) (BME_OR32(&EMVSIM_PCSR_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_PCSR(base, value) (BME_AND32(&EMVSIM_PCSR_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_PCSR(base, value) (BME_XOR32(&EMVSIM_PCSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_PCSR bitfields
 */

/*!
 * @name Register EMVSIM_PCSR, field SAPD[0] (RW)
 *
 * Used to enable/disable the auto power down feature. This bit must be set
 * prior to the auto power conditions are met. This bit will be return to 0 at the
 * end of the auto power down sequence. This bit controls the auto power down
 * function which can be initiated by: Setting the SPD bit in this register by
 * software Assertion of the RTE bit in the RX_STATUS register Assertion of the SPDIF
 * bit when the interrupt is used for detecting card removal Manual Power Down via
 * software by writing to the SCEN, SRST, and VCC_EN can still be carried out
 * irrespective of the value of this bit.
 *
 * Values:
 * - 0b0 - Auto power down disabled (default)
 * - 0b1 - Auto power down enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SAPD field. */
#define EMVSIM_RD_PCSR_SAPD(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SAPD_MASK) >> EMVSIM_PCSR_SAPD_SHIFT)
#define EMVSIM_BRD_PCSR_SAPD(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SAPD_SHIFT, EMVSIM_PCSR_SAPD_WIDTH))

/*! @brief Set the SAPD field to a new value. */
#define EMVSIM_WR_PCSR_SAPD(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SAPD_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SAPD(value)))
#define EMVSIM_BWR_PCSR_SAPD(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SAPD_SHIFT), EMVSIM_PCSR_SAPD_SHIFT, EMVSIM_PCSR_SAPD_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SVCC_EN[1] (RW)
 *
 * Used to control the state of the SVEN pin on Smart Card port. The SVEN pin
 * controls the Smart Card Vcc enable in the power management chip. It can be
 * forced low by hardware during the auto power down sequence. This bit is XORed with
 * the VCCENP bit to control the polarity of the SVEN output pad.
 *
 * Values:
 * - 0b0 - Smart Card Voltage disabled (default)
 * - 0b1 - Smart Card Voltage enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SVCC_EN field. */
#define EMVSIM_RD_PCSR_SVCC_EN(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SVCC_EN_MASK) >> EMVSIM_PCSR_SVCC_EN_SHIFT)
#define EMVSIM_BRD_PCSR_SVCC_EN(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SVCC_EN_SHIFT, EMVSIM_PCSR_SVCC_EN_WIDTH))

/*! @brief Set the SVCC_EN field to a new value. */
#define EMVSIM_WR_PCSR_SVCC_EN(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SVCC_EN_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SVCC_EN(value)))
#define EMVSIM_BWR_PCSR_SVCC_EN(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SVCC_EN_SHIFT), EMVSIM_PCSR_SVCC_EN_SHIFT, EMVSIM_PCSR_SVCC_EN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field VCCENP[2] (RW)
 *
 * Used to control the polarity of the SVEN output pad via the SVCC_EN bit. When
 * set to '1', this bit will invert the value of SVCC_EN bit of this register
 * and output to SVEN output pad of device.
 *
 * Values:
 * - 0b0 - VCC_EN is active high. Polarity of SVCC_EN is unchanged.
 * - 0b1 - VCC_EN is active low. Polarity of SVCC_EN is inverted.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_VCCENP field. */
#define EMVSIM_RD_PCSR_VCCENP(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_VCCENP_MASK) >> EMVSIM_PCSR_VCCENP_SHIFT)
#define EMVSIM_BRD_PCSR_VCCENP(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_VCCENP_SHIFT, EMVSIM_PCSR_VCCENP_WIDTH))

/*! @brief Set the VCCENP field to a new value. */
#define EMVSIM_WR_PCSR_VCCENP(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_VCCENP_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_VCCENP(value)))
#define EMVSIM_BWR_PCSR_VCCENP(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_VCCENP_SHIFT), EMVSIM_PCSR_VCCENP_SHIFT, EMVSIM_PCSR_VCCENP_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SRST[3] (RW)
 *
 * Used to control state of reset line to the Smart Card. It can be forced low
 * by hardware during the auto power down sequence. Smart Card reset signals are
 * active low.
 *
 * Values:
 * - 0b0 - Smart Card Reset is asserted (default)
 * - 0b1 - Smart Card Reset is de-asserted
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SRST field. */
#define EMVSIM_RD_PCSR_SRST(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SRST_MASK) >> EMVSIM_PCSR_SRST_SHIFT)
#define EMVSIM_BRD_PCSR_SRST(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SRST_SHIFT, EMVSIM_PCSR_SRST_WIDTH))

/*! @brief Set the SRST field to a new value. */
#define EMVSIM_WR_PCSR_SRST(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SRST_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SRST(value)))
#define EMVSIM_BWR_PCSR_SRST(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SRST_SHIFT), EMVSIM_PCSR_SRST_SHIFT, EMVSIM_PCSR_SRST_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SCEN[4] (RW)
 *
 * Used to enable/disable the clock to the Smart Card. It can be forced low by
 * hardware during the auto power down sequence.
 *
 * Values:
 * - 0b0 - Smart Card Clock Disabled
 * - 0b1 - Smart Card Clock Enabled
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SCEN field. */
#define EMVSIM_RD_PCSR_SCEN(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SCEN_MASK) >> EMVSIM_PCSR_SCEN_SHIFT)
#define EMVSIM_BRD_PCSR_SCEN(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SCEN_SHIFT, EMVSIM_PCSR_SCEN_WIDTH))

/*! @brief Set the SCEN field to a new value. */
#define EMVSIM_WR_PCSR_SCEN(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SCEN_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SCEN(value)))
#define EMVSIM_BWR_PCSR_SCEN(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SCEN_SHIFT), EMVSIM_PCSR_SCEN_SHIFT, EMVSIM_PCSR_SCEN_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SCSP[5] (RW)
 *
 * Used to control the polarity of the idle EMV SIM clock when the clock is
 * disabled by SCEN.
 *
 * Values:
 * - 0b0 - Clock is logic 0 when stopped by SCEN
 * - 0b1 - Clock is logic 1 when stopped by SCEN
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SCSP field. */
#define EMVSIM_RD_PCSR_SCSP(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SCSP_MASK) >> EMVSIM_PCSR_SCSP_SHIFT)
#define EMVSIM_BRD_PCSR_SCSP(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SCSP_SHIFT, EMVSIM_PCSR_SCSP_WIDTH))

/*! @brief Set the SCSP field to a new value. */
#define EMVSIM_WR_PCSR_SCSP(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SCSP_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SCSP(value)))
#define EMVSIM_BWR_PCSR_SCSP(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SCSP_SHIFT), EMVSIM_PCSR_SCSP_SHIFT, EMVSIM_PCSR_SCSP_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SPD[7] (RW)
 *
 * Writing a '1' to this location will start the autopower down sequence
 * provided the auto power down feature is enabled by writing '1' to SAPD bit of this
 * register. The SPD bit will autoclear when power down is complete.
 *
 * Values:
 * - 0b0 - No effect (default)
 * - 0b1 - Start Auto Powerdown or Power Down is in progress
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SPD field. */
#define EMVSIM_RD_PCSR_SPD(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SPD_MASK) >> EMVSIM_PCSR_SPD_SHIFT)
#define EMVSIM_BRD_PCSR_SPD(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SPD_SHIFT, EMVSIM_PCSR_SPD_WIDTH))

/*! @brief Set the SPD field to a new value. */
#define EMVSIM_WR_PCSR_SPD(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SPD_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SPD(value)))
#define EMVSIM_BWR_PCSR_SPD(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SPD_SHIFT), EMVSIM_PCSR_SPD_SHIFT, EMVSIM_PCSR_SPD_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SPDIM[24] (RW)
 *
 * Interrupt mask for the presence detect interrupt flag (SPDIF).
 *
 * Values:
 * - 0b0 - SIM presence detect interrupt is enabled
 * - 0b1 - SIM presence detect interrupt is masked (default)
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SPDIM field. */
#define EMVSIM_RD_PCSR_SPDIM(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SPDIM_MASK) >> EMVSIM_PCSR_SPDIM_SHIFT)
#define EMVSIM_BRD_PCSR_SPDIM(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SPDIM_SHIFT, EMVSIM_PCSR_SPDIM_WIDTH))

/*! @brief Set the SPDIM field to a new value. */
#define EMVSIM_WR_PCSR_SPDIM(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SPDIM_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SPDIM(value)))
#define EMVSIM_BWR_PCSR_SPDIM(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SPDIM_SHIFT), EMVSIM_PCSR_SPDIM_SHIFT, EMVSIM_PCSR_SPDIM_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SPDIF[25] (W1C)
 *
 * Status flag to indicate that an insertion or removal of a Smart Card has been
 * detected on port. Can create an interrupt to the MCU if SPDIM is low and/or
 * initiate the auto power down sequence if SAPD bit is '1'. Write a '1' to this
 * bit to clear.
 *
 * Values:
 * - 0b0 - No insertion or removal of Smart Card detected on Port (default)
 * - 0b1 - Insertion or removal of Smart Card detected on Port
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SPDIF field. */
#define EMVSIM_RD_PCSR_SPDIF(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SPDIF_MASK) >> EMVSIM_PCSR_SPDIF_SHIFT)
#define EMVSIM_BRD_PCSR_SPDIF(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SPDIF_SHIFT, EMVSIM_PCSR_SPDIF_WIDTH))

/*! @brief Set the SPDIF field to a new value. */
#define EMVSIM_WR_PCSR_SPDIF(base, value) (EMVSIM_RMW_PCSR(base, EMVSIM_PCSR_SPDIF_MASK, EMVSIM_PCSR_SPDIF(value)))
#define EMVSIM_BWR_PCSR_SPDIF(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SPDIF_SHIFT), EMVSIM_PCSR_SPDIF_SHIFT, EMVSIM_PCSR_SPDIF_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SPDP[26] (RO)
 *
 * This bit reflects the state of the Smart Card Presence Detect pin. It is not
 * a latched register bit, but instead a synchronized version of the state of the
 * pin itself.
 *
 * Values:
 * - 0b0 - SIM Presence Detect pin is logic low
 * - 0b1 - SIM Presence Detectpin is logic high
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SPDP field. */
#define EMVSIM_RD_PCSR_SPDP(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SPDP_MASK) >> EMVSIM_PCSR_SPDP_SHIFT)
#define EMVSIM_BRD_PCSR_SPDP(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SPDP_SHIFT, EMVSIM_PCSR_SPDP_WIDTH))
/*@}*/

/*!
 * @name Register EMVSIM_PCSR, field SPDES[27] (RW)
 *
 * Controls which edge of the Smart Card Presence Detect pin is used to detect
 * the presence of the Smart Card.
 *
 * Values:
 * - 0b0 - Falling edge on the pin (default)
 * - 0b1 - Rising edge on the pin
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_PCSR_SPDES field. */
#define EMVSIM_RD_PCSR_SPDES(base) ((EMVSIM_PCSR_REG(base) & EMVSIM_PCSR_SPDES_MASK) >> EMVSIM_PCSR_SPDES_SHIFT)
#define EMVSIM_BRD_PCSR_SPDES(base) (BME_UBFX32(&EMVSIM_PCSR_REG(base), EMVSIM_PCSR_SPDES_SHIFT, EMVSIM_PCSR_SPDES_WIDTH))

/*! @brief Set the SPDES field to a new value. */
#define EMVSIM_WR_PCSR_SPDES(base, value) (EMVSIM_RMW_PCSR(base, (EMVSIM_PCSR_SPDES_MASK | EMVSIM_PCSR_SPDIF_MASK), EMVSIM_PCSR_SPDES(value)))
#define EMVSIM_BWR_PCSR_SPDES(base, value) (BME_BFI32(&EMVSIM_PCSR_REG(base), ((uint32_t)(value) << EMVSIM_PCSR_SPDES_SHIFT), EMVSIM_PCSR_SPDES_SHIFT, EMVSIM_PCSR_SPDES_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_RX_BUF - Receive Data Read Buffer
 ******************************************************************************/

/*!
 * @brief EMVSIM_RX_BUF - Receive Data Read Buffer (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire EMVSIM_RX_BUF register
 */
/*@{*/
#define EMVSIM_RD_RX_BUF(base)   (EMVSIM_RX_BUF_REG(base))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_RX_BUF bitfields
 */

/*!
 * @name Register EMVSIM_RX_BUF, field RX_BYTE[7:0] (RO)
 *
 * Provides the byte value from the top of the receive FIFO. Each read access to
 * this register will increment the read pointer of the Receive FIFO.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_RX_BUF_RX_BYTE field. */
#define EMVSIM_RD_RX_BUF_RX_BYTE(base) ((EMVSIM_RX_BUF_REG(base) & EMVSIM_RX_BUF_RX_BYTE_MASK) >> EMVSIM_RX_BUF_RX_BYTE_SHIFT)
#define EMVSIM_BRD_RX_BUF_RX_BYTE(base) (BME_UBFX32(&EMVSIM_RX_BUF_REG(base), EMVSIM_RX_BUF_RX_BYTE_SHIFT, EMVSIM_RX_BUF_RX_BYTE_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_TX_BUF - Transmit Data Buffer
 ******************************************************************************/

/*!
 * @brief EMVSIM_TX_BUF - Transmit Data Buffer (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire EMVSIM_TX_BUF register
 */
/*@{*/
#define EMVSIM_RD_TX_BUF(base)   (EMVSIM_TX_BUF_REG(base))
#define EMVSIM_WR_TX_BUF(base, value) (EMVSIM_TX_BUF_REG(base) = (value))
#define EMVSIM_RMW_TX_BUF(base, mask, value) (EMVSIM_WR_TX_BUF(base, (EMVSIM_RD_TX_BUF(base) & ~(mask)) | (value)))
#define EMVSIM_SET_TX_BUF(base, value) (BME_OR32(&EMVSIM_TX_BUF_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_TX_BUF(base, value) (BME_AND32(&EMVSIM_TX_BUF_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_TX_BUF(base, value) (BME_XOR32(&EMVSIM_TX_BUF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_TX_BUF bitfields
 */

/*!
 * @name Register EMVSIM_TX_BUF, field TX_BYTE[7:0] (WORZ)
 *
 * Write to this register to fill the transmit FIFO with the bytes to be
 * transmitted. The Tx FIFO can be written to only when the transmitter is enabled.
 * Writing to this register while transmitter is disabled will lead to ignoring of
 * all write accesses to this register. Reads to this register will return zeros.
 * Writing more data to the transmit FIFO than it can hold, will cause a Transmit
 * FIFO Full (TFF) error.
 */
/*@{*/
/*! @brief Set the TX_BYTE field to a new value. */
#define EMVSIM_WR_TX_BUF_TX_BYTE(base, value) (EMVSIM_RMW_TX_BUF(base, EMVSIM_TX_BUF_TX_BYTE_MASK, EMVSIM_TX_BUF_TX_BYTE(value)))
#define EMVSIM_BWR_TX_BUF_TX_BYTE(base, value) (BME_BFI32(&EMVSIM_TX_BUF_REG(base), ((uint32_t)(value) << EMVSIM_TX_BUF_TX_BYTE_SHIFT), EMVSIM_TX_BUF_TX_BYTE_SHIFT, EMVSIM_TX_BUF_TX_BYTE_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_TX_GETU - Transmitter Guard ETU Value Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_TX_GETU - Transmitter Guard ETU Value Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire EMVSIM_TX_GETU register
 */
/*@{*/
#define EMVSIM_RD_TX_GETU(base)  (EMVSIM_TX_GETU_REG(base))
#define EMVSIM_WR_TX_GETU(base, value) (EMVSIM_TX_GETU_REG(base) = (value))
#define EMVSIM_RMW_TX_GETU(base, mask, value) (EMVSIM_WR_TX_GETU(base, (EMVSIM_RD_TX_GETU(base) & ~(mask)) | (value)))
#define EMVSIM_SET_TX_GETU(base, value) (BME_OR32(&EMVSIM_TX_GETU_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_TX_GETU(base, value) (BME_AND32(&EMVSIM_TX_GETU_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_TX_GETU(base, value) (BME_XOR32(&EMVSIM_TX_GETU_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_TX_GETU bitfields
 */

/*!
 * @name Register EMVSIM_TX_GETU, field GETU[7:0] (RW)
 *
 * Used to control the number of additional Elementary Time Units (ETUs)
 * inserted between bytes transmitted by the EMV SIM transmitter. An ETU is equivalent
 * to one bit time at the given baud rate (for example, the length of a START
 * bit). The guard time has no effect on the EMV SIM receiver. A value of 0x00
 * inserts no additional ETUs, while a value of 0xFE inserts 254 additional ETUs. A
 * value of 0xFF subtracts one ETU by reducing the number of STOP bits from two to
 * one.
 *
 * Values:
 * - 0b00000000 - no additional ETUs inserted (default)
 * - 0b00000001 - 1 additional ETU inserted
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_TX_GETU_GETU field. */
#define EMVSIM_RD_TX_GETU_GETU(base) ((EMVSIM_TX_GETU_REG(base) & EMVSIM_TX_GETU_GETU_MASK) >> EMVSIM_TX_GETU_GETU_SHIFT)
#define EMVSIM_BRD_TX_GETU_GETU(base) (BME_UBFX32(&EMVSIM_TX_GETU_REG(base), EMVSIM_TX_GETU_GETU_SHIFT, EMVSIM_TX_GETU_GETU_WIDTH))

/*! @brief Set the GETU field to a new value. */
#define EMVSIM_WR_TX_GETU_GETU(base, value) (EMVSIM_RMW_TX_GETU(base, EMVSIM_TX_GETU_GETU_MASK, EMVSIM_TX_GETU_GETU(value)))
#define EMVSIM_BWR_TX_GETU_GETU(base, value) (BME_BFI32(&EMVSIM_TX_GETU_REG(base), ((uint32_t)(value) << EMVSIM_TX_GETU_GETU_SHIFT), EMVSIM_TX_GETU_GETU_SHIFT, EMVSIM_TX_GETU_GETU_WIDTH))
/*@}*/

/*******************************************************************************
 * EMVSIM_CWT_VAL - Character Wait Time Value Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_CWT_VAL - Character Wait Time Value Register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire EMVSIM_CWT_VAL register
 */
/*@{*/
#define EMVSIM_RD_CWT_VAL(base)  (EMVSIM_CWT_VAL_REG(base))
#define EMVSIM_WR_CWT_VAL(base, value) (EMVSIM_CWT_VAL_REG(base) = (value))
#define EMVSIM_RMW_CWT_VAL(base, mask, value) (EMVSIM_WR_CWT_VAL(base, (EMVSIM_RD_CWT_VAL(base) & ~(mask)) | (value)))
#define EMVSIM_SET_CWT_VAL(base, value) (BME_OR32(&EMVSIM_CWT_VAL_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_CWT_VAL(base, value) (BME_AND32(&EMVSIM_CWT_VAL_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_CWT_VAL(base, value) (BME_XOR32(&EMVSIM_CWT_VAL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_CWT_VAL bitfields
 */

/*!
 * @name Register EMVSIM_CWT_VAL, field CWT[15:0] (RW)
 *
 * The value written to this register will specify the number of ETU times
 * allowed between characters. Default is 0xFFFF
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_CWT_VAL_CWT field. */
#define EMVSIM_RD_CWT_VAL_CWT(base) ((EMVSIM_CWT_VAL_REG(base) & EMVSIM_CWT_VAL_CWT_MASK) >> EMVSIM_CWT_VAL_CWT_SHIFT)
#define EMVSIM_BRD_CWT_VAL_CWT(base) (EMVSIM_RD_CWT_VAL_CWT(base))

/*! @brief Set the CWT field to a new value. */
#define EMVSIM_WR_CWT_VAL_CWT(base, value) (EMVSIM_RMW_CWT_VAL(base, EMVSIM_CWT_VAL_CWT_MASK, EMVSIM_CWT_VAL_CWT(value)))
#define EMVSIM_BWR_CWT_VAL_CWT(base, value) (EMVSIM_WR_CWT_VAL_CWT(base, value))
/*@}*/

/*******************************************************************************
 * EMVSIM_BWT_VAL - Block Wait Time Value Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_BWT_VAL - Block Wait Time Value Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 */
/*!
 * @name Constants and macros for entire EMVSIM_BWT_VAL register
 */
/*@{*/
#define EMVSIM_RD_BWT_VAL(base)  (EMVSIM_BWT_VAL_REG(base))
#define EMVSIM_WR_BWT_VAL(base, value) (EMVSIM_BWT_VAL_REG(base) = (value))
#define EMVSIM_RMW_BWT_VAL(base, mask, value) (EMVSIM_WR_BWT_VAL(base, (EMVSIM_RD_BWT_VAL(base) & ~(mask)) | (value)))
#define EMVSIM_SET_BWT_VAL(base, value) (BME_OR32(&EMVSIM_BWT_VAL_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_BWT_VAL(base, value) (BME_AND32(&EMVSIM_BWT_VAL_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_BWT_VAL(base, value) (BME_XOR32(&EMVSIM_BWT_VAL_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * EMVSIM_BGT_VAL - Block Guard Time Value Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_BGT_VAL - Block Guard Time Value Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire EMVSIM_BGT_VAL register
 */
/*@{*/
#define EMVSIM_RD_BGT_VAL(base)  (EMVSIM_BGT_VAL_REG(base))
#define EMVSIM_WR_BGT_VAL(base, value) (EMVSIM_BGT_VAL_REG(base) = (value))
#define EMVSIM_RMW_BGT_VAL(base, mask, value) (EMVSIM_WR_BGT_VAL(base, (EMVSIM_RD_BGT_VAL(base) & ~(mask)) | (value)))
#define EMVSIM_SET_BGT_VAL(base, value) (BME_OR32(&EMVSIM_BGT_VAL_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_BGT_VAL(base, value) (BME_AND32(&EMVSIM_BGT_VAL_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_BGT_VAL(base, value) (BME_XOR32(&EMVSIM_BGT_VAL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_BGT_VAL bitfields
 */

/*!
 * @name Register EMVSIM_BGT_VAL, field BGT[15:0] (RW)
 *
 * The value in this register is the block guard time. Time from START bit of
 * last byte sent from the EMV SIM module to the START bit of the first byte sent
 * from the SmartCard must be greater than this value. If it is not, then the BGT
 * flag will be set.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_BGT_VAL_BGT field. */
#define EMVSIM_RD_BGT_VAL_BGT(base) ((EMVSIM_BGT_VAL_REG(base) & EMVSIM_BGT_VAL_BGT_MASK) >> EMVSIM_BGT_VAL_BGT_SHIFT)
#define EMVSIM_BRD_BGT_VAL_BGT(base) (EMVSIM_RD_BGT_VAL_BGT(base))

/*! @brief Set the BGT field to a new value. */
#define EMVSIM_WR_BGT_VAL_BGT(base, value) (EMVSIM_RMW_BGT_VAL(base, EMVSIM_BGT_VAL_BGT_MASK, EMVSIM_BGT_VAL_BGT(value)))
#define EMVSIM_BWR_BGT_VAL_BGT(base, value) (EMVSIM_WR_BGT_VAL_BGT(base, value))
/*@}*/

/*******************************************************************************
 * EMVSIM_GPCNT0_VAL - General Purpose Counter 0 Timeout Value Register
 ******************************************************************************/

/*!
 * @brief EMVSIM_GPCNT0_VAL - General Purpose Counter 0 Timeout Value Register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire EMVSIM_GPCNT0_VAL register
 */
/*@{*/
#define EMVSIM_RD_GPCNT0_VAL(base) (EMVSIM_GPCNT0_VAL_REG(base))
#define EMVSIM_WR_GPCNT0_VAL(base, value) (EMVSIM_GPCNT0_VAL_REG(base) = (value))
#define EMVSIM_RMW_GPCNT0_VAL(base, mask, value) (EMVSIM_WR_GPCNT0_VAL(base, (EMVSIM_RD_GPCNT0_VAL(base) & ~(mask)) | (value)))
#define EMVSIM_SET_GPCNT0_VAL(base, value) (BME_OR32(&EMVSIM_GPCNT0_VAL_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_GPCNT0_VAL(base, value) (BME_AND32(&EMVSIM_GPCNT0_VAL_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_GPCNT0_VAL(base, value) (BME_XOR32(&EMVSIM_GPCNT0_VAL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_GPCNT0_VAL bitfields
 */

/*!
 * @name Register EMVSIM_GPCNT0_VAL, field GPCNT0[15:0] (RW)
 *
 * The value written to this register will be used to compare to the general
 * purpose counter 0 in the EMV SIM module. Once the General purpose counter reaches
 * this value, the GPCNT0 flag in the TX_STATUS register will be set. This
 * counter is intended to be used for any events that must be monitored for duration
 * based on the card clock, receiver sample rate, or ETU rate (transmit clock).
 * Example: ATR arrival time and ATR duration.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_GPCNT0_VAL_GPCNT0 field. */
#define EMVSIM_RD_GPCNT0_VAL_GPCNT0(base) ((EMVSIM_GPCNT0_VAL_REG(base) & EMVSIM_GPCNT0_VAL_GPCNT0_MASK) >> EMVSIM_GPCNT0_VAL_GPCNT0_SHIFT)
#define EMVSIM_BRD_GPCNT0_VAL_GPCNT0(base) (EMVSIM_RD_GPCNT0_VAL_GPCNT0(base))

/*! @brief Set the GPCNT0 field to a new value. */
#define EMVSIM_WR_GPCNT0_VAL_GPCNT0(base, value) (EMVSIM_RMW_GPCNT0_VAL(base, EMVSIM_GPCNT0_VAL_GPCNT0_MASK, EMVSIM_GPCNT0_VAL_GPCNT0(value)))
#define EMVSIM_BWR_GPCNT0_VAL_GPCNT0(base, value) (EMVSIM_WR_GPCNT0_VAL_GPCNT0(base, value))
/*@}*/

/*******************************************************************************
 * EMVSIM_GPCNT1_VAL - General Purpose Counter 1 Timeout Value
 ******************************************************************************/

/*!
 * @brief EMVSIM_GPCNT1_VAL - General Purpose Counter 1 Timeout Value (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire EMVSIM_GPCNT1_VAL register
 */
/*@{*/
#define EMVSIM_RD_GPCNT1_VAL(base) (EMVSIM_GPCNT1_VAL_REG(base))
#define EMVSIM_WR_GPCNT1_VAL(base, value) (EMVSIM_GPCNT1_VAL_REG(base) = (value))
#define EMVSIM_RMW_GPCNT1_VAL(base, mask, value) (EMVSIM_WR_GPCNT1_VAL(base, (EMVSIM_RD_GPCNT1_VAL(base) & ~(mask)) | (value)))
#define EMVSIM_SET_GPCNT1_VAL(base, value) (BME_OR32(&EMVSIM_GPCNT1_VAL_REG(base), (uint32_t)(value)))
#define EMVSIM_CLR_GPCNT1_VAL(base, value) (BME_AND32(&EMVSIM_GPCNT1_VAL_REG(base), (uint32_t)(~(value))))
#define EMVSIM_TOG_GPCNT1_VAL(base, value) (BME_XOR32(&EMVSIM_GPCNT1_VAL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EMVSIM_GPCNT1_VAL bitfields
 */

/*!
 * @name Register EMVSIM_GPCNT1_VAL, field GPCNT1[15:0] (RW)
 *
 * The value written to this register will be used to compare to the general
 * purpose counter in the EMV SIM module. Once the General purpose counter reaches
 * this value, the GPCNT1 flag in the XMT_STATUS register will be set. This
 * counter is intended to be used for any events that must be monitored for duration
 * based on the card clock, receiver sample rate, or ETU rate (transmit clock).
 * Example: ATR arrival time and ATR duration.
 */
/*@{*/
/*! @brief Read current value of the EMVSIM_GPCNT1_VAL_GPCNT1 field. */
#define EMVSIM_RD_GPCNT1_VAL_GPCNT1(base) ((EMVSIM_GPCNT1_VAL_REG(base) & EMVSIM_GPCNT1_VAL_GPCNT1_MASK) >> EMVSIM_GPCNT1_VAL_GPCNT1_SHIFT)
#define EMVSIM_BRD_GPCNT1_VAL_GPCNT1(base) (EMVSIM_RD_GPCNT1_VAL_GPCNT1(base))

/*! @brief Set the GPCNT1 field to a new value. */
#define EMVSIM_WR_GPCNT1_VAL_GPCNT1(base, value) (EMVSIM_RMW_GPCNT1_VAL(base, EMVSIM_GPCNT1_VAL_GPCNT1_MASK, EMVSIM_GPCNT1_VAL_GPCNT1(value)))
#define EMVSIM_BWR_GPCNT1_VAL_GPCNT1(base, value) (EMVSIM_WR_GPCNT1_VAL_GPCNT1(base, value))
/*@}*/

/*
 * MKL28Z7 FGPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - FGPIO_PDOR - Port Data Output Register
 * - FGPIO_PSOR - Port Set Output Register
 * - FGPIO_PCOR - Port Clear Output Register
 * - FGPIO_PTOR - Port Toggle Output Register
 * - FGPIO_PDIR - Port Data Input Register
 * - FGPIO_PDDR - Port Data Direction Register
 * - FGPIO_PIDR - Port Input Disable Register
 */

#define FGPIO_INSTANCE_COUNT (1U) /*!< Number of instances of the FGPIO module. */
#define FGPIOA_IDX (0U) /*!< Instance number for FGPIOA. */

/*******************************************************************************
 * FGPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins.
 */
/*!
 * @name Constants and macros for entire FGPIO_PDOR register
 */
/*@{*/
#define FGPIO_RD_PDOR(base)      (FGPIO_PDOR_REG(base))
#define FGPIO_WR_PDOR(base, value) (FGPIO_PDOR_REG(base) = (value))
#define FGPIO_RMW_PDOR(base, mask, value) (FGPIO_WR_PDOR(base, (FGPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define FGPIO_SET_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) |  (value)))
#define FGPIO_CLR_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) & ~(value)))
#define FGPIO_TOG_PDOR(base, value) (FGPIO_WR_PDOR(base, FGPIO_RD_PDOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire FGPIO_PSOR register
 */
/*@{*/
#define FGPIO_RD_PSOR(base)      (FGPIO_PSOR_REG(base))
#define FGPIO_WR_PSOR(base, value) (FGPIO_PSOR_REG(base) = (value))
#define FGPIO_RMW_PSOR(base, mask, value) (FGPIO_WR_PSOR(base, (FGPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire FGPIO_PCOR register
 */
/*@{*/
#define FGPIO_RD_PCOR(base)      (FGPIO_PCOR_REG(base))
#define FGPIO_WR_PCOR(base, value) (FGPIO_PCOR_REG(base) = (value))
#define FGPIO_RMW_PCOR(base, mask, value) (FGPIO_WR_PCOR(base, (FGPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FGPIO_PTOR register
 */
/*@{*/
#define FGPIO_RD_PTOR(base)      (FGPIO_PTOR_REG(base))
#define FGPIO_WR_PTOR(base, value) (FGPIO_PTOR_REG(base) = (value))
#define FGPIO_RMW_PTOR(base, mask, value) (FGPIO_WR_PTOR(base, (FGPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FGPIO_PDIR register
 */
/*@{*/
#define FGPIO_RD_PDIR(base)      (FGPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * FGPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire FGPIO_PDDR register
 */
/*@{*/
#define FGPIO_RD_PDDR(base)      (FGPIO_PDDR_REG(base))
#define FGPIO_WR_PDDR(base, value) (FGPIO_PDDR_REG(base) = (value))
#define FGPIO_RMW_PDDR(base, mask, value) (FGPIO_WR_PDDR(base, (FGPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define FGPIO_SET_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) |  (value)))
#define FGPIO_CLR_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) & ~(value)))
#define FGPIO_TOG_PDDR(base, value) (FGPIO_WR_PDDR(base, FGPIO_RD_PDDR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FGPIO_PIDR - Port Input Disable Register
 ******************************************************************************/

/*!
 * @brief FGPIO_PIDR - Port Input Disable Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 */
/*!
 * @name Constants and macros for entire FGPIO_PIDR register
 */
/*@{*/
#define FGPIO_RD_PIDR(base)      (FGPIO_PIDR_REG(base))
#define FGPIO_WR_PIDR(base, value) (FGPIO_PIDR_REG(base) = (value))
#define FGPIO_RMW_PIDR(base, mask, value) (FGPIO_WR_PIDR(base, (FGPIO_RD_PIDR(base) & ~(mask)) | (value)))
#define FGPIO_SET_PIDR(base, value) (FGPIO_WR_PIDR(base, FGPIO_RD_PIDR(base) |  (value)))
#define FGPIO_CLR_PIDR(base, value) (FGPIO_WR_PIDR(base, FGPIO_RD_PIDR(base) & ~(value)))
#define FGPIO_TOG_PIDR(base, value) (FGPIO_WR_PIDR(base, FGPIO_RD_PIDR(base) ^  (value)))
/*@}*/

/*
 * MKL28Z7 FLEXIO
 *
 * The FLEXIO Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - FLEXIO_VERID - Version ID Register
 * - FLEXIO_PARAM - Parameter Register
 * - FLEXIO_CTRL - FlexIO Control Register
 * - FLEXIO_PIN - Pin State Register
 * - FLEXIO_SHIFTSTAT - Shifter Status Register
 * - FLEXIO_SHIFTERR - Shifter Error Register
 * - FLEXIO_TIMSTAT - Timer Status Register
 * - FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 * - FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 * - FLEXIO_TIMIEN - Timer Interrupt Enable Register
 * - FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 * - FLEXIO_SHIFTSTATE - Shifter State Register
 * - FLEXIO_SHIFTCTL - Shifter Control N Register
 * - FLEXIO_SHIFTCFG - Shifter Configuration N Register
 * - FLEXIO_SHIFTBUF - Shifter Buffer N Register
 * - FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register
 * - FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register
 * - FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register
 * - FLEXIO_TIMCTL - Timer Control N Register
 * - FLEXIO_TIMCFG - Timer Configuration N Register
 * - FLEXIO_TIMCMP - Timer Compare N Register
 * - FLEXIO_SHIFTBUFNBS - Shifter Buffer N Nibble Byte Swapped Register
 * - FLEXIO_SHIFTBUFHWS - Shifter Buffer N Half Word Swapped Register
 * - FLEXIO_SHIFTBUFNIS - Shifter Buffer N Nibble Swapped Register
 */

#define FLEXIO_INSTANCE_COUNT (1U) /*!< Number of instances of the FLEXIO module. */
#define FLEXIO0_IDX (0U) /*!< Instance number for FLEXIO0. */

/*******************************************************************************
 * FLEXIO_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01010001U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_VERID register
 */
/*@{*/
#define FLEXIO_RD_VERID(base)    (FLEXIO_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_VERID bitfields
 */

/*!
 * @name Register FLEXIO_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000000 - Standard features implemented.
 * - 0b0000000000000001 - Supports state, logic and parallel modes.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_FEATURE field. */
#define FLEXIO_RD_VERID_FEATURE(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_FEATURE_MASK) >> FLEXIO_VERID_FEATURE_SHIFT)
#define FLEXIO_BRD_VERID_FEATURE(base) (FLEXIO_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_MINOR field. */
#define FLEXIO_RD_VERID_MINOR(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_MINOR_MASK) >> FLEXIO_VERID_MINOR_SHIFT)
#define FLEXIO_BRD_VERID_MINOR(base) (BME_UBFX32(&FLEXIO_VERID_REG(base), FLEXIO_VERID_MINOR_SHIFT, FLEXIO_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_MAJOR field. */
#define FLEXIO_RD_VERID_MAJOR(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_MAJOR_MASK) >> FLEXIO_VERID_MAJOR_SHIFT)
#define FLEXIO_BRD_VERID_MAJOR(base) (BME_UBFX32(&FLEXIO_VERID_REG(base), FLEXIO_VERID_MAJOR_SHIFT, FLEXIO_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x10200808U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_PARAM register
 */
/*@{*/
#define FLEXIO_RD_PARAM(base)    (FLEXIO_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_PARAM bitfields
 */

/*!
 * @name Register FLEXIO_PARAM, field SHIFTER[7:0] (RO)
 *
 * Number of Shifters implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_SHIFTER field. */
#define FLEXIO_RD_PARAM_SHIFTER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_SHIFTER_MASK) >> FLEXIO_PARAM_SHIFTER_SHIFT)
#define FLEXIO_BRD_PARAM_SHIFTER(base) (BME_UBFX32(&FLEXIO_PARAM_REG(base), FLEXIO_PARAM_SHIFTER_SHIFT, FLEXIO_PARAM_SHIFTER_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TIMER[15:8] (RO)
 *
 * Number of Timers implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_TIMER field. */
#define FLEXIO_RD_PARAM_TIMER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_TIMER_MASK) >> FLEXIO_PARAM_TIMER_SHIFT)
#define FLEXIO_BRD_PARAM_TIMER(base) (BME_UBFX32(&FLEXIO_PARAM_REG(base), FLEXIO_PARAM_TIMER_SHIFT, FLEXIO_PARAM_TIMER_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field PIN[23:16] (RO)
 *
 * Number of Pins implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_PIN field. */
#define FLEXIO_RD_PARAM_PIN(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_PIN_MASK) >> FLEXIO_PARAM_PIN_SHIFT)
#define FLEXIO_BRD_PARAM_PIN(base) (BME_UBFX32(&FLEXIO_PARAM_REG(base), FLEXIO_PARAM_PIN_SHIFT, FLEXIO_PARAM_PIN_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TRIGGER[31:24] (RO)
 *
 * Number of external triggers implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_TRIGGER field. */
#define FLEXIO_RD_PARAM_TRIGGER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_TRIGGER_MASK) >> FLEXIO_PARAM_TRIGGER_SHIFT)
#define FLEXIO_BRD_PARAM_TRIGGER(base) (BME_UBFX32(&FLEXIO_PARAM_REG(base), FLEXIO_PARAM_TRIGGER_SHIFT, FLEXIO_PARAM_TRIGGER_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_CTRL - FlexIO Control Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_CTRL - FlexIO Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_CTRL register
 */
/*@{*/
#define FLEXIO_RD_CTRL(base)     (FLEXIO_CTRL_REG(base))
#define FLEXIO_WR_CTRL(base, value) (FLEXIO_CTRL_REG(base) = (value))
#define FLEXIO_RMW_CTRL(base, mask, value) (FLEXIO_WR_CTRL(base, (FLEXIO_RD_CTRL(base) & ~(mask)) | (value)))
#define FLEXIO_SET_CTRL(base, value) (BME_OR32(&FLEXIO_CTRL_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_CTRL(base, value) (BME_AND32(&FLEXIO_CTRL_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_CTRL(base, value) (BME_XOR32(&FLEXIO_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_CTRL bitfields
 */

/*!
 * @name Register FLEXIO_CTRL, field FLEXEN[0] (RW)
 *
 * Values:
 * - 0b0 - FlexIO module is disabled.
 * - 0b1 - FlexIO module is enabled.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_FLEXEN field. */
#define FLEXIO_RD_CTRL_FLEXEN(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_FLEXEN_MASK) >> FLEXIO_CTRL_FLEXEN_SHIFT)
#define FLEXIO_BRD_CTRL_FLEXEN(base) (BME_UBFX32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FLEXEN_SHIFT, FLEXIO_CTRL_FLEXEN_WIDTH))

/*! @brief Set the FLEXEN field to a new value. */
#define FLEXIO_WR_CTRL_FLEXEN(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_FLEXEN_MASK, FLEXIO_CTRL_FLEXEN(value)))
#define FLEXIO_BWR_CTRL_FLEXEN(base, value) (BME_BFI32(&FLEXIO_CTRL_REG(base), ((uint32_t)(value) << FLEXIO_CTRL_FLEXEN_SHIFT), FLEXIO_CTRL_FLEXEN_SHIFT, FLEXIO_CTRL_FLEXEN_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field SWRST[1] (RW)
 *
 * The FlexIO Control Register is not affected by the software reset, all other
 * logic in the FlexIO is affected by the software reset and register accesses
 * are ignored until this bit is cleared. This register bit will remain set until
 * cleared by software, and the reset has cleared in the FlexIO clock domain.
 *
 * Values:
 * - 0b0 - Software reset is disabled
 * - 0b1 - Software reset is enabled, all FlexIO registers except the Control
 *     Register are reset.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_SWRST field. */
#define FLEXIO_RD_CTRL_SWRST(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_SWRST_MASK) >> FLEXIO_CTRL_SWRST_SHIFT)
#define FLEXIO_BRD_CTRL_SWRST(base) (BME_UBFX32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_SWRST_SHIFT, FLEXIO_CTRL_SWRST_WIDTH))

/*! @brief Set the SWRST field to a new value. */
#define FLEXIO_WR_CTRL_SWRST(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_SWRST_MASK, FLEXIO_CTRL_SWRST(value)))
#define FLEXIO_BWR_CTRL_SWRST(base, value) (BME_BFI32(&FLEXIO_CTRL_REG(base), ((uint32_t)(value) << FLEXIO_CTRL_SWRST_SHIFT), FLEXIO_CTRL_SWRST_SHIFT, FLEXIO_CTRL_SWRST_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field FASTACC[2] (RW)
 *
 * Enables fast register accesses to FlexIO registers, but requires the FlexIO
 * clock to be at least twice the frequency of the bus clock.
 *
 * Values:
 * - 0b0 - Configures for normal register accesses to FlexIO
 * - 0b1 - Configures for fast register accesses to FlexIO
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_FASTACC field. */
#define FLEXIO_RD_CTRL_FASTACC(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_FASTACC_MASK) >> FLEXIO_CTRL_FASTACC_SHIFT)
#define FLEXIO_BRD_CTRL_FASTACC(base) (BME_UBFX32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FASTACC_SHIFT, FLEXIO_CTRL_FASTACC_WIDTH))

/*! @brief Set the FASTACC field to a new value. */
#define FLEXIO_WR_CTRL_FASTACC(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_FASTACC_MASK, FLEXIO_CTRL_FASTACC(value)))
#define FLEXIO_BWR_CTRL_FASTACC(base, value) (BME_BFI32(&FLEXIO_CTRL_REG(base), ((uint32_t)(value) << FLEXIO_CTRL_FASTACC_SHIFT), FLEXIO_CTRL_FASTACC_SHIFT, FLEXIO_CTRL_FASTACC_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DBGE[30] (RW)
 *
 * Enables FlexIO operation in Debug mode.
 *
 * Values:
 * - 0b0 - FlexIO is disabled in debug modes.
 * - 0b1 - FlexIO is enabled in debug modes
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_DBGE field. */
#define FLEXIO_RD_CTRL_DBGE(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_DBGE_MASK) >> FLEXIO_CTRL_DBGE_SHIFT)
#define FLEXIO_BRD_CTRL_DBGE(base) (BME_UBFX32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DBGE_SHIFT, FLEXIO_CTRL_DBGE_WIDTH))

/*! @brief Set the DBGE field to a new value. */
#define FLEXIO_WR_CTRL_DBGE(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_DBGE_MASK, FLEXIO_CTRL_DBGE(value)))
#define FLEXIO_BWR_CTRL_DBGE(base, value) (BME_BFI32(&FLEXIO_CTRL_REG(base), ((uint32_t)(value) << FLEXIO_CTRL_DBGE_SHIFT), FLEXIO_CTRL_DBGE_SHIFT, FLEXIO_CTRL_DBGE_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DOZEN[31] (RW)
 *
 * Disables FlexIO operation in Doze modes. This field is ignored and the FlexIO
 * always disabled in low-leakage stop modes.
 *
 * Values:
 * - 0b0 - FlexIO enabled in Doze modes.
 * - 0b1 - FlexIO disabled in Doze modes.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_DOZEN field. */
#define FLEXIO_RD_CTRL_DOZEN(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_DOZEN_MASK) >> FLEXIO_CTRL_DOZEN_SHIFT)
#define FLEXIO_BRD_CTRL_DOZEN(base) (BME_UBFX32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DOZEN_SHIFT, FLEXIO_CTRL_DOZEN_WIDTH))

/*! @brief Set the DOZEN field to a new value. */
#define FLEXIO_WR_CTRL_DOZEN(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_DOZEN_MASK, FLEXIO_CTRL_DOZEN(value)))
#define FLEXIO_BWR_CTRL_DOZEN(base, value) (BME_BFI32(&FLEXIO_CTRL_REG(base), ((uint32_t)(value) << FLEXIO_CTRL_DOZEN_SHIFT), FLEXIO_CTRL_DOZEN_SHIFT, FLEXIO_CTRL_DOZEN_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_PIN - Pin State Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_PIN - Pin State Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FLEXIO_PIN register
 */
/*@{*/
#define FLEXIO_RD_PIN(base)      (FLEXIO_PIN_REG(base))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSTAT - Shifter Status Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSTAT - Shifter Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSTAT register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSTAT(base) (FLEXIO_SHIFTSTAT_REG(base))
#define FLEXIO_WR_SHIFTSTAT(base, value) (FLEXIO_SHIFTSTAT_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSTAT(base, mask, value) (FLEXIO_WR_SHIFTSTAT(base, (FLEXIO_RD_SHIFTSTAT(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSTAT(base, value) (BME_OR32(&FLEXIO_SHIFTSTAT_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTSTAT(base, value) (BME_AND32(&FLEXIO_SHIFTSTAT_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTSTAT(base, value) (BME_XOR32(&FLEXIO_SHIFTSTAT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSTAT bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSTAT, field SSF[7:0] (W1C)
 *
 * The shifter status flag is updated when one of the following events occurs:
 * For SMOD=Receive, the status flag is set when SHIFTBUF has been loaded with
 * data from Shifter (SHIFTBUF is full), and the status flag is cleared when
 * SHIFTBUF register is read. For SMOD=Transmit, the status flag is set when SHIFTBUF
 * data has been transferred to the Shifter (SHIFTBUF is empty) or when initially
 * configured for SMOD=Transmit, and the status flag is cleared when the SHIFTBUF
 * register is written. For SMOD=Match Store, the status flag is set when a match
 * has occured between SHIFTBUF and Shifter, and the status flag is cleared when
 * the SHIFTBUF register is read. For SMOD=Match Continuous, returns the current
 * match result between the SHIFTBUF and Shifter. For SMOD=State, the status
 * flag for a shifter will set when it is selected by the current state pointer. For
 * SMOD=Logic, returns the current value of the programmable logic block output.
 * The status flag can also be cleared by writing a logic one to the flag for
 * all modes except Match Continuous/State /Logic.
 *
 * Values:
 * - 0b00000000 - Status flag is clear
 * - 0b00000001 - Status flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSTAT_SSF field. */
#define FLEXIO_RD_SHIFTSTAT_SSF(base) ((FLEXIO_SHIFTSTAT_REG(base) & FLEXIO_SHIFTSTAT_SSF_MASK) >> FLEXIO_SHIFTSTAT_SSF_SHIFT)
#define FLEXIO_BRD_SHIFTSTAT_SSF(base) (BME_UBFX32(&FLEXIO_SHIFTSTAT_REG(base), FLEXIO_SHIFTSTAT_SSF_SHIFT, FLEXIO_SHIFTSTAT_SSF_WIDTH))

/*! @brief Set the SSF field to a new value. */
#define FLEXIO_WR_SHIFTSTAT_SSF(base, value) (FLEXIO_RMW_SHIFTSTAT(base, FLEXIO_SHIFTSTAT_SSF_MASK, FLEXIO_SHIFTSTAT_SSF(value)))
#define FLEXIO_BWR_SHIFTSTAT_SSF(base, value) (BME_BFI32(&FLEXIO_SHIFTSTAT_REG(base), ((uint32_t)(value) << FLEXIO_SHIFTSTAT_SSF_SHIFT), FLEXIO_SHIFTSTAT_SSF_SHIFT, FLEXIO_SHIFTSTAT_SSF_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTERR - Shifter Error Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTERR - Shifter Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTERR register
 */
/*@{*/
#define FLEXIO_RD_SHIFTERR(base) (FLEXIO_SHIFTERR_REG(base))
#define FLEXIO_WR_SHIFTERR(base, value) (FLEXIO_SHIFTERR_REG(base) = (value))
#define FLEXIO_RMW_SHIFTERR(base, mask, value) (FLEXIO_WR_SHIFTERR(base, (FLEXIO_RD_SHIFTERR(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTERR(base, value) (BME_OR32(&FLEXIO_SHIFTERR_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTERR(base, value) (BME_AND32(&FLEXIO_SHIFTERR_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTERR(base, value) (BME_XOR32(&FLEXIO_SHIFTERR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTERR bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTERR, field SEF[7:0] (W1C)
 *
 * The shifter error flag is set when one of the following events occurs: For
 * SMOD=Receive, indicates Shifter was ready to store new data into SHIFTBUF before
 * the previous data was read from SHIFTBUF (SHIFTBUF Overrun), or indicates
 * that the received start or stop bit does not match the expected value. For
 * SMOD=Transmit, indicates Shifter was ready to load new data from SHIFTBUF before new
 * data had been written into SHIFTBUF (SHIFTBUF Underrun). For SMOD=Match
 * Store, indicates a match event occured before the previous match data was read from
 * SHIFTBUF (SHIFTBUF Overrun). For SMOD=Match Continuous, the error flag is set
 * when a match has occured between SHIFTBUF and Shifter. For SMOD=Logic, the
 * error flag is set when the output of the programmable logic block has asserted.
 * Can be cleared by writing logic one to the flag. For SMOD=Match Continuous,
 * can also be cleared when the SHIFTBUF register is read.
 *
 * Values:
 * - 0b00000000 - Shifter Error Flag is clear
 * - 0b00000001 - Shifter Error Flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTERR_SEF field. */
#define FLEXIO_RD_SHIFTERR_SEF(base) ((FLEXIO_SHIFTERR_REG(base) & FLEXIO_SHIFTERR_SEF_MASK) >> FLEXIO_SHIFTERR_SEF_SHIFT)
#define FLEXIO_BRD_SHIFTERR_SEF(base) (BME_UBFX32(&FLEXIO_SHIFTERR_REG(base), FLEXIO_SHIFTERR_SEF_SHIFT, FLEXIO_SHIFTERR_SEF_WIDTH))

/*! @brief Set the SEF field to a new value. */
#define FLEXIO_WR_SHIFTERR_SEF(base, value) (FLEXIO_RMW_SHIFTERR(base, FLEXIO_SHIFTERR_SEF_MASK, FLEXIO_SHIFTERR_SEF(value)))
#define FLEXIO_BWR_SHIFTERR_SEF(base, value) (BME_BFI32(&FLEXIO_SHIFTERR_REG(base), ((uint32_t)(value) << FLEXIO_SHIFTERR_SEF_SHIFT), FLEXIO_SHIFTERR_SEF_SHIFT, FLEXIO_SHIFTERR_SEF_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMSTAT - Timer Status Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMSTAT - Timer Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMSTAT register
 */
/*@{*/
#define FLEXIO_RD_TIMSTAT(base)  (FLEXIO_TIMSTAT_REG(base))
#define FLEXIO_WR_TIMSTAT(base, value) (FLEXIO_TIMSTAT_REG(base) = (value))
#define FLEXIO_RMW_TIMSTAT(base, mask, value) (FLEXIO_WR_TIMSTAT(base, (FLEXIO_RD_TIMSTAT(base) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMSTAT(base, value) (BME_OR32(&FLEXIO_TIMSTAT_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_TIMSTAT(base, value) (BME_AND32(&FLEXIO_TIMSTAT_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_TIMSTAT(base, value) (BME_XOR32(&FLEXIO_TIMSTAT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMSTAT bitfields
 */

/*!
 * @name Register FLEXIO_TIMSTAT, field TSF[7:0] (W1C)
 *
 * The timer status flag sets depending on the timer mode, and can be cleared by
 * writing logic one to the flag. In 8-bit counter mode, the timer status flag
 * is set when the upper 8-bit counter equals zero and decrements, this also
 * causes the counter to reload with the value in the compare register. In 8-bit PWM
 * mode, the timer status flag is set when the upper 8-bit counter equals zero and
 * decrements, this also causes the counter to reload with the value in the
 * compare register.. In 16-bit counter mode, the timer status flag is set when the
 * 16-bit counter equals zero and decrements, this also causes the counter to
 * reload with the value in the compare register..
 *
 * Values:
 * - 0b00000000 - Timer Status Flag is clear
 * - 0b00000001 - Timer Status Flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMSTAT_TSF field. */
#define FLEXIO_RD_TIMSTAT_TSF(base) ((FLEXIO_TIMSTAT_REG(base) & FLEXIO_TIMSTAT_TSF_MASK) >> FLEXIO_TIMSTAT_TSF_SHIFT)
#define FLEXIO_BRD_TIMSTAT_TSF(base) (BME_UBFX32(&FLEXIO_TIMSTAT_REG(base), FLEXIO_TIMSTAT_TSF_SHIFT, FLEXIO_TIMSTAT_TSF_WIDTH))

/*! @brief Set the TSF field to a new value. */
#define FLEXIO_WR_TIMSTAT_TSF(base, value) (FLEXIO_RMW_TIMSTAT(base, FLEXIO_TIMSTAT_TSF_MASK, FLEXIO_TIMSTAT_TSF(value)))
#define FLEXIO_BWR_TIMSTAT_TSF(base, value) (BME_BFI32(&FLEXIO_TIMSTAT_REG(base), ((uint32_t)(value) << FLEXIO_TIMSTAT_TSF_SHIFT), FLEXIO_TIMSTAT_TSF_SHIFT, FLEXIO_TIMSTAT_TSF_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSIEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSIEN(base) (FLEXIO_SHIFTSIEN_REG(base))
#define FLEXIO_WR_SHIFTSIEN(base, value) (FLEXIO_SHIFTSIEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSIEN(base, mask, value) (FLEXIO_WR_SHIFTSIEN(base, (FLEXIO_RD_SHIFTSIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSIEN(base, value) (BME_OR32(&FLEXIO_SHIFTSIEN_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTSIEN(base, value) (BME_AND32(&FLEXIO_SHIFTSIEN_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTSIEN(base, value) (BME_XOR32(&FLEXIO_SHIFTSIEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSIEN, field SSIE[7:0] (RW)
 *
 * Enables interrupt generation when corresponding SSF is set.
 *
 * Values:
 * - 0b00000000 - Shifter Status Flag interrupt disabled
 * - 0b00000001 - Shifter Status Flag interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSIEN_SSIE field. */
#define FLEXIO_RD_SHIFTSIEN_SSIE(base) ((FLEXIO_SHIFTSIEN_REG(base) & FLEXIO_SHIFTSIEN_SSIE_MASK) >> FLEXIO_SHIFTSIEN_SSIE_SHIFT)
#define FLEXIO_BRD_SHIFTSIEN_SSIE(base) (BME_UBFX32(&FLEXIO_SHIFTSIEN_REG(base), FLEXIO_SHIFTSIEN_SSIE_SHIFT, FLEXIO_SHIFTSIEN_SSIE_WIDTH))

/*! @brief Set the SSIE field to a new value. */
#define FLEXIO_WR_SHIFTSIEN_SSIE(base, value) (FLEXIO_RMW_SHIFTSIEN(base, FLEXIO_SHIFTSIEN_SSIE_MASK, FLEXIO_SHIFTSIEN_SSIE(value)))
#define FLEXIO_BWR_SHIFTSIEN_SSIE(base, value) (BME_BFI32(&FLEXIO_SHIFTSIEN_REG(base), ((uint32_t)(value) << FLEXIO_SHIFTSIEN_SSIE_SHIFT), FLEXIO_SHIFTSIEN_SSIE_SHIFT, FLEXIO_SHIFTSIEN_SSIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTEIEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTEIEN(base) (FLEXIO_SHIFTEIEN_REG(base))
#define FLEXIO_WR_SHIFTEIEN(base, value) (FLEXIO_SHIFTEIEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTEIEN(base, mask, value) (FLEXIO_WR_SHIFTEIEN(base, (FLEXIO_RD_SHIFTEIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTEIEN(base, value) (BME_OR32(&FLEXIO_SHIFTEIEN_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTEIEN(base, value) (BME_AND32(&FLEXIO_SHIFTEIEN_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTEIEN(base, value) (BME_XOR32(&FLEXIO_SHIFTEIEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTEIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTEIEN, field SEIE[7:0] (RW)
 *
 * Enables interrupt generation when corresponding SEF is set.
 *
 * Values:
 * - 0b00000000 - Shifter Error Flag interrupt disabled
 * - 0b00000001 - Shifter Error Flag interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTEIEN_SEIE field. */
#define FLEXIO_RD_SHIFTEIEN_SEIE(base) ((FLEXIO_SHIFTEIEN_REG(base) & FLEXIO_SHIFTEIEN_SEIE_MASK) >> FLEXIO_SHIFTEIEN_SEIE_SHIFT)
#define FLEXIO_BRD_SHIFTEIEN_SEIE(base) (BME_UBFX32(&FLEXIO_SHIFTEIEN_REG(base), FLEXIO_SHIFTEIEN_SEIE_SHIFT, FLEXIO_SHIFTEIEN_SEIE_WIDTH))

/*! @brief Set the SEIE field to a new value. */
#define FLEXIO_WR_SHIFTEIEN_SEIE(base, value) (FLEXIO_RMW_SHIFTEIEN(base, FLEXIO_SHIFTEIEN_SEIE_MASK, FLEXIO_SHIFTEIEN_SEIE(value)))
#define FLEXIO_BWR_SHIFTEIEN_SEIE(base, value) (BME_BFI32(&FLEXIO_SHIFTEIEN_REG(base), ((uint32_t)(value) << FLEXIO_SHIFTEIEN_SEIE_SHIFT), FLEXIO_SHIFTEIEN_SEIE_SHIFT, FLEXIO_SHIFTEIEN_SEIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMIEN - Timer Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMIEN - Timer Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMIEN register
 */
/*@{*/
#define FLEXIO_RD_TIMIEN(base)   (FLEXIO_TIMIEN_REG(base))
#define FLEXIO_WR_TIMIEN(base, value) (FLEXIO_TIMIEN_REG(base) = (value))
#define FLEXIO_RMW_TIMIEN(base, mask, value) (FLEXIO_WR_TIMIEN(base, (FLEXIO_RD_TIMIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMIEN(base, value) (BME_OR32(&FLEXIO_TIMIEN_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_TIMIEN(base, value) (BME_AND32(&FLEXIO_TIMIEN_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_TIMIEN(base, value) (BME_XOR32(&FLEXIO_TIMIEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMIEN bitfields
 */

/*!
 * @name Register FLEXIO_TIMIEN, field TEIE[7:0] (RW)
 *
 * Enables interrupt generation when corresponding TSF is set.
 *
 * Values:
 * - 0b00000000 - Timer Status Flag interrupt is disabled
 * - 0b00000001 - Timer Status Flag interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMIEN_TEIE field. */
#define FLEXIO_RD_TIMIEN_TEIE(base) ((FLEXIO_TIMIEN_REG(base) & FLEXIO_TIMIEN_TEIE_MASK) >> FLEXIO_TIMIEN_TEIE_SHIFT)
#define FLEXIO_BRD_TIMIEN_TEIE(base) (BME_UBFX32(&FLEXIO_TIMIEN_REG(base), FLEXIO_TIMIEN_TEIE_SHIFT, FLEXIO_TIMIEN_TEIE_WIDTH))

/*! @brief Set the TEIE field to a new value. */
#define FLEXIO_WR_TIMIEN_TEIE(base, value) (FLEXIO_RMW_TIMIEN(base, FLEXIO_TIMIEN_TEIE_MASK, FLEXIO_TIMIEN_TEIE(value)))
#define FLEXIO_BWR_TIMIEN_TEIE(base, value) (BME_BFI32(&FLEXIO_TIMIEN_REG(base), ((uint32_t)(value) << FLEXIO_TIMIEN_TEIE_SHIFT), FLEXIO_TIMIEN_TEIE_SHIFT, FLEXIO_TIMIEN_TEIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSDEN - Shifter Status DMA Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSDEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSDEN(base) (FLEXIO_SHIFTSDEN_REG(base))
#define FLEXIO_WR_SHIFTSDEN(base, value) (FLEXIO_SHIFTSDEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSDEN(base, mask, value) (FLEXIO_WR_SHIFTSDEN(base, (FLEXIO_RD_SHIFTSDEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSDEN(base, value) (BME_OR32(&FLEXIO_SHIFTSDEN_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTSDEN(base, value) (BME_AND32(&FLEXIO_SHIFTSDEN_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTSDEN(base, value) (BME_XOR32(&FLEXIO_SHIFTSDEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSDEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSDEN, field SSDE[7:0] (RW)
 *
 * Enables DMA request generation when corresponding SSF is set.
 *
 * Values:
 * - 0b00000000 - Shifter Status Flag DMA request is disabled
 * - 0b00000001 - Shifter Status Flag DMA request is enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSDEN_SSDE field. */
#define FLEXIO_RD_SHIFTSDEN_SSDE(base) ((FLEXIO_SHIFTSDEN_REG(base) & FLEXIO_SHIFTSDEN_SSDE_MASK) >> FLEXIO_SHIFTSDEN_SSDE_SHIFT)
#define FLEXIO_BRD_SHIFTSDEN_SSDE(base) (BME_UBFX32(&FLEXIO_SHIFTSDEN_REG(base), FLEXIO_SHIFTSDEN_SSDE_SHIFT, FLEXIO_SHIFTSDEN_SSDE_WIDTH))

/*! @brief Set the SSDE field to a new value. */
#define FLEXIO_WR_SHIFTSDEN_SSDE(base, value) (FLEXIO_RMW_SHIFTSDEN(base, FLEXIO_SHIFTSDEN_SSDE_MASK, FLEXIO_SHIFTSDEN_SSDE(value)))
#define FLEXIO_BWR_SHIFTSDEN_SSDE(base, value) (BME_BFI32(&FLEXIO_SHIFTSDEN_REG(base), ((uint32_t)(value) << FLEXIO_SHIFTSDEN_SSDE_SHIFT), FLEXIO_SHIFTSDEN_SSDE_SHIFT, FLEXIO_SHIFTSDEN_SSDE_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSTATE - Shifter State Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSTATE - Shifter State Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSTATE register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSTATE(base) (FLEXIO_SHIFTSTATE_REG(base))
#define FLEXIO_WR_SHIFTSTATE(base, value) (FLEXIO_SHIFTSTATE_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSTATE(base, mask, value) (FLEXIO_WR_SHIFTSTATE(base, (FLEXIO_RD_SHIFTSTATE(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSTATE(base, value) (BME_OR32(&FLEXIO_SHIFTSTATE_REG(base), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTSTATE(base, value) (BME_AND32(&FLEXIO_SHIFTSTATE_REG(base), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTSTATE(base, value) (BME_XOR32(&FLEXIO_SHIFTSTATE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSTATE bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSTATE, field STATE[2:0] (RW)
 *
 * The current state field maintains a pointer to keep track of the current
 * Shifter (configured for State mode) enabled to drive outputs and compute the next
 * state. See 'State Mode' section for more detail.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSTATE_STATE field. */
#define FLEXIO_RD_SHIFTSTATE_STATE(base) ((FLEXIO_SHIFTSTATE_REG(base) & FLEXIO_SHIFTSTATE_STATE_MASK) >> FLEXIO_SHIFTSTATE_STATE_SHIFT)
#define FLEXIO_BRD_SHIFTSTATE_STATE(base) (BME_UBFX32(&FLEXIO_SHIFTSTATE_REG(base), FLEXIO_SHIFTSTATE_STATE_SHIFT, FLEXIO_SHIFTSTATE_STATE_WIDTH))

/*! @brief Set the STATE field to a new value. */
#define FLEXIO_WR_SHIFTSTATE_STATE(base, value) (FLEXIO_RMW_SHIFTSTATE(base, FLEXIO_SHIFTSTATE_STATE_MASK, FLEXIO_SHIFTSTATE_STATE(value)))
#define FLEXIO_BWR_SHIFTSTATE_STATE(base, value) (BME_BFI32(&FLEXIO_SHIFTSTATE_REG(base), ((uint32_t)(value) << FLEXIO_SHIFTSTATE_STATE_SHIFT), FLEXIO_SHIFTSTATE_STATE_SHIFT, FLEXIO_SHIFTSTATE_STATE_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTCTL - Shifter Control N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTCTL - Shifter Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCTL register
 */
/*@{*/
#define FLEXIO_RD_SHIFTCTL(base, index) (FLEXIO_SHIFTCTL_REG(base, index))
#define FLEXIO_WR_SHIFTCTL(base, index, value) (FLEXIO_SHIFTCTL_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTCTL(base, index, mask, value) (FLEXIO_WR_SHIFTCTL(base, index, (FLEXIO_RD_SHIFTCTL(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTCTL(base, index, value) (BME_OR32(&FLEXIO_SHIFTCTL_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTCTL(base, index, value) (BME_AND32(&FLEXIO_SHIFTCTL_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTCTL(base, index, value) (BME_XOR32(&FLEXIO_SHIFTCTL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCTL bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCTL, field SMOD[2:0] (RW)
 *
 * Configures the mode of the Shifter.
 *
 * Values:
 * - 0b000 - Disabled.
 * - 0b001 - Receive mode. Captures the current Shifter content into the
 *     SHIFTBUF on expiration of the Timer.
 * - 0b010 - Transmit mode. Load SHIFTBUF contents into the Shifter on
 *     expiration of the Timer.
 * - 0b011 - Reserved.
 * - 0b100 - Match Store mode. Shifter data is compared to SHIFTBUF content on
 *     expiration of the Timer.
 * - 0b101 - Match Continuous mode. Shifter data is continuously compared to
 *     SHIFTBUF contents.
 * - 0b110 - State mode. SHIFTBUF contents are used for storing programmable
 *     state attributes.
 * - 0b111 - Logic mode. SHIFTBUF contents are used for implementing
 *     programmable logic look up table.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_SMOD field. */
#define FLEXIO_RD_SHIFTCTL_SMOD(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_SMOD_MASK) >> FLEXIO_SHIFTCTL_SMOD_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_SMOD(base, index) (BME_UBFX32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_SMOD_SHIFT, FLEXIO_SHIFTCTL_SMOD_WIDTH))

/*! @brief Set the SMOD field to a new value. */
#define FLEXIO_WR_SHIFTCTL_SMOD(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_SMOD_MASK, FLEXIO_SHIFTCTL_SMOD(value)))
#define FLEXIO_BWR_SHIFTCTL_SMOD(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCTL_SMOD_SHIFT), FLEXIO_SHIFTCTL_SMOD_SHIFT, FLEXIO_SHIFTCTL_SMOD_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINPOL[7] (RW)
 *
 * Values:
 * - 0b0 - Pin is active high
 * - 0b1 - Pin is active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINPOL field. */
#define FLEXIO_RD_SHIFTCTL_PINPOL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINPOL_MASK) >> FLEXIO_SHIFTCTL_PINPOL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINPOL(base, index) (BME_UBFX32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_PINPOL_SHIFT, FLEXIO_SHIFTCTL_PINPOL_WIDTH))

/*! @brief Set the PINPOL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINPOL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINPOL_MASK, FLEXIO_SHIFTCTL_PINPOL(value)))
#define FLEXIO_BWR_SHIFTCTL_PINPOL(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCTL_PINPOL_SHIFT), FLEXIO_SHIFTCTL_PINPOL_SHIFT, FLEXIO_SHIFTCTL_PINPOL_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINSEL[12:8] (RW)
 *
 * Selects which pin is used by the Shifter input or output.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINSEL field. */
#define FLEXIO_RD_SHIFTCTL_PINSEL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINSEL_MASK) >> FLEXIO_SHIFTCTL_PINSEL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINSEL(base, index) (BME_UBFX32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_PINSEL_SHIFT, FLEXIO_SHIFTCTL_PINSEL_WIDTH))

/*! @brief Set the PINSEL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINSEL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINSEL_MASK, FLEXIO_SHIFTCTL_PINSEL(value)))
#define FLEXIO_BWR_SHIFTCTL_PINSEL(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCTL_PINSEL_SHIFT), FLEXIO_SHIFTCTL_PINSEL_SHIFT, FLEXIO_SHIFTCTL_PINSEL_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 0b00 - Shifter pin output disabled
 * - 0b01 - Shifter pin open drain or bidirectional output enable
 * - 0b10 - Shifter pin bidirectional output data
 * - 0b11 - Shifter pin output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINCFG field. */
#define FLEXIO_RD_SHIFTCTL_PINCFG(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINCFG_MASK) >> FLEXIO_SHIFTCTL_PINCFG_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINCFG(base, index) (BME_UBFX32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_PINCFG_SHIFT, FLEXIO_SHIFTCTL_PINCFG_WIDTH))

/*! @brief Set the PINCFG field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINCFG(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINCFG_MASK, FLEXIO_SHIFTCTL_PINCFG(value)))
#define FLEXIO_BWR_SHIFTCTL_PINCFG(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCTL_PINCFG_SHIFT), FLEXIO_SHIFTCTL_PINCFG_SHIFT, FLEXIO_SHIFTCTL_PINCFG_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field TIMPOL[23] (RW)
 *
 * Values:
 * - 0b0 - Shift on posedge of Shift clock
 * - 0b1 - Shift on negedge of Shift clock
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_TIMPOL field. */
#define FLEXIO_RD_SHIFTCTL_TIMPOL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_TIMPOL_MASK) >> FLEXIO_SHIFTCTL_TIMPOL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_TIMPOL(base, index) (BME_UBFX32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_TIMPOL_SHIFT, FLEXIO_SHIFTCTL_TIMPOL_WIDTH))

/*! @brief Set the TIMPOL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_TIMPOL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_TIMPOL_MASK, FLEXIO_SHIFTCTL_TIMPOL(value)))
#define FLEXIO_BWR_SHIFTCTL_TIMPOL(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCTL_TIMPOL_SHIFT), FLEXIO_SHIFTCTL_TIMPOL_SHIFT, FLEXIO_SHIFTCTL_TIMPOL_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field TIMSEL[26:24] (RW)
 *
 * Selects which Timer is used for controlling the logic/shift register and
 * generating the Shift clock.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_TIMSEL field. */
#define FLEXIO_RD_SHIFTCTL_TIMSEL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_TIMSEL_MASK) >> FLEXIO_SHIFTCTL_TIMSEL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_TIMSEL(base, index) (BME_UBFX32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_TIMSEL_SHIFT, FLEXIO_SHIFTCTL_TIMSEL_WIDTH))

/*! @brief Set the TIMSEL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_TIMSEL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_TIMSEL_MASK, FLEXIO_SHIFTCTL_TIMSEL(value)))
#define FLEXIO_BWR_SHIFTCTL_TIMSEL(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCTL_TIMSEL_SHIFT), FLEXIO_SHIFTCTL_TIMSEL_SHIFT, FLEXIO_SHIFTCTL_TIMSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTCFG - Shifter Configuration N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTCFG - Shifter Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCFG register
 */
/*@{*/
#define FLEXIO_RD_SHIFTCFG(base, index) (FLEXIO_SHIFTCFG_REG(base, index))
#define FLEXIO_WR_SHIFTCFG(base, index, value) (FLEXIO_SHIFTCFG_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTCFG(base, index, mask, value) (FLEXIO_WR_SHIFTCFG(base, index, (FLEXIO_RD_SHIFTCFG(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTCFG(base, index, value) (BME_OR32(&FLEXIO_SHIFTCFG_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTCFG(base, index, value) (BME_AND32(&FLEXIO_SHIFTCFG_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTCFG(base, index, value) (BME_XOR32(&FLEXIO_SHIFTCFG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCFG bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCFG, field SSTART[1:0] (RW)
 *
 * For SMOD=Transmit, this field allows automatic start bit insertion if the
 * selected timer has also enabled a start bit. For SMOD=Receive or Match Store,
 * this field allows automatic start bit checking if the selected timer has also
 * enabled a start bit. For SMOD=State, this field is used to disable state outputs.
 * See 'State Mode' section for more detail. For SMOD=Logic, this field is used
 * to mask logic pin inputs. See 'Logic Mode' section for more detail.
 *
 * Values:
 * - 0b00 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on enable
 * - 0b01 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on first shift
 * - 0b10 - Transmitter outputs start bit value 0 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 0
 * - 0b11 - Transmitter outputs start bit value 1 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 1
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_SSTART field. */
#define FLEXIO_RD_SHIFTCFG_SSTART(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_SSTART_MASK) >> FLEXIO_SHIFTCFG_SSTART_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_SSTART(base, index) (BME_UBFX32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_SSTART_SHIFT, FLEXIO_SHIFTCFG_SSTART_WIDTH))

/*! @brief Set the SSTART field to a new value. */
#define FLEXIO_WR_SHIFTCFG_SSTART(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_SSTART_MASK, FLEXIO_SHIFTCFG_SSTART(value)))
#define FLEXIO_BWR_SHIFTCFG_SSTART(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCFG_SSTART_SHIFT), FLEXIO_SHIFTCFG_SSTART_SHIFT, FLEXIO_SHIFTCFG_SSTART_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field SSTOP[5:4] (RW)
 *
 * For SMOD=Transmit, this field allows automatic stop bit insertion if the
 * selected timer has also enabled a stop bit. For SMOD=Receive or Match Store, this
 * field allows automatic stop bit checking if the selected timer has also
 * enabled a stop bit. For SMOD=State, this field is used to disable state outputs. See
 * 'State Mode' section for more detail. For SMOD=Logic, this field is used to
 * mask logic pin inputs. See 'Logic Mode' section for more detail.
 *
 * Values:
 * - 0b00 - Stop bit disabled for transmitter/receiver/match store
 * - 0b01 - Reserved for transmitter/receiver/match store
 * - 0b10 - Transmitter outputs stop bit value 0 on store, receiver/match store
 *     sets error flag if stop bit is not 0
 * - 0b11 - Transmitter outputs stop bit value 1 on store, receiver/match store
 *     sets error flag if stop bit is not 1
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_SSTOP field. */
#define FLEXIO_RD_SHIFTCFG_SSTOP(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_SSTOP_MASK) >> FLEXIO_SHIFTCFG_SSTOP_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_SSTOP(base, index) (BME_UBFX32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_SSTOP_SHIFT, FLEXIO_SHIFTCFG_SSTOP_WIDTH))

/*! @brief Set the SSTOP field to a new value. */
#define FLEXIO_WR_SHIFTCFG_SSTOP(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_SSTOP_MASK, FLEXIO_SHIFTCFG_SSTOP(value)))
#define FLEXIO_BWR_SHIFTCFG_SSTOP(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCFG_SSTOP_SHIFT), FLEXIO_SHIFTCFG_SSTOP_SHIFT, FLEXIO_SHIFTCFG_SSTOP_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field INSRC[8] (RW)
 *
 * Selects the input source for the shifter.
 *
 * Values:
 * - 0b0 - Pin
 * - 0b1 - Shifter N+1 Output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_INSRC field. */
#define FLEXIO_RD_SHIFTCFG_INSRC(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_INSRC_MASK) >> FLEXIO_SHIFTCFG_INSRC_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_INSRC(base, index) (BME_UBFX32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_INSRC_SHIFT, FLEXIO_SHIFTCFG_INSRC_WIDTH))

/*! @brief Set the INSRC field to a new value. */
#define FLEXIO_WR_SHIFTCFG_INSRC(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_INSRC_MASK, FLEXIO_SHIFTCFG_INSRC(value)))
#define FLEXIO_BWR_SHIFTCFG_INSRC(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCFG_INSRC_SHIFT), FLEXIO_SHIFTCFG_INSRC_SHIFT, FLEXIO_SHIFTCFG_INSRC_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field PWIDTH[20:16] (RW)
 *
 * For all Shifters, this register field configures the number of bits to be
 * shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4-bit shift for
 * PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift for PWIDTH=8...15
 * 32-bit shift for PWIDTH=16...31 For Shifters which support parallel transmit
 * (SHIFTER0, SHIFTER4) or parallel receive (SHIFTER3, SHIFTER7), this register field,
 * together with PSEL, also selects the pins to be driven or sampled on each
 * Shift clock as follows: FXIO_D[PSEL+PWIDTH]:FXIO_D[PSEL] For SMOD=State, this
 * field is used to disable state outputs. See 'State Mode' section for more detail.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_PWIDTH field. */
#define FLEXIO_RD_SHIFTCFG_PWIDTH(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_PWIDTH_MASK) >> FLEXIO_SHIFTCFG_PWIDTH_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_PWIDTH(base, index) (BME_UBFX32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_PWIDTH_SHIFT, FLEXIO_SHIFTCFG_PWIDTH_WIDTH))

/*! @brief Set the PWIDTH field to a new value. */
#define FLEXIO_WR_SHIFTCFG_PWIDTH(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_PWIDTH_MASK, FLEXIO_SHIFTCFG_PWIDTH(value)))
#define FLEXIO_BWR_SHIFTCFG_PWIDTH(base, index, value) (BME_BFI32(&FLEXIO_SHIFTCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_SHIFTCFG_PWIDTH_SHIFT), FLEXIO_SHIFTCFG_PWIDTH_SHIFT, FLEXIO_SHIFTCFG_PWIDTH_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUF - Shifter Buffer N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUF - Shifter Buffer N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUF register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUF(base, index) (FLEXIO_SHIFTBUF_REG(base, index))
#define FLEXIO_WR_SHIFTBUF(base, index, value) (FLEXIO_SHIFTBUF_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUF(base, index, mask, value) (FLEXIO_WR_SHIFTBUF(base, index, (FLEXIO_RD_SHIFTBUF(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUF(base, index, value) (BME_OR32(&FLEXIO_SHIFTBUF_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTBUF(base, index, value) (BME_AND32(&FLEXIO_SHIFTBUF_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTBUF(base, index, value) (BME_XOR32(&FLEXIO_SHIFTBUF_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBIS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBIS(base, index) (FLEXIO_SHIFTBUFBIS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBIS(base, index, value) (FLEXIO_SHIFTBUFBIS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBIS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, (FLEXIO_RD_SHIFTBUFBIS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBIS(base, index, value) (BME_OR32(&FLEXIO_SHIFTBUFBIS_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTBUFBIS(base, index, value) (BME_AND32(&FLEXIO_SHIFTBUFBIS_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTBUFBIS(base, index, value) (BME_XOR32(&FLEXIO_SHIFTBUFBIS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBYS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBYS(base, index) (FLEXIO_SHIFTBUFBYS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBYS(base, index, value) (FLEXIO_SHIFTBUFBYS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBYS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, (FLEXIO_RD_SHIFTBUFBYS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBYS(base, index, value) (BME_OR32(&FLEXIO_SHIFTBUFBYS_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTBUFBYS(base, index, value) (BME_AND32(&FLEXIO_SHIFTBUFBYS_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTBUFBYS(base, index, value) (BME_XOR32(&FLEXIO_SHIFTBUFBYS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBBS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBBS(base, index) (FLEXIO_SHIFTBUFBBS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBBS(base, index, value) (FLEXIO_SHIFTBUFBBS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBBS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, (FLEXIO_RD_SHIFTBUFBBS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBBS(base, index, value) (BME_OR32(&FLEXIO_SHIFTBUFBBS_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTBUFBBS(base, index, value) (BME_AND32(&FLEXIO_SHIFTBUFBBS_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTBUFBBS(base, index, value) (BME_XOR32(&FLEXIO_SHIFTBUFBBS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCTL - Timer Control N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCTL - Timer Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCTL register
 */
/*@{*/
#define FLEXIO_RD_TIMCTL(base, index) (FLEXIO_TIMCTL_REG(base, index))
#define FLEXIO_WR_TIMCTL(base, index, value) (FLEXIO_TIMCTL_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCTL(base, index, mask, value) (FLEXIO_WR_TIMCTL(base, index, (FLEXIO_RD_TIMCTL(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCTL(base, index, value) (BME_OR32(&FLEXIO_TIMCTL_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_TIMCTL(base, index, value) (BME_AND32(&FLEXIO_TIMCTL_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_TIMCTL(base, index, value) (BME_XOR32(&FLEXIO_TIMCTL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCTL bitfields
 */

/*!
 * @name Register FLEXIO_TIMCTL, field TIMOD[1:0] (RW)
 *
 * In 8-bit counter mode, the lower 8-bits of the counter and compare register
 * are used to configure the baud rate of the timer shift clock and the upper
 * 8-bits are used to configure the shifter bit count. In 8-bit PWM mode, the lower
 * 8-bits of the counter and compare register are used to configure the high
 * period of the timer shift clock and the upper 8-bits are used to configure the low
 * period of the timer shift clock. The shifter bit count is configured using
 * another timer or external signal. In 16-bit counter mode, the full 16-bits of the
 * counter and compare register are used to configure either the baud rate of
 * the shift clock or the shifter bit count.
 *
 * Values:
 * - 0b00 - Timer Disabled.
 * - 0b01 - Dual 8-bit counters baud/bit mode.
 * - 0b10 - Dual 8-bit counters PWM mode.
 * - 0b11 - Single 16-bit counter mode.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TIMOD field. */
#define FLEXIO_RD_TIMCTL_TIMOD(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TIMOD_MASK) >> FLEXIO_TIMCTL_TIMOD_SHIFT)
#define FLEXIO_BRD_TIMCTL_TIMOD(base, index) (BME_UBFX32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TIMOD_SHIFT, FLEXIO_TIMCTL_TIMOD_WIDTH))

/*! @brief Set the TIMOD field to a new value. */
#define FLEXIO_WR_TIMCTL_TIMOD(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TIMOD_MASK, FLEXIO_TIMCTL_TIMOD(value)))
#define FLEXIO_BWR_TIMCTL_TIMOD(base, index, value) (BME_BFI32(&FLEXIO_TIMCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCTL_TIMOD_SHIFT), FLEXIO_TIMCTL_TIMOD_SHIFT, FLEXIO_TIMCTL_TIMOD_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINPOL[7] (RW)
 *
 * Values:
 * - 0b0 - Pin is active high
 * - 0b1 - Pin is active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINPOL field. */
#define FLEXIO_RD_TIMCTL_PINPOL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINPOL_MASK) >> FLEXIO_TIMCTL_PINPOL_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINPOL(base, index) (BME_UBFX32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_PINPOL_SHIFT, FLEXIO_TIMCTL_PINPOL_WIDTH))

/*! @brief Set the PINPOL field to a new value. */
#define FLEXIO_WR_TIMCTL_PINPOL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINPOL_MASK, FLEXIO_TIMCTL_PINPOL(value)))
#define FLEXIO_BWR_TIMCTL_PINPOL(base, index, value) (BME_BFI32(&FLEXIO_TIMCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCTL_PINPOL_SHIFT), FLEXIO_TIMCTL_PINPOL_SHIFT, FLEXIO_TIMCTL_PINPOL_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINSEL[12:8] (RW)
 *
 * Selects which pin is used by the Timer input or output.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINSEL field. */
#define FLEXIO_RD_TIMCTL_PINSEL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINSEL_MASK) >> FLEXIO_TIMCTL_PINSEL_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINSEL(base, index) (BME_UBFX32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_PINSEL_SHIFT, FLEXIO_TIMCTL_PINSEL_WIDTH))

/*! @brief Set the PINSEL field to a new value. */
#define FLEXIO_WR_TIMCTL_PINSEL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINSEL_MASK, FLEXIO_TIMCTL_PINSEL(value)))
#define FLEXIO_BWR_TIMCTL_PINSEL(base, index, value) (BME_BFI32(&FLEXIO_TIMCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCTL_PINSEL_SHIFT), FLEXIO_TIMCTL_PINSEL_SHIFT, FLEXIO_TIMCTL_PINSEL_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 0b00 - Timer pin output disabled
 * - 0b01 - Timer pin open drain or bidirectional output enable
 * - 0b10 - Timer pin bidirectional output data
 * - 0b11 - Timer pin output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINCFG field. */
#define FLEXIO_RD_TIMCTL_PINCFG(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINCFG_MASK) >> FLEXIO_TIMCTL_PINCFG_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINCFG(base, index) (BME_UBFX32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_PINCFG_SHIFT, FLEXIO_TIMCTL_PINCFG_WIDTH))

/*! @brief Set the PINCFG field to a new value. */
#define FLEXIO_WR_TIMCTL_PINCFG(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINCFG_MASK, FLEXIO_TIMCTL_PINCFG(value)))
#define FLEXIO_BWR_TIMCTL_PINCFG(base, index, value) (BME_BFI32(&FLEXIO_TIMCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCTL_PINCFG_SHIFT), FLEXIO_TIMCTL_PINCFG_SHIFT, FLEXIO_TIMCTL_PINCFG_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGSRC[22] (RW)
 *
 * Values:
 * - 0b0 - External trigger selected
 * - 0b1 - Internal trigger selected
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGSRC field. */
#define FLEXIO_RD_TIMCTL_TRGSRC(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGSRC_MASK) >> FLEXIO_TIMCTL_TRGSRC_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGSRC(base, index) (BME_UBFX32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGSRC_SHIFT, FLEXIO_TIMCTL_TRGSRC_WIDTH))

/*! @brief Set the TRGSRC field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGSRC(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGSRC_MASK, FLEXIO_TIMCTL_TRGSRC(value)))
#define FLEXIO_BWR_TIMCTL_TRGSRC(base, index, value) (BME_BFI32(&FLEXIO_TIMCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCTL_TRGSRC_SHIFT), FLEXIO_TIMCTL_TRGSRC_SHIFT, FLEXIO_TIMCTL_TRGSRC_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGPOL[23] (RW)
 *
 * Values:
 * - 0b0 - Trigger active high
 * - 0b1 - Trigger active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGPOL field. */
#define FLEXIO_RD_TIMCTL_TRGPOL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGPOL_MASK) >> FLEXIO_TIMCTL_TRGPOL_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGPOL(base, index) (BME_UBFX32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGPOL_SHIFT, FLEXIO_TIMCTL_TRGPOL_WIDTH))

/*! @brief Set the TRGPOL field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGPOL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGPOL_MASK, FLEXIO_TIMCTL_TRGPOL(value)))
#define FLEXIO_BWR_TIMCTL_TRGPOL(base, index, value) (BME_BFI32(&FLEXIO_TIMCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCTL_TRGPOL_SHIFT), FLEXIO_TIMCTL_TRGPOL_SHIFT, FLEXIO_TIMCTL_TRGPOL_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGSEL[29:24] (RW)
 *
 * The valid values for TRGSEL will depend on the FLEXIO_PARAM register. When
 * TRGSRC = 1, the valid values for N will depend on PIN, TIMER, SHIFTER fields in
 * the FLEXIO_PARAM register. When TRGSRC = 0, the valid values for N will depend
 * on TRIGGER field in FLEXIO_PARAM register. Refer to the chip configuration
 * section for external trigger selection. For a pin, N=0 to 31. For a
 * Shifter/Timer, N=0 to 7. The internal trigger selection is configured as follows:
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGSEL field. */
#define FLEXIO_RD_TIMCTL_TRGSEL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGSEL_MASK) >> FLEXIO_TIMCTL_TRGSEL_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGSEL(base, index) (BME_UBFX32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGSEL_SHIFT, FLEXIO_TIMCTL_TRGSEL_WIDTH))

/*! @brief Set the TRGSEL field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGSEL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGSEL_MASK, FLEXIO_TIMCTL_TRGSEL(value)))
#define FLEXIO_BWR_TIMCTL_TRGSEL(base, index, value) (BME_BFI32(&FLEXIO_TIMCTL_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCTL_TRGSEL_SHIFT), FLEXIO_TIMCTL_TRGSEL_SHIFT, FLEXIO_TIMCTL_TRGSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCFG - Timer Configuration N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCFG - Timer Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The options to enable or disable the timer using the Timer N-1 enable or
 * disable are reserved when N is evenly divisible by 4 (eg: Timer 0).
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCFG register
 */
/*@{*/
#define FLEXIO_RD_TIMCFG(base, index) (FLEXIO_TIMCFG_REG(base, index))
#define FLEXIO_WR_TIMCFG(base, index, value) (FLEXIO_TIMCFG_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCFG(base, index, mask, value) (FLEXIO_WR_TIMCFG(base, index, (FLEXIO_RD_TIMCFG(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCFG(base, index, value) (BME_OR32(&FLEXIO_TIMCFG_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_TIMCFG(base, index, value) (BME_AND32(&FLEXIO_TIMCFG_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_TIMCFG(base, index, value) (BME_XOR32(&FLEXIO_TIMCFG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCFG bitfields
 */

/*!
 * @name Register FLEXIO_TIMCFG, field TSTART[1] (RW)
 *
 * When start bit is enabled, configured shifters will output the contents of
 * the start bit when the timer is enabled and the timer counter will reload from
 * the compare register on the first rising edge of the shift clock.
 *
 * Values:
 * - 0b0 - Start bit disabled
 * - 0b1 - Start bit enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TSTART field. */
#define FLEXIO_RD_TIMCFG_TSTART(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TSTART_MASK) >> FLEXIO_TIMCFG_TSTART_SHIFT)
#define FLEXIO_BRD_TIMCFG_TSTART(base, index) (BME_UBFX32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TSTART_SHIFT, FLEXIO_TIMCFG_TSTART_WIDTH))

/*! @brief Set the TSTART field to a new value. */
#define FLEXIO_WR_TIMCFG_TSTART(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TSTART_MASK, FLEXIO_TIMCFG_TSTART(value)))
#define FLEXIO_BWR_TIMCFG_TSTART(base, index, value) (BME_BFI32(&FLEXIO_TIMCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCFG_TSTART_SHIFT), FLEXIO_TIMCFG_TSTART_SHIFT, FLEXIO_TIMCFG_TSTART_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TSTOP[5:4] (RW)
 *
 * The stop bit can be added on a timer compare (between each word) or on a
 * timer disable. When stop bit is enabled, configured shifters will output the
 * contents of the stop bit when the timer is disabled. When stop bit is enabled on
 * timer disable, the timer remains disabled until the next rising edge of the
 * shift clock. If configured for both timer compare and timer disable, only one stop
 * bit is inserted on timer disable.
 *
 * Values:
 * - 0b00 - Stop bit disabled
 * - 0b01 - Stop bit is enabled on timer compare
 * - 0b10 - Stop bit is enabled on timer disable
 * - 0b11 - Stop bit is enabled on timer compare and timer disable
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TSTOP field. */
#define FLEXIO_RD_TIMCFG_TSTOP(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TSTOP_MASK) >> FLEXIO_TIMCFG_TSTOP_SHIFT)
#define FLEXIO_BRD_TIMCFG_TSTOP(base, index) (BME_UBFX32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TSTOP_SHIFT, FLEXIO_TIMCFG_TSTOP_WIDTH))

/*! @brief Set the TSTOP field to a new value. */
#define FLEXIO_WR_TIMCFG_TSTOP(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TSTOP_MASK, FLEXIO_TIMCFG_TSTOP(value)))
#define FLEXIO_BWR_TIMCFG_TSTOP(base, index, value) (BME_BFI32(&FLEXIO_TIMCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCFG_TSTOP_SHIFT), FLEXIO_TIMCFG_TSTOP_SHIFT, FLEXIO_TIMCFG_TSTOP_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMENA[10:8] (RW)
 *
 * Configures the condition that causes the Timer to be enabled and start
 * decrementing.
 *
 * Values:
 * - 0b000 - Timer always enabled
 * - 0b001 - Timer enabled on Timer N-1 enable
 * - 0b010 - Timer enabled on Trigger high
 * - 0b011 - Timer enabled on Trigger high and Pin high
 * - 0b100 - Timer enabled on Pin rising edge
 * - 0b101 - Timer enabled on Pin rising edge and Trigger high
 * - 0b110 - Timer enabled on Trigger rising edge
 * - 0b111 - Timer enabled on Trigger rising or falling edge
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMENA field. */
#define FLEXIO_RD_TIMCFG_TIMENA(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMENA_MASK) >> FLEXIO_TIMCFG_TIMENA_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMENA(base, index) (BME_UBFX32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TIMENA_SHIFT, FLEXIO_TIMCFG_TIMENA_WIDTH))

/*! @brief Set the TIMENA field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMENA(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMENA_MASK, FLEXIO_TIMCFG_TIMENA(value)))
#define FLEXIO_BWR_TIMCFG_TIMENA(base, index, value) (BME_BFI32(&FLEXIO_TIMCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCFG_TIMENA_SHIFT), FLEXIO_TIMCFG_TIMENA_SHIFT, FLEXIO_TIMCFG_TIMENA_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMDIS[14:12] (RW)
 *
 * Configures the condition that causes the Timer to be disabled and stop
 * decrementing.
 *
 * Values:
 * - 0b000 - Timer never disabled
 * - 0b001 - Timer disabled on Timer N-1 disable
 * - 0b010 - Timer disabled on Timer compare
 * - 0b011 - Timer disabled on Timer compare and Trigger Low
 * - 0b100 - Timer disabled on Pin rising or falling edge
 * - 0b101 - Timer disabled on Pin rising or falling edge provided Trigger is
 *     high
 * - 0b110 - Timer disabled on Trigger falling edge
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMDIS field. */
#define FLEXIO_RD_TIMCFG_TIMDIS(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMDIS_MASK) >> FLEXIO_TIMCFG_TIMDIS_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMDIS(base, index) (BME_UBFX32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TIMDIS_SHIFT, FLEXIO_TIMCFG_TIMDIS_WIDTH))

/*! @brief Set the TIMDIS field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMDIS(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMDIS_MASK, FLEXIO_TIMCFG_TIMDIS(value)))
#define FLEXIO_BWR_TIMCFG_TIMDIS(base, index, value) (BME_BFI32(&FLEXIO_TIMCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCFG_TIMDIS_SHIFT), FLEXIO_TIMCFG_TIMDIS_SHIFT, FLEXIO_TIMCFG_TIMDIS_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMRST[18:16] (RW)
 *
 * Configures the condition that causes the timer counter (and optionally the
 * timer output) to be reset. In 8-bit counter mode, the timer reset will only
 * reset the lower 8-bits that configure the baud rate. In all other modes, the timer
 * reset will reset the full 16-bits of the counter.
 *
 * Values:
 * - 0b000 - Timer never reset
 * - 0b001 - Reserved
 * - 0b010 - Timer reset on Timer Pin equal to Timer Output
 * - 0b011 - Timer reset on Timer Trigger equal to Timer Output
 * - 0b100 - Timer reset on Timer Pin rising edge
 * - 0b101 - Reserved
 * - 0b110 - Timer reset on Trigger rising edge
 * - 0b111 - Timer reset on Trigger rising or falling edge
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMRST field. */
#define FLEXIO_RD_TIMCFG_TIMRST(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMRST_MASK) >> FLEXIO_TIMCFG_TIMRST_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMRST(base, index) (BME_UBFX32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TIMRST_SHIFT, FLEXIO_TIMCFG_TIMRST_WIDTH))

/*! @brief Set the TIMRST field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMRST(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMRST_MASK, FLEXIO_TIMCFG_TIMRST(value)))
#define FLEXIO_BWR_TIMCFG_TIMRST(base, index, value) (BME_BFI32(&FLEXIO_TIMCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCFG_TIMRST_SHIFT), FLEXIO_TIMCFG_TIMRST_SHIFT, FLEXIO_TIMCFG_TIMRST_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMDEC[21:20] (RW)
 *
 * Configures the source of the Timer decrement and the source of the Shift
 * clock.
 *
 * Values:
 * - 0b00 - Decrement counter on FlexIO clock, Shift clock equals Timer output.
 * - 0b01 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Timer output.
 * - 0b10 - Decrement counter on Pin input (both edges), Shift clock equals Pin
 *     input.
 * - 0b11 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Trigger input.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMDEC field. */
#define FLEXIO_RD_TIMCFG_TIMDEC(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMDEC_MASK) >> FLEXIO_TIMCFG_TIMDEC_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMDEC(base, index) (BME_UBFX32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TIMDEC_SHIFT, FLEXIO_TIMCFG_TIMDEC_WIDTH))

/*! @brief Set the TIMDEC field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMDEC(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMDEC_MASK, FLEXIO_TIMCFG_TIMDEC(value)))
#define FLEXIO_BWR_TIMCFG_TIMDEC(base, index, value) (BME_BFI32(&FLEXIO_TIMCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCFG_TIMDEC_SHIFT), FLEXIO_TIMCFG_TIMDEC_SHIFT, FLEXIO_TIMCFG_TIMDEC_WIDTH))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMOUT[25:24] (RW)
 *
 * Configures the initial state of the Timer Output and whether it is affected
 * by the Timer reset.
 *
 * Values:
 * - 0b00 - Timer output is logic one when enabled and is not affected by timer
 *     reset
 * - 0b01 - Timer output is logic zero when enabled and is not affected by timer
 *     reset
 * - 0b10 - Timer output is logic one when enabled and on timer reset
 * - 0b11 - Timer output is logic zero when enabled and on timer reset
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMOUT field. */
#define FLEXIO_RD_TIMCFG_TIMOUT(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMOUT_MASK) >> FLEXIO_TIMCFG_TIMOUT_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMOUT(base, index) (BME_UBFX32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TIMOUT_SHIFT, FLEXIO_TIMCFG_TIMOUT_WIDTH))

/*! @brief Set the TIMOUT field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMOUT(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMOUT_MASK, FLEXIO_TIMCFG_TIMOUT(value)))
#define FLEXIO_BWR_TIMCFG_TIMOUT(base, index, value) (BME_BFI32(&FLEXIO_TIMCFG_REG(base, index), ((uint32_t)(value) << FLEXIO_TIMCFG_TIMOUT_SHIFT), FLEXIO_TIMCFG_TIMOUT_SHIFT, FLEXIO_TIMCFG_TIMOUT_WIDTH))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCMP - Timer Compare N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCMP - Timer Compare N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCMP register
 */
/*@{*/
#define FLEXIO_RD_TIMCMP(base, index) (FLEXIO_TIMCMP_REG(base, index))
#define FLEXIO_WR_TIMCMP(base, index, value) (FLEXIO_TIMCMP_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCMP(base, index, mask, value) (FLEXIO_WR_TIMCMP(base, index, (FLEXIO_RD_TIMCMP(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCMP(base, index, value) (BME_OR32(&FLEXIO_TIMCMP_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_TIMCMP(base, index, value) (BME_AND32(&FLEXIO_TIMCMP_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_TIMCMP(base, index, value) (BME_XOR32(&FLEXIO_TIMCMP_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCMP bitfields
 */

/*!
 * @name Register FLEXIO_TIMCMP, field CMP[15:0] (RW)
 *
 * The timer compare value is loaded into the timer counter when the timer is
 * first enabled, when the timer is reset and when the timer decrements down to
 * zero. In dual 8-bit counters baud/bit mode, the lower 8-bits configures the baud
 * rate divider equal to (CMP[7:0] + 1) * 2. The upper 8-bits configure the
 * number of bits in each word equal to (CMP[15:8] + 1) / 2. In dual 8-bit counters
 * PWM mode, the lower 8-bits configure the high period of the output to (CMP[7:0]
 * + 1) * 2. The upper 8-bits configure the low period of the output to
 * (CMP[15:8] + 1) * 2. In 16-bit counter mode, the compare value can be used to generate
 * the baud rate divider (if shift clock source is timer output) to equal
 * (CMP[15:0] + 1) * 2. When the shift clock source is a pin or trigger input, the
 * compare register is used to set the number of bits in each word equal to (CMP[15:0]
 * + 1) / 2.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCMP_CMP field. */
#define FLEXIO_RD_TIMCMP_CMP(base, index) ((FLEXIO_TIMCMP_REG(base, index) & FLEXIO_TIMCMP_CMP_MASK) >> FLEXIO_TIMCMP_CMP_SHIFT)
#define FLEXIO_BRD_TIMCMP_CMP(base, index) (FLEXIO_RD_TIMCMP_CMP(base, index))

/*! @brief Set the CMP field to a new value. */
#define FLEXIO_WR_TIMCMP_CMP(base, index, value) (FLEXIO_RMW_TIMCMP(base, index, FLEXIO_TIMCMP_CMP_MASK, FLEXIO_TIMCMP_CMP(value)))
#define FLEXIO_BWR_TIMCMP_CMP(base, index, value) (FLEXIO_WR_TIMCMP_CMP(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFNBS - Shifter Buffer N Nibble Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFNBS - Shifter Buffer N Nibble Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFNBS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFNBS(base, index) (FLEXIO_SHIFTBUFNBS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFNBS(base, index, value) (FLEXIO_SHIFTBUFNBS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFNBS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFNBS(base, index, (FLEXIO_RD_SHIFTBUFNBS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFNBS(base, index, value) (BME_OR32(&FLEXIO_SHIFTBUFNBS_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTBUFNBS(base, index, value) (BME_AND32(&FLEXIO_SHIFTBUFNBS_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTBUFNBS(base, index, value) (BME_XOR32(&FLEXIO_SHIFTBUFNBS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFHWS - Shifter Buffer N Half Word Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFHWS - Shifter Buffer N Half Word Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFHWS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFHWS(base, index) (FLEXIO_SHIFTBUFHWS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFHWS(base, index, value) (FLEXIO_SHIFTBUFHWS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFHWS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFHWS(base, index, (FLEXIO_RD_SHIFTBUFHWS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFHWS(base, index, value) (BME_OR32(&FLEXIO_SHIFTBUFHWS_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTBUFHWS(base, index, value) (BME_AND32(&FLEXIO_SHIFTBUFHWS_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTBUFHWS(base, index, value) (BME_XOR32(&FLEXIO_SHIFTBUFHWS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFNIS - Shifter Buffer N Nibble Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFNIS - Shifter Buffer N Nibble Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFNIS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFNIS(base, index) (FLEXIO_SHIFTBUFNIS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFNIS(base, index, value) (FLEXIO_SHIFTBUFNIS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFNIS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFNIS(base, index, (FLEXIO_RD_SHIFTBUFNIS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFNIS(base, index, value) (BME_OR32(&FLEXIO_SHIFTBUFNIS_REG(base, index), (uint32_t)(value)))
#define FLEXIO_CLR_SHIFTBUFNIS(base, index, value) (BME_AND32(&FLEXIO_SHIFTBUFNIS_REG(base, index), (uint32_t)(~(value))))
#define FLEXIO_TOG_SHIFTBUFNIS(base, index, value) (BME_XOR32(&FLEXIO_SHIFTBUFNIS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * MKL28Z7 FTFA
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFA_FSTAT - Flash Status Register
 * - FTFA_FCNFG - Flash Configuration Register
 * - FTFA_FSEC - Flash Security Register
 * - FTFA_FOPT - Flash Option Register
 * - FTFA_FCCOB3 - Flash Common Command Object Registers
 * - FTFA_FCCOB2 - Flash Common Command Object Registers
 * - FTFA_FCCOB1 - Flash Common Command Object Registers
 * - FTFA_FCCOB0 - Flash Common Command Object Registers
 * - FTFA_FCCOB7 - Flash Common Command Object Registers
 * - FTFA_FCCOB6 - Flash Common Command Object Registers
 * - FTFA_FCCOB5 - Flash Common Command Object Registers
 * - FTFA_FCCOB4 - Flash Common Command Object Registers
 * - FTFA_FCCOBB - Flash Common Command Object Registers
 * - FTFA_FCCOBA - Flash Common Command Object Registers
 * - FTFA_FCCOB9 - Flash Common Command Object Registers
 * - FTFA_FCCOB8 - Flash Common Command Object Registers
 * - FTFA_FPROT3 - Program Flash Protection Registers
 * - FTFA_FPROT2 - Program Flash Protection Registers
 * - FTFA_FPROT1 - Program Flash Protection Registers
 * - FTFA_FPROT0 - Program Flash Protection Registers
 * - FTFA_XACCH3 - Execute-only Access Registers
 * - FTFA_XACCH2 - Execute-only Access Registers
 * - FTFA_XACCH1 - Execute-only Access Registers
 * - FTFA_XACCH0 - Execute-only Access Registers
 * - FTFA_XACCL3 - Execute-only Access Registers
 * - FTFA_XACCL2 - Execute-only Access Registers
 * - FTFA_XACCL1 - Execute-only Access Registers
 * - FTFA_XACCL0 - Execute-only Access Registers
 * - FTFA_SACCH3 - Supervisor-only Access Registers
 * - FTFA_SACCH2 - Supervisor-only Access Registers
 * - FTFA_SACCH1 - Supervisor-only Access Registers
 * - FTFA_SACCH0 - Supervisor-only Access Registers
 * - FTFA_SACCL3 - Supervisor-only Access Registers
 * - FTFA_SACCL2 - Supervisor-only Access Registers
 * - FTFA_SACCL1 - Supervisor-only Access Registers
 * - FTFA_SACCL0 - Supervisor-only Access Registers
 * - FTFA_FACSS - Flash Access Segment Size Register
 * - FTFA_FACSN - Flash Access Segment Number Register
 */

#define FTFA_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFA module. */
#define FTFA_IDX (0U) /*!< Instance number for FTFA. */

/*******************************************************************************
 * FTFA_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the flash memory module.
 * The CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The
 * MGSTAT0 bit is read only. The unassigned bits read 0 and are not writable. When
 * set, the Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in
 * this register prevent the launch of any more commands until the flag is
 * cleared (by writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFA_FSTAT register
 */
/*@{*/
#define FTFA_RD_FSTAT(base)      (FTFA_FSTAT_REG(base))
#define FTFA_WR_FSTAT(base, value) (FTFA_FSTAT_REG(base) = (value))
#define FTFA_RMW_FSTAT(base, mask, value) (FTFA_WR_FSTAT(base, (FTFA_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFA_SET_FSTAT(base, value) (BME_OR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FSTAT(base, value) (BME_AND8(&FTFA_FSTAT_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FSTAT(base, value) (BME_XOR8(&FTFA_FSTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSTAT bitfields
 */

/*!
 * @name Register FTFA_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of a
 * flash command or during the flash reset sequence. As a status flag, this field
 * cannot (and need not) be cleared by the user like the other error flags in
 * this register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the
 * previous result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_MGSTAT0 field. */
#define FTFA_RD_FSTAT_MGSTAT0(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_MGSTAT0_MASK) >> FTFA_FSTAT_MGSTAT0_SHIFT)
#define FTFA_BRD_FSTAT_MGSTAT0(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_MGSTAT0_SHIFT, FTFA_FSTAT_MGSTAT0_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field FPVIOL[4] (W1C)
 *
 * Indicates an attempt was made to program or erase an address in a protected
 * area of program flash memory during a command write sequence . While FPVIOL is
 * set, the CCIF flag cannot be cleared to launch a command. The FPVIOL bit is
 * cleared by writing a 1 to FPVIOL while CCIF is set. Writing a 0 to the FPVIOL
 * bit has no effect.
 *
 * Values:
 * - 0b0 - No protection violation detected
 * - 0b1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_FPVIOL field. */
#define FTFA_RD_FSTAT_FPVIOL(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_FPVIOL_MASK) >> FTFA_FSTAT_FPVIOL_SHIFT)
#define FTFA_BRD_FSTAT_FPVIOL(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFA_WR_FSTAT_FPVIOL(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_FPVIOL(value)))
#define FTFA_BWR_FSTAT_FPVIOL(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_FPVIOL_SHIFT), FTFA_FSTAT_FPVIOL_SHIFT, FTFA_FSTAT_FPVIOL_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field ACCERR[5] (W1C)
 *
 * Indicates an illegal access has occurred to a flash memory resource caused by
 * a violation of the command write sequence or issuing an illegal flash
 * command. While ACCERR is set, the CCIF flag cannot be cleared to launch a command.
 * The ACCERR bit is cleared by writing a 1 to ACCERR while CCIF is set. Writing a
 * 0 to the ACCERR bit has no effect.
 *
 * Values:
 * - 0b0 - No access error detected
 * - 0b1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_ACCERR field. */
#define FTFA_RD_FSTAT_ACCERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_ACCERR_MASK) >> FTFA_FSTAT_ACCERR_SHIFT)
#define FTFA_BRD_FSTAT_ACCERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))

/*! @brief Set the ACCERR field to a new value. */
#define FTFA_WR_FSTAT_ACCERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_ACCERR(value)))
#define FTFA_BWR_FSTAT_ACCERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_ACCERR_SHIFT), FTFA_FSTAT_ACCERR_SHIFT, FTFA_FSTAT_ACCERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field RDCOLERR[6] (W1C)
 *
 * Indicates that the MCU attempted a read from a flash memory resource that was
 * being manipulated by a flash command (CCIF=0). Any simultaneous access is
 * detected as a collision error by the block arbitration logic. The read data in
 * this case cannot be guaranteed. The RDCOLERR bit is cleared by writing a 1 to
 * it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0b0 - No collision error detected
 * - 0b1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_RDCOLERR field. */
#define FTFA_RD_FSTAT_RDCOLERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_RDCOLERR_MASK) >> FTFA_FSTAT_RDCOLERR_SHIFT)
#define FTFA_BRD_FSTAT_RDCOLERR(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFA_WR_FSTAT_RDCOLERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_RDCOLERR(value)))
#define FTFA_BWR_FSTAT_RDCOLERR(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_RDCOLERR_SHIFT), FTFA_FSTAT_RDCOLERR_SHIFT, FTFA_FSTAT_RDCOLERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field CCIF[7] (W1C)
 *
 * Indicates that a flash command has completed. The CCIF flag is cleared by
 * writing a 1 to CCIF to launch a command, and CCIF stays low until command
 * completion or command violation. CCIF is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0b0 - Flash command in progress
 * - 0b1 - Flash command has completed
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_CCIF field. */
#define FTFA_RD_FSTAT_CCIF(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_CCIF_MASK) >> FTFA_FSTAT_CCIF_SHIFT)
#define FTFA_BRD_FSTAT_CCIF(base) (BME_UBFX8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))

/*! @brief Set the CCIF field to a new value. */
#define FTFA_WR_FSTAT_CCIF(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_CCIF_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK), FTFA_FSTAT_CCIF(value)))
#define FTFA_BWR_FSTAT_CCIF(base, value) (BME_BFI8(&FTFA_FSTAT_REG(base), ((uint8_t)(value) << FTFA_FSTAT_CCIF_SHIFT), FTFA_FSTAT_CCIF_SHIFT, FTFA_FSTAT_CCIF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFA_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * flash memory module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. The unassigned bits read as noted and are not writable.
 */
/*!
 * @name Constants and macros for entire FTFA_FCNFG register
 */
/*@{*/
#define FTFA_RD_FCNFG(base)      (FTFA_FCNFG_REG(base))
#define FTFA_WR_FCNFG(base, value) (FTFA_FCNFG_REG(base) = (value))
#define FTFA_RMW_FCNFG(base, mask, value) (FTFA_WR_FCNFG(base, (FTFA_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFA_SET_FCNFG(base, value) (BME_OR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCNFG(base, value) (BME_AND8(&FTFA_FCNFG_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCNFG(base, value) (BME_XOR8(&FTFA_FCNFG_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCNFG bitfields
 */

/*!
 * @name Register FTFA_FCNFG, field ERSSUSP[4] (RW)
 *
 * Allows the user to suspend (interrupt) the Erase Flash Sector command while
 * it is executing.
 *
 * Values:
 * - 0b0 - No suspend requested
 * - 0b1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSSUSP field. */
#define FTFA_RD_FCNFG_ERSSUSP(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSSUSP_MASK) >> FTFA_FCNFG_ERSSUSP_SHIFT)
#define FTFA_BRD_FCNFG_ERSSUSP(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFA_WR_FCNFG_ERSSUSP(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_ERSSUSP_MASK, FTFA_FCNFG_ERSSUSP(value)))
#define FTFA_BWR_FCNFG_ERSSUSP(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_ERSSUSP_SHIFT), FTFA_FCNFG_ERSSUSP_SHIFT, FTFA_FCNFG_ERSSUSP_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field ERSAREQ[5] (RO)
 *
 * Issues a request to the memory controller to execute the Erase All Blocks
 * command and release security. ERSAREQ is not directly writable but is under
 * indirect user control. Refer to the device's Chip Configuration details on how to
 * request this command. ERSAREQ sets when an erase all request is triggered
 * external to the flash memory module and CCIF is set (no command is currently being
 * executed). ERSAREQ is cleared by the flash memory module when the operation
 * completes.
 *
 * Values:
 * - 0b0 - No request or request complete
 * - 0b1 - Request to: run the Erase All Blocks command, verify the erased
 *     state, program the security byte in the Flash Configuration Field to the
 *     unsecure state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSAREQ field. */
#define FTFA_RD_FCNFG_ERSAREQ(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSAREQ_MASK) >> FTFA_FCNFG_ERSAREQ_SHIFT)
#define FTFA_BRD_FCNFG_ERSAREQ(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSAREQ_SHIFT, FTFA_FCNFG_ERSAREQ_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field RDCOLLIE[6] (RW)
 *
 * Controls interrupt generation when a flash memory read collision error occurs.
 *
 * Values:
 * - 0b0 - Read collision error interrupt disabled
 * - 0b1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever a flash memory read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_RDCOLLIE field. */
#define FTFA_RD_FCNFG_RDCOLLIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_RDCOLLIE_MASK) >> FTFA_FCNFG_RDCOLLIE_SHIFT)
#define FTFA_BRD_FCNFG_RDCOLLIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFA_WR_FCNFG_RDCOLLIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_RDCOLLIE_MASK, FTFA_FCNFG_RDCOLLIE(value)))
#define FTFA_BWR_FCNFG_RDCOLLIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_RDCOLLIE_SHIFT), FTFA_FCNFG_RDCOLLIE_SHIFT, FTFA_FCNFG_RDCOLLIE_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field CCIE[7] (RW)
 *
 * Controls interrupt generation when a flash command completes.
 *
 * Values:
 * - 0b0 - Command complete interrupt disabled
 * - 0b1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_CCIE field. */
#define FTFA_RD_FCNFG_CCIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_CCIE_MASK) >> FTFA_FCNFG_CCIE_SHIFT)
#define FTFA_BRD_FCNFG_CCIE(base) (BME_UBFX8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))

/*! @brief Set the CCIE field to a new value. */
#define FTFA_WR_FCNFG_CCIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_CCIE_MASK, FTFA_FCNFG_CCIE(value)))
#define FTFA_BWR_FCNFG_CCIE(base, value) (BME_BFI8(&FTFA_FCNFG_REG(base), ((uint8_t)(value) << FTFA_FCNFG_CCIE_SHIFT), FTFA_FCNFG_CCIE_SHIFT, FTFA_FCNFG_CCIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and flash memory module. During the reset sequence, the register is loaded
 * with the contents of the flash security byte in the Flash Configuration Field
 * located in program flash memory. The flash basis for the values is signified by
 * X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFA_FSEC register
 */
/*@{*/
#define FTFA_RD_FSEC(base)       (FTFA_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSEC bitfields
 */

/*!
 * @name Register FTFA_FSEC, field SEC[1:0] (RO)
 *
 * Defines the security state of the MCU. In the secure state, the MCU limits
 * access to flash memory module resources. The limitations are defined per device
 * and are detailed in the Chip Configuration details. If the flash memory module
 * is unsecured using backdoor key access, SEC is forced to 10b.
 *
 * Values:
 * - 0b00 - MCU security status is secure.
 * - 0b01 - MCU security status is secure.
 * - 0b10 - MCU security status is unsecure. (The standard shipping condition of
 *     the flash memory module is unsecure.)
 * - 0b11 - MCU security status is secure.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_SEC field. */
#define FTFA_RD_FSEC_SEC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_SEC_MASK) >> FTFA_FSEC_SEC_SHIFT)
#define FTFA_BRD_FSEC_SEC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_SEC_SHIFT, FTFA_FSEC_SEC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field FSLACC[3:2] (RO)
 *
 * Enables or disables access to the flash memory contents during returned part
 * failure analysis at Freescale. When SEC is secure and FSLACC is denied, access
 * to the program flash contents is denied and any failure analysis performed by
 * Freescale factory test must begin with a full erase to unsecure the part.
 * When access is granted (SEC is unsecure, or SEC is secure and FSLACC is granted),
 * Freescale factory testing has visibility of the current flash contents. The
 * state of the FSLACC bits is only relevant when SEC is set to secure. When SEC
 * is set to unsecure, the FSLACC setting does not matter.
 *
 * Values:
 * - 0b00 - Freescale factory access granted
 * - 0b01 - Freescale factory access denied
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_FSLACC field. */
#define FTFA_RD_FSEC_FSLACC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_FSLACC_MASK) >> FTFA_FSEC_FSLACC_SHIFT)
#define FTFA_BRD_FSEC_FSLACC(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_FSLACC_SHIFT, FTFA_FSEC_FSLACC_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the flash memory module. The
 * state of this field is relevant only when SEC is set to secure. When SEC is set
 * to unsecure, the MEEN setting does not matter.
 *
 * Values:
 * - 0b00 - Mass erase is enabled
 * - 0b01 - Mass erase is enabled
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_MEEN field. */
#define FTFA_RD_FSEC_MEEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_MEEN_MASK) >> FTFA_FSEC_MEEN_SHIFT)
#define FTFA_BRD_FSEC_MEEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_MEEN_SHIFT, FTFA_FSEC_MEEN_WIDTH))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field KEYEN[7:6] (RO)
 *
 * Enables or disables backdoor key access to the flash memory module.
 *
 * Values:
 * - 0b00 - Backdoor key access disabled
 * - 0b01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_KEYEN field. */
#define FTFA_RD_FSEC_KEYEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_KEYEN_MASK) >> FTFA_FSEC_KEYEN_SHIFT)
#define FTFA_BRD_FSEC_KEYEN(base) (BME_UBFX8(&FTFA_FSEC_REG(base), FTFA_FSEC_KEYEN_SHIFT, FTFA_FSEC_KEYEN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFA_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFA_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value. However, the register is written to 0xFF if the
 * contents of the flash nonvolatile option byte are 0x00.
 */
/*!
 * @name Constants and macros for entire FTFA_FOPT register
 */
/*@{*/
#define FTFA_RD_FOPT(base)       (FTFA_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB3 register
 */
/*@{*/
#define FTFA_RD_FCCOB3(base)     (FTFA_FCCOB3_REG(base))
#define FTFA_WR_FCCOB3(base, value) (FTFA_FCCOB3_REG(base) = (value))
#define FTFA_RMW_FCCOB3(base, mask, value) (FTFA_WR_FCCOB3(base, (FTFA_RD_FCCOB3(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB3(base, value) (BME_OR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB3(base, value) (BME_AND8(&FTFA_FCCOB3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB3(base, value) (BME_XOR8(&FTFA_FCCOB3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB2 register
 */
/*@{*/
#define FTFA_RD_FCCOB2(base)     (FTFA_FCCOB2_REG(base))
#define FTFA_WR_FCCOB2(base, value) (FTFA_FCCOB2_REG(base) = (value))
#define FTFA_RMW_FCCOB2(base, mask, value) (FTFA_WR_FCCOB2(base, (FTFA_RD_FCCOB2(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB2(base, value) (BME_OR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB2(base, value) (BME_AND8(&FTFA_FCCOB2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB2(base, value) (BME_XOR8(&FTFA_FCCOB2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB1 register
 */
/*@{*/
#define FTFA_RD_FCCOB1(base)     (FTFA_FCCOB1_REG(base))
#define FTFA_WR_FCCOB1(base, value) (FTFA_FCCOB1_REG(base) = (value))
#define FTFA_RMW_FCCOB1(base, mask, value) (FTFA_WR_FCCOB1(base, (FTFA_RD_FCCOB1(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB1(base, value) (BME_OR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB1(base, value) (BME_AND8(&FTFA_FCCOB1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB1(base, value) (BME_XOR8(&FTFA_FCCOB1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB0 register
 */
/*@{*/
#define FTFA_RD_FCCOB0(base)     (FTFA_FCCOB0_REG(base))
#define FTFA_WR_FCCOB0(base, value) (FTFA_FCCOB0_REG(base) = (value))
#define FTFA_RMW_FCCOB0(base, mask, value) (FTFA_WR_FCCOB0(base, (FTFA_RD_FCCOB0(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB0(base, value) (BME_OR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB0(base, value) (BME_AND8(&FTFA_FCCOB0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB0(base, value) (BME_XOR8(&FTFA_FCCOB0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB7 register
 */
/*@{*/
#define FTFA_RD_FCCOB7(base)     (FTFA_FCCOB7_REG(base))
#define FTFA_WR_FCCOB7(base, value) (FTFA_FCCOB7_REG(base) = (value))
#define FTFA_RMW_FCCOB7(base, mask, value) (FTFA_WR_FCCOB7(base, (FTFA_RD_FCCOB7(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB7(base, value) (BME_OR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB7(base, value) (BME_AND8(&FTFA_FCCOB7_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB7(base, value) (BME_XOR8(&FTFA_FCCOB7_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB6 register
 */
/*@{*/
#define FTFA_RD_FCCOB6(base)     (FTFA_FCCOB6_REG(base))
#define FTFA_WR_FCCOB6(base, value) (FTFA_FCCOB6_REG(base) = (value))
#define FTFA_RMW_FCCOB6(base, mask, value) (FTFA_WR_FCCOB6(base, (FTFA_RD_FCCOB6(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB6(base, value) (BME_OR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB6(base, value) (BME_AND8(&FTFA_FCCOB6_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB6(base, value) (BME_XOR8(&FTFA_FCCOB6_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB5 register
 */
/*@{*/
#define FTFA_RD_FCCOB5(base)     (FTFA_FCCOB5_REG(base))
#define FTFA_WR_FCCOB5(base, value) (FTFA_FCCOB5_REG(base) = (value))
#define FTFA_RMW_FCCOB5(base, mask, value) (FTFA_WR_FCCOB5(base, (FTFA_RD_FCCOB5(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB5(base, value) (BME_OR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB5(base, value) (BME_AND8(&FTFA_FCCOB5_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB5(base, value) (BME_XOR8(&FTFA_FCCOB5_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB4 register
 */
/*@{*/
#define FTFA_RD_FCCOB4(base)     (FTFA_FCCOB4_REG(base))
#define FTFA_WR_FCCOB4(base, value) (FTFA_FCCOB4_REG(base) = (value))
#define FTFA_RMW_FCCOB4(base, mask, value) (FTFA_WR_FCCOB4(base, (FTFA_RD_FCCOB4(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB4(base, value) (BME_OR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB4(base, value) (BME_AND8(&FTFA_FCCOB4_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB4(base, value) (BME_XOR8(&FTFA_FCCOB4_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBB register
 */
/*@{*/
#define FTFA_RD_FCCOBB(base)     (FTFA_FCCOBB_REG(base))
#define FTFA_WR_FCCOBB(base, value) (FTFA_FCCOBB_REG(base) = (value))
#define FTFA_RMW_FCCOBB(base, mask, value) (FTFA_WR_FCCOBB(base, (FTFA_RD_FCCOBB(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBB(base, value) (BME_OR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBB(base, value) (BME_AND8(&FTFA_FCCOBB_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBB(base, value) (BME_XOR8(&FTFA_FCCOBB_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBA register
 */
/*@{*/
#define FTFA_RD_FCCOBA(base)     (FTFA_FCCOBA_REG(base))
#define FTFA_WR_FCCOBA(base, value) (FTFA_FCCOBA_REG(base) = (value))
#define FTFA_RMW_FCCOBA(base, mask, value) (FTFA_WR_FCCOBA(base, (FTFA_RD_FCCOBA(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBA(base, value) (BME_OR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOBA(base, value) (BME_AND8(&FTFA_FCCOBA_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOBA(base, value) (BME_XOR8(&FTFA_FCCOBA_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB9 register
 */
/*@{*/
#define FTFA_RD_FCCOB9(base)     (FTFA_FCCOB9_REG(base))
#define FTFA_WR_FCCOB9(base, value) (FTFA_FCCOB9_REG(base) = (value))
#define FTFA_RMW_FCCOB9(base, mask, value) (FTFA_WR_FCCOB9(base, (FTFA_RD_FCCOB9(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB9(base, value) (BME_OR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB9(base, value) (BME_AND8(&FTFA_FCCOB9_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB9(base, value) (BME_XOR8(&FTFA_FCCOB9_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB8 register
 */
/*@{*/
#define FTFA_RD_FCCOB8(base)     (FTFA_FCCOB8_REG(base))
#define FTFA_WR_FCCOB8(base, value) (FTFA_FCCOB8_REG(base) = (value))
#define FTFA_RMW_FCCOB8(base, mask, value) (FTFA_WR_FCCOB8(base, (FTFA_RD_FCCOB8(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB8(base, value) (BME_OR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FCCOB8(base, value) (BME_AND8(&FTFA_FCCOB8_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FCCOB8(base, value) (BME_XOR8(&FTFA_FCCOB8_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT3 register
 */
/*@{*/
#define FTFA_RD_FPROT3(base)     (FTFA_FPROT3_REG(base))
#define FTFA_WR_FPROT3(base, value) (FTFA_FPROT3_REG(base) = (value))
#define FTFA_RMW_FPROT3(base, mask, value) (FTFA_WR_FPROT3(base, (FTFA_RD_FPROT3(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT3(base, value) (BME_OR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT3(base, value) (BME_AND8(&FTFA_FPROT3_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT3(base, value) (BME_XOR8(&FTFA_FPROT3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT2 register
 */
/*@{*/
#define FTFA_RD_FPROT2(base)     (FTFA_FPROT2_REG(base))
#define FTFA_WR_FPROT2(base, value) (FTFA_FPROT2_REG(base) = (value))
#define FTFA_RMW_FPROT2(base, mask, value) (FTFA_WR_FPROT2(base, (FTFA_RD_FPROT2(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT2(base, value) (BME_OR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT2(base, value) (BME_AND8(&FTFA_FPROT2_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT2(base, value) (BME_XOR8(&FTFA_FPROT2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT1 register
 */
/*@{*/
#define FTFA_RD_FPROT1(base)     (FTFA_FPROT1_REG(base))
#define FTFA_WR_FPROT1(base, value) (FTFA_FPROT1_REG(base) = (value))
#define FTFA_RMW_FPROT1(base, mask, value) (FTFA_WR_FPROT1(base, (FTFA_RD_FPROT1(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT1(base, value) (BME_OR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT1(base, value) (BME_AND8(&FTFA_FPROT1_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT1(base, value) (BME_XOR8(&FTFA_FPROT1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT0 register
 */
/*@{*/
#define FTFA_RD_FPROT0(base)     (FTFA_FPROT0_REG(base))
#define FTFA_WR_FPROT0(base, value) (FTFA_FPROT0_REG(base) = (value))
#define FTFA_RMW_FPROT0(base, mask, value) (FTFA_WR_FPROT0(base, (FTFA_RD_FPROT0(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT0(base, value) (BME_OR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
#define FTFA_CLR_FPROT0(base, value) (BME_AND8(&FTFA_FPROT0_REG(base), (uint8_t)(~(value))))
#define FTFA_TOG_FPROT0(base, value) (BME_XOR8(&FTFA_FPROT0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH3 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH3 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH3 register
 */
/*@{*/
#define FTFA_RD_XACCH3(base)     (FTFA_XACCH3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH2 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH2 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH2 register
 */
/*@{*/
#define FTFA_RD_XACCH2(base)     (FTFA_XACCH2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH1 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH1 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH1 register
 */
/*@{*/
#define FTFA_RD_XACCH1(base)     (FTFA_XACCH1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH0 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH0 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH0 register
 */
/*@{*/
#define FTFA_RD_XACCH0(base)     (FTFA_XACCH0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL3 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL3 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL3 register
 */
/*@{*/
#define FTFA_RD_XACCL3(base)     (FTFA_XACCL3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL2 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL2 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL2 register
 */
/*@{*/
#define FTFA_RD_XACCL2(base)     (FTFA_XACCL2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL1 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL1 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL1 register
 */
/*@{*/
#define FTFA_RD_XACCL1(base)     (FTFA_XACCL1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL0 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL0 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL0 register
 */
/*@{*/
#define FTFA_RD_XACCL0(base)     (FTFA_XACCL0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH3 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH3 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH3 register
 */
/*@{*/
#define FTFA_RD_SACCH3(base)     (FTFA_SACCH3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH2 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH2 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH2 register
 */
/*@{*/
#define FTFA_RD_SACCH2(base)     (FTFA_SACCH2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH1 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH1 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH1 register
 */
/*@{*/
#define FTFA_RD_SACCH1(base)     (FTFA_SACCH1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH0 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH0 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH0 register
 */
/*@{*/
#define FTFA_RD_SACCH0(base)     (FTFA_SACCH0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL3 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL3 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL3 register
 */
/*@{*/
#define FTFA_RD_SACCL3(base)     (FTFA_SACCL3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL2 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL2 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL2 register
 */
/*@{*/
#define FTFA_RD_SACCL2(base)     (FTFA_SACCL2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL1 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL1 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL1 register
 */
/*@{*/
#define FTFA_RD_SACCL1(base)     (FTFA_SACCL1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL0 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL0 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL0 register
 */
/*@{*/
#define FTFA_RD_SACCL0(base)     (FTFA_SACCL0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FACSS - Flash Access Segment Size Register
 ******************************************************************************/

/*!
 * @brief FTFA_FACSS - Flash Access Segment Size Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash access segment size register determines which bits in the address
 * are used to index into the SACC and XACC bitmaps to get the appropriate
 * permission flags. All bits in the register are read-only. The contents of this
 * register are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_FACSS register
 */
/*@{*/
#define FTFA_RD_FACSS(base)      (FTFA_FACSS_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FACSN - Flash Access Segment Number Register
 ******************************************************************************/

/*!
 * @brief FTFA_FACSN - Flash Access Segment Number Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash access segment number register provides the number of program flash
 * segments that are available for XACC and SACC permissions. All bits in the
 * register are read-only. The contents of this register are loaded during the
 * reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_FACSN register
 */
/*@{*/
#define FTFA_RD_FACSN(base)      (FTFA_FACSN_REG(base))
/*@}*/

/*
 * MKL28Z7 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 * - GPIO_PIDR - Port Input Disable Register
 */

#define GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define GPIOA_IDX (0U) /*!< Instance number for GPIOA. */
#define GPIOB_IDX (1U) /*!< Instance number for GPIOB. */
#define GPIOC_IDX (2U) /*!< Instance number for GPIOC. */
#define GPIOD_IDX (3U) /*!< Instance number for GPIOD. */
#define GPIOE_IDX (4U) /*!< Instance number for GPIOE. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (BME_OR32(&GPIO_PDOR_REG(base), (uint32_t)(value)))
#define GPIO_CLR_PDOR(base, value) (BME_AND32(&GPIO_PDOR_REG(base), (uint32_t)(~(value))))
#define GPIO_TOG_PDOR(base, value) (BME_XOR32(&GPIO_PDOR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (BME_OR32(&GPIO_PDDR_REG(base), (uint32_t)(value)))
#define GPIO_CLR_PDDR(base, value) (BME_AND32(&GPIO_PDDR_REG(base), (uint32_t)(~(value))))
#define GPIO_TOG_PDDR(base, value) (BME_XOR32(&GPIO_PDDR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * GPIO_PIDR - Port Input Disable Register
 ******************************************************************************/

/*!
 * @brief GPIO_PIDR - Port Input Disable Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 */
/*!
 * @name Constants and macros for entire GPIO_PIDR register
 */
/*@{*/
#define GPIO_RD_PIDR(base)       (GPIO_PIDR_REG(base))
#define GPIO_WR_PIDR(base, value) (GPIO_PIDR_REG(base) = (value))
#define GPIO_RMW_PIDR(base, mask, value) (GPIO_WR_PIDR(base, (GPIO_RD_PIDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PIDR(base, value) (BME_OR32(&GPIO_PIDR_REG(base), (uint32_t)(value)))
#define GPIO_CLR_PIDR(base, value) (BME_AND32(&GPIO_PIDR_REG(base), (uint32_t)(~(value))))
#define GPIO_TOG_PIDR(base, value) (BME_XOR32(&GPIO_PIDR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * MKL28Z7 I2S
 *
 * Inter-IC Sound / Synchronous Audio Interface
 *
 * Registers defined in this header file:
 * - I2S_TCSR - SAI Transmit Control Register
 * - I2S_TCR1 - SAI Transmit Configuration 1 Register
 * - I2S_TCR2 - SAI Transmit Configuration 2 Register
 * - I2S_TCR3 - SAI Transmit Configuration 3 Register
 * - I2S_TCR4 - SAI Transmit Configuration 4 Register
 * - I2S_TCR5 - SAI Transmit Configuration 5 Register
 * - I2S_TDR - SAI Transmit Data Register
 * - I2S_TFR - SAI Transmit FIFO Register
 * - I2S_TMR - SAI Transmit Mask Register
 * - I2S_RCSR - SAI Receive Control Register
 * - I2S_RCR1 - SAI Receive Configuration 1 Register
 * - I2S_RCR2 - SAI Receive Configuration 2 Register
 * - I2S_RCR3 - SAI Receive Configuration 3 Register
 * - I2S_RCR4 - SAI Receive Configuration 4 Register
 * - I2S_RCR5 - SAI Receive Configuration 5 Register
 * - I2S_RDR - SAI Receive Data Register
 * - I2S_RFR - SAI Receive FIFO Register
 * - I2S_RMR - SAI Receive Mask Register
 */

#define I2S_INSTANCE_COUNT (1U) /*!< Number of instances of the I2S module. */
#define I2S0_IDX (0U) /*!< Instance number for I2S0. */

/*******************************************************************************
 * I2S_TCSR - SAI Transmit Control Register
 ******************************************************************************/

/*!
 * @brief I2S_TCSR - SAI Transmit Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCSR register
 */
/*@{*/
#define I2S_RD_TCSR(base)        (I2S_TCSR_REG(base))
#define I2S_WR_TCSR(base, value) (I2S_TCSR_REG(base) = (value))
#define I2S_RMW_TCSR(base, mask, value) (I2S_WR_TCSR(base, (I2S_RD_TCSR(base) & ~(mask)) | (value)))
#define I2S_SET_TCSR(base, value) (BME_OR32(&I2S_TCSR_REG(base), (uint32_t)(value)))
#define I2S_CLR_TCSR(base, value) (BME_AND32(&I2S_TCSR_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_TCSR(base, value) (BME_XOR32(&I2S_TCSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCSR bitfields
 */

/*!
 * @name Register I2S_TCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0b0 - Disables the DMA request.
 * - 0b1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRDE field. */
#define I2S_RD_TCSR_FRDE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRDE_MASK) >> I2S_TCSR_FRDE_SHIFT)
#define I2S_BRD_TCSR_FRDE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FRDE_SHIFT, I2S_TCSR_FRDE_WIDTH))

/*! @brief Set the FRDE field to a new value. */
#define I2S_WR_TCSR_FRDE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FRDE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FRDE(value)))
#define I2S_BWR_TCSR_FRDE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_FRDE_SHIFT), I2S_TCSR_FRDE_SHIFT, I2S_TCSR_FRDE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0b0 - Disables the DMA request.
 * - 0b1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWDE field. */
#define I2S_RD_TCSR_FWDE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWDE_MASK) >> I2S_TCSR_FWDE_SHIFT)
#define I2S_BRD_TCSR_FWDE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FWDE_SHIFT, I2S_TCSR_FWDE_WIDTH))

/*! @brief Set the FWDE field to a new value. */
#define I2S_WR_TCSR_FWDE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FWDE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FWDE(value)))
#define I2S_BWR_TCSR_FWDE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_FWDE_SHIFT), I2S_TCSR_FWDE_SHIFT, I2S_TCSR_FWDE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0b0 - Disables the interrupt.
 * - 0b1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRIE field. */
#define I2S_RD_TCSR_FRIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRIE_MASK) >> I2S_TCSR_FRIE_SHIFT)
#define I2S_BRD_TCSR_FRIE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FRIE_SHIFT, I2S_TCSR_FRIE_WIDTH))

/*! @brief Set the FRIE field to a new value. */
#define I2S_WR_TCSR_FRIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FRIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FRIE(value)))
#define I2S_BWR_TCSR_FRIE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_FRIE_SHIFT), I2S_TCSR_FRIE_SHIFT, I2S_TCSR_FRIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0b0 - Disables the interrupt.
 * - 0b1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWIE field. */
#define I2S_RD_TCSR_FWIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWIE_MASK) >> I2S_TCSR_FWIE_SHIFT)
#define I2S_BRD_TCSR_FWIE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FWIE_SHIFT, I2S_TCSR_FWIE_WIDTH))

/*! @brief Set the FWIE field to a new value. */
#define I2S_WR_TCSR_FWIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FWIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FWIE(value)))
#define I2S_BWR_TCSR_FWIE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_FWIE_SHIFT), I2S_TCSR_FWIE_SHIFT, I2S_TCSR_FWIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0b0 - Disables the interrupt.
 * - 0b1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FEIE field. */
#define I2S_RD_TCSR_FEIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FEIE_MASK) >> I2S_TCSR_FEIE_SHIFT)
#define I2S_BRD_TCSR_FEIE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FEIE_SHIFT, I2S_TCSR_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define I2S_WR_TCSR_FEIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FEIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FEIE(value)))
#define I2S_BWR_TCSR_FEIE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_FEIE_SHIFT), I2S_TCSR_FEIE_SHIFT, I2S_TCSR_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0b0 - Disables interrupt.
 * - 0b1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SEIE field. */
#define I2S_RD_TCSR_SEIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SEIE_MASK) >> I2S_TCSR_SEIE_SHIFT)
#define I2S_BRD_TCSR_SEIE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_SEIE_SHIFT, I2S_TCSR_SEIE_WIDTH))

/*! @brief Set the SEIE field to a new value. */
#define I2S_WR_TCSR_SEIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SEIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SEIE(value)))
#define I2S_BWR_TCSR_SEIE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_SEIE_SHIFT), I2S_TCSR_SEIE_SHIFT, I2S_TCSR_SEIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0b0 - Disables interrupt.
 * - 0b1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_WSIE field. */
#define I2S_RD_TCSR_WSIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_WSIE_MASK) >> I2S_TCSR_WSIE_SHIFT)
#define I2S_BRD_TCSR_WSIE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_WSIE_SHIFT, I2S_TCSR_WSIE_WIDTH))

/*! @brief Set the WSIE field to a new value. */
#define I2S_WR_TCSR_WSIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_WSIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_WSIE(value)))
#define I2S_BWR_TCSR_WSIE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_WSIE_SHIFT), I2S_TCSR_WSIE_SHIFT, I2S_TCSR_WSIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled transmit channel FIFO is
 * less than or equal to the transmit FIFO watermark.
 *
 * Values:
 * - 0b0 - Transmit FIFO watermark has not been reached.
 * - 0b1 - Transmit FIFO watermark has been reached.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRF field. */
#define I2S_RD_TCSR_FRF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRF_MASK) >> I2S_TCSR_FRF_SHIFT)
#define I2S_BRD_TCSR_FRF(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FRF_SHIFT, I2S_TCSR_FRF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled transmit FIFO is empty.
 *
 * Values:
 * - 0b0 - No enabled transmit FIFO is empty.
 * - 0b1 - Enabled transmit FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWF field. */
#define I2S_RD_TCSR_FWF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWF_MASK) >> I2S_TCSR_FWF_SHIFT)
#define I2S_BRD_TCSR_FWF(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FWF_SHIFT, I2S_TCSR_FWF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled transmit FIFO has underrun. Write a logic 1 to this
 * field to clear this flag.
 *
 * Values:
 * - 0b0 - Transmit underrun not detected.
 * - 0b1 - Transmit underrun detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FEF field. */
#define I2S_RD_TCSR_FEF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FEF_MASK) >> I2S_TCSR_FEF_SHIFT)
#define I2S_BRD_TCSR_FEF(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_FEF_SHIFT, I2S_TCSR_FEF_WIDTH))

/*! @brief Set the FEF field to a new value. */
#define I2S_WR_TCSR_FEF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FEF(value)))
#define I2S_BWR_TCSR_FEF(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_FEF_SHIFT), I2S_TCSR_FEF_SHIFT, I2S_TCSR_FEF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0b0 - Sync error not detected.
 * - 0b1 - Frame sync error detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SEF field. */
#define I2S_RD_TCSR_SEF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SEF_MASK) >> I2S_TCSR_SEF_SHIFT)
#define I2S_BRD_TCSR_SEF(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_SEF_SHIFT, I2S_TCSR_SEF_WIDTH))

/*! @brief Set the SEF field to a new value. */
#define I2S_WR_TCSR_SEF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SEF_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SEF(value)))
#define I2S_BWR_TCSR_SEF(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_SEF_SHIFT), I2S_TCSR_SEF_SHIFT, I2S_TCSR_SEF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0b0 - Start of word not detected.
 * - 0b1 - Start of word detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_WSF field. */
#define I2S_RD_TCSR_WSF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_WSF_MASK) >> I2S_TCSR_WSF_SHIFT)
#define I2S_BRD_TCSR_WSF(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_WSF_SHIFT, I2S_TCSR_WSF_WIDTH))

/*! @brief Set the WSF field to a new value. */
#define I2S_WR_TCSR_WSF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_WSF_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK), I2S_TCSR_WSF(value)))
#define I2S_BWR_TCSR_WSF(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_WSF_SHIFT), I2S_TCSR_WSF_SHIFT, I2S_TCSR_WSF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SR[24] (RW)
 *
 * When set, resets the internal transmitter logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Software reset.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SR field. */
#define I2S_RD_TCSR_SR(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SR_MASK) >> I2S_TCSR_SR_SHIFT)
#define I2S_BRD_TCSR_SR(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_SR_SHIFT, I2S_TCSR_SR_WIDTH))

/*! @brief Set the SR field to a new value. */
#define I2S_WR_TCSR_SR(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SR_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SR(value)))
#define I2S_BWR_TCSR_SR(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_SR_SHIFT), I2S_TCSR_SR_SHIFT, I2S_TCSR_SR_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the transmitter is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - FIFO reset.
 */
/*@{*/
/*! @brief Set the FR field to a new value. */
#define I2S_WR_TCSR_FR(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FR_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FR(value)))
#define I2S_BWR_TCSR_FR(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_FR_SHIFT), I2S_TCSR_FR_SHIFT, I2S_TCSR_FR_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field BCE[28] (RW)
 *
 * Enables the transmit bit clock, separately from the TE. This field is
 * automatically set whenever TE is set. When software clears this field, the transmit
 * bit clock remains enabled, and this bit remains set, until the end of the
 * current frame.
 *
 * Values:
 * - 0b0 - Transmit bit clock is disabled.
 * - 0b1 - Transmit bit clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_BCE field. */
#define I2S_RD_TCSR_BCE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_BCE_MASK) >> I2S_TCSR_BCE_SHIFT)
#define I2S_BRD_TCSR_BCE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_BCE_SHIFT, I2S_TCSR_BCE_WIDTH))

/*! @brief Set the BCE field to a new value. */
#define I2S_WR_TCSR_BCE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_BCE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_BCE(value)))
#define I2S_BWR_TCSR_BCE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_BCE_SHIFT), I2S_TCSR_BCE_SHIFT, I2S_TCSR_BCE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field DBGE[29] (RW)
 *
 * Enables/disables transmitter operation in Debug mode. The transmit bit clock
 * is not affected by debug mode.
 *
 * Values:
 * - 0b0 - Transmitter is disabled in Debug mode, after completing the current
 *     frame.
 * - 0b1 - Transmitter is enabled in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_DBGE field. */
#define I2S_RD_TCSR_DBGE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_DBGE_MASK) >> I2S_TCSR_DBGE_SHIFT)
#define I2S_BRD_TCSR_DBGE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_DBGE_SHIFT, I2S_TCSR_DBGE_WIDTH))

/*! @brief Set the DBGE field to a new value. */
#define I2S_WR_TCSR_DBGE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_DBGE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_DBGE(value)))
#define I2S_BWR_TCSR_DBGE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_DBGE_SHIFT), I2S_TCSR_DBGE_SHIFT, I2S_TCSR_DBGE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field STOPE[30] (RW)
 *
 * Configures transmitter operation in Stop mode. This field is ignored and the
 * transmitter is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0b0 - Transmitter disabled in Stop mode.
 * - 0b1 - Transmitter enabled in Stop mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_STOPE field. */
#define I2S_RD_TCSR_STOPE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_STOPE_MASK) >> I2S_TCSR_STOPE_SHIFT)
#define I2S_BRD_TCSR_STOPE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_STOPE_SHIFT, I2S_TCSR_STOPE_WIDTH))

/*! @brief Set the STOPE field to a new value. */
#define I2S_WR_TCSR_STOPE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_STOPE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_STOPE(value)))
#define I2S_BWR_TCSR_STOPE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_STOPE_SHIFT), I2S_TCSR_STOPE_SHIFT, I2S_TCSR_STOPE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCSR, field TE[31] (RW)
 *
 * Enables/disables the transmitter. When software clears this field, the
 * transmitter remains enabled, and this bit remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0b0 - Transmitter is disabled.
 * - 0b1 - Transmitter is enabled, or transmitter has been disabled and has not
 *     yet reached end of frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_TE field. */
#define I2S_RD_TCSR_TE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_TE_MASK) >> I2S_TCSR_TE_SHIFT)
#define I2S_BRD_TCSR_TE(base) (BME_UBFX32(&I2S_TCSR_REG(base), I2S_TCSR_TE_SHIFT, I2S_TCSR_TE_WIDTH))

/*! @brief Set the TE field to a new value. */
#define I2S_WR_TCSR_TE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_TE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_TE(value)))
#define I2S_BWR_TCSR_TE(base, value) (BME_BFI32(&I2S_TCSR_REG(base), ((uint32_t)(value) << I2S_TCSR_TE_SHIFT), I2S_TCSR_TE_SHIFT, I2S_TCSR_TE_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_TCR1 - SAI Transmit Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR1 - SAI Transmit Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCR1 register
 */
/*@{*/
#define I2S_RD_TCR1(base)        (I2S_TCR1_REG(base))
#define I2S_WR_TCR1(base, value) (I2S_TCR1_REG(base) = (value))
#define I2S_RMW_TCR1(base, mask, value) (I2S_WR_TCR1(base, (I2S_RD_TCR1(base) & ~(mask)) | (value)))
#define I2S_SET_TCR1(base, value) (BME_OR32(&I2S_TCR1_REG(base), (uint32_t)(value)))
#define I2S_CLR_TCR1(base, value) (BME_AND32(&I2S_TCR1_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_TCR1(base, value) (BME_XOR32(&I2S_TCR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR1 bitfields
 */

/*!
 * @name Register I2S_TCR1, field TFW[1:0] (RW)
 *
 * Configures the watermark level for all enabled transmit channels.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR1_TFW field. */
#define I2S_RD_TCR1_TFW(base) ((I2S_TCR1_REG(base) & I2S_TCR1_TFW_MASK) >> I2S_TCR1_TFW_SHIFT)
#define I2S_BRD_TCR1_TFW(base) (BME_UBFX32(&I2S_TCR1_REG(base), I2S_TCR1_TFW_SHIFT, I2S_TCR1_TFW_WIDTH))

/*! @brief Set the TFW field to a new value. */
#define I2S_WR_TCR1_TFW(base, value) (I2S_RMW_TCR1(base, I2S_TCR1_TFW_MASK, I2S_TCR1_TFW(value)))
#define I2S_BWR_TCR1_TFW(base, value) (BME_BFI32(&I2S_TCR1_REG(base), ((uint32_t)(value) << I2S_TCR1_TFW_SHIFT), I2S_TCR1_TFW_SHIFT, I2S_TCR1_TFW_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_TCR2 - SAI Transmit Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR2 - SAI Transmit Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR2 register
 */
/*@{*/
#define I2S_RD_TCR2(base)        (I2S_TCR2_REG(base))
#define I2S_WR_TCR2(base, value) (I2S_TCR2_REG(base) = (value))
#define I2S_RMW_TCR2(base, mask, value) (I2S_WR_TCR2(base, (I2S_RD_TCR2(base) & ~(mask)) | (value)))
#define I2S_SET_TCR2(base, value) (BME_OR32(&I2S_TCR2_REG(base), (uint32_t)(value)))
#define I2S_CLR_TCR2(base, value) (BME_AND32(&I2S_TCR2_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_TCR2(base, value) (BME_XOR32(&I2S_TCR2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR2 bitfields
 */

/*!
 * @name Register I2S_TCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_DIV field. */
#define I2S_RD_TCR2_DIV(base) ((I2S_TCR2_REG(base) & I2S_TCR2_DIV_MASK) >> I2S_TCR2_DIV_SHIFT)
#define I2S_BRD_TCR2_DIV(base) (BME_UBFX32(&I2S_TCR2_REG(base), I2S_TCR2_DIV_SHIFT, I2S_TCR2_DIV_WIDTH))

/*! @brief Set the DIV field to a new value. */
#define I2S_WR_TCR2_DIV(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_DIV_MASK, I2S_TCR2_DIV(value)))
#define I2S_BWR_TCR2_DIV(base, value) (BME_BFI32(&I2S_TCR2_REG(base), ((uint32_t)(value) << I2S_TCR2_DIV_SHIFT), I2S_TCR2_DIV_SHIFT, I2S_TCR2_DIV_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0b0 - Bit clock is generated externally in Slave mode.
 * - 0b1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCD field. */
#define I2S_RD_TCR2_BCD(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCD_MASK) >> I2S_TCR2_BCD_SHIFT)
#define I2S_BRD_TCR2_BCD(base) (BME_UBFX32(&I2S_TCR2_REG(base), I2S_TCR2_BCD_SHIFT, I2S_TCR2_BCD_WIDTH))

/*! @brief Set the BCD field to a new value. */
#define I2S_WR_TCR2_BCD(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCD_MASK, I2S_TCR2_BCD(value)))
#define I2S_BWR_TCR2_BCD(base, value) (BME_BFI32(&I2S_TCR2_REG(base), ((uint32_t)(value) << I2S_TCR2_BCD_SHIFT), I2S_TCR2_BCD_SHIFT, I2S_TCR2_BCD_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0b0 - Bit clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 0b1 - Bit clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCP field. */
#define I2S_RD_TCR2_BCP(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCP_MASK) >> I2S_TCR2_BCP_SHIFT)
#define I2S_BRD_TCR2_BCP(base) (BME_UBFX32(&I2S_TCR2_REG(base), I2S_TCR2_BCP_SHIFT, I2S_TCR2_BCP_WIDTH))

/*! @brief Set the BCP field to a new value. */
#define I2S_WR_TCR2_BCP(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCP_MASK, I2S_TCR2_BCP(value)))
#define I2S_BWR_TCR2_BCP(base, value) (BME_BFI32(&I2S_TCR2_REG(base), ((uint32_t)(value) << I2S_TCR2_BCP_SHIFT), I2S_TCR2_BCP_SHIFT, I2S_TCR2_BCP_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip configuration details for the availability and
 * chip-specific meaning of each option.
 *
 * Values:
 * - 0b01 - Master Clock (MCLK) 1 option selected.
 * - 0b10 - Master Clock (MCLK) 2 option selected.
 * - 0b11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_MSEL field. */
#define I2S_RD_TCR2_MSEL(base) ((I2S_TCR2_REG(base) & I2S_TCR2_MSEL_MASK) >> I2S_TCR2_MSEL_SHIFT)
#define I2S_BRD_TCR2_MSEL(base) (BME_UBFX32(&I2S_TCR2_REG(base), I2S_TCR2_MSEL_SHIFT, I2S_TCR2_MSEL_WIDTH))

/*! @brief Set the MSEL field to a new value. */
#define I2S_WR_TCR2_MSEL(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_MSEL_MASK, I2S_TCR2_MSEL(value)))
#define I2S_BWR_TCR2_MSEL(base, value) (BME_BFI32(&I2S_TCR2_REG(base), ((uint32_t)(value) << I2S_TCR2_MSEL_SHIFT), I2S_TCR2_MSEL_SHIFT, I2S_TCR2_MSEL_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the
 * transmitter is delayed by the pad output delay (the transmitter is clocked by the pad
 * input as if the clock was externally generated). This has the effect of
 * decreasing the data input setup time, but increasing the data output valid time. The
 * slave mode timing from the datasheet should be used for the transmitter when
 * this bit is set. In synchronous mode, this bit allows the transmitter to use
 * the slave mode timing from the datasheet, while the receiver uses the master
 * mode timing. This field has no effect when configured for an externally generated
 * bit clock .
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCI field. */
#define I2S_RD_TCR2_BCI(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCI_MASK) >> I2S_TCR2_BCI_SHIFT)
#define I2S_BRD_TCR2_BCI(base) (BME_UBFX32(&I2S_TCR2_REG(base), I2S_TCR2_BCI_SHIFT, I2S_TCR2_BCI_WIDTH))

/*! @brief Set the BCI field to a new value. */
#define I2S_WR_TCR2_BCI(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCI_MASK, I2S_TCR2_BCI(value)))
#define I2S_BWR_TCR2_BCI(base, value) (BME_BFI32(&I2S_TCR2_REG(base), ((uint32_t)(value) << I2S_TCR2_BCI_SHIFT), I2S_TCR2_BCI_SHIFT, I2S_TCR2_BCI_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the transmitter. When the transmitter
 * is configured in asynchronous mode and this bit is set, the transmitter is
 * clocked by the receiver bit clock (SAI_RX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the transmitter continues to use the
 * transmit frame sync (SAI_TX_SYNC). When the transmitter is configured in
 * synchronous mode, the transmitter BCS field and receiver BCS field must be set to
 * the same value. When both are set, the transmitter and receiver are both
 * clocked by the transmitter bit clock (SAI_TX_BCLK) but use the receiver frame sync
 * (SAI_RX_SYNC).
 *
 * Values:
 * - 0b0 - Use the normal bit clock source.
 * - 0b1 - Swap the bit clock source.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCS field. */
#define I2S_RD_TCR2_BCS(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCS_MASK) >> I2S_TCR2_BCS_SHIFT)
#define I2S_BRD_TCR2_BCS(base) (BME_UBFX32(&I2S_TCR2_REG(base), I2S_TCR2_BCS_SHIFT, I2S_TCR2_BCS_WIDTH))

/*! @brief Set the BCS field to a new value. */
#define I2S_WR_TCR2_BCS(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCS_MASK, I2S_TCR2_BCS(value)))
#define I2S_BWR_TCR2_BCS(base, value) (BME_BFI32(&I2S_TCR2_REG(base), ((uint32_t)(value) << I2S_TCR2_BCS_SHIFT), I2S_TCR2_BCS_SHIFT, I2S_TCR2_BCS_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the receiver must be configured
 * for asynchronous operation.
 *
 * Values:
 * - 0b00 - Asynchronous mode.
 * - 0b01 - Synchronous with receiver.
 * - 0b10 - Synchronous with another SAI transmitter.
 * - 0b11 - Synchronous with another SAI receiver.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_SYNC field. */
#define I2S_RD_TCR2_SYNC(base) ((I2S_TCR2_REG(base) & I2S_TCR2_SYNC_MASK) >> I2S_TCR2_SYNC_SHIFT)
#define I2S_BRD_TCR2_SYNC(base) (BME_UBFX32(&I2S_TCR2_REG(base), I2S_TCR2_SYNC_SHIFT, I2S_TCR2_SYNC_WIDTH))

/*! @brief Set the SYNC field to a new value. */
#define I2S_WR_TCR2_SYNC(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_SYNC_MASK, I2S_TCR2_SYNC(value)))
#define I2S_BWR_TCR2_SYNC(base, value) (BME_BFI32(&I2S_TCR2_REG(base), ((uint32_t)(value) << I2S_TCR2_SYNC_SHIFT), I2S_TCR2_SYNC_SHIFT, I2S_TCR2_SYNC_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_TCR3 - SAI Transmit Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR3 - SAI Transmit Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCR3 register
 */
/*@{*/
#define I2S_RD_TCR3(base)        (I2S_TCR3_REG(base))
#define I2S_WR_TCR3(base, value) (I2S_TCR3_REG(base) = (value))
#define I2S_RMW_TCR3(base, mask, value) (I2S_WR_TCR3(base, (I2S_RD_TCR3(base) & ~(mask)) | (value)))
#define I2S_SET_TCR3(base, value) (BME_OR32(&I2S_TCR3_REG(base), (uint32_t)(value)))
#define I2S_CLR_TCR3(base, value) (BME_AND32(&I2S_TCR3_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_TCR3(base, value) (BME_XOR32(&I2S_TCR3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR3 bitfields
 */

/*!
 * @name Register I2S_TCR3, field WDFL[3:0] (RW)
 *
 * Configures which word sets the start of word flag. The value written must be
 * one less than the word number. For example, writing 0 configures the first
 * word in the frame. When configured to a value greater than TCR4[FRSZ], then the
 * start of word flag is never set.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR3_WDFL field. */
#define I2S_RD_TCR3_WDFL(base) ((I2S_TCR3_REG(base) & I2S_TCR3_WDFL_MASK) >> I2S_TCR3_WDFL_SHIFT)
#define I2S_BRD_TCR3_WDFL(base) (BME_UBFX32(&I2S_TCR3_REG(base), I2S_TCR3_WDFL_SHIFT, I2S_TCR3_WDFL_WIDTH))

/*! @brief Set the WDFL field to a new value. */
#define I2S_WR_TCR3_WDFL(base, value) (I2S_RMW_TCR3(base, I2S_TCR3_WDFL_MASK, I2S_TCR3_WDFL(value)))
#define I2S_BWR_TCR3_WDFL(base, value) (BME_BFI32(&I2S_TCR3_REG(base), ((uint32_t)(value) << I2S_TCR3_WDFL_SHIFT), I2S_TCR3_WDFL_SHIFT, I2S_TCR3_WDFL_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR3, field TCE[16] (RW)
 *
 * Enables the corresponding data channel for transmit operation. A channel must
 * be enabled before its FIFO is accessed. Changing this field will take effect
 * immediately for generating the FIFO request and warning flags, but at the end
 * of each frame for transmit operation.
 *
 * Values:
 * - 0b0 - Transmit data channel N is disabled.
 * - 0b1 - Transmit data channel N is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR3_TCE field. */
#define I2S_RD_TCR3_TCE(base) ((I2S_TCR3_REG(base) & I2S_TCR3_TCE_MASK) >> I2S_TCR3_TCE_SHIFT)
#define I2S_BRD_TCR3_TCE(base) (BME_UBFX32(&I2S_TCR3_REG(base), I2S_TCR3_TCE_SHIFT, I2S_TCR3_TCE_WIDTH))

/*! @brief Set the TCE field to a new value. */
#define I2S_WR_TCR3_TCE(base, value) (I2S_RMW_TCR3(base, I2S_TCR3_TCE_MASK, I2S_TCR3_TCE(value)))
#define I2S_BWR_TCR3_TCE(base, value) (BME_BFI32(&I2S_TCR3_REG(base), ((uint32_t)(value) << I2S_TCR3_TCE_SHIFT), I2S_TCR3_TCE_SHIFT, I2S_TCR3_TCE_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_TCR4 - SAI Transmit Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR4 - SAI Transmit Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR4 register
 */
/*@{*/
#define I2S_RD_TCR4(base)        (I2S_TCR4_REG(base))
#define I2S_WR_TCR4(base, value) (I2S_TCR4_REG(base) = (value))
#define I2S_RMW_TCR4(base, mask, value) (I2S_WR_TCR4(base, (I2S_RD_TCR4(base) & ~(mask)) | (value)))
#define I2S_SET_TCR4(base, value) (BME_OR32(&I2S_TCR4_REG(base), (uint32_t)(value)))
#define I2S_CLR_TCR4(base, value) (BME_AND32(&I2S_TCR4_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_TCR4(base, value) (BME_XOR32(&I2S_TCR4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR4 bitfields
 */

/*!
 * @name Register I2S_TCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0b0 - Frame sync is generated externally in Slave mode.
 * - 0b1 - Frame sync is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSD field. */
#define I2S_RD_TCR4_FSD(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSD_MASK) >> I2S_TCR4_FSD_SHIFT)
#define I2S_BRD_TCR4_FSD(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_FSD_SHIFT, I2S_TCR4_FSD_WIDTH))

/*! @brief Set the FSD field to a new value. */
#define I2S_WR_TCR4_FSD(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSD_MASK, I2S_TCR4_FSD(value)))
#define I2S_BWR_TCR4_FSD(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_FSD_SHIFT), I2S_TCR4_FSD_SHIFT, I2S_TCR4_FSD_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0b0 - Frame sync is active high.
 * - 0b1 - Frame sync is active low.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSP field. */
#define I2S_RD_TCR4_FSP(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSP_MASK) >> I2S_TCR4_FSP_SHIFT)
#define I2S_BRD_TCR4_FSP(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_FSP_SHIFT, I2S_TCR4_FSP_WIDTH))

/*! @brief Set the FSP field to a new value. */
#define I2S_WR_TCR4_FSP(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSP_MASK, I2S_TCR4_FSP(value)))
#define I2S_BWR_TCR4_FSP(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_FSP_SHIFT), I2S_TCR4_FSP_SHIFT, I2S_TCR4_FSP_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field ONDEM[2] (RW)
 *
 * When set, and the frame sync is generated internally, a frame sync is only
 * generated when the FIFO warning flag is clear.
 *
 * Values:
 * - 0b0 - Internal frame sync is generated continuously.
 * - 0b1 - Internal frame sync is generated when the FIFO warning flag is clear.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_ONDEM field. */
#define I2S_RD_TCR4_ONDEM(base) ((I2S_TCR4_REG(base) & I2S_TCR4_ONDEM_MASK) >> I2S_TCR4_ONDEM_SHIFT)
#define I2S_BRD_TCR4_ONDEM(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_ONDEM_SHIFT, I2S_TCR4_ONDEM_WIDTH))

/*! @brief Set the ONDEM field to a new value. */
#define I2S_WR_TCR4_ONDEM(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_ONDEM_MASK, I2S_TCR4_ONDEM(value)))
#define I2S_BWR_TCR4_ONDEM(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_ONDEM_SHIFT), I2S_TCR4_ONDEM_SHIFT, I2S_TCR4_ONDEM_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0b0 - Frame sync asserts with the first bit of the frame.
 * - 0b1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSE field. */
#define I2S_RD_TCR4_FSE(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSE_MASK) >> I2S_TCR4_FSE_SHIFT)
#define I2S_BRD_TCR4_FSE(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_FSE_SHIFT, I2S_TCR4_FSE_WIDTH))

/*! @brief Set the FSE field to a new value. */
#define I2S_WR_TCR4_FSE(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSE_MASK, I2S_TCR4_FSE(value)))
#define I2S_BWR_TCR4_FSE(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_FSE_SHIFT), I2S_TCR4_FSE_SHIFT, I2S_TCR4_FSE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is transmitted first.
 *
 * Values:
 * - 0b0 - LSB is transmitted first.
 * - 0b1 - MSB is transmitted first.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_MF field. */
#define I2S_RD_TCR4_MF(base) ((I2S_TCR4_REG(base) & I2S_TCR4_MF_MASK) >> I2S_TCR4_MF_SHIFT)
#define I2S_BRD_TCR4_MF(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_MF_SHIFT, I2S_TCR4_MF_WIDTH))

/*! @brief Set the MF field to a new value. */
#define I2S_WR_TCR4_MF(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_MF_MASK, I2S_TCR4_MF(value)))
#define I2S_BWR_TCR4_MF(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_MF_SHIFT), I2S_TCR4_MF_SHIFT, I2S_TCR4_MF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_SYWD field. */
#define I2S_RD_TCR4_SYWD(base) ((I2S_TCR4_REG(base) & I2S_TCR4_SYWD_MASK) >> I2S_TCR4_SYWD_SHIFT)
#define I2S_BRD_TCR4_SYWD(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_SYWD_SHIFT, I2S_TCR4_SYWD_WIDTH))

/*! @brief Set the SYWD field to a new value. */
#define I2S_WR_TCR4_SYWD(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_SYWD_MASK, I2S_TCR4_SYWD(value)))
#define I2S_BWR_TCR4_SYWD(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_SYWD_SHIFT), I2S_TCR4_SYWD_SHIFT, I2S_TCR4_SYWD_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FRSZ[19:16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 16 words.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FRSZ field. */
#define I2S_RD_TCR4_FRSZ(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FRSZ_MASK) >> I2S_TCR4_FRSZ_SHIFT)
#define I2S_BRD_TCR4_FRSZ(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_FRSZ_SHIFT, I2S_TCR4_FRSZ_WIDTH))

/*! @brief Set the FRSZ field to a new value. */
#define I2S_WR_TCR4_FRSZ(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FRSZ_MASK, I2S_TCR4_FRSZ(value)))
#define I2S_BWR_TCR4_FRSZ(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_FRSZ_SHIFT), I2S_TCR4_FRSZ_SHIFT, I2S_TCR4_FRSZ_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FPACK[25:24] (RW)
 *
 * Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO word. If
 * the word size is greater than 8-bit or 16-bit then only the first 8-bit or
 * 16-bits are loaded from the FIFO. The first word in each frame always starts with
 * a new 32-bit FIFO word and the first bit shifted must be configured within the
 * first packed word. When FIFO packing is enabled, the FIFO write pointer will
 * only increment when the full 32-bit FIFO word has been written by software.
 *
 * Values:
 * - 0b00 - FIFO packing is disabled
 * - 0b01 - Reserved
 * - 0b10 - 8-bit FIFO packing is enabled
 * - 0b11 - 16-bit FIFO packing is enabled
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FPACK field. */
#define I2S_RD_TCR4_FPACK(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FPACK_MASK) >> I2S_TCR4_FPACK_SHIFT)
#define I2S_BRD_TCR4_FPACK(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_FPACK_SHIFT, I2S_TCR4_FPACK_WIDTH))

/*! @brief Set the FPACK field to a new value. */
#define I2S_WR_TCR4_FPACK(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FPACK_MASK, I2S_TCR4_FPACK(value)))
#define I2S_BWR_TCR4_FPACK(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_FPACK_SHIFT), I2S_TCR4_FPACK_SHIFT, I2S_TCR4_FPACK_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FCONT[28] (RW)
 *
 * Configures when the SAI will continue transmitting after a FIFO error has
 * been detected.
 *
 * Values:
 * - 0b0 - On FIFO error, the SAI will continue from the start of the next frame
 *     after the FIFO error flag has been cleared.
 * - 0b1 - On FIFO error, the SAI will continue from the same word that caused
 *     the FIFO error to set after the FIFO warning flag has been cleared.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FCONT field. */
#define I2S_RD_TCR4_FCONT(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FCONT_MASK) >> I2S_TCR4_FCONT_SHIFT)
#define I2S_BRD_TCR4_FCONT(base) (BME_UBFX32(&I2S_TCR4_REG(base), I2S_TCR4_FCONT_SHIFT, I2S_TCR4_FCONT_WIDTH))

/*! @brief Set the FCONT field to a new value. */
#define I2S_WR_TCR4_FCONT(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FCONT_MASK, I2S_TCR4_FCONT(value)))
#define I2S_BWR_TCR4_FCONT(base, value) (BME_BFI32(&I2S_TCR4_REG(base), ((uint32_t)(value) << I2S_TCR4_FCONT_SHIFT), I2S_TCR4_FCONT_SHIFT, I2S_TCR4_FCONT_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_TCR5 - SAI Transmit Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR5 - SAI Transmit Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR5 register
 */
/*@{*/
#define I2S_RD_TCR5(base)        (I2S_TCR5_REG(base))
#define I2S_WR_TCR5(base, value) (I2S_TCR5_REG(base) = (value))
#define I2S_RMW_TCR5(base, mask, value) (I2S_WR_TCR5(base, (I2S_RD_TCR5(base) & ~(mask)) | (value)))
#define I2S_SET_TCR5(base, value) (BME_OR32(&I2S_TCR5_REG(base), (uint32_t)(value)))
#define I2S_CLR_TCR5(base, value) (BME_AND32(&I2S_TCR5_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_TCR5(base, value) (BME_XOR32(&I2S_TCR5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR5 bitfields
 */

/*!
 * @name Register I2S_TCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit transmitted for each word in the
 * frame. If configured for MSB First, the index of the next bit transmitted is
 * one less than the current bit transmitted. If configured for LSB First, the
 * index of the next bit transmitted is one more than the current bit transmitted.
 * The value written must be greater than or equal to the word width when
 * configured for MSB First. The value written must be less than or equal to 31-word width
 * when configured for LSB First.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_FBT field. */
#define I2S_RD_TCR5_FBT(base) ((I2S_TCR5_REG(base) & I2S_TCR5_FBT_MASK) >> I2S_TCR5_FBT_SHIFT)
#define I2S_BRD_TCR5_FBT(base) (BME_UBFX32(&I2S_TCR5_REG(base), I2S_TCR5_FBT_SHIFT, I2S_TCR5_FBT_WIDTH))

/*! @brief Set the FBT field to a new value. */
#define I2S_WR_TCR5_FBT(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_FBT_MASK, I2S_TCR5_FBT(value)))
#define I2S_BWR_TCR5_FBT(base, value) (BME_BFI32(&I2S_TCR5_REG(base), ((uint32_t)(value) << I2S_TCR5_FBT_SHIFT), I2S_TCR5_FBT_SHIFT, I2S_TCR5_FBT_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_W0W field. */
#define I2S_RD_TCR5_W0W(base) ((I2S_TCR5_REG(base) & I2S_TCR5_W0W_MASK) >> I2S_TCR5_W0W_SHIFT)
#define I2S_BRD_TCR5_W0W(base) (BME_UBFX32(&I2S_TCR5_REG(base), I2S_TCR5_W0W_SHIFT, I2S_TCR5_W0W_WIDTH))

/*! @brief Set the W0W field to a new value. */
#define I2S_WR_TCR5_W0W(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_W0W_MASK, I2S_TCR5_W0W(value)))
#define I2S_BWR_TCR5_W0W(base, value) (BME_BFI32(&I2S_TCR5_REG(base), ((uint32_t)(value) << I2S_TCR5_W0W_SHIFT), I2S_TCR5_W0W_SHIFT, I2S_TCR5_W0W_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_WNW field. */
#define I2S_RD_TCR5_WNW(base) ((I2S_TCR5_REG(base) & I2S_TCR5_WNW_MASK) >> I2S_TCR5_WNW_SHIFT)
#define I2S_BRD_TCR5_WNW(base) (BME_UBFX32(&I2S_TCR5_REG(base), I2S_TCR5_WNW_SHIFT, I2S_TCR5_WNW_WIDTH))

/*! @brief Set the WNW field to a new value. */
#define I2S_WR_TCR5_WNW(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_WNW_MASK, I2S_TCR5_WNW(value)))
#define I2S_BWR_TCR5_WNW(base, value) (BME_BFI32(&I2S_TCR5_REG(base), ((uint32_t)(value) << I2S_TCR5_WNW_SHIFT), I2S_TCR5_WNW_SHIFT, I2S_TCR5_WNW_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_TDR - SAI Transmit Data Register
 ******************************************************************************/

/*!
 * @brief I2S_TDR - SAI Transmit Data Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TDR register
 */
/*@{*/
#define I2S_RD_TDR(base, index)  (I2S_TDR_REG(base, index))
#define I2S_WR_TDR(base, index, value) (I2S_TDR_REG(base, index) = (value))
#define I2S_RMW_TDR(base, index, mask, value) (I2S_WR_TDR(base, index, (I2S_RD_TDR(base, index) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * I2S_TFR - SAI Transmit FIFO Register
 ******************************************************************************/

/*!
 * @brief I2S_TFR - SAI Transmit FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read and write pointers is used to distinguish between FIFO
 * full and empty conditions. If the read and write pointers are identical, then
 * the FIFO is empty. If the read and write pointers are identical except for the
 * MSB, then the FIFO is full.
 */
/*!
 * @name Constants and macros for entire I2S_TFR register
 */
/*@{*/
#define I2S_RD_TFR(base, index)  (I2S_TFR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual I2S_TFR bitfields
 */

/*!
 * @name Register I2S_TFR, field RFP[2:0] (RO)
 *
 * FIFO read pointer for transmit data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_TFR_RFP field. */
#define I2S_RD_TFR_RFP(base, index) ((I2S_TFR_REG(base, index) & I2S_TFR_RFP_MASK) >> I2S_TFR_RFP_SHIFT)
#define I2S_BRD_TFR_RFP(base, index) (BME_UBFX32(&I2S_TFR_REG(base, index), I2S_TFR_RFP_SHIFT, I2S_TFR_RFP_WIDTH))
/*@}*/

/*!
 * @name Register I2S_TFR, field WFP[18:16] (RO)
 *
 * FIFO write pointer for transmit data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_TFR_WFP field. */
#define I2S_RD_TFR_WFP(base, index) ((I2S_TFR_REG(base, index) & I2S_TFR_WFP_MASK) >> I2S_TFR_WFP_SHIFT)
#define I2S_BRD_TFR_WFP(base, index) (BME_UBFX32(&I2S_TFR_REG(base, index), I2S_TFR_WFP_SHIFT, I2S_TFR_WFP_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_TMR - SAI Transmit Mask Register
 ******************************************************************************/

/*!
 * @brief I2S_TMR - SAI Transmit Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When TCSR[TE] is first set At
 * the end of each frame. This allows the masked words in each frame to change
 * from frame to frame.
 */
/*!
 * @name Constants and macros for entire I2S_TMR register
 */
/*@{*/
#define I2S_RD_TMR(base)         (I2S_TMR_REG(base))
#define I2S_WR_TMR(base, value)  (I2S_TMR_REG(base) = (value))
#define I2S_RMW_TMR(base, mask, value) (I2S_WR_TMR(base, (I2S_RD_TMR(base) & ~(mask)) | (value)))
#define I2S_SET_TMR(base, value) (BME_OR32(&I2S_TMR_REG(base), (uint32_t)(value)))
#define I2S_CLR_TMR(base, value) (BME_AND32(&I2S_TMR_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_TMR(base, value) (BME_XOR32(&I2S_TMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TMR bitfields
 */

/*!
 * @name Register I2S_TMR, field TWM[15:0] (RW)
 *
 * Configures whether the transmit word is masked (transmit data pin tristated
 * and transmit data not read from FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0b0000000000000000 - Word N is enabled.
 * - 0b0000000000000001 - Word N is masked. The transmit data pins are
 *     tri-stated when masked.
 */
/*@{*/
/*! @brief Read current value of the I2S_TMR_TWM field. */
#define I2S_RD_TMR_TWM(base) ((I2S_TMR_REG(base) & I2S_TMR_TWM_MASK) >> I2S_TMR_TWM_SHIFT)
#define I2S_BRD_TMR_TWM(base) (I2S_RD_TMR_TWM(base))

/*! @brief Set the TWM field to a new value. */
#define I2S_WR_TMR_TWM(base, value) (I2S_RMW_TMR(base, I2S_TMR_TWM_MASK, I2S_TMR_TWM(value)))
#define I2S_BWR_TMR_TWM(base, value) (I2S_WR_TMR_TWM(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCSR - SAI Receive Control Register
 ******************************************************************************/

/*!
 * @brief I2S_RCSR - SAI Receive Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCSR register
 */
/*@{*/
#define I2S_RD_RCSR(base)        (I2S_RCSR_REG(base))
#define I2S_WR_RCSR(base, value) (I2S_RCSR_REG(base) = (value))
#define I2S_RMW_RCSR(base, mask, value) (I2S_WR_RCSR(base, (I2S_RD_RCSR(base) & ~(mask)) | (value)))
#define I2S_SET_RCSR(base, value) (BME_OR32(&I2S_RCSR_REG(base), (uint32_t)(value)))
#define I2S_CLR_RCSR(base, value) (BME_AND32(&I2S_RCSR_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_RCSR(base, value) (BME_XOR32(&I2S_RCSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCSR bitfields
 */

/*!
 * @name Register I2S_RCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0b0 - Disables the DMA request.
 * - 0b1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRDE field. */
#define I2S_RD_RCSR_FRDE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRDE_MASK) >> I2S_RCSR_FRDE_SHIFT)
#define I2S_BRD_RCSR_FRDE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FRDE_SHIFT, I2S_RCSR_FRDE_WIDTH))

/*! @brief Set the FRDE field to a new value. */
#define I2S_WR_RCSR_FRDE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FRDE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FRDE(value)))
#define I2S_BWR_RCSR_FRDE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_FRDE_SHIFT), I2S_RCSR_FRDE_SHIFT, I2S_RCSR_FRDE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0b0 - Disables the DMA request.
 * - 0b1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWDE field. */
#define I2S_RD_RCSR_FWDE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWDE_MASK) >> I2S_RCSR_FWDE_SHIFT)
#define I2S_BRD_RCSR_FWDE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FWDE_SHIFT, I2S_RCSR_FWDE_WIDTH))

/*! @brief Set the FWDE field to a new value. */
#define I2S_WR_RCSR_FWDE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FWDE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FWDE(value)))
#define I2S_BWR_RCSR_FWDE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_FWDE_SHIFT), I2S_RCSR_FWDE_SHIFT, I2S_RCSR_FWDE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0b0 - Disables the interrupt.
 * - 0b1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRIE field. */
#define I2S_RD_RCSR_FRIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRIE_MASK) >> I2S_RCSR_FRIE_SHIFT)
#define I2S_BRD_RCSR_FRIE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FRIE_SHIFT, I2S_RCSR_FRIE_WIDTH))

/*! @brief Set the FRIE field to a new value. */
#define I2S_WR_RCSR_FRIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FRIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FRIE(value)))
#define I2S_BWR_RCSR_FRIE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_FRIE_SHIFT), I2S_RCSR_FRIE_SHIFT, I2S_RCSR_FRIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0b0 - Disables the interrupt.
 * - 0b1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWIE field. */
#define I2S_RD_RCSR_FWIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWIE_MASK) >> I2S_RCSR_FWIE_SHIFT)
#define I2S_BRD_RCSR_FWIE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FWIE_SHIFT, I2S_RCSR_FWIE_WIDTH))

/*! @brief Set the FWIE field to a new value. */
#define I2S_WR_RCSR_FWIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FWIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FWIE(value)))
#define I2S_BWR_RCSR_FWIE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_FWIE_SHIFT), I2S_RCSR_FWIE_SHIFT, I2S_RCSR_FWIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0b0 - Disables the interrupt.
 * - 0b1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FEIE field. */
#define I2S_RD_RCSR_FEIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FEIE_MASK) >> I2S_RCSR_FEIE_SHIFT)
#define I2S_BRD_RCSR_FEIE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FEIE_SHIFT, I2S_RCSR_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define I2S_WR_RCSR_FEIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FEIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FEIE(value)))
#define I2S_BWR_RCSR_FEIE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_FEIE_SHIFT), I2S_RCSR_FEIE_SHIFT, I2S_RCSR_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0b0 - Disables interrupt.
 * - 0b1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SEIE field. */
#define I2S_RD_RCSR_SEIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SEIE_MASK) >> I2S_RCSR_SEIE_SHIFT)
#define I2S_BRD_RCSR_SEIE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_SEIE_SHIFT, I2S_RCSR_SEIE_WIDTH))

/*! @brief Set the SEIE field to a new value. */
#define I2S_WR_RCSR_SEIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SEIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SEIE(value)))
#define I2S_BWR_RCSR_SEIE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_SEIE_SHIFT), I2S_RCSR_SEIE_SHIFT, I2S_RCSR_SEIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0b0 - Disables interrupt.
 * - 0b1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_WSIE field. */
#define I2S_RD_RCSR_WSIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_WSIE_MASK) >> I2S_RCSR_WSIE_SHIFT)
#define I2S_BRD_RCSR_WSIE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_WSIE_SHIFT, I2S_RCSR_WSIE_WIDTH))

/*! @brief Set the WSIE field to a new value. */
#define I2S_WR_RCSR_WSIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_WSIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_WSIE(value)))
#define I2S_BWR_RCSR_WSIE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_WSIE_SHIFT), I2S_RCSR_WSIE_SHIFT, I2S_RCSR_WSIE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled receive channel FIFO is
 * greater than the receive FIFO watermark.
 *
 * Values:
 * - 0b0 - Receive FIFO watermark not reached.
 * - 0b1 - Receive FIFO watermark has been reached.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRF field. */
#define I2S_RD_RCSR_FRF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRF_MASK) >> I2S_RCSR_FRF_SHIFT)
#define I2S_BRD_RCSR_FRF(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FRF_SHIFT, I2S_RCSR_FRF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled receive FIFO is full.
 *
 * Values:
 * - 0b0 - No enabled receive FIFO is full.
 * - 0b1 - Enabled receive FIFO is full.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWF field. */
#define I2S_RD_RCSR_FWF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWF_MASK) >> I2S_RCSR_FWF_SHIFT)
#define I2S_BRD_RCSR_FWF(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FWF_SHIFT, I2S_RCSR_FWF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled receive FIFO has overflowed. Write a logic 1 to
 * this field to clear this flag.
 *
 * Values:
 * - 0b0 - Receive overflow not detected.
 * - 0b1 - Receive overflow detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FEF field. */
#define I2S_RD_RCSR_FEF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FEF_MASK) >> I2S_RCSR_FEF_SHIFT)
#define I2S_BRD_RCSR_FEF(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_FEF_SHIFT, I2S_RCSR_FEF_WIDTH))

/*! @brief Set the FEF field to a new value. */
#define I2S_WR_RCSR_FEF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FEF(value)))
#define I2S_BWR_RCSR_FEF(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_FEF_SHIFT), I2S_RCSR_FEF_SHIFT, I2S_RCSR_FEF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0b0 - Sync error not detected.
 * - 0b1 - Frame sync error detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SEF field. */
#define I2S_RD_RCSR_SEF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SEF_MASK) >> I2S_RCSR_SEF_SHIFT)
#define I2S_BRD_RCSR_SEF(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_SEF_SHIFT, I2S_RCSR_SEF_WIDTH))

/*! @brief Set the SEF field to a new value. */
#define I2S_WR_RCSR_SEF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SEF_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SEF(value)))
#define I2S_BWR_RCSR_SEF(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_SEF_SHIFT), I2S_RCSR_SEF_SHIFT, I2S_RCSR_SEF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0b0 - Start of word not detected.
 * - 0b1 - Start of word detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_WSF field. */
#define I2S_RD_RCSR_WSF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_WSF_MASK) >> I2S_RCSR_WSF_SHIFT)
#define I2S_BRD_RCSR_WSF(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_WSF_SHIFT, I2S_RCSR_WSF_WIDTH))

/*! @brief Set the WSF field to a new value. */
#define I2S_WR_RCSR_WSF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_WSF_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK), I2S_RCSR_WSF(value)))
#define I2S_BWR_RCSR_WSF(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_WSF_SHIFT), I2S_RCSR_WSF_SHIFT, I2S_RCSR_WSF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SR[24] (RW)
 *
 * Resets the internal receiver logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Software reset.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SR field. */
#define I2S_RD_RCSR_SR(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SR_MASK) >> I2S_RCSR_SR_SHIFT)
#define I2S_BRD_RCSR_SR(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_SR_SHIFT, I2S_RCSR_SR_WIDTH))

/*! @brief Set the SR field to a new value. */
#define I2S_WR_RCSR_SR(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SR_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SR(value)))
#define I2S_BWR_RCSR_SR(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_SR_SHIFT), I2S_RCSR_SR_SHIFT, I2S_RCSR_SR_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the receiver is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - FIFO reset.
 */
/*@{*/
/*! @brief Set the FR field to a new value. */
#define I2S_WR_RCSR_FR(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FR_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FR(value)))
#define I2S_BWR_RCSR_FR(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_FR_SHIFT), I2S_RCSR_FR_SHIFT, I2S_RCSR_FR_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field BCE[28] (RW)
 *
 * Enables the receive bit clock, separately from RE. This field is
 * automatically set whenever RE is set. When software clears this field, the receive bit
 * clock remains enabled, and this field remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0b0 - Receive bit clock is disabled.
 * - 0b1 - Receive bit clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_BCE field. */
#define I2S_RD_RCSR_BCE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_BCE_MASK) >> I2S_RCSR_BCE_SHIFT)
#define I2S_BRD_RCSR_BCE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_BCE_SHIFT, I2S_RCSR_BCE_WIDTH))

/*! @brief Set the BCE field to a new value. */
#define I2S_WR_RCSR_BCE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_BCE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_BCE(value)))
#define I2S_BWR_RCSR_BCE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_BCE_SHIFT), I2S_RCSR_BCE_SHIFT, I2S_RCSR_BCE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field DBGE[29] (RW)
 *
 * Enables/disables receiver operation in Debug mode. The receive bit clock is
 * not affected by Debug mode.
 *
 * Values:
 * - 0b0 - Receiver is disabled in Debug mode, after completing the current
 *     frame.
 * - 0b1 - Receiver is enabled in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_DBGE field. */
#define I2S_RD_RCSR_DBGE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_DBGE_MASK) >> I2S_RCSR_DBGE_SHIFT)
#define I2S_BRD_RCSR_DBGE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_DBGE_SHIFT, I2S_RCSR_DBGE_WIDTH))

/*! @brief Set the DBGE field to a new value. */
#define I2S_WR_RCSR_DBGE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_DBGE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_DBGE(value)))
#define I2S_BWR_RCSR_DBGE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_DBGE_SHIFT), I2S_RCSR_DBGE_SHIFT, I2S_RCSR_DBGE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field STOPE[30] (RW)
 *
 * Configures receiver operation in Stop mode. This bit is ignored and the
 * receiver is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0b0 - Receiver disabled in Stop mode.
 * - 0b1 - Receiver enabled in Stop mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_STOPE field. */
#define I2S_RD_RCSR_STOPE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_STOPE_MASK) >> I2S_RCSR_STOPE_SHIFT)
#define I2S_BRD_RCSR_STOPE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_STOPE_SHIFT, I2S_RCSR_STOPE_WIDTH))

/*! @brief Set the STOPE field to a new value. */
#define I2S_WR_RCSR_STOPE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_STOPE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_STOPE(value)))
#define I2S_BWR_RCSR_STOPE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_STOPE_SHIFT), I2S_RCSR_STOPE_SHIFT, I2S_RCSR_STOPE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCSR, field RE[31] (RW)
 *
 * Enables/disables the receiver. When software clears this field, the receiver
 * remains enabled, and this bit remains set, until the end of the current frame.
 *
 * Values:
 * - 0b0 - Receiver is disabled.
 * - 0b1 - Receiver is enabled, or receiver has been disabled and has not yet
 *     reached end of frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_RE field. */
#define I2S_RD_RCSR_RE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_RE_MASK) >> I2S_RCSR_RE_SHIFT)
#define I2S_BRD_RCSR_RE(base) (BME_UBFX32(&I2S_RCSR_REG(base), I2S_RCSR_RE_SHIFT, I2S_RCSR_RE_WIDTH))

/*! @brief Set the RE field to a new value. */
#define I2S_WR_RCSR_RE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_RE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_RE(value)))
#define I2S_BWR_RCSR_RE(base, value) (BME_BFI32(&I2S_RCSR_REG(base), ((uint32_t)(value) << I2S_RCSR_RE_SHIFT), I2S_RCSR_RE_SHIFT, I2S_RCSR_RE_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_RCR1 - SAI Receive Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR1 - SAI Receive Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCR1 register
 */
/*@{*/
#define I2S_RD_RCR1(base)        (I2S_RCR1_REG(base))
#define I2S_WR_RCR1(base, value) (I2S_RCR1_REG(base) = (value))
#define I2S_RMW_RCR1(base, mask, value) (I2S_WR_RCR1(base, (I2S_RD_RCR1(base) & ~(mask)) | (value)))
#define I2S_SET_RCR1(base, value) (BME_OR32(&I2S_RCR1_REG(base), (uint32_t)(value)))
#define I2S_CLR_RCR1(base, value) (BME_AND32(&I2S_RCR1_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_RCR1(base, value) (BME_XOR32(&I2S_RCR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR1 bitfields
 */

/*!
 * @name Register I2S_RCR1, field RFW[1:0] (RW)
 *
 * Configures the watermark level for all enabled receiver channels.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR1_RFW field. */
#define I2S_RD_RCR1_RFW(base) ((I2S_RCR1_REG(base) & I2S_RCR1_RFW_MASK) >> I2S_RCR1_RFW_SHIFT)
#define I2S_BRD_RCR1_RFW(base) (BME_UBFX32(&I2S_RCR1_REG(base), I2S_RCR1_RFW_SHIFT, I2S_RCR1_RFW_WIDTH))

/*! @brief Set the RFW field to a new value. */
#define I2S_WR_RCR1_RFW(base, value) (I2S_RMW_RCR1(base, I2S_RCR1_RFW_MASK, I2S_RCR1_RFW(value)))
#define I2S_BWR_RCR1_RFW(base, value) (BME_BFI32(&I2S_RCR1_REG(base), ((uint32_t)(value) << I2S_RCR1_RFW_SHIFT), I2S_RCR1_RFW_SHIFT, I2S_RCR1_RFW_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_RCR2 - SAI Receive Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR2 - SAI Receive Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR2 register
 */
/*@{*/
#define I2S_RD_RCR2(base)        (I2S_RCR2_REG(base))
#define I2S_WR_RCR2(base, value) (I2S_RCR2_REG(base) = (value))
#define I2S_RMW_RCR2(base, mask, value) (I2S_WR_RCR2(base, (I2S_RD_RCR2(base) & ~(mask)) | (value)))
#define I2S_SET_RCR2(base, value) (BME_OR32(&I2S_RCR2_REG(base), (uint32_t)(value)))
#define I2S_CLR_RCR2(base, value) (BME_AND32(&I2S_RCR2_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_RCR2(base, value) (BME_XOR32(&I2S_RCR2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR2 bitfields
 */

/*!
 * @name Register I2S_RCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_DIV field. */
#define I2S_RD_RCR2_DIV(base) ((I2S_RCR2_REG(base) & I2S_RCR2_DIV_MASK) >> I2S_RCR2_DIV_SHIFT)
#define I2S_BRD_RCR2_DIV(base) (BME_UBFX32(&I2S_RCR2_REG(base), I2S_RCR2_DIV_SHIFT, I2S_RCR2_DIV_WIDTH))

/*! @brief Set the DIV field to a new value. */
#define I2S_WR_RCR2_DIV(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_DIV_MASK, I2S_RCR2_DIV(value)))
#define I2S_BWR_RCR2_DIV(base, value) (BME_BFI32(&I2S_RCR2_REG(base), ((uint32_t)(value) << I2S_RCR2_DIV_SHIFT), I2S_RCR2_DIV_SHIFT, I2S_RCR2_DIV_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0b0 - Bit clock is generated externally in Slave mode.
 * - 0b1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCD field. */
#define I2S_RD_RCR2_BCD(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCD_MASK) >> I2S_RCR2_BCD_SHIFT)
#define I2S_BRD_RCR2_BCD(base) (BME_UBFX32(&I2S_RCR2_REG(base), I2S_RCR2_BCD_SHIFT, I2S_RCR2_BCD_WIDTH))

/*! @brief Set the BCD field to a new value. */
#define I2S_WR_RCR2_BCD(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCD_MASK, I2S_RCR2_BCD(value)))
#define I2S_BWR_RCR2_BCD(base, value) (BME_BFI32(&I2S_RCR2_REG(base), ((uint32_t)(value) << I2S_RCR2_BCD_SHIFT), I2S_RCR2_BCD_SHIFT, I2S_RCR2_BCD_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0b0 - Bit Clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 0b1 - Bit Clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCP field. */
#define I2S_RD_RCR2_BCP(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCP_MASK) >> I2S_RCR2_BCP_SHIFT)
#define I2S_BRD_RCR2_BCP(base) (BME_UBFX32(&I2S_RCR2_REG(base), I2S_RCR2_BCP_SHIFT, I2S_RCR2_BCP_WIDTH))

/*! @brief Set the BCP field to a new value. */
#define I2S_WR_RCR2_BCP(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCP_MASK, I2S_RCR2_BCP(value)))
#define I2S_BWR_RCR2_BCP(base, value) (BME_BFI32(&I2S_RCR2_REG(base), ((uint32_t)(value) << I2S_RCR2_BCP_SHIFT), I2S_RCR2_BCP_SHIFT, I2S_RCR2_BCP_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip configuration details for the availability and
 * chip-specific meaning of each option.
 *
 * Values:
 * - 0b00 - Bus Clock selected.
 * - 0b01 - Master Clock (MCLK) 1 option selected.
 * - 0b10 - Master Clock (MCLK) 2 option selected.
 * - 0b11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_MSEL field. */
#define I2S_RD_RCR2_MSEL(base) ((I2S_RCR2_REG(base) & I2S_RCR2_MSEL_MASK) >> I2S_RCR2_MSEL_SHIFT)
#define I2S_BRD_RCR2_MSEL(base) (BME_UBFX32(&I2S_RCR2_REG(base), I2S_RCR2_MSEL_SHIFT, I2S_RCR2_MSEL_WIDTH))

/*! @brief Set the MSEL field to a new value. */
#define I2S_WR_RCR2_MSEL(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_MSEL_MASK, I2S_RCR2_MSEL(value)))
#define I2S_BWR_RCR2_MSEL(base, value) (BME_BFI32(&I2S_RCR2_REG(base), ((uint32_t)(value) << I2S_RCR2_MSEL_SHIFT), I2S_RCR2_MSEL_SHIFT, I2S_RCR2_MSEL_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the receiver
 * is delayed by the pad output delay (the receiver is clocked by the pad input
 * as if the clock was externally generated). This has the effect of decreasing
 * the data input setup time, but increasing the data output valid time. The slave
 * mode timing from the datasheet should be used for the receiver when this bit
 * is set. In synchronous mode, this bit allows the receiver to use the slave mode
 * timing from the datasheet, while the transmitter uses the master mode timing.
 * This field has no effect when configured for an externally generated bit
 * clock .
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCI field. */
#define I2S_RD_RCR2_BCI(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCI_MASK) >> I2S_RCR2_BCI_SHIFT)
#define I2S_BRD_RCR2_BCI(base) (BME_UBFX32(&I2S_RCR2_REG(base), I2S_RCR2_BCI_SHIFT, I2S_RCR2_BCI_WIDTH))

/*! @brief Set the BCI field to a new value. */
#define I2S_WR_RCR2_BCI(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCI_MASK, I2S_RCR2_BCI(value)))
#define I2S_BWR_RCR2_BCI(base, value) (BME_BFI32(&I2S_RCR2_REG(base), ((uint32_t)(value) << I2S_RCR2_BCI_SHIFT), I2S_RCR2_BCI_SHIFT, I2S_RCR2_BCI_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the receiver. When the receiver is
 * configured in asynchronous mode and this bit is set, the receiver is clocked by
 * the transmitter bit clock (SAI_TX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the receiver continues to use the receiver
 * frame sync (SAI_RX_SYNC). When the receiver is configured in synchronous
 * mode, the transmitter BCS field and receiver BCS field must be set to the same
 * value. When both are set, the transmitter and receiver are both clocked by the
 * receiver bit clock (SAI_RX_BCLK) but use the transmitter frame sync
 * (SAI_TX_SYNC).
 *
 * Values:
 * - 0b0 - Use the normal bit clock source.
 * - 0b1 - Swap the bit clock source.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCS field. */
#define I2S_RD_RCR2_BCS(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCS_MASK) >> I2S_RCR2_BCS_SHIFT)
#define I2S_BRD_RCR2_BCS(base) (BME_UBFX32(&I2S_RCR2_REG(base), I2S_RCR2_BCS_SHIFT, I2S_RCR2_BCS_WIDTH))

/*! @brief Set the BCS field to a new value. */
#define I2S_WR_RCR2_BCS(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCS_MASK, I2S_RCR2_BCS(value)))
#define I2S_BWR_RCR2_BCS(base, value) (BME_BFI32(&I2S_RCR2_REG(base), ((uint32_t)(value) << I2S_RCR2_BCS_SHIFT), I2S_RCR2_BCS_SHIFT, I2S_RCR2_BCS_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the transmitter must be configured
 * for asynchronous operation.
 *
 * Values:
 * - 0b00 - Asynchronous mode.
 * - 0b01 - Synchronous with transmitter.
 * - 0b10 - Synchronous with another SAI receiver.
 * - 0b11 - Synchronous with another SAI transmitter.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_SYNC field. */
#define I2S_RD_RCR2_SYNC(base) ((I2S_RCR2_REG(base) & I2S_RCR2_SYNC_MASK) >> I2S_RCR2_SYNC_SHIFT)
#define I2S_BRD_RCR2_SYNC(base) (BME_UBFX32(&I2S_RCR2_REG(base), I2S_RCR2_SYNC_SHIFT, I2S_RCR2_SYNC_WIDTH))

/*! @brief Set the SYNC field to a new value. */
#define I2S_WR_RCR2_SYNC(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_SYNC_MASK, I2S_RCR2_SYNC(value)))
#define I2S_BWR_RCR2_SYNC(base, value) (BME_BFI32(&I2S_RCR2_REG(base), ((uint32_t)(value) << I2S_RCR2_SYNC_SHIFT), I2S_RCR2_SYNC_SHIFT, I2S_RCR2_SYNC_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_RCR3 - SAI Receive Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR3 - SAI Receive Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCR3 register
 */
/*@{*/
#define I2S_RD_RCR3(base)        (I2S_RCR3_REG(base))
#define I2S_WR_RCR3(base, value) (I2S_RCR3_REG(base) = (value))
#define I2S_RMW_RCR3(base, mask, value) (I2S_WR_RCR3(base, (I2S_RD_RCR3(base) & ~(mask)) | (value)))
#define I2S_SET_RCR3(base, value) (BME_OR32(&I2S_RCR3_REG(base), (uint32_t)(value)))
#define I2S_CLR_RCR3(base, value) (BME_AND32(&I2S_RCR3_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_RCR3(base, value) (BME_XOR32(&I2S_RCR3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR3 bitfields
 */

/*!
 * @name Register I2S_RCR3, field WDFL[3:0] (RW)
 *
 * Configures which word the start of word flag is set. The value written should
 * be one less than the word number (for example, write zero to configure for
 * the first word in the frame). When configured to a value greater than the Frame
 * Size field, then the start of word flag is never set.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR3_WDFL field. */
#define I2S_RD_RCR3_WDFL(base) ((I2S_RCR3_REG(base) & I2S_RCR3_WDFL_MASK) >> I2S_RCR3_WDFL_SHIFT)
#define I2S_BRD_RCR3_WDFL(base) (BME_UBFX32(&I2S_RCR3_REG(base), I2S_RCR3_WDFL_SHIFT, I2S_RCR3_WDFL_WIDTH))

/*! @brief Set the WDFL field to a new value. */
#define I2S_WR_RCR3_WDFL(base, value) (I2S_RMW_RCR3(base, I2S_RCR3_WDFL_MASK, I2S_RCR3_WDFL(value)))
#define I2S_BWR_RCR3_WDFL(base, value) (BME_BFI32(&I2S_RCR3_REG(base), ((uint32_t)(value) << I2S_RCR3_WDFL_SHIFT), I2S_RCR3_WDFL_SHIFT, I2S_RCR3_WDFL_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR3, field RCE[16] (RW)
 *
 * Enables the corresponding data channel for receive operation. A channel must
 * be enabled before its FIFO is accessed. Changing this field will take effect
 * immediately for generating the FIFO request and warning flags, but at the end
 * of each frame for receive operation.
 *
 * Values:
 * - 0b0 - Receive data channel N is disabled.
 * - 0b1 - Receive data channel N is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR3_RCE field. */
#define I2S_RD_RCR3_RCE(base) ((I2S_RCR3_REG(base) & I2S_RCR3_RCE_MASK) >> I2S_RCR3_RCE_SHIFT)
#define I2S_BRD_RCR3_RCE(base) (BME_UBFX32(&I2S_RCR3_REG(base), I2S_RCR3_RCE_SHIFT, I2S_RCR3_RCE_WIDTH))

/*! @brief Set the RCE field to a new value. */
#define I2S_WR_RCR3_RCE(base, value) (I2S_RMW_RCR3(base, I2S_RCR3_RCE_MASK, I2S_RCR3_RCE(value)))
#define I2S_BWR_RCR3_RCE(base, value) (BME_BFI32(&I2S_RCR3_REG(base), ((uint32_t)(value) << I2S_RCR3_RCE_SHIFT), I2S_RCR3_RCE_SHIFT, I2S_RCR3_RCE_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_RCR4 - SAI Receive Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR4 - SAI Receive Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR4 register
 */
/*@{*/
#define I2S_RD_RCR4(base)        (I2S_RCR4_REG(base))
#define I2S_WR_RCR4(base, value) (I2S_RCR4_REG(base) = (value))
#define I2S_RMW_RCR4(base, mask, value) (I2S_WR_RCR4(base, (I2S_RD_RCR4(base) & ~(mask)) | (value)))
#define I2S_SET_RCR4(base, value) (BME_OR32(&I2S_RCR4_REG(base), (uint32_t)(value)))
#define I2S_CLR_RCR4(base, value) (BME_AND32(&I2S_RCR4_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_RCR4(base, value) (BME_XOR32(&I2S_RCR4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR4 bitfields
 */

/*!
 * @name Register I2S_RCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0b0 - Frame Sync is generated externally in Slave mode.
 * - 0b1 - Frame Sync is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSD field. */
#define I2S_RD_RCR4_FSD(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSD_MASK) >> I2S_RCR4_FSD_SHIFT)
#define I2S_BRD_RCR4_FSD(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_FSD_SHIFT, I2S_RCR4_FSD_WIDTH))

/*! @brief Set the FSD field to a new value. */
#define I2S_WR_RCR4_FSD(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSD_MASK, I2S_RCR4_FSD(value)))
#define I2S_BWR_RCR4_FSD(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_FSD_SHIFT), I2S_RCR4_FSD_SHIFT, I2S_RCR4_FSD_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0b0 - Frame sync is active high.
 * - 0b1 - Frame sync is active low.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSP field. */
#define I2S_RD_RCR4_FSP(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSP_MASK) >> I2S_RCR4_FSP_SHIFT)
#define I2S_BRD_RCR4_FSP(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_FSP_SHIFT, I2S_RCR4_FSP_WIDTH))

/*! @brief Set the FSP field to a new value. */
#define I2S_WR_RCR4_FSP(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSP_MASK, I2S_RCR4_FSP(value)))
#define I2S_BWR_RCR4_FSP(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_FSP_SHIFT), I2S_RCR4_FSP_SHIFT, I2S_RCR4_FSP_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field ONDEM[2] (RW)
 *
 * When set, and the frame sync is generated internally, a frame sync is only
 * generated when the FIFO warning flag is clear.
 *
 * Values:
 * - 0b0 - Internal frame sync is generated continuously.
 * - 0b1 - Internal frame sync is generated when the FIFO warning flag is clear.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_ONDEM field. */
#define I2S_RD_RCR4_ONDEM(base) ((I2S_RCR4_REG(base) & I2S_RCR4_ONDEM_MASK) >> I2S_RCR4_ONDEM_SHIFT)
#define I2S_BRD_RCR4_ONDEM(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_ONDEM_SHIFT, I2S_RCR4_ONDEM_WIDTH))

/*! @brief Set the ONDEM field to a new value. */
#define I2S_WR_RCR4_ONDEM(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_ONDEM_MASK, I2S_RCR4_ONDEM(value)))
#define I2S_BWR_RCR4_ONDEM(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_ONDEM_SHIFT), I2S_RCR4_ONDEM_SHIFT, I2S_RCR4_ONDEM_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0b0 - Frame sync asserts with the first bit of the frame.
 * - 0b1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSE field. */
#define I2S_RD_RCR4_FSE(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSE_MASK) >> I2S_RCR4_FSE_SHIFT)
#define I2S_BRD_RCR4_FSE(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_FSE_SHIFT, I2S_RCR4_FSE_WIDTH))

/*! @brief Set the FSE field to a new value. */
#define I2S_WR_RCR4_FSE(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSE_MASK, I2S_RCR4_FSE(value)))
#define I2S_BWR_RCR4_FSE(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_FSE_SHIFT), I2S_RCR4_FSE_SHIFT, I2S_RCR4_FSE_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is received first.
 *
 * Values:
 * - 0b0 - LSB is received first.
 * - 0b1 - MSB is received first.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_MF field. */
#define I2S_RD_RCR4_MF(base) ((I2S_RCR4_REG(base) & I2S_RCR4_MF_MASK) >> I2S_RCR4_MF_SHIFT)
#define I2S_BRD_RCR4_MF(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_MF_SHIFT, I2S_RCR4_MF_WIDTH))

/*! @brief Set the MF field to a new value. */
#define I2S_WR_RCR4_MF(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_MF_MASK, I2S_RCR4_MF(value)))
#define I2S_BWR_RCR4_MF(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_MF_SHIFT), I2S_RCR4_MF_SHIFT, I2S_RCR4_MF_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_SYWD field. */
#define I2S_RD_RCR4_SYWD(base) ((I2S_RCR4_REG(base) & I2S_RCR4_SYWD_MASK) >> I2S_RCR4_SYWD_SHIFT)
#define I2S_BRD_RCR4_SYWD(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_SYWD_SHIFT, I2S_RCR4_SYWD_WIDTH))

/*! @brief Set the SYWD field to a new value. */
#define I2S_WR_RCR4_SYWD(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_SYWD_MASK, I2S_RCR4_SYWD(value)))
#define I2S_BWR_RCR4_SYWD(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_SYWD_SHIFT), I2S_RCR4_SYWD_SHIFT, I2S_RCR4_SYWD_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FRSZ[19:16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 16 words.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FRSZ field. */
#define I2S_RD_RCR4_FRSZ(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FRSZ_MASK) >> I2S_RCR4_FRSZ_SHIFT)
#define I2S_BRD_RCR4_FRSZ(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_FRSZ_SHIFT, I2S_RCR4_FRSZ_WIDTH))

/*! @brief Set the FRSZ field to a new value. */
#define I2S_WR_RCR4_FRSZ(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FRSZ_MASK, I2S_RCR4_FRSZ(value)))
#define I2S_BWR_RCR4_FRSZ(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_FRSZ_SHIFT), I2S_RCR4_FRSZ_SHIFT, I2S_RCR4_FRSZ_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FPACK[25:24] (RW)
 *
 * Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO word. If
 * the word size is greater than 8-bit or 16-bit then only the first 8-bit or
 * 16-bits are stored to the FIFO. The first word in each frame always starts with a
 * new 32-bit FIFO word and the first bit shifted must be configured within the
 * first packed word. When FIFO packing is enabled, the FIFO read pointer will
 * only increment when the full 32-bit FIFO word has been read by software.
 *
 * Values:
 * - 0b00 - FIFO packing is disabled
 * - 0b01 - Reserved.
 * - 0b10 - 8-bit FIFO packing is enabled
 * - 0b11 - 16-bit FIFO packing is enabled
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FPACK field. */
#define I2S_RD_RCR4_FPACK(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FPACK_MASK) >> I2S_RCR4_FPACK_SHIFT)
#define I2S_BRD_RCR4_FPACK(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_FPACK_SHIFT, I2S_RCR4_FPACK_WIDTH))

/*! @brief Set the FPACK field to a new value. */
#define I2S_WR_RCR4_FPACK(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FPACK_MASK, I2S_RCR4_FPACK(value)))
#define I2S_BWR_RCR4_FPACK(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_FPACK_SHIFT), I2S_RCR4_FPACK_SHIFT, I2S_RCR4_FPACK_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FCONT[28] (RW)
 *
 * Configures when the SAI will continue receiving after a FIFO error has been
 * detected.
 *
 * Values:
 * - 0b0 - On FIFO error, the SAI will continue from the start of the next frame
 *     after the FIFO error flag has been cleared.
 * - 0b1 - On FIFO error, the SAI will continue from the same word that caused
 *     the FIFO error to set after the FIFO warning flag has been cleared.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FCONT field. */
#define I2S_RD_RCR4_FCONT(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FCONT_MASK) >> I2S_RCR4_FCONT_SHIFT)
#define I2S_BRD_RCR4_FCONT(base) (BME_UBFX32(&I2S_RCR4_REG(base), I2S_RCR4_FCONT_SHIFT, I2S_RCR4_FCONT_WIDTH))

/*! @brief Set the FCONT field to a new value. */
#define I2S_WR_RCR4_FCONT(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FCONT_MASK, I2S_RCR4_FCONT(value)))
#define I2S_BWR_RCR4_FCONT(base, value) (BME_BFI32(&I2S_RCR4_REG(base), ((uint32_t)(value) << I2S_RCR4_FCONT_SHIFT), I2S_RCR4_FCONT_SHIFT, I2S_RCR4_FCONT_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_RCR5 - SAI Receive Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR5 - SAI Receive Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR5 register
 */
/*@{*/
#define I2S_RD_RCR5(base)        (I2S_RCR5_REG(base))
#define I2S_WR_RCR5(base, value) (I2S_RCR5_REG(base) = (value))
#define I2S_RMW_RCR5(base, mask, value) (I2S_WR_RCR5(base, (I2S_RD_RCR5(base) & ~(mask)) | (value)))
#define I2S_SET_RCR5(base, value) (BME_OR32(&I2S_RCR5_REG(base), (uint32_t)(value)))
#define I2S_CLR_RCR5(base, value) (BME_AND32(&I2S_RCR5_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_RCR5(base, value) (BME_XOR32(&I2S_RCR5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR5 bitfields
 */

/*!
 * @name Register I2S_RCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit received for each word in the
 * frame. If configured for MSB First, the index of the next bit received is one less
 * than the current bit received. If configured for LSB First, the index of the
 * next bit received is one more than the current bit received. The value written
 * must be greater than or equal to the word width when configured for MSB
 * First. The value written must be less than or equal to 31-word width when
 * configured for LSB First.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_FBT field. */
#define I2S_RD_RCR5_FBT(base) ((I2S_RCR5_REG(base) & I2S_RCR5_FBT_MASK) >> I2S_RCR5_FBT_SHIFT)
#define I2S_BRD_RCR5_FBT(base) (BME_UBFX32(&I2S_RCR5_REG(base), I2S_RCR5_FBT_SHIFT, I2S_RCR5_FBT_WIDTH))

/*! @brief Set the FBT field to a new value. */
#define I2S_WR_RCR5_FBT(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_FBT_MASK, I2S_RCR5_FBT(value)))
#define I2S_BWR_RCR5_FBT(base, value) (BME_BFI32(&I2S_RCR5_REG(base), ((uint32_t)(value) << I2S_RCR5_FBT_SHIFT), I2S_RCR5_FBT_SHIFT, I2S_RCR5_FBT_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_W0W field. */
#define I2S_RD_RCR5_W0W(base) ((I2S_RCR5_REG(base) & I2S_RCR5_W0W_MASK) >> I2S_RCR5_W0W_SHIFT)
#define I2S_BRD_RCR5_W0W(base) (BME_UBFX32(&I2S_RCR5_REG(base), I2S_RCR5_W0W_SHIFT, I2S_RCR5_W0W_WIDTH))

/*! @brief Set the W0W field to a new value. */
#define I2S_WR_RCR5_W0W(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_W0W_MASK, I2S_RCR5_W0W(value)))
#define I2S_BWR_RCR5_W0W(base, value) (BME_BFI32(&I2S_RCR5_REG(base), ((uint32_t)(value) << I2S_RCR5_W0W_SHIFT), I2S_RCR5_W0W_SHIFT, I2S_RCR5_W0W_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_WNW field. */
#define I2S_RD_RCR5_WNW(base) ((I2S_RCR5_REG(base) & I2S_RCR5_WNW_MASK) >> I2S_RCR5_WNW_SHIFT)
#define I2S_BRD_RCR5_WNW(base) (BME_UBFX32(&I2S_RCR5_REG(base), I2S_RCR5_WNW_SHIFT, I2S_RCR5_WNW_WIDTH))

/*! @brief Set the WNW field to a new value. */
#define I2S_WR_RCR5_WNW(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_WNW_MASK, I2S_RCR5_WNW(value)))
#define I2S_BWR_RCR5_WNW(base, value) (BME_BFI32(&I2S_RCR5_REG(base), ((uint32_t)(value) << I2S_RCR5_WNW_SHIFT), I2S_RCR5_WNW_SHIFT, I2S_RCR5_WNW_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_RDR - SAI Receive Data Register
 ******************************************************************************/

/*!
 * @brief I2S_RDR - SAI Receive Data Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reading this register introduces one additional peripheral clock wait state
 * on each read.
 */
/*!
 * @name Constants and macros for entire I2S_RDR register
 */
/*@{*/
#define I2S_RD_RDR(base, index)  (I2S_RDR_REG(base, index))
/*@}*/

/*******************************************************************************
 * I2S_RFR - SAI Receive FIFO Register
 ******************************************************************************/

/*!
 * @brief I2S_RFR - SAI Receive FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read and write pointers is used to distinguish between FIFO
 * full and empty conditions. If the read and write pointers are identical, then
 * the FIFO is empty. If the read and write pointers are identical except for the
 * MSB, then the FIFO is full.
 */
/*!
 * @name Constants and macros for entire I2S_RFR register
 */
/*@{*/
#define I2S_RD_RFR(base, index)  (I2S_RFR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual I2S_RFR bitfields
 */

/*!
 * @name Register I2S_RFR, field RFP[2:0] (RO)
 *
 * FIFO read pointer for receive data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_RFR_RFP field. */
#define I2S_RD_RFR_RFP(base, index) ((I2S_RFR_REG(base, index) & I2S_RFR_RFP_MASK) >> I2S_RFR_RFP_SHIFT)
#define I2S_BRD_RFR_RFP(base, index) (BME_UBFX32(&I2S_RFR_REG(base, index), I2S_RFR_RFP_SHIFT, I2S_RFR_RFP_WIDTH))
/*@}*/

/*!
 * @name Register I2S_RFR, field WFP[18:16] (RO)
 *
 * FIFO write pointer for receive data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_RFR_WFP field. */
#define I2S_RD_RFR_WFP(base, index) ((I2S_RFR_REG(base, index) & I2S_RFR_WFP_MASK) >> I2S_RFR_WFP_SHIFT)
#define I2S_BRD_RFR_WFP(base, index) (BME_UBFX32(&I2S_RFR_REG(base, index), I2S_RFR_WFP_SHIFT, I2S_RFR_WFP_WIDTH))
/*@}*/

/*******************************************************************************
 * I2S_RMR - SAI Receive Mask Register
 ******************************************************************************/

/*!
 * @brief I2S_RMR - SAI Receive Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When RCSR[RE] is first set At
 * the end of each frame This allows the masked words in each frame to change from
 * frame to frame.
 */
/*!
 * @name Constants and macros for entire I2S_RMR register
 */
/*@{*/
#define I2S_RD_RMR(base)         (I2S_RMR_REG(base))
#define I2S_WR_RMR(base, value)  (I2S_RMR_REG(base) = (value))
#define I2S_RMW_RMR(base, mask, value) (I2S_WR_RMR(base, (I2S_RD_RMR(base) & ~(mask)) | (value)))
#define I2S_SET_RMR(base, value) (BME_OR32(&I2S_RMR_REG(base), (uint32_t)(value)))
#define I2S_CLR_RMR(base, value) (BME_AND32(&I2S_RMR_REG(base), (uint32_t)(~(value))))
#define I2S_TOG_RMR(base, value) (BME_XOR32(&I2S_RMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RMR bitfields
 */

/*!
 * @name Register I2S_RMR, field RWM[15:0] (RW)
 *
 * Configures whether the receive word is masked (received data ignored and not
 * written to receive FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0b0000000000000000 - Word N is enabled.
 * - 0b0000000000000001 - Word N is masked.
 */
/*@{*/
/*! @brief Read current value of the I2S_RMR_RWM field. */
#define I2S_RD_RMR_RWM(base) ((I2S_RMR_REG(base) & I2S_RMR_RWM_MASK) >> I2S_RMR_RWM_SHIFT)
#define I2S_BRD_RMR_RWM(base) (I2S_RD_RMR_RWM(base))

/*! @brief Set the RWM field to a new value. */
#define I2S_WR_RMR_RWM(base, value) (I2S_RMW_RMR(base, I2S_RMR_RWM_MASK, I2S_RMR_RWM(value)))
#define I2S_BWR_RMR_RWM(base, value) (I2S_WR_RMR_RWM(base, value))
/*@}*/

/*
 * MKL28Z7 INTMUX
 *
 * Interrupt Multiplexer
 *
 * Registers defined in this header file:
 * - INTMUX_CHn_CSR - Channel n Control Status Register
 * - INTMUX_CHn_VEC - Channel n Vector Number Register
 * - INTMUX_CHn_IER_31_0 - Channel n Interrupt Enable Register
 * - INTMUX_CHn_IPR_31_0 - Channel n Interrupt Pending Register
 */

#define INTMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the INTMUX module. */
#define INTMUX0_IDX (0U) /*!< Instance number for INTMUX0. */

/*******************************************************************************
 * INTMUX_CHn_CSR - Channel n Control Status Register
 ******************************************************************************/

/*!
 * @brief INTMUX_CHn_CSR - Channel n Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire INTMUX_CHn_CSR register
 */
/*@{*/
#define INTMUX_RD_CHn_CSR(base, index) (INTMUX_CHn_CSR_REG(base, index))
#define INTMUX_WR_CHn_CSR(base, index, value) (INTMUX_CHn_CSR_REG(base, index) = (value))
#define INTMUX_RMW_CHn_CSR(base, index, mask, value) (INTMUX_WR_CHn_CSR(base, index, (INTMUX_RD_CHn_CSR(base, index) & ~(mask)) | (value)))
#define INTMUX_SET_CHn_CSR(base, index, value) (BME_OR32(&INTMUX_CHn_CSR_REG(base, index), (uint32_t)(value)))
#define INTMUX_CLR_CHn_CSR(base, index, value) (BME_AND32(&INTMUX_CHn_CSR_REG(base, index), (uint32_t)(~(value))))
#define INTMUX_TOG_CHn_CSR(base, index, value) (BME_XOR32(&INTMUX_CHn_CSR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual INTMUX_CHn_CSR bitfields
 */

/*!
 * @name Register INTMUX_CHn_CSR, field RST[0] (RW)
 *
 * This bit is used to software reset this channel. This bit always reads as 0.
 *
 * Values:
 * - 0b0 - No operation.
 * - 0b1 - Perform a software reset on this channel.
 */
/*@{*/
/*! @brief Read current value of the INTMUX_CHn_CSR_RST field. */
#define INTMUX_RD_CHn_CSR_RST(base, index) ((INTMUX_CHn_CSR_REG(base, index) & INTMUX_CHn_CSR_RST_MASK) >> INTMUX_CHn_CSR_RST_SHIFT)
#define INTMUX_BRD_CHn_CSR_RST(base, index) (BME_UBFX32(&INTMUX_CHn_CSR_REG(base, index), INTMUX_CHn_CSR_RST_SHIFT, INTMUX_CHn_CSR_RST_WIDTH))

/*! @brief Set the RST field to a new value. */
#define INTMUX_WR_CHn_CSR_RST(base, index, value) (INTMUX_RMW_CHn_CSR(base, index, INTMUX_CHn_CSR_RST_MASK, INTMUX_CHn_CSR_RST(value)))
#define INTMUX_BWR_CHn_CSR_RST(base, index, value) (BME_BFI32(&INTMUX_CHn_CSR_REG(base, index), ((uint32_t)(value) << INTMUX_CHn_CSR_RST_SHIFT), INTMUX_CHn_CSR_RST_SHIFT, INTMUX_CHn_CSR_RST_WIDTH))
/*@}*/

/*!
 * @name Register INTMUX_CHn_CSR, field AND[1] (RW)
 *
 * This bit used to Logic AND or Logic OR all enabled interrupt inputs of this
 * channel and generate the interrput output of this channel.
 *
 * Values:
 * - 0b0 - Logic OR all enabled interrupt inputs.
 * - 0b1 - Logic AND all enabled interrupt inputs.
 */
/*@{*/
/*! @brief Read current value of the INTMUX_CHn_CSR_AND field. */
#define INTMUX_RD_CHn_CSR_AND(base, index) ((INTMUX_CHn_CSR_REG(base, index) & INTMUX_CHn_CSR_AND_MASK) >> INTMUX_CHn_CSR_AND_SHIFT)
#define INTMUX_BRD_CHn_CSR_AND(base, index) (BME_UBFX32(&INTMUX_CHn_CSR_REG(base, index), INTMUX_CHn_CSR_AND_SHIFT, INTMUX_CHn_CSR_AND_WIDTH))

/*! @brief Set the AND field to a new value. */
#define INTMUX_WR_CHn_CSR_AND(base, index, value) (INTMUX_RMW_CHn_CSR(base, index, INTMUX_CHn_CSR_AND_MASK, INTMUX_CHn_CSR_AND(value)))
#define INTMUX_BWR_CHn_CSR_AND(base, index, value) (BME_BFI32(&INTMUX_CHn_CSR_REG(base, index), ((uint32_t)(value) << INTMUX_CHn_CSR_AND_SHIFT), INTMUX_CHn_CSR_AND_SHIFT, INTMUX_CHn_CSR_AND_WIDTH))
/*@}*/

/*!
 * @name Register INTMUX_CHn_CSR, field IRQN[5:4] (RO)
 *
 * These bits represent the interrupt input number of this channel.
 *
 * Values:
 * - 0b00 - 32 interrupt inputs
 * - 0b01 - Reserved
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the INTMUX_CHn_CSR_IRQN field. */
#define INTMUX_RD_CHn_CSR_IRQN(base, index) ((INTMUX_CHn_CSR_REG(base, index) & INTMUX_CHn_CSR_IRQN_MASK) >> INTMUX_CHn_CSR_IRQN_SHIFT)
#define INTMUX_BRD_CHn_CSR_IRQN(base, index) (BME_UBFX32(&INTMUX_CHn_CSR_REG(base, index), INTMUX_CHn_CSR_IRQN_SHIFT, INTMUX_CHn_CSR_IRQN_WIDTH))
/*@}*/

/*!
 * @name Register INTMUX_CHn_CSR, field CHIN[11:8] (RO)
 *
 * These bits represent the instance number of this channel.
 */
/*@{*/
/*! @brief Read current value of the INTMUX_CHn_CSR_CHIN field. */
#define INTMUX_RD_CHn_CSR_CHIN(base, index) ((INTMUX_CHn_CSR_REG(base, index) & INTMUX_CHn_CSR_CHIN_MASK) >> INTMUX_CHn_CSR_CHIN_SHIFT)
#define INTMUX_BRD_CHn_CSR_CHIN(base, index) (BME_UBFX32(&INTMUX_CHn_CSR_REG(base, index), INTMUX_CHn_CSR_CHIN_SHIFT, INTMUX_CHn_CSR_CHIN_WIDTH))
/*@}*/

/*!
 * @name Register INTMUX_CHn_CSR, field IRQP[31] (RO)
 *
 * This bit is available for polling purposes and represents the channel output.
 *
 * Values:
 * - 0b0 - No interrupt is pending.
 * - 0b1 - The interrupt output of this channel is pending.
 */
/*@{*/
/*! @brief Read current value of the INTMUX_CHn_CSR_IRQP field. */
#define INTMUX_RD_CHn_CSR_IRQP(base, index) ((INTMUX_CHn_CSR_REG(base, index) & INTMUX_CHn_CSR_IRQP_MASK) >> INTMUX_CHn_CSR_IRQP_SHIFT)
#define INTMUX_BRD_CHn_CSR_IRQP(base, index) (BME_UBFX32(&INTMUX_CHn_CSR_REG(base, index), INTMUX_CHn_CSR_IRQP_SHIFT, INTMUX_CHn_CSR_IRQP_WIDTH))
/*@}*/

/*******************************************************************************
 * INTMUX_CHn_VEC - Channel n Vector Number Register
 ******************************************************************************/

/*!
 * @brief INTMUX_CHn_VEC - Channel n Vector Number Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire INTMUX_CHn_VEC register
 */
/*@{*/
#define INTMUX_RD_CHn_VEC(base, index) (INTMUX_CHn_VEC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual INTMUX_CHn_VEC bitfields
 */

/*!
 * @name Register INTMUX_CHn_VEC, field VECN[13:2] (RO)
 *
 * These bits represent the vector number for the highest priority interrupt
 * source of this channel.
 */
/*@{*/
/*! @brief Read current value of the INTMUX_CHn_VEC_VECN field. */
#define INTMUX_RD_CHn_VEC_VECN(base, index) ((INTMUX_CHn_VEC_REG(base, index) & INTMUX_CHn_VEC_VECN_MASK) >> INTMUX_CHn_VEC_VECN_SHIFT)
#define INTMUX_BRD_CHn_VEC_VECN(base, index) (INTMUX_RD_CHn_VEC_VECN(base, index))
/*@}*/

/*******************************************************************************
 * INTMUX_CHn_IER_31_0 - Channel n Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief INTMUX_CHn_IER_31_0 - Channel n Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire INTMUX_CHn_IER_31_0 register
 */
/*@{*/
#define INTMUX_RD_CHn_IER_31_0(base, index) (INTMUX_CHn_IER_31_0_REG(base, index))
#define INTMUX_WR_CHn_IER_31_0(base, index, value) (INTMUX_CHn_IER_31_0_REG(base, index) = (value))
#define INTMUX_RMW_CHn_IER_31_0(base, index, mask, value) (INTMUX_WR_CHn_IER_31_0(base, index, (INTMUX_RD_CHn_IER_31_0(base, index) & ~(mask)) | (value)))
#define INTMUX_SET_CHn_IER_31_0(base, index, value) (BME_OR32(&INTMUX_CHn_IER_31_0_REG(base, index), (uint32_t)(value)))
#define INTMUX_CLR_CHn_IER_31_0(base, index, value) (BME_AND32(&INTMUX_CHn_IER_31_0_REG(base, index), (uint32_t)(~(value))))
#define INTMUX_TOG_CHn_IER_31_0(base, index, value) (BME_XOR32(&INTMUX_CHn_IER_31_0_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * INTMUX_CHn_IPR_31_0 - Channel n Interrupt Pending Register
 ******************************************************************************/

/*!
 * @brief INTMUX_CHn_IPR_31_0 - Channel n Interrupt Pending Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire INTMUX_CHn_IPR_31_0 register
 */
/*@{*/
#define INTMUX_RD_CHn_IPR_31_0(base, index) (INTMUX_CHn_IPR_31_0_REG(base, index))
/*@}*/

/*
 * MKL28Z7 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - LLWU_VERID - Version ID Register
 * - LLWU_PARAM - Parameter Register
 * - LLWU_PE1 - LLWU Pin Enable 1 register
 * - LLWU_PE2 - LLWU Pin Enable 2 register
 * - LLWU_ME - LLWU Module Interrupt Enable register
 * - LLWU_DE - LLWU Module DMA Enable register
 * - LLWU_PF - LLWU Pin Flag register
 * - LLWU_MF - LLWU Module Interrupt Flag register
 * - LLWU_FILT - LLWU Pin Filter register
 */

#define LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define LLWU0_IDX (0U) /*!< Instance number for LLWU0. */

/*******************************************************************************
 * LLWU_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LLWU_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire LLWU_VERID register
 */
/*@{*/
#define LLWU_RD_VERID(base)      (LLWU_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_VERID bitfields
 */

/*!
 * @name Register LLWU_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000000 - Standard features implemented
 */
/*@{*/
/*! @brief Read current value of the LLWU_VERID_FEATURE field. */
#define LLWU_RD_VERID_FEATURE(base) ((LLWU_VERID_REG(base) & LLWU_VERID_FEATURE_MASK) >> LLWU_VERID_FEATURE_SHIFT)
#define LLWU_BRD_VERID_FEATURE(base) (LLWU_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LLWU_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LLWU_VERID_MINOR field. */
#define LLWU_RD_VERID_MINOR(base) ((LLWU_VERID_REG(base) & LLWU_VERID_MINOR_MASK) >> LLWU_VERID_MINOR_SHIFT)
#define LLWU_BRD_VERID_MINOR(base) (BME_UBFX32(&LLWU_VERID_REG(base), LLWU_VERID_MINOR_SHIFT, LLWU_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LLWU_VERID_MAJOR field. */
#define LLWU_RD_VERID_MAJOR(base) ((LLWU_VERID_REG(base) & LLWU_VERID_MAJOR_MASK) >> LLWU_VERID_MAJOR_SHIFT)
#define LLWU_BRD_VERID_MAJOR(base) (BME_UBFX32(&LLWU_VERID_REG(base), LLWU_VERID_MAJOR_SHIFT, LLWU_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LLWU_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x20080804U
 */
/*!
 * @name Constants and macros for entire LLWU_PARAM register
 */
/*@{*/
#define LLWU_RD_PARAM(base)      (LLWU_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_PARAM bitfields
 */

/*!
 * @name Register LLWU_PARAM, field FILTERS[7:0] (RO)
 *
 * Number of Pin Filters implemented
 */
/*@{*/
/*! @brief Read current value of the LLWU_PARAM_FILTERS field. */
#define LLWU_RD_PARAM_FILTERS(base) ((LLWU_PARAM_REG(base) & LLWU_PARAM_FILTERS_MASK) >> LLWU_PARAM_FILTERS_SHIFT)
#define LLWU_BRD_PARAM_FILTERS(base) (BME_UBFX32(&LLWU_PARAM_REG(base), LLWU_PARAM_FILTERS_SHIFT, LLWU_PARAM_FILTERS_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PARAM, field DMAS[15:8] (RO)
 *
 * Number of DMA wakeup sources supported
 */
/*@{*/
/*! @brief Read current value of the LLWU_PARAM_DMAS field. */
#define LLWU_RD_PARAM_DMAS(base) ((LLWU_PARAM_REG(base) & LLWU_PARAM_DMAS_MASK) >> LLWU_PARAM_DMAS_SHIFT)
#define LLWU_BRD_PARAM_DMAS(base) (BME_UBFX32(&LLWU_PARAM_REG(base), LLWU_PARAM_DMAS_SHIFT, LLWU_PARAM_DMAS_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PARAM, field MODULES[23:16] (RO)
 *
 * Number of Module wakeup sources supported
 */
/*@{*/
/*! @brief Read current value of the LLWU_PARAM_MODULES field. */
#define LLWU_RD_PARAM_MODULES(base) ((LLWU_PARAM_REG(base) & LLWU_PARAM_MODULES_MASK) >> LLWU_PARAM_MODULES_SHIFT)
#define LLWU_BRD_PARAM_MODULES(base) (BME_UBFX32(&LLWU_PARAM_REG(base), LLWU_PARAM_MODULES_SHIFT, LLWU_PARAM_MODULES_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PARAM, field PINS[31:24] (RO)
 *
 * Number of Pin wakeup sources supported
 */
/*@{*/
/*! @brief Read current value of the LLWU_PARAM_PINS field. */
#define LLWU_RD_PARAM_PINS(base) ((LLWU_PARAM_REG(base) & LLWU_PARAM_PINS_MASK) >> LLWU_PARAM_PINS_SHIFT)
#define LLWU_BRD_PARAM_PINS(base) (BME_UBFX32(&LLWU_PARAM_REG(base), LLWU_PARAM_PINS_SHIFT, LLWU_PARAM_PINS_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define LLWU_RD_PE1(base)        (LLWU_PE1_REG(base))
#define LLWU_WR_PE1(base, value) (LLWU_PE1_REG(base) = (value))
#define LLWU_RMW_PE1(base, mask, value) (LLWU_WR_PE1(base, (LLWU_RD_PE1(base) & ~(mask)) | (value)))
#define LLWU_SET_PE1(base, value) (BME_OR32(&LLWU_PE1_REG(base), (uint32_t)(value)))
#define LLWU_CLR_PE1(base, value) (BME_AND32(&LLWU_PE1_REG(base), (uint32_t)(~(value))))
#define LLWU_TOG_PE1(base, value) (BME_XOR32(&LLWU_PE1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define LLWU_RD_PE1_WUPE0(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE0_MASK) >> LLWU_PE1_WUPE0_SHIFT)
#define LLWU_BRD_PE1_WUPE0(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))

/*! @brief Set the WUPE0 field to a new value. */
#define LLWU_WR_PE1_WUPE0(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE0(value)))
#define LLWU_BWR_PE1_WUPE0(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE0_SHIFT), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define LLWU_RD_PE1_WUPE1(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE1_MASK) >> LLWU_PE1_WUPE1_SHIFT)
#define LLWU_BRD_PE1_WUPE1(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))

/*! @brief Set the WUPE1 field to a new value. */
#define LLWU_WR_PE1_WUPE1(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE1(value)))
#define LLWU_BWR_PE1_WUPE1(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE1_SHIFT), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define LLWU_RD_PE1_WUPE2(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE2_MASK) >> LLWU_PE1_WUPE2_SHIFT)
#define LLWU_BRD_PE1_WUPE2(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))

/*! @brief Set the WUPE2 field to a new value. */
#define LLWU_WR_PE1_WUPE2(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE2(value)))
#define LLWU_BWR_PE1_WUPE2(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE2_SHIFT), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define LLWU_RD_PE1_WUPE3(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE3_MASK) >> LLWU_PE1_WUPE3_SHIFT)
#define LLWU_BRD_PE1_WUPE3(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))

/*! @brief Set the WUPE3 field to a new value. */
#define LLWU_WR_PE1_WUPE3(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE3_MASK, LLWU_PE1_WUPE3(value)))
#define LLWU_BWR_PE1_WUPE3(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE3_SHIFT), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE4[9:8] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE4 field. */
#define LLWU_RD_PE1_WUPE4(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE4_MASK) >> LLWU_PE1_WUPE4_SHIFT)
#define LLWU_BRD_PE1_WUPE4(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE4_SHIFT, LLWU_PE1_WUPE4_WIDTH))

/*! @brief Set the WUPE4 field to a new value. */
#define LLWU_WR_PE1_WUPE4(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE4_MASK, LLWU_PE1_WUPE4(value)))
#define LLWU_BWR_PE1_WUPE4(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE4_SHIFT), LLWU_PE1_WUPE4_SHIFT, LLWU_PE1_WUPE4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE5[11:10] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE5 field. */
#define LLWU_RD_PE1_WUPE5(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE5_MASK) >> LLWU_PE1_WUPE5_SHIFT)
#define LLWU_BRD_PE1_WUPE5(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE5_SHIFT, LLWU_PE1_WUPE5_WIDTH))

/*! @brief Set the WUPE5 field to a new value. */
#define LLWU_WR_PE1_WUPE5(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE5_MASK, LLWU_PE1_WUPE5(value)))
#define LLWU_BWR_PE1_WUPE5(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE5_SHIFT), LLWU_PE1_WUPE5_SHIFT, LLWU_PE1_WUPE5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE6[13:12] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE6 field. */
#define LLWU_RD_PE1_WUPE6(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE6_MASK) >> LLWU_PE1_WUPE6_SHIFT)
#define LLWU_BRD_PE1_WUPE6(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE6_SHIFT, LLWU_PE1_WUPE6_WIDTH))

/*! @brief Set the WUPE6 field to a new value. */
#define LLWU_WR_PE1_WUPE6(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE6_MASK, LLWU_PE1_WUPE6(value)))
#define LLWU_BWR_PE1_WUPE6(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE6_SHIFT), LLWU_PE1_WUPE6_SHIFT, LLWU_PE1_WUPE6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE7[15:14] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE7 field. */
#define LLWU_RD_PE1_WUPE7(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE7_MASK) >> LLWU_PE1_WUPE7_SHIFT)
#define LLWU_BRD_PE1_WUPE7(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE7_SHIFT, LLWU_PE1_WUPE7_WIDTH))

/*! @brief Set the WUPE7 field to a new value. */
#define LLWU_WR_PE1_WUPE7(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE7_MASK, LLWU_PE1_WUPE7(value)))
#define LLWU_BWR_PE1_WUPE7(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE7_SHIFT), LLWU_PE1_WUPE7_SHIFT, LLWU_PE1_WUPE7_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE8[17:16] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE8 field. */
#define LLWU_RD_PE1_WUPE8(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE8_MASK) >> LLWU_PE1_WUPE8_SHIFT)
#define LLWU_BRD_PE1_WUPE8(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE8_SHIFT, LLWU_PE1_WUPE8_WIDTH))

/*! @brief Set the WUPE8 field to a new value. */
#define LLWU_WR_PE1_WUPE8(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE8_MASK, LLWU_PE1_WUPE8(value)))
#define LLWU_BWR_PE1_WUPE8(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE8_SHIFT), LLWU_PE1_WUPE8_SHIFT, LLWU_PE1_WUPE8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE9[19:18] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE9 field. */
#define LLWU_RD_PE1_WUPE9(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE9_MASK) >> LLWU_PE1_WUPE9_SHIFT)
#define LLWU_BRD_PE1_WUPE9(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE9_SHIFT, LLWU_PE1_WUPE9_WIDTH))

/*! @brief Set the WUPE9 field to a new value. */
#define LLWU_WR_PE1_WUPE9(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE9_MASK, LLWU_PE1_WUPE9(value)))
#define LLWU_BWR_PE1_WUPE9(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE9_SHIFT), LLWU_PE1_WUPE9_SHIFT, LLWU_PE1_WUPE9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE10[21:20] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE10 field. */
#define LLWU_RD_PE1_WUPE10(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE10_MASK) >> LLWU_PE1_WUPE10_SHIFT)
#define LLWU_BRD_PE1_WUPE10(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE10_SHIFT, LLWU_PE1_WUPE10_WIDTH))

/*! @brief Set the WUPE10 field to a new value. */
#define LLWU_WR_PE1_WUPE10(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE10_MASK, LLWU_PE1_WUPE10(value)))
#define LLWU_BWR_PE1_WUPE10(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE10_SHIFT), LLWU_PE1_WUPE10_SHIFT, LLWU_PE1_WUPE10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE11[23:22] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE11 field. */
#define LLWU_RD_PE1_WUPE11(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE11_MASK) >> LLWU_PE1_WUPE11_SHIFT)
#define LLWU_BRD_PE1_WUPE11(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE11_SHIFT, LLWU_PE1_WUPE11_WIDTH))

/*! @brief Set the WUPE11 field to a new value. */
#define LLWU_WR_PE1_WUPE11(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE11_MASK, LLWU_PE1_WUPE11(value)))
#define LLWU_BWR_PE1_WUPE11(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE11_SHIFT), LLWU_PE1_WUPE11_SHIFT, LLWU_PE1_WUPE11_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE12[25:24] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE12 field. */
#define LLWU_RD_PE1_WUPE12(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE12_MASK) >> LLWU_PE1_WUPE12_SHIFT)
#define LLWU_BRD_PE1_WUPE12(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE12_SHIFT, LLWU_PE1_WUPE12_WIDTH))

/*! @brief Set the WUPE12 field to a new value. */
#define LLWU_WR_PE1_WUPE12(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE12_MASK, LLWU_PE1_WUPE12(value)))
#define LLWU_BWR_PE1_WUPE12(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE12_SHIFT), LLWU_PE1_WUPE12_SHIFT, LLWU_PE1_WUPE12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE13[27:26] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE13 field. */
#define LLWU_RD_PE1_WUPE13(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE13_MASK) >> LLWU_PE1_WUPE13_SHIFT)
#define LLWU_BRD_PE1_WUPE13(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE13_SHIFT, LLWU_PE1_WUPE13_WIDTH))

/*! @brief Set the WUPE13 field to a new value. */
#define LLWU_WR_PE1_WUPE13(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE13_MASK, LLWU_PE1_WUPE13(value)))
#define LLWU_BWR_PE1_WUPE13(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE13_SHIFT), LLWU_PE1_WUPE13_SHIFT, LLWU_PE1_WUPE13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE14[29:28] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE14 field. */
#define LLWU_RD_PE1_WUPE14(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE14_MASK) >> LLWU_PE1_WUPE14_SHIFT)
#define LLWU_BRD_PE1_WUPE14(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE14_SHIFT, LLWU_PE1_WUPE14_WIDTH))

/*! @brief Set the WUPE14 field to a new value. */
#define LLWU_WR_PE1_WUPE14(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE14_MASK, LLWU_PE1_WUPE14(value)))
#define LLWU_BWR_PE1_WUPE14(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE14_SHIFT), LLWU_PE1_WUPE14_SHIFT, LLWU_PE1_WUPE14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE15[31:30] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE15 field. */
#define LLWU_RD_PE1_WUPE15(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE15_MASK) >> LLWU_PE1_WUPE15_SHIFT)
#define LLWU_BRD_PE1_WUPE15(base) (BME_UBFX32(&LLWU_PE1_REG(base), LLWU_PE1_WUPE15_SHIFT, LLWU_PE1_WUPE15_WIDTH))

/*! @brief Set the WUPE15 field to a new value. */
#define LLWU_WR_PE1_WUPE15(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE15_MASK, LLWU_PE1_WUPE15(value)))
#define LLWU_BWR_PE1_WUPE15(base, value) (BME_BFI32(&LLWU_PE1_REG(base), ((uint32_t)(value) << LLWU_PE1_WUPE15_SHIFT), LLWU_PE1_WUPE15_SHIFT, LLWU_PE1_WUPE15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P31-LLWU_P16. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define LLWU_RD_PE2(base)        (LLWU_PE2_REG(base))
#define LLWU_WR_PE2(base, value) (LLWU_PE2_REG(base) = (value))
#define LLWU_RMW_PE2(base, mask, value) (LLWU_WR_PE2(base, (LLWU_RD_PE2(base) & ~(mask)) | (value)))
#define LLWU_SET_PE2(base, value) (BME_OR32(&LLWU_PE2_REG(base), (uint32_t)(value)))
#define LLWU_CLR_PE2(base, value) (BME_AND32(&LLWU_PE2_REG(base), (uint32_t)(~(value))))
#define LLWU_TOG_PE2(base, value) (BME_XOR32(&LLWU_PE2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE16[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE16 field. */
#define LLWU_RD_PE2_WUPE16(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE16_MASK) >> LLWU_PE2_WUPE16_SHIFT)
#define LLWU_BRD_PE2_WUPE16(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE16_SHIFT, LLWU_PE2_WUPE16_WIDTH))

/*! @brief Set the WUPE16 field to a new value. */
#define LLWU_WR_PE2_WUPE16(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE16_MASK, LLWU_PE2_WUPE16(value)))
#define LLWU_BWR_PE2_WUPE16(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE16_SHIFT), LLWU_PE2_WUPE16_SHIFT, LLWU_PE2_WUPE16_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE17[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE17 field. */
#define LLWU_RD_PE2_WUPE17(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE17_MASK) >> LLWU_PE2_WUPE17_SHIFT)
#define LLWU_BRD_PE2_WUPE17(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE17_SHIFT, LLWU_PE2_WUPE17_WIDTH))

/*! @brief Set the WUPE17 field to a new value. */
#define LLWU_WR_PE2_WUPE17(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE17_MASK, LLWU_PE2_WUPE17(value)))
#define LLWU_BWR_PE2_WUPE17(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE17_SHIFT), LLWU_PE2_WUPE17_SHIFT, LLWU_PE2_WUPE17_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE18[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE18 field. */
#define LLWU_RD_PE2_WUPE18(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE18_MASK) >> LLWU_PE2_WUPE18_SHIFT)
#define LLWU_BRD_PE2_WUPE18(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE18_SHIFT, LLWU_PE2_WUPE18_WIDTH))

/*! @brief Set the WUPE18 field to a new value. */
#define LLWU_WR_PE2_WUPE18(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE18_MASK, LLWU_PE2_WUPE18(value)))
#define LLWU_BWR_PE2_WUPE18(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE18_SHIFT), LLWU_PE2_WUPE18_SHIFT, LLWU_PE2_WUPE18_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE19[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE19 field. */
#define LLWU_RD_PE2_WUPE19(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE19_MASK) >> LLWU_PE2_WUPE19_SHIFT)
#define LLWU_BRD_PE2_WUPE19(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE19_SHIFT, LLWU_PE2_WUPE19_WIDTH))

/*! @brief Set the WUPE19 field to a new value. */
#define LLWU_WR_PE2_WUPE19(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE19_MASK, LLWU_PE2_WUPE19(value)))
#define LLWU_BWR_PE2_WUPE19(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE19_SHIFT), LLWU_PE2_WUPE19_SHIFT, LLWU_PE2_WUPE19_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE20[9:8] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE20 field. */
#define LLWU_RD_PE2_WUPE20(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE20_MASK) >> LLWU_PE2_WUPE20_SHIFT)
#define LLWU_BRD_PE2_WUPE20(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE20_SHIFT, LLWU_PE2_WUPE20_WIDTH))

/*! @brief Set the WUPE20 field to a new value. */
#define LLWU_WR_PE2_WUPE20(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE20_MASK, LLWU_PE2_WUPE20(value)))
#define LLWU_BWR_PE2_WUPE20(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE20_SHIFT), LLWU_PE2_WUPE20_SHIFT, LLWU_PE2_WUPE20_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE21[11:10] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE21 field. */
#define LLWU_RD_PE2_WUPE21(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE21_MASK) >> LLWU_PE2_WUPE21_SHIFT)
#define LLWU_BRD_PE2_WUPE21(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE21_SHIFT, LLWU_PE2_WUPE21_WIDTH))

/*! @brief Set the WUPE21 field to a new value. */
#define LLWU_WR_PE2_WUPE21(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE21_MASK, LLWU_PE2_WUPE21(value)))
#define LLWU_BWR_PE2_WUPE21(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE21_SHIFT), LLWU_PE2_WUPE21_SHIFT, LLWU_PE2_WUPE21_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE22[13:12] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE22 field. */
#define LLWU_RD_PE2_WUPE22(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE22_MASK) >> LLWU_PE2_WUPE22_SHIFT)
#define LLWU_BRD_PE2_WUPE22(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE22_SHIFT, LLWU_PE2_WUPE22_WIDTH))

/*! @brief Set the WUPE22 field to a new value. */
#define LLWU_WR_PE2_WUPE22(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE22_MASK, LLWU_PE2_WUPE22(value)))
#define LLWU_BWR_PE2_WUPE22(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE22_SHIFT), LLWU_PE2_WUPE22_SHIFT, LLWU_PE2_WUPE22_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE23[15:14] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE23 field. */
#define LLWU_RD_PE2_WUPE23(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE23_MASK) >> LLWU_PE2_WUPE23_SHIFT)
#define LLWU_BRD_PE2_WUPE23(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE23_SHIFT, LLWU_PE2_WUPE23_WIDTH))

/*! @brief Set the WUPE23 field to a new value. */
#define LLWU_WR_PE2_WUPE23(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE23_MASK, LLWU_PE2_WUPE23(value)))
#define LLWU_BWR_PE2_WUPE23(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE23_SHIFT), LLWU_PE2_WUPE23_SHIFT, LLWU_PE2_WUPE23_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE24[17:16] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE24 field. */
#define LLWU_RD_PE2_WUPE24(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE24_MASK) >> LLWU_PE2_WUPE24_SHIFT)
#define LLWU_BRD_PE2_WUPE24(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE24_SHIFT, LLWU_PE2_WUPE24_WIDTH))

/*! @brief Set the WUPE24 field to a new value. */
#define LLWU_WR_PE2_WUPE24(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE24_MASK, LLWU_PE2_WUPE24(value)))
#define LLWU_BWR_PE2_WUPE24(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE24_SHIFT), LLWU_PE2_WUPE24_SHIFT, LLWU_PE2_WUPE24_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE25[19:18] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE25 field. */
#define LLWU_RD_PE2_WUPE25(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE25_MASK) >> LLWU_PE2_WUPE25_SHIFT)
#define LLWU_BRD_PE2_WUPE25(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE25_SHIFT, LLWU_PE2_WUPE25_WIDTH))

/*! @brief Set the WUPE25 field to a new value. */
#define LLWU_WR_PE2_WUPE25(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE25_MASK, LLWU_PE2_WUPE25(value)))
#define LLWU_BWR_PE2_WUPE25(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE25_SHIFT), LLWU_PE2_WUPE25_SHIFT, LLWU_PE2_WUPE25_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE26[21:20] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE26 field. */
#define LLWU_RD_PE2_WUPE26(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE26_MASK) >> LLWU_PE2_WUPE26_SHIFT)
#define LLWU_BRD_PE2_WUPE26(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE26_SHIFT, LLWU_PE2_WUPE26_WIDTH))

/*! @brief Set the WUPE26 field to a new value. */
#define LLWU_WR_PE2_WUPE26(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE26_MASK, LLWU_PE2_WUPE26(value)))
#define LLWU_BWR_PE2_WUPE26(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE26_SHIFT), LLWU_PE2_WUPE26_SHIFT, LLWU_PE2_WUPE26_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE27[23:22] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE27 field. */
#define LLWU_RD_PE2_WUPE27(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE27_MASK) >> LLWU_PE2_WUPE27_SHIFT)
#define LLWU_BRD_PE2_WUPE27(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE27_SHIFT, LLWU_PE2_WUPE27_WIDTH))

/*! @brief Set the WUPE27 field to a new value. */
#define LLWU_WR_PE2_WUPE27(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE27_MASK, LLWU_PE2_WUPE27(value)))
#define LLWU_BWR_PE2_WUPE27(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE27_SHIFT), LLWU_PE2_WUPE27_SHIFT, LLWU_PE2_WUPE27_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE28[25:24] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE28 field. */
#define LLWU_RD_PE2_WUPE28(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE28_MASK) >> LLWU_PE2_WUPE28_SHIFT)
#define LLWU_BRD_PE2_WUPE28(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE28_SHIFT, LLWU_PE2_WUPE28_WIDTH))

/*! @brief Set the WUPE28 field to a new value. */
#define LLWU_WR_PE2_WUPE28(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE28_MASK, LLWU_PE2_WUPE28(value)))
#define LLWU_BWR_PE2_WUPE28(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE28_SHIFT), LLWU_PE2_WUPE28_SHIFT, LLWU_PE2_WUPE28_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE29[27:26] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE29 field. */
#define LLWU_RD_PE2_WUPE29(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE29_MASK) >> LLWU_PE2_WUPE29_SHIFT)
#define LLWU_BRD_PE2_WUPE29(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE29_SHIFT, LLWU_PE2_WUPE29_WIDTH))

/*! @brief Set the WUPE29 field to a new value. */
#define LLWU_WR_PE2_WUPE29(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE29_MASK, LLWU_PE2_WUPE29(value)))
#define LLWU_BWR_PE2_WUPE29(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE29_SHIFT), LLWU_PE2_WUPE29_SHIFT, LLWU_PE2_WUPE29_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE30[29:28] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE30 field. */
#define LLWU_RD_PE2_WUPE30(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE30_MASK) >> LLWU_PE2_WUPE30_SHIFT)
#define LLWU_BRD_PE2_WUPE30(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE30_SHIFT, LLWU_PE2_WUPE30_WIDTH))

/*! @brief Set the WUPE30 field to a new value. */
#define LLWU_WR_PE2_WUPE30(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE30_MASK, LLWU_PE2_WUPE30(value)))
#define LLWU_BWR_PE2_WUPE30(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE30_SHIFT), LLWU_PE2_WUPE30_SHIFT, LLWU_PE2_WUPE30_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE31[31:30] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE31 field. */
#define LLWU_RD_PE2_WUPE31(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE31_MASK) >> LLWU_PE2_WUPE31_SHIFT)
#define LLWU_BRD_PE2_WUPE31(base) (BME_UBFX32(&LLWU_PE2_REG(base), LLWU_PE2_WUPE31_SHIFT, LLWU_PE2_WUPE31_WIDTH))

/*! @brief Set the WUPE31 field to a new value. */
#define LLWU_WR_PE2_WUPE31(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE31_MASK, LLWU_PE2_WUPE31(value)))
#define LLWU_BWR_PE2_WUPE31(base, value) (BME_BFI32(&LLWU_PE2_REG(base), ((uint32_t)(value) << LLWU_PE2_WUPE31_SHIFT), LLWU_PE2_WUPE31_SHIFT, LLWU_PE2_WUPE31_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_ME - LLWU Module Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief LLWU_ME - LLWU Module Interrupt Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * LLWU_ME contains the bits to enable an internal module interrupt as a wakeup
 * source for inputs LLWU_M7IF - LLWU_M0IF. This register is reset on Chip Reset
 * not VLLS and by reset types that trigger Chip Reset not VLLS. It is unaffected
 * by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the chip's
 * reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define LLWU_RD_ME(base)         (LLWU_ME_REG(base))
#define LLWU_WR_ME(base, value)  (LLWU_ME_REG(base) = (value))
#define LLWU_RMW_ME(base, mask, value) (LLWU_WR_ME(base, (LLWU_RD_ME(base) & ~(mask)) | (value)))
#define LLWU_SET_ME(base, value) (BME_OR32(&LLWU_ME_REG(base), (uint32_t)(value)))
#define LLWU_CLR_ME(base, value) (BME_AND32(&LLWU_ME_REG(base), (uint32_t)(~(value))))
#define LLWU_TOG_ME(base, value) (BME_XOR32(&LLWU_ME_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define LLWU_RD_ME_WUME0(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME0_MASK) >> LLWU_ME_WUME0_SHIFT)
#define LLWU_BRD_ME_WUME0(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))

/*! @brief Set the WUME0 field to a new value. */
#define LLWU_WR_ME_WUME0(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME0_MASK, LLWU_ME_WUME0(value)))
#define LLWU_BWR_ME_WUME0(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME0_SHIFT), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define LLWU_RD_ME_WUME1(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME1_MASK) >> LLWU_ME_WUME1_SHIFT)
#define LLWU_BRD_ME_WUME1(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))

/*! @brief Set the WUME1 field to a new value. */
#define LLWU_WR_ME_WUME1(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME1_MASK, LLWU_ME_WUME1(value)))
#define LLWU_BWR_ME_WUME1(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME1_SHIFT), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define LLWU_RD_ME_WUME2(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME2_MASK) >> LLWU_ME_WUME2_SHIFT)
#define LLWU_BRD_ME_WUME2(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))

/*! @brief Set the WUME2 field to a new value. */
#define LLWU_WR_ME_WUME2(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME2_MASK, LLWU_ME_WUME2(value)))
#define LLWU_BWR_ME_WUME2(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME2_SHIFT), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define LLWU_RD_ME_WUME3(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME3_MASK) >> LLWU_ME_WUME3_SHIFT)
#define LLWU_BRD_ME_WUME3(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))

/*! @brief Set the WUME3 field to a new value. */
#define LLWU_WR_ME_WUME3(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME3_MASK, LLWU_ME_WUME3(value)))
#define LLWU_BWR_ME_WUME3(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME3_SHIFT), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define LLWU_RD_ME_WUME4(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME4_MASK) >> LLWU_ME_WUME4_SHIFT)
#define LLWU_BRD_ME_WUME4(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))

/*! @brief Set the WUME4 field to a new value. */
#define LLWU_WR_ME_WUME4(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME4_MASK, LLWU_ME_WUME4(value)))
#define LLWU_BWR_ME_WUME4(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME4_SHIFT), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define LLWU_RD_ME_WUME5(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME5_MASK) >> LLWU_ME_WUME5_SHIFT)
#define LLWU_BRD_ME_WUME5(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))

/*! @brief Set the WUME5 field to a new value. */
#define LLWU_WR_ME_WUME5(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME5_MASK, LLWU_ME_WUME5(value)))
#define LLWU_BWR_ME_WUME5(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME5_SHIFT), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define LLWU_RD_ME_WUME6(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME6_MASK) >> LLWU_ME_WUME6_SHIFT)
#define LLWU_BRD_ME_WUME6(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))

/*! @brief Set the WUME6 field to a new value. */
#define LLWU_WR_ME_WUME6(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME6_MASK, LLWU_ME_WUME6(value)))
#define LLWU_BWR_ME_WUME6(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME6_SHIFT), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define LLWU_RD_ME_WUME7(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME7_MASK) >> LLWU_ME_WUME7_SHIFT)
#define LLWU_BRD_ME_WUME7(base) (BME_UBFX32(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))

/*! @brief Set the WUME7 field to a new value. */
#define LLWU_WR_ME_WUME7(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME7_MASK, LLWU_ME_WUME7(value)))
#define LLWU_BWR_ME_WUME7(base, value) (BME_BFI32(&LLWU_ME_REG(base), ((uint32_t)(value) << LLWU_ME_WUME7_SHIFT), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_DE - LLWU Module DMA Enable register
 ******************************************************************************/

/*!
 * @brief LLWU_DE - LLWU Module DMA Enable register (RW)
 *
 * Reset value: 0x00000000U
 *
 * LLWU_DE contains the bits to enable an internal module DMA request as a
 * wakeup source for inputs LLWU_M7DR - LLWU_M0DR . This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_DE register
 */
/*@{*/
#define LLWU_RD_DE(base)         (LLWU_DE_REG(base))
#define LLWU_WR_DE(base, value)  (LLWU_DE_REG(base) = (value))
#define LLWU_RMW_DE(base, mask, value) (LLWU_WR_DE(base, (LLWU_RD_DE(base) & ~(mask)) | (value)))
#define LLWU_SET_DE(base, value) (BME_OR32(&LLWU_DE_REG(base), (uint32_t)(value)))
#define LLWU_CLR_DE(base, value) (BME_AND32(&LLWU_DE_REG(base), (uint32_t)(~(value))))
#define LLWU_TOG_DE(base, value) (BME_XOR32(&LLWU_DE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_DE bitfields
 */

/*!
 * @name Register LLWU_DE, field WUDE0[0] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE0 field. */
#define LLWU_RD_DE_WUDE0(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE0_MASK) >> LLWU_DE_WUDE0_SHIFT)
#define LLWU_BRD_DE_WUDE0(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE0_SHIFT, LLWU_DE_WUDE0_WIDTH))

/*! @brief Set the WUDE0 field to a new value. */
#define LLWU_WR_DE_WUDE0(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE0_MASK, LLWU_DE_WUDE0(value)))
#define LLWU_BWR_DE_WUDE0(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE0_SHIFT), LLWU_DE_WUDE0_SHIFT, LLWU_DE_WUDE0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_DE, field WUDE1[1] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE1 field. */
#define LLWU_RD_DE_WUDE1(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE1_MASK) >> LLWU_DE_WUDE1_SHIFT)
#define LLWU_BRD_DE_WUDE1(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE1_SHIFT, LLWU_DE_WUDE1_WIDTH))

/*! @brief Set the WUDE1 field to a new value. */
#define LLWU_WR_DE_WUDE1(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE1_MASK, LLWU_DE_WUDE1(value)))
#define LLWU_BWR_DE_WUDE1(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE1_SHIFT), LLWU_DE_WUDE1_SHIFT, LLWU_DE_WUDE1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_DE, field WUDE2[2] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE2 field. */
#define LLWU_RD_DE_WUDE2(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE2_MASK) >> LLWU_DE_WUDE2_SHIFT)
#define LLWU_BRD_DE_WUDE2(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE2_SHIFT, LLWU_DE_WUDE2_WIDTH))

/*! @brief Set the WUDE2 field to a new value. */
#define LLWU_WR_DE_WUDE2(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE2_MASK, LLWU_DE_WUDE2(value)))
#define LLWU_BWR_DE_WUDE2(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE2_SHIFT), LLWU_DE_WUDE2_SHIFT, LLWU_DE_WUDE2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_DE, field WUDE3[3] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE3 field. */
#define LLWU_RD_DE_WUDE3(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE3_MASK) >> LLWU_DE_WUDE3_SHIFT)
#define LLWU_BRD_DE_WUDE3(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE3_SHIFT, LLWU_DE_WUDE3_WIDTH))

/*! @brief Set the WUDE3 field to a new value. */
#define LLWU_WR_DE_WUDE3(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE3_MASK, LLWU_DE_WUDE3(value)))
#define LLWU_BWR_DE_WUDE3(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE3_SHIFT), LLWU_DE_WUDE3_SHIFT, LLWU_DE_WUDE3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_DE, field WUDE4[4] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE4 field. */
#define LLWU_RD_DE_WUDE4(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE4_MASK) >> LLWU_DE_WUDE4_SHIFT)
#define LLWU_BRD_DE_WUDE4(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE4_SHIFT, LLWU_DE_WUDE4_WIDTH))

/*! @brief Set the WUDE4 field to a new value. */
#define LLWU_WR_DE_WUDE4(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE4_MASK, LLWU_DE_WUDE4(value)))
#define LLWU_BWR_DE_WUDE4(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE4_SHIFT), LLWU_DE_WUDE4_SHIFT, LLWU_DE_WUDE4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_DE, field WUDE5[5] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE5 field. */
#define LLWU_RD_DE_WUDE5(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE5_MASK) >> LLWU_DE_WUDE5_SHIFT)
#define LLWU_BRD_DE_WUDE5(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE5_SHIFT, LLWU_DE_WUDE5_WIDTH))

/*! @brief Set the WUDE5 field to a new value. */
#define LLWU_WR_DE_WUDE5(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE5_MASK, LLWU_DE_WUDE5(value)))
#define LLWU_BWR_DE_WUDE5(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE5_SHIFT), LLWU_DE_WUDE5_SHIFT, LLWU_DE_WUDE5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_DE, field WUDE6[6] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE6 field. */
#define LLWU_RD_DE_WUDE6(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE6_MASK) >> LLWU_DE_WUDE6_SHIFT)
#define LLWU_BRD_DE_WUDE6(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE6_SHIFT, LLWU_DE_WUDE6_WIDTH))

/*! @brief Set the WUDE6 field to a new value. */
#define LLWU_WR_DE_WUDE6(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE6_MASK, LLWU_DE_WUDE6(value)))
#define LLWU_BWR_DE_WUDE6(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE6_SHIFT), LLWU_DE_WUDE6_SHIFT, LLWU_DE_WUDE6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_DE, field WUDE7[7] (RW)
 *
 * Enables an internal module as a DMA wakeup source.
 *
 * Values:
 * - 0b0 - Internal module request not used as a DMA wakeup source
 * - 0b1 - Internal module request used as a DMA wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_DE_WUDE7 field. */
#define LLWU_RD_DE_WUDE7(base) ((LLWU_DE_REG(base) & LLWU_DE_WUDE7_MASK) >> LLWU_DE_WUDE7_SHIFT)
#define LLWU_BRD_DE_WUDE7(base) (BME_UBFX32(&LLWU_DE_REG(base), LLWU_DE_WUDE7_SHIFT, LLWU_DE_WUDE7_WIDTH))

/*! @brief Set the WUDE7 field to a new value. */
#define LLWU_WR_DE_WUDE7(base, value) (LLWU_RMW_DE(base, LLWU_DE_WUDE7_MASK, LLWU_DE_WUDE7(value)))
#define LLWU_BWR_DE_WUDE7(base, value) (BME_BFI32(&LLWU_DE_REG(base), ((uint32_t)(value) << LLWU_DE_WUDE7_SHIFT), LLWU_DE_WUDE7_SHIFT, LLWU_DE_WUDE7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF - LLWU Pin Flag register
 ******************************************************************************/

/*!
 * @brief LLWU_PF - LLWU Pin Flag register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * LLWU_PF contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF register
 */
/*@{*/
#define LLWU_RD_PF(base)         (LLWU_PF_REG(base))
#define LLWU_WR_PF(base, value)  (LLWU_PF_REG(base) = (value))
#define LLWU_RMW_PF(base, mask, value) (LLWU_WR_PF(base, (LLWU_RD_PF(base) & ~(mask)) | (value)))
#define LLWU_SET_PF(base, value) (BME_OR32(&LLWU_PF_REG(base), (uint32_t)(value)))
#define LLWU_CLR_PF(base, value) (BME_AND32(&LLWU_PF_REG(base), (uint32_t)(~(value))))
#define LLWU_TOG_PF(base, value) (BME_XOR32(&LLWU_PF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF bitfields
 */

/*!
 * @name Register LLWU_PF, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF0.
 *
 * Values:
 * - 0b0 - LLWU_P0 input was not a wakeup source
 * - 0b1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF0 field. */
#define LLWU_RD_PF_WUF0(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF0_MASK) >> LLWU_PF_WUF0_SHIFT)
#define LLWU_BRD_PF_WUF0(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF0_SHIFT, LLWU_PF_WUF0_WIDTH))

/*! @brief Set the WUF0 field to a new value. */
#define LLWU_WR_PF_WUF0(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF0(value)))
#define LLWU_BWR_PF_WUF0(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF0_SHIFT), LLWU_PF_WUF0_SHIFT, LLWU_PF_WUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF1.
 *
 * Values:
 * - 0b0 - LLWU_P1 input was not a wakeup source
 * - 0b1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF1 field. */
#define LLWU_RD_PF_WUF1(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF1_MASK) >> LLWU_PF_WUF1_SHIFT)
#define LLWU_BRD_PF_WUF1(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF1_SHIFT, LLWU_PF_WUF1_WIDTH))

/*! @brief Set the WUF1 field to a new value. */
#define LLWU_WR_PF_WUF1(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF1_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF1(value)))
#define LLWU_BWR_PF_WUF1(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF1_SHIFT), LLWU_PF_WUF1_SHIFT, LLWU_PF_WUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF2.
 *
 * Values:
 * - 0b0 - LLWU_P2 input was not a wakeup source
 * - 0b1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF2 field. */
#define LLWU_RD_PF_WUF2(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF2_MASK) >> LLWU_PF_WUF2_SHIFT)
#define LLWU_BRD_PF_WUF2(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF2_SHIFT, LLWU_PF_WUF2_WIDTH))

/*! @brief Set the WUF2 field to a new value. */
#define LLWU_WR_PF_WUF2(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF2_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF2(value)))
#define LLWU_BWR_PF_WUF2(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF2_SHIFT), LLWU_PF_WUF2_SHIFT, LLWU_PF_WUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF3.
 *
 * Values:
 * - 0b0 - LLWU_P3 input was not a wakeup source
 * - 0b1 - LLWU_P3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF3 field. */
#define LLWU_RD_PF_WUF3(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF3_MASK) >> LLWU_PF_WUF3_SHIFT)
#define LLWU_BRD_PF_WUF3(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF3_SHIFT, LLWU_PF_WUF3_WIDTH))

/*! @brief Set the WUF3 field to a new value. */
#define LLWU_WR_PF_WUF3(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF3_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF3(value)))
#define LLWU_BWR_PF_WUF3(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF3_SHIFT), LLWU_PF_WUF3_SHIFT, LLWU_PF_WUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF4.
 *
 * Values:
 * - 0b0 - LLWU_P4 input was not a wakeup source
 * - 0b1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF4 field. */
#define LLWU_RD_PF_WUF4(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF4_MASK) >> LLWU_PF_WUF4_SHIFT)
#define LLWU_BRD_PF_WUF4(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF4_SHIFT, LLWU_PF_WUF4_WIDTH))

/*! @brief Set the WUF4 field to a new value. */
#define LLWU_WR_PF_WUF4(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF4_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF4(value)))
#define LLWU_BWR_PF_WUF4(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF4_SHIFT), LLWU_PF_WUF4_SHIFT, LLWU_PF_WUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF5.
 *
 * Values:
 * - 0b0 - LLWU_P5 input was not a wakeup source
 * - 0b1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF5 field. */
#define LLWU_RD_PF_WUF5(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF5_MASK) >> LLWU_PF_WUF5_SHIFT)
#define LLWU_BRD_PF_WUF5(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF5_SHIFT, LLWU_PF_WUF5_WIDTH))

/*! @brief Set the WUF5 field to a new value. */
#define LLWU_WR_PF_WUF5(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF5_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF5(value)))
#define LLWU_BWR_PF_WUF5(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF5_SHIFT), LLWU_PF_WUF5_SHIFT, LLWU_PF_WUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF6.
 *
 * Values:
 * - 0b0 - LLWU_P6 input was not a wakeup source
 * - 0b1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF6 field. */
#define LLWU_RD_PF_WUF6(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF6_MASK) >> LLWU_PF_WUF6_SHIFT)
#define LLWU_BRD_PF_WUF6(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF6_SHIFT, LLWU_PF_WUF6_WIDTH))

/*! @brief Set the WUF6 field to a new value. */
#define LLWU_WR_PF_WUF6(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF6_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF6(value)))
#define LLWU_BWR_PF_WUF6(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF6_SHIFT), LLWU_PF_WUF6_SHIFT, LLWU_PF_WUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF7.
 *
 * Values:
 * - 0b0 - LLWU_P7 input was not a wakeup source
 * - 0b1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF7 field. */
#define LLWU_RD_PF_WUF7(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF7_MASK) >> LLWU_PF_WUF7_SHIFT)
#define LLWU_BRD_PF_WUF7(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF7_SHIFT, LLWU_PF_WUF7_WIDTH))

/*! @brief Set the WUF7 field to a new value. */
#define LLWU_WR_PF_WUF7(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF7_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF7(value)))
#define LLWU_BWR_PF_WUF7(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF7_SHIFT), LLWU_PF_WUF7_SHIFT, LLWU_PF_WUF7_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF8[8] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF8.
 *
 * Values:
 * - 0b0 - LLWU_P8 input was not a wakeup source
 * - 0b1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF8 field. */
#define LLWU_RD_PF_WUF8(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF8_MASK) >> LLWU_PF_WUF8_SHIFT)
#define LLWU_BRD_PF_WUF8(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF8_SHIFT, LLWU_PF_WUF8_WIDTH))

/*! @brief Set the WUF8 field to a new value. */
#define LLWU_WR_PF_WUF8(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF8_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF8(value)))
#define LLWU_BWR_PF_WUF8(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF8_SHIFT), LLWU_PF_WUF8_SHIFT, LLWU_PF_WUF8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF9[9] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF9.
 *
 * Values:
 * - 0b0 - LLWU_P9 input was not a wakeup source
 * - 0b1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF9 field. */
#define LLWU_RD_PF_WUF9(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF9_MASK) >> LLWU_PF_WUF9_SHIFT)
#define LLWU_BRD_PF_WUF9(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF9_SHIFT, LLWU_PF_WUF9_WIDTH))

/*! @brief Set the WUF9 field to a new value. */
#define LLWU_WR_PF_WUF9(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF9_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF9(value)))
#define LLWU_BWR_PF_WUF9(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF9_SHIFT), LLWU_PF_WUF9_SHIFT, LLWU_PF_WUF9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF10[10] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF10.
 *
 * Values:
 * - 0b0 - LLWU_P10 input was not a wakeup source
 * - 0b1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF10 field. */
#define LLWU_RD_PF_WUF10(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF10_MASK) >> LLWU_PF_WUF10_SHIFT)
#define LLWU_BRD_PF_WUF10(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF10_SHIFT, LLWU_PF_WUF10_WIDTH))

/*! @brief Set the WUF10 field to a new value. */
#define LLWU_WR_PF_WUF10(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF10_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF10(value)))
#define LLWU_BWR_PF_WUF10(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF10_SHIFT), LLWU_PF_WUF10_SHIFT, LLWU_PF_WUF10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF11[11] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF11.
 *
 * Values:
 * - 0b0 - LLWU_P11 input was not a wakeup source
 * - 0b1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF11 field. */
#define LLWU_RD_PF_WUF11(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF11_MASK) >> LLWU_PF_WUF11_SHIFT)
#define LLWU_BRD_PF_WUF11(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF11_SHIFT, LLWU_PF_WUF11_WIDTH))

/*! @brief Set the WUF11 field to a new value. */
#define LLWU_WR_PF_WUF11(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF11_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF11(value)))
#define LLWU_BWR_PF_WUF11(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF11_SHIFT), LLWU_PF_WUF11_SHIFT, LLWU_PF_WUF11_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF12[12] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF12.
 *
 * Values:
 * - 0b0 - LLWU_P12 input was not a wakeup source
 * - 0b1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF12 field. */
#define LLWU_RD_PF_WUF12(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF12_MASK) >> LLWU_PF_WUF12_SHIFT)
#define LLWU_BRD_PF_WUF12(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF12_SHIFT, LLWU_PF_WUF12_WIDTH))

/*! @brief Set the WUF12 field to a new value. */
#define LLWU_WR_PF_WUF12(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF12_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF12(value)))
#define LLWU_BWR_PF_WUF12(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF12_SHIFT), LLWU_PF_WUF12_SHIFT, LLWU_PF_WUF12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF13[13] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF13.
 *
 * Values:
 * - 0b0 - LLWU_P13 input was not a wakeup source
 * - 0b1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF13 field. */
#define LLWU_RD_PF_WUF13(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF13_MASK) >> LLWU_PF_WUF13_SHIFT)
#define LLWU_BRD_PF_WUF13(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF13_SHIFT, LLWU_PF_WUF13_WIDTH))

/*! @brief Set the WUF13 field to a new value. */
#define LLWU_WR_PF_WUF13(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF13_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF13(value)))
#define LLWU_BWR_PF_WUF13(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF13_SHIFT), LLWU_PF_WUF13_SHIFT, LLWU_PF_WUF13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF14[14] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF14.
 *
 * Values:
 * - 0b0 - LLWU_P14 input was not a wakeup source
 * - 0b1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF14 field. */
#define LLWU_RD_PF_WUF14(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF14_MASK) >> LLWU_PF_WUF14_SHIFT)
#define LLWU_BRD_PF_WUF14(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF14_SHIFT, LLWU_PF_WUF14_WIDTH))

/*! @brief Set the WUF14 field to a new value. */
#define LLWU_WR_PF_WUF14(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF14_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF14(value)))
#define LLWU_BWR_PF_WUF14(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF14_SHIFT), LLWU_PF_WUF14_SHIFT, LLWU_PF_WUF14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF15[15] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF15.
 *
 * Values:
 * - 0b0 - LLWU_P15 input was not a wakeup source
 * - 0b1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF15 field. */
#define LLWU_RD_PF_WUF15(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF15_MASK) >> LLWU_PF_WUF15_SHIFT)
#define LLWU_BRD_PF_WUF15(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF15_SHIFT, LLWU_PF_WUF15_WIDTH))

/*! @brief Set the WUF15 field to a new value. */
#define LLWU_WR_PF_WUF15(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF15_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF15(value)))
#define LLWU_BWR_PF_WUF15(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF15_SHIFT), LLWU_PF_WUF15_SHIFT, LLWU_PF_WUF15_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF16[16] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF16.
 *
 * Values:
 * - 0b0 - LLWU_P16 input was not a wakeup source
 * - 0b1 - LLWU_P16 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF16 field. */
#define LLWU_RD_PF_WUF16(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF16_MASK) >> LLWU_PF_WUF16_SHIFT)
#define LLWU_BRD_PF_WUF16(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF16_SHIFT, LLWU_PF_WUF16_WIDTH))

/*! @brief Set the WUF16 field to a new value. */
#define LLWU_WR_PF_WUF16(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF16_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF16(value)))
#define LLWU_BWR_PF_WUF16(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF16_SHIFT), LLWU_PF_WUF16_SHIFT, LLWU_PF_WUF16_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF17[17] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF17.
 *
 * Values:
 * - 0b0 - LLWU_P17 input was not a wakeup source
 * - 0b1 - LLWU_P17 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF17 field. */
#define LLWU_RD_PF_WUF17(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF17_MASK) >> LLWU_PF_WUF17_SHIFT)
#define LLWU_BRD_PF_WUF17(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF17_SHIFT, LLWU_PF_WUF17_WIDTH))

/*! @brief Set the WUF17 field to a new value. */
#define LLWU_WR_PF_WUF17(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF17_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF17(value)))
#define LLWU_BWR_PF_WUF17(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF17_SHIFT), LLWU_PF_WUF17_SHIFT, LLWU_PF_WUF17_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF18[18] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF18.
 *
 * Values:
 * - 0b0 - LLWU_P18 input was not a wakeup source
 * - 0b1 - LLWU_P18 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF18 field. */
#define LLWU_RD_PF_WUF18(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF18_MASK) >> LLWU_PF_WUF18_SHIFT)
#define LLWU_BRD_PF_WUF18(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF18_SHIFT, LLWU_PF_WUF18_WIDTH))

/*! @brief Set the WUF18 field to a new value. */
#define LLWU_WR_PF_WUF18(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF18_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF18(value)))
#define LLWU_BWR_PF_WUF18(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF18_SHIFT), LLWU_PF_WUF18_SHIFT, LLWU_PF_WUF18_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF19[19] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF19.
 *
 * Values:
 * - 0b0 - LLWU_P19 input was not a wakeup source
 * - 0b1 - LLWU_P19 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF19 field. */
#define LLWU_RD_PF_WUF19(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF19_MASK) >> LLWU_PF_WUF19_SHIFT)
#define LLWU_BRD_PF_WUF19(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF19_SHIFT, LLWU_PF_WUF19_WIDTH))

/*! @brief Set the WUF19 field to a new value. */
#define LLWU_WR_PF_WUF19(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF19_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF19(value)))
#define LLWU_BWR_PF_WUF19(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF19_SHIFT), LLWU_PF_WUF19_SHIFT, LLWU_PF_WUF19_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF20[20] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF20.
 *
 * Values:
 * - 0b0 - LLWU_P20 input was not a wakeup source
 * - 0b1 - LLWU_P20 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF20 field. */
#define LLWU_RD_PF_WUF20(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF20_MASK) >> LLWU_PF_WUF20_SHIFT)
#define LLWU_BRD_PF_WUF20(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF20_SHIFT, LLWU_PF_WUF20_WIDTH))

/*! @brief Set the WUF20 field to a new value. */
#define LLWU_WR_PF_WUF20(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF20_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF20(value)))
#define LLWU_BWR_PF_WUF20(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF20_SHIFT), LLWU_PF_WUF20_SHIFT, LLWU_PF_WUF20_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF21[21] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF21.
 *
 * Values:
 * - 0b0 - LLWU_P21 input was not a wakeup source
 * - 0b1 - LLWU_P21 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF21 field. */
#define LLWU_RD_PF_WUF21(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF21_MASK) >> LLWU_PF_WUF21_SHIFT)
#define LLWU_BRD_PF_WUF21(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF21_SHIFT, LLWU_PF_WUF21_WIDTH))

/*! @brief Set the WUF21 field to a new value. */
#define LLWU_WR_PF_WUF21(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF21_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF21(value)))
#define LLWU_BWR_PF_WUF21(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF21_SHIFT), LLWU_PF_WUF21_SHIFT, LLWU_PF_WUF21_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF22[22] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF22.
 *
 * Values:
 * - 0b0 - LLWU_P22 input was not a wakeup source
 * - 0b1 - LLWU_P22 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF22 field. */
#define LLWU_RD_PF_WUF22(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF22_MASK) >> LLWU_PF_WUF22_SHIFT)
#define LLWU_BRD_PF_WUF22(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF22_SHIFT, LLWU_PF_WUF22_WIDTH))

/*! @brief Set the WUF22 field to a new value. */
#define LLWU_WR_PF_WUF22(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF22_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF22(value)))
#define LLWU_BWR_PF_WUF22(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF22_SHIFT), LLWU_PF_WUF22_SHIFT, LLWU_PF_WUF22_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF23[23] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF23.
 *
 * Values:
 * - 0b0 - LLWU_P23 input was not a wakeup source
 * - 0b1 - LLWU_P23 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF23 field. */
#define LLWU_RD_PF_WUF23(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF23_MASK) >> LLWU_PF_WUF23_SHIFT)
#define LLWU_BRD_PF_WUF23(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF23_SHIFT, LLWU_PF_WUF23_WIDTH))

/*! @brief Set the WUF23 field to a new value. */
#define LLWU_WR_PF_WUF23(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF23_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF23(value)))
#define LLWU_BWR_PF_WUF23(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF23_SHIFT), LLWU_PF_WUF23_SHIFT, LLWU_PF_WUF23_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF24[24] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF24.
 *
 * Values:
 * - 0b0 - LLWU_P24 input was not a wakeup source
 * - 0b1 - LLWU_P24 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF24 field. */
#define LLWU_RD_PF_WUF24(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF24_MASK) >> LLWU_PF_WUF24_SHIFT)
#define LLWU_BRD_PF_WUF24(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF24_SHIFT, LLWU_PF_WUF24_WIDTH))

/*! @brief Set the WUF24 field to a new value. */
#define LLWU_WR_PF_WUF24(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF24_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF24(value)))
#define LLWU_BWR_PF_WUF24(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF24_SHIFT), LLWU_PF_WUF24_SHIFT, LLWU_PF_WUF24_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF25[25] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF25.
 *
 * Values:
 * - 0b0 - LLWU_P25 input was not a wakeup source
 * - 0b1 - LLWU_P25 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF25 field. */
#define LLWU_RD_PF_WUF25(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF25_MASK) >> LLWU_PF_WUF25_SHIFT)
#define LLWU_BRD_PF_WUF25(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF25_SHIFT, LLWU_PF_WUF25_WIDTH))

/*! @brief Set the WUF25 field to a new value. */
#define LLWU_WR_PF_WUF25(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF25_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF25(value)))
#define LLWU_BWR_PF_WUF25(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF25_SHIFT), LLWU_PF_WUF25_SHIFT, LLWU_PF_WUF25_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF26[26] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF26.
 *
 * Values:
 * - 0b0 - LLWU_P26 input was not a wakeup source
 * - 0b1 - LLWU_P26 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF26 field. */
#define LLWU_RD_PF_WUF26(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF26_MASK) >> LLWU_PF_WUF26_SHIFT)
#define LLWU_BRD_PF_WUF26(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF26_SHIFT, LLWU_PF_WUF26_WIDTH))

/*! @brief Set the WUF26 field to a new value. */
#define LLWU_WR_PF_WUF26(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF26_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF26(value)))
#define LLWU_BWR_PF_WUF26(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF26_SHIFT), LLWU_PF_WUF26_SHIFT, LLWU_PF_WUF26_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF27[27] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF27.
 *
 * Values:
 * - 0b0 - LLWU_P27 input was not a wakeup source
 * - 0b1 - LLWU_P27 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF27 field. */
#define LLWU_RD_PF_WUF27(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF27_MASK) >> LLWU_PF_WUF27_SHIFT)
#define LLWU_BRD_PF_WUF27(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF27_SHIFT, LLWU_PF_WUF27_WIDTH))

/*! @brief Set the WUF27 field to a new value. */
#define LLWU_WR_PF_WUF27(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF27_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF27(value)))
#define LLWU_BWR_PF_WUF27(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF27_SHIFT), LLWU_PF_WUF27_SHIFT, LLWU_PF_WUF27_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF28[28] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF28.
 *
 * Values:
 * - 0b0 - LLWU_P28 input was not a wakeup source
 * - 0b1 - LLWU_P28 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF28 field. */
#define LLWU_RD_PF_WUF28(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF28_MASK) >> LLWU_PF_WUF28_SHIFT)
#define LLWU_BRD_PF_WUF28(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF28_SHIFT, LLWU_PF_WUF28_WIDTH))

/*! @brief Set the WUF28 field to a new value. */
#define LLWU_WR_PF_WUF28(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF28_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF28(value)))
#define LLWU_BWR_PF_WUF28(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF28_SHIFT), LLWU_PF_WUF28_SHIFT, LLWU_PF_WUF28_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF29[29] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF29.
 *
 * Values:
 * - 0b0 - LLWU_P29 input was not a wakeup source
 * - 0b1 - LLWU_P29 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF29 field. */
#define LLWU_RD_PF_WUF29(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF29_MASK) >> LLWU_PF_WUF29_SHIFT)
#define LLWU_BRD_PF_WUF29(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF29_SHIFT, LLWU_PF_WUF29_WIDTH))

/*! @brief Set the WUF29 field to a new value. */
#define LLWU_WR_PF_WUF29(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF29_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF30_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF29(value)))
#define LLWU_BWR_PF_WUF29(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF29_SHIFT), LLWU_PF_WUF29_SHIFT, LLWU_PF_WUF29_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF30[30] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF30.
 *
 * Values:
 * - 0b0 - LLWU_P30 input was not a wakeup source
 * - 0b1 - LLWU_P30 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF30 field. */
#define LLWU_RD_PF_WUF30(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF30_MASK) >> LLWU_PF_WUF30_SHIFT)
#define LLWU_BRD_PF_WUF30(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF30_SHIFT, LLWU_PF_WUF30_WIDTH))

/*! @brief Set the WUF30 field to a new value. */
#define LLWU_WR_PF_WUF30(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF30_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF31_MASK), LLWU_PF_WUF30(value)))
#define LLWU_BWR_PF_WUF30(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF30_SHIFT), LLWU_PF_WUF30_SHIFT, LLWU_PF_WUF30_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF, field WUF31[31] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF31.
 *
 * Values:
 * - 0b0 - LLWU_P31 input was not a wakeup source
 * - 0b1 - LLWU_P31 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF_WUF31 field. */
#define LLWU_RD_PF_WUF31(base) ((LLWU_PF_REG(base) & LLWU_PF_WUF31_MASK) >> LLWU_PF_WUF31_SHIFT)
#define LLWU_BRD_PF_WUF31(base) (BME_UBFX32(&LLWU_PF_REG(base), LLWU_PF_WUF31_SHIFT, LLWU_PF_WUF31_WIDTH))

/*! @brief Set the WUF31 field to a new value. */
#define LLWU_WR_PF_WUF31(base, value) (LLWU_RMW_PF(base, (LLWU_PF_WUF31_MASK | LLWU_PF_WUF0_MASK | LLWU_PF_WUF1_MASK | LLWU_PF_WUF2_MASK | LLWU_PF_WUF3_MASK | LLWU_PF_WUF4_MASK | LLWU_PF_WUF5_MASK | LLWU_PF_WUF6_MASK | LLWU_PF_WUF7_MASK | LLWU_PF_WUF8_MASK | LLWU_PF_WUF9_MASK | LLWU_PF_WUF10_MASK | LLWU_PF_WUF11_MASK | LLWU_PF_WUF12_MASK | LLWU_PF_WUF13_MASK | LLWU_PF_WUF14_MASK | LLWU_PF_WUF15_MASK | LLWU_PF_WUF16_MASK | LLWU_PF_WUF17_MASK | LLWU_PF_WUF18_MASK | LLWU_PF_WUF19_MASK | LLWU_PF_WUF20_MASK | LLWU_PF_WUF21_MASK | LLWU_PF_WUF22_MASK | LLWU_PF_WUF23_MASK | LLWU_PF_WUF24_MASK | LLWU_PF_WUF25_MASK | LLWU_PF_WUF26_MASK | LLWU_PF_WUF27_MASK | LLWU_PF_WUF28_MASK | LLWU_PF_WUF29_MASK | LLWU_PF_WUF30_MASK), LLWU_PF_WUF31(value)))
#define LLWU_BWR_PF_WUF31(base, value) (BME_BFI32(&LLWU_PF_REG(base), ((uint32_t)(value) << LLWU_PF_WUF31_SHIFT), LLWU_PF_WUF31_SHIFT, LLWU_PF_WUF31_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_MF - LLWU Module Interrupt Flag register
 ******************************************************************************/

/*!
 * @brief LLWU_MF - LLWU Module Interrupt Flag register (RO)
 *
 * Reset value: 0x00000000U
 *
 * LLWU_MF contains the wakeup flags indicating which internal module interrupt
 * caused the MCU to exit LLS or VLLS mode. For LLS, this is the source causing
 * the CPU interrupt flow. For VLLS, this is the source causing the MCU reset
 * flow. For internal peripherals that are capable of running in a low-leakage power
 * mode, such as a real time clock module or CMP module, the flag from the
 * associated peripheral is accessible as the MWUFx bit. The flag will need to be
 * cleared in the peripheral instead of writing a 1 to the MWUFx bit. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS.
 * See the IntroductionInformation found here describes the registers of the
 * Reset Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_MF register
 */
/*@{*/
#define LLWU_RD_MF(base)         (LLWU_MF_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_MF bitfields
 */

/*!
 * @name Register LLWU_MF, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 0 input was not a wakeup source
 * - 0b1 - Module 0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF0 field. */
#define LLWU_RD_MF_MWUF0(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF0_MASK) >> LLWU_MF_MWUF0_SHIFT)
#define LLWU_BRD_MF_MWUF0(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF0_SHIFT, LLWU_MF_MWUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 1 input was not a wakeup source
 * - 0b1 - Module 1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF1 field. */
#define LLWU_RD_MF_MWUF1(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF1_MASK) >> LLWU_MF_MWUF1_SHIFT)
#define LLWU_BRD_MF_MWUF1(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF1_SHIFT, LLWU_MF_MWUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 2 input was not a wakeup source
 * - 0b1 - Module 2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF2 field. */
#define LLWU_RD_MF_MWUF2(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF2_MASK) >> LLWU_MF_MWUF2_SHIFT)
#define LLWU_BRD_MF_MWUF2(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF2_SHIFT, LLWU_MF_MWUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 3 input was not a wakeup source
 * - 0b1 - Module 3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF3 field. */
#define LLWU_RD_MF_MWUF3(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF3_MASK) >> LLWU_MF_MWUF3_SHIFT)
#define LLWU_BRD_MF_MWUF3(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF3_SHIFT, LLWU_MF_MWUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 4 input was not a wakeup source
 * - 0b1 - Module 4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF4 field. */
#define LLWU_RD_MF_MWUF4(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF4_MASK) >> LLWU_MF_MWUF4_SHIFT)
#define LLWU_BRD_MF_MWUF4(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF4_SHIFT, LLWU_MF_MWUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 5 input was not a wakeup source
 * - 0b1 - Module 5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF5 field. */
#define LLWU_RD_MF_MWUF5(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF5_MASK) >> LLWU_MF_MWUF5_SHIFT)
#define LLWU_BRD_MF_MWUF5(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF5_SHIFT, LLWU_MF_MWUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 6 input was not a wakeup source
 * - 0b1 - Module 6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF6 field. */
#define LLWU_RD_MF_MWUF6(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF6_MASK) >> LLWU_MF_MWUF6_SHIFT)
#define LLWU_BRD_MF_MWUF6(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF6_SHIFT, LLWU_MF_MWUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 7 input was not a wakeup source
 * - 0b1 - Module 7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF_MWUF7 field. */
#define LLWU_RD_MF_MWUF7(base) ((LLWU_MF_REG(base) & LLWU_MF_MWUF7_MASK) >> LLWU_MF_MWUF7_SHIFT)
#define LLWU_BRD_MF_MWUF7(base) (BME_UBFX32(&LLWU_MF_REG(base), LLWU_MF_MWUF7_SHIFT, LLWU_MF_MWUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT - LLWU Pin Filter register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT - LLWU Pin Filter register (RW)
 *
 * Reset value: 0x00000000U
 *
 * LLWU_FILT is a control and status register that is used to enable/disable the
 * digital filter features for an external pin. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT register
 */
/*@{*/
#define LLWU_RD_FILT(base)       (LLWU_FILT_REG(base))
#define LLWU_WR_FILT(base, value) (LLWU_FILT_REG(base) = (value))
#define LLWU_RMW_FILT(base, mask, value) (LLWU_WR_FILT(base, (LLWU_RD_FILT(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT(base, value) (BME_OR32(&LLWU_FILT_REG(base), (uint32_t)(value)))
#define LLWU_CLR_FILT(base, value) (BME_AND32(&LLWU_FILT_REG(base), (uint32_t)(~(value))))
#define LLWU_TOG_FILT(base, value) (BME_XOR32(&LLWU_FILT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT bitfields
 */

/*!
 * @name Register LLWU_FILT, field FILTSEL1[4:0] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into filter 1.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTSEL1 field. */
#define LLWU_RD_FILT_FILTSEL1(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTSEL1_MASK) >> LLWU_FILT_FILTSEL1_SHIFT)
#define LLWU_BRD_FILT_FILTSEL1(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTSEL1_SHIFT, LLWU_FILT_FILTSEL1_WIDTH))

/*! @brief Set the FILTSEL1 field to a new value. */
#define LLWU_WR_FILT_FILTSEL1(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTSEL1_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTSEL1(value)))
#define LLWU_BWR_FILT_FILTSEL1(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTSEL1_SHIFT), LLWU_FILT_FILTSEL1_SHIFT, LLWU_FILT_FILTSEL1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTE1[6:5] (RW)
 *
 * Controls the digital filter 1 options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTE1 field. */
#define LLWU_RD_FILT_FILTE1(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTE1_MASK) >> LLWU_FILT_FILTE1_SHIFT)
#define LLWU_BRD_FILT_FILTE1(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTE1_SHIFT, LLWU_FILT_FILTE1_WIDTH))

/*! @brief Set the FILTE1 field to a new value. */
#define LLWU_WR_FILT_FILTE1(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTE1_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTE1(value)))
#define LLWU_BWR_FILT_FILTE1(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTE1_SHIFT), LLWU_FILT_FILTE1_SHIFT, LLWU_FILT_FILTE1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTF1[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 1 was not a wakeup source
 * - 0b1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTF1 field. */
#define LLWU_RD_FILT_FILTF1(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTF1_MASK) >> LLWU_FILT_FILTF1_SHIFT)
#define LLWU_BRD_FILT_FILTF1(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTF1_SHIFT, LLWU_FILT_FILTF1_WIDTH))

/*! @brief Set the FILTF1 field to a new value. */
#define LLWU_WR_FILT_FILTF1(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTF1(value)))
#define LLWU_BWR_FILT_FILTF1(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTF1_SHIFT), LLWU_FILT_FILTF1_SHIFT, LLWU_FILT_FILTF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTSEL2[12:8] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into filter 2.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTSEL2 field. */
#define LLWU_RD_FILT_FILTSEL2(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTSEL2_MASK) >> LLWU_FILT_FILTSEL2_SHIFT)
#define LLWU_BRD_FILT_FILTSEL2(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTSEL2_SHIFT, LLWU_FILT_FILTSEL2_WIDTH))

/*! @brief Set the FILTSEL2 field to a new value. */
#define LLWU_WR_FILT_FILTSEL2(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTSEL2_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTSEL2(value)))
#define LLWU_BWR_FILT_FILTSEL2(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTSEL2_SHIFT), LLWU_FILT_FILTSEL2_SHIFT, LLWU_FILT_FILTSEL2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTE2[14:13] (RW)
 *
 * Controls the digital filter 2 options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTE2 field. */
#define LLWU_RD_FILT_FILTE2(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTE2_MASK) >> LLWU_FILT_FILTE2_SHIFT)
#define LLWU_BRD_FILT_FILTE2(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTE2_SHIFT, LLWU_FILT_FILTE2_WIDTH))

/*! @brief Set the FILTE2 field to a new value. */
#define LLWU_WR_FILT_FILTE2(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTE2_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTE2(value)))
#define LLWU_BWR_FILT_FILTE2(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTE2_SHIFT), LLWU_FILT_FILTE2_SHIFT, LLWU_FILT_FILTE2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTF2[15] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 1 was not a wakeup source
 * - 0b1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTF2 field. */
#define LLWU_RD_FILT_FILTF2(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTF2_MASK) >> LLWU_FILT_FILTF2_SHIFT)
#define LLWU_BRD_FILT_FILTF2(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTF2_SHIFT, LLWU_FILT_FILTF2_WIDTH))

/*! @brief Set the FILTF2 field to a new value. */
#define LLWU_WR_FILT_FILTF2(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTF2(value)))
#define LLWU_BWR_FILT_FILTF2(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTF2_SHIFT), LLWU_FILT_FILTF2_SHIFT, LLWU_FILT_FILTF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTSEL3[20:16] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into filter 3.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTSEL3 field. */
#define LLWU_RD_FILT_FILTSEL3(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTSEL3_MASK) >> LLWU_FILT_FILTSEL3_SHIFT)
#define LLWU_BRD_FILT_FILTSEL3(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTSEL3_SHIFT, LLWU_FILT_FILTSEL3_WIDTH))

/*! @brief Set the FILTSEL3 field to a new value. */
#define LLWU_WR_FILT_FILTSEL3(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTSEL3_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTSEL3(value)))
#define LLWU_BWR_FILT_FILTSEL3(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTSEL3_SHIFT), LLWU_FILT_FILTSEL3_SHIFT, LLWU_FILT_FILTSEL3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTE3[22:21] (RW)
 *
 * Controls the digital filter 3 options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTE3 field. */
#define LLWU_RD_FILT_FILTE3(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTE3_MASK) >> LLWU_FILT_FILTE3_SHIFT)
#define LLWU_BRD_FILT_FILTE3(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTE3_SHIFT, LLWU_FILT_FILTE3_WIDTH))

/*! @brief Set the FILTE3 field to a new value. */
#define LLWU_WR_FILT_FILTE3(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTE3_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTE3(value)))
#define LLWU_BWR_FILT_FILTE3(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTE3_SHIFT), LLWU_FILT_FILTE3_SHIFT, LLWU_FILT_FILTE3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTF3[23] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 1 was not a wakeup source
 * - 0b1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTF3 field. */
#define LLWU_RD_FILT_FILTF3(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTF3_MASK) >> LLWU_FILT_FILTF3_SHIFT)
#define LLWU_BRD_FILT_FILTF3(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTF3_SHIFT, LLWU_FILT_FILTF3_WIDTH))

/*! @brief Set the FILTF3 field to a new value. */
#define LLWU_WR_FILT_FILTF3(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTF3(value)))
#define LLWU_BWR_FILT_FILTF3(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTF3_SHIFT), LLWU_FILT_FILTF3_SHIFT, LLWU_FILT_FILTF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTSEL4[28:24] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into filter 4.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTSEL4 field. */
#define LLWU_RD_FILT_FILTSEL4(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTSEL4_MASK) >> LLWU_FILT_FILTSEL4_SHIFT)
#define LLWU_BRD_FILT_FILTSEL4(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTSEL4_SHIFT, LLWU_FILT_FILTSEL4_WIDTH))

/*! @brief Set the FILTSEL4 field to a new value. */
#define LLWU_WR_FILT_FILTSEL4(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTSEL4_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTSEL4(value)))
#define LLWU_BWR_FILT_FILTSEL4(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTSEL4_SHIFT), LLWU_FILT_FILTSEL4_SHIFT, LLWU_FILT_FILTSEL4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTE4[30:29] (RW)
 *
 * Controls the digital filter 4 options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTE4 field. */
#define LLWU_RD_FILT_FILTE4(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTE4_MASK) >> LLWU_FILT_FILTE4_SHIFT)
#define LLWU_BRD_FILT_FILTE4(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTE4_SHIFT, LLWU_FILT_FILTE4_WIDTH))

/*! @brief Set the FILTE4 field to a new value. */
#define LLWU_WR_FILT_FILTE4(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTE4_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK | LLWU_FILT_FILTF4_MASK), LLWU_FILT_FILTE4(value)))
#define LLWU_BWR_FILT_FILTE4(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTE4_SHIFT), LLWU_FILT_FILTE4_SHIFT, LLWU_FILT_FILTE4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT, field FILTF4[31] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 1 was not a wakeup source
 * - 0b1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT_FILTF4 field. */
#define LLWU_RD_FILT_FILTF4(base) ((LLWU_FILT_REG(base) & LLWU_FILT_FILTF4_MASK) >> LLWU_FILT_FILTF4_SHIFT)
#define LLWU_BRD_FILT_FILTF4(base) (BME_UBFX32(&LLWU_FILT_REG(base), LLWU_FILT_FILTF4_SHIFT, LLWU_FILT_FILTF4_WIDTH))

/*! @brief Set the FILTF4 field to a new value. */
#define LLWU_WR_FILT_FILTF4(base, value) (LLWU_RMW_FILT(base, (LLWU_FILT_FILTF4_MASK | LLWU_FILT_FILTF1_MASK | LLWU_FILT_FILTF2_MASK | LLWU_FILT_FILTF3_MASK), LLWU_FILT_FILTF4(value)))
#define LLWU_BWR_FILT_FILTF4(base, value) (BME_BFI32(&LLWU_FILT_REG(base), ((uint32_t)(value) << LLWU_FILT_FILTF4_SHIFT), LLWU_FILT_FILTF4_SHIFT, LLWU_FILT_FILTF4_WIDTH))
/*@}*/

/*
 * MKL28Z7 LPI2C
 *
 * The LPI2C Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - LPI2C_VERID - Version ID Register
 * - LPI2C_PARAM - Parameter Register
 * - LPI2C_MCR - Master Control Register
 * - LPI2C_MSR - Master Status Register
 * - LPI2C_MIER - Master Interrupt Enable Register
 * - LPI2C_MDER - Master DMA Enable Register
 * - LPI2C_MCFGR0 - Master Configuration Register 0
 * - LPI2C_MCFGR1 - Master Configuration Register 1
 * - LPI2C_MCFGR2 - Master Configuration Register 2
 * - LPI2C_MCFGR3 - Master Configuration Register 3
 * - LPI2C_MDMR - Master Data Match Register
 * - LPI2C_MCCR0 - Master Clock Configuration Register 0
 * - LPI2C_MCCR1 - Master Clock Configuration Register 1
 * - LPI2C_MFCR - Master FIFO Control Register
 * - LPI2C_MFSR - Master FIFO Status Register
 * - LPI2C_MTDR - Master Transmit Data Register
 * - LPI2C_MRDR - Master Receive Data Register
 * - LPI2C_SCR - Slave Control Register
 * - LPI2C_SSR - Slave Status Register
 * - LPI2C_SIER - Slave Interrupt Enable Register
 * - LPI2C_SDER - Slave DMA Enable Register
 * - LPI2C_SCFGR1 - Slave Configuration Register 1
 * - LPI2C_SCFGR2 - Slave Configuration Register 2
 * - LPI2C_SAMR - Slave Address Match Register
 * - LPI2C_SASR - Slave Address Status Register
 * - LPI2C_STAR - Slave Transmit ACK Register
 * - LPI2C_STDR - Slave Transmit Data Register
 * - LPI2C_SRDR - Slave Receive Data Register
 */

#define LPI2C_INSTANCE_COUNT (3U) /*!< Number of instances of the LPI2C module. */
#define LPI2C0_IDX (0U) /*!< Instance number for LPI2C0. */
#define LPI2C1_IDX (1U) /*!< Instance number for LPI2C1. */
#define LPI2C2_IDX (2U) /*!< Instance number for LPI2C2. */

/*******************************************************************************
 * LPI2C_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPI2C_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000003U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPI2C_VERID register
 */
/*@{*/
#define LPI2C_RD_VERID(base)     (LPI2C_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_VERID bitfields
 */

/*!
 * @name Register LPI2C_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000010 - Master only with standard feature set.
 * - 0b0000000000000011 - Master and slave with standard feature set.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_FEATURE field. */
#define LPI2C_RD_VERID_FEATURE(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_FEATURE_MASK) >> LPI2C_VERID_FEATURE_SHIFT)
#define LPI2C_BRD_VERID_FEATURE(base) (LPI2C_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPI2C_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_MINOR field. */
#define LPI2C_RD_VERID_MINOR(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_MINOR_MASK) >> LPI2C_VERID_MINOR_SHIFT)
#define LPI2C_BRD_VERID_MINOR(base) (BME_UBFX32(&LPI2C_VERID_REG(base), LPI2C_VERID_MINOR_SHIFT, LPI2C_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_MAJOR field. */
#define LPI2C_RD_VERID_MAJOR(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_MAJOR_MASK) >> LPI2C_VERID_MAJOR_SHIFT)
#define LPI2C_BRD_VERID_MAJOR(base) (BME_UBFX32(&LPI2C_VERID_REG(base), LPI2C_VERID_MAJOR_SHIFT, LPI2C_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPI2C_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000202U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPI2C_PARAM register
 */
/*@{*/
#define LPI2C_RD_PARAM(base)     (LPI2C_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_PARAM bitfields
 */

/*!
 * @name Register LPI2C_PARAM, field MTXFIFO[3:0] (RO)
 *
 * The number of words in the master transmit FIFO is 2^MTXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_PARAM_MTXFIFO field. */
#define LPI2C_RD_PARAM_MTXFIFO(base) ((LPI2C_PARAM_REG(base) & LPI2C_PARAM_MTXFIFO_MASK) >> LPI2C_PARAM_MTXFIFO_SHIFT)
#define LPI2C_BRD_PARAM_MTXFIFO(base) (BME_UBFX32(&LPI2C_PARAM_REG(base), LPI2C_PARAM_MTXFIFO_SHIFT, LPI2C_PARAM_MTXFIFO_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_PARAM, field MRXFIFO[11:8] (RO)
 *
 * The number of words in the master receive FIFO is 2^MRXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_PARAM_MRXFIFO field. */
#define LPI2C_RD_PARAM_MRXFIFO(base) ((LPI2C_PARAM_REG(base) & LPI2C_PARAM_MRXFIFO_MASK) >> LPI2C_PARAM_MRXFIFO_SHIFT)
#define LPI2C_BRD_PARAM_MRXFIFO(base) (BME_UBFX32(&LPI2C_PARAM_REG(base), LPI2C_PARAM_MRXFIFO_SHIFT, LPI2C_PARAM_MRXFIFO_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MCR - Master Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MCR - Master Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MCR register
 */
/*@{*/
#define LPI2C_RD_MCR(base)       (LPI2C_MCR_REG(base))
#define LPI2C_WR_MCR(base, value) (LPI2C_MCR_REG(base) = (value))
#define LPI2C_RMW_MCR(base, mask, value) (LPI2C_WR_MCR(base, (LPI2C_RD_MCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCR(base, value) (BME_OR32(&LPI2C_MCR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MCR(base, value) (BME_AND32(&LPI2C_MCR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MCR(base, value) (BME_XOR32(&LPI2C_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCR bitfields
 */

/*!
 * @name Register LPI2C_MCR, field MEN[0] (RW)
 *
 * Values:
 * - 0b0 - Master logic is disabled.
 * - 0b1 - Master logic is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_MEN field. */
#define LPI2C_RD_MCR_MEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_MEN_MASK) >> LPI2C_MCR_MEN_SHIFT)
#define LPI2C_BRD_MCR_MEN(base) (BME_UBFX32(&LPI2C_MCR_REG(base), LPI2C_MCR_MEN_SHIFT, LPI2C_MCR_MEN_WIDTH))

/*! @brief Set the MEN field to a new value. */
#define LPI2C_WR_MCR_MEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_MEN_MASK, LPI2C_MCR_MEN(value)))
#define LPI2C_BWR_MCR_MEN(base, value) (BME_BFI32(&LPI2C_MCR_REG(base), ((uint32_t)(value) << LPI2C_MCR_MEN_SHIFT), LPI2C_MCR_MEN_SHIFT, LPI2C_MCR_MEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RST[1] (RW)
 *
 * Reset all internal master logic and registers, except the Master Control
 * Register. Remains set until cleared by software.
 *
 * Values:
 * - 0b0 - Master logic is not reset.
 * - 0b1 - Master logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_RST field. */
#define LPI2C_RD_MCR_RST(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_RST_MASK) >> LPI2C_MCR_RST_SHIFT)
#define LPI2C_BRD_MCR_RST(base) (BME_UBFX32(&LPI2C_MCR_REG(base), LPI2C_MCR_RST_SHIFT, LPI2C_MCR_RST_WIDTH))

/*! @brief Set the RST field to a new value. */
#define LPI2C_WR_MCR_RST(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RST_MASK, LPI2C_MCR_RST(value)))
#define LPI2C_BWR_MCR_RST(base, value) (BME_BFI32(&LPI2C_MCR_REG(base), ((uint32_t)(value) << LPI2C_MCR_RST_SHIFT), LPI2C_MCR_RST_SHIFT, LPI2C_MCR_RST_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field DOZEN[2] (RW)
 *
 * Enables or disables Doze mode for the master.
 *
 * Values:
 * - 0b0 - Master is enabled in Doze mode.
 * - 0b1 - Master is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_DOZEN field. */
#define LPI2C_RD_MCR_DOZEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_DOZEN_MASK) >> LPI2C_MCR_DOZEN_SHIFT)
#define LPI2C_BRD_MCR_DOZEN(base) (BME_UBFX32(&LPI2C_MCR_REG(base), LPI2C_MCR_DOZEN_SHIFT, LPI2C_MCR_DOZEN_WIDTH))

/*! @brief Set the DOZEN field to a new value. */
#define LPI2C_WR_MCR_DOZEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_DOZEN_MASK, LPI2C_MCR_DOZEN(value)))
#define LPI2C_BWR_MCR_DOZEN(base, value) (BME_BFI32(&LPI2C_MCR_REG(base), ((uint32_t)(value) << LPI2C_MCR_DOZEN_SHIFT), LPI2C_MCR_DOZEN_SHIFT, LPI2C_MCR_DOZEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field DBGEN[3] (RW)
 *
 * Values:
 * - 0b0 - Master is disabled in debug mode.
 * - 0b1 - Master is enabled in debug mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_DBGEN field. */
#define LPI2C_RD_MCR_DBGEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_DBGEN_MASK) >> LPI2C_MCR_DBGEN_SHIFT)
#define LPI2C_BRD_MCR_DBGEN(base) (BME_UBFX32(&LPI2C_MCR_REG(base), LPI2C_MCR_DBGEN_SHIFT, LPI2C_MCR_DBGEN_WIDTH))

/*! @brief Set the DBGEN field to a new value. */
#define LPI2C_WR_MCR_DBGEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_DBGEN_MASK, LPI2C_MCR_DBGEN(value)))
#define LPI2C_BWR_MCR_DBGEN(base, value) (BME_BFI32(&LPI2C_MCR_REG(base), ((uint32_t)(value) << LPI2C_MCR_DBGEN_SHIFT), LPI2C_MCR_DBGEN_SHIFT, LPI2C_MCR_DBGEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RTF[8] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Transmit FIFO is reset.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPI2C_WR_MCR_RTF(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RTF_MASK, LPI2C_MCR_RTF(value)))
#define LPI2C_BWR_MCR_RTF(base, value) (BME_BFI32(&LPI2C_MCR_REG(base), ((uint32_t)(value) << LPI2C_MCR_RTF_SHIFT), LPI2C_MCR_RTF_SHIFT, LPI2C_MCR_RTF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RRF[9] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Receive FIFO is reset.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPI2C_WR_MCR_RRF(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RRF_MASK, LPI2C_MCR_RRF(value)))
#define LPI2C_BWR_MCR_RRF(base, value) (BME_BFI32(&LPI2C_MCR_REG(base), ((uint32_t)(value) << LPI2C_MCR_RRF_SHIFT), LPI2C_MCR_RRF_SHIFT, LPI2C_MCR_RRF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MSR - Master Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MSR - Master Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire LPI2C_MSR register
 */
/*@{*/
#define LPI2C_RD_MSR(base)       (LPI2C_MSR_REG(base))
#define LPI2C_WR_MSR(base, value) (LPI2C_MSR_REG(base) = (value))
#define LPI2C_RMW_MSR(base, mask, value) (LPI2C_WR_MSR(base, (LPI2C_RD_MSR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MSR(base, value) (BME_OR32(&LPI2C_MSR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MSR(base, value) (BME_AND32(&LPI2C_MSR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MSR(base, value) (BME_XOR32(&LPI2C_MSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MSR bitfields
 */

/*!
 * @name Register LPI2C_MSR, field TDF[0] (RO)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER.
 *
 * Values:
 * - 0b0 - Transmit data not requested.
 * - 0b1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_TDF field. */
#define LPI2C_RD_MSR_TDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_TDF_MASK) >> LPI2C_MSR_TDF_SHIFT)
#define LPI2C_BRD_MSR_TDF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_TDF_SHIFT, LPI2C_MSR_TDF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field RDF[1] (RO)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER.
 *
 * Values:
 * - 0b0 - Receive Data is not ready.
 * - 0b1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_RDF field. */
#define LPI2C_RD_MSR_RDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_RDF_MASK) >> LPI2C_MSR_RDF_SHIFT)
#define LPI2C_BRD_MSR_RDF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_RDF_SHIFT, LPI2C_MSR_RDF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field EPF[8] (W1C)
 *
 * This flag will set when the LPI2C master generates either a repeated START or
 * a STOP condition. It does not set when the master first generates a START
 * condition.
 *
 * Values:
 * - 0b0 - Master has not generated a STOP or Repeated START condition.
 * - 0b1 - Master has generated a STOP or Repeated START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_EPF field. */
#define LPI2C_RD_MSR_EPF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_EPF_MASK) >> LPI2C_MSR_EPF_SHIFT)
#define LPI2C_BRD_MSR_EPF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_EPF_SHIFT, LPI2C_MSR_EPF_WIDTH))

/*! @brief Set the EPF field to a new value. */
#define LPI2C_WR_MSR_EPF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_EPF(value)))
#define LPI2C_BWR_MSR_EPF(base, value) (BME_BFI32(&LPI2C_MSR_REG(base), ((uint32_t)(value) << LPI2C_MSR_EPF_SHIFT), LPI2C_MSR_EPF_SHIFT, LPI2C_MSR_EPF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field SDF[9] (W1C)
 *
 * This flag will set when the LPI2C master generates a STOP condition.
 *
 * Values:
 * - 0b0 - Master has not generated a STOP condition.
 * - 0b1 - Master has generated a STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_SDF field. */
#define LPI2C_RD_MSR_SDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_SDF_MASK) >> LPI2C_MSR_SDF_SHIFT)
#define LPI2C_BRD_MSR_SDF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_SDF_SHIFT, LPI2C_MSR_SDF_WIDTH))

/*! @brief Set the SDF field to a new value. */
#define LPI2C_WR_MSR_SDF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_SDF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_SDF(value)))
#define LPI2C_BWR_MSR_SDF(base, value) (BME_BFI32(&LPI2C_MSR_REG(base), ((uint32_t)(value) << LPI2C_MSR_SDF_SHIFT), LPI2C_MSR_SDF_SHIFT, LPI2C_MSR_SDF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field NDF[10] (W1C)
 *
 * This flag will set if the LPI2C master detects a NACK when transmitting an
 * address or data. If a NACK is expected for a given address (as configured by the
 * command word) then the flag will set if a NACK is not generated. When set,
 * the master will transmit a STOP condition and will not initiate a new START
 * condition until this flag has been cleared.
 *
 * Values:
 * - 0b0 - Unexpected NACK not detected.
 * - 0b1 - Unexpected NACK was detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_NDF field. */
#define LPI2C_RD_MSR_NDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_NDF_MASK) >> LPI2C_MSR_NDF_SHIFT)
#define LPI2C_BRD_MSR_NDF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_NDF_SHIFT, LPI2C_MSR_NDF_WIDTH))

/*! @brief Set the NDF field to a new value. */
#define LPI2C_WR_MSR_NDF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_NDF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_NDF(value)))
#define LPI2C_BWR_MSR_NDF(base, value) (BME_BFI32(&LPI2C_MSR_REG(base), ((uint32_t)(value) << LPI2C_MSR_NDF_SHIFT), LPI2C_MSR_NDF_SHIFT, LPI2C_MSR_NDF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field ALF[11] (W1C)
 *
 * This flag will set if the LPI2C master transmits a logic one and detects a
 * logic zero on the I2C bus, or if it detects a START or STOP condition while it
 * is transmitting data. When this flag sets, the LPI2C master will release the
 * bus (go idle) and will not initiate a new START condition until this flag has
 * been cleared.
 *
 * Values:
 * - 0b0 - Master has not lost arbitration.
 * - 0b1 - Master has lost arbitration.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_ALF field. */
#define LPI2C_RD_MSR_ALF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_ALF_MASK) >> LPI2C_MSR_ALF_SHIFT)
#define LPI2C_BRD_MSR_ALF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_ALF_SHIFT, LPI2C_MSR_ALF_WIDTH))

/*! @brief Set the ALF field to a new value. */
#define LPI2C_WR_MSR_ALF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_ALF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_ALF(value)))
#define LPI2C_BWR_MSR_ALF(base, value) (BME_BFI32(&LPI2C_MSR_REG(base), ((uint32_t)(value) << LPI2C_MSR_ALF_SHIFT), LPI2C_MSR_ALF_SHIFT, LPI2C_MSR_ALF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field FEF[12] (W1C)
 *
 * Detects an attempt to send or receive data without first generating a
 * (repeated) START condition. This can occur if the transmit FIFO underflows when the
 * AUTOSTOP bit is set. When this flag is set, the LPI2C master will send a STOP
 * condition (if busy) and will not initiate a new START condition until this flag
 * has been cleared.
 *
 * Values:
 * - 0b0 - No error.
 * - 0b1 - Master sending or receiving data without START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_FEF field. */
#define LPI2C_RD_MSR_FEF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_FEF_MASK) >> LPI2C_MSR_FEF_SHIFT)
#define LPI2C_BRD_MSR_FEF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_FEF_SHIFT, LPI2C_MSR_FEF_WIDTH))

/*! @brief Set the FEF field to a new value. */
#define LPI2C_WR_MSR_FEF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_FEF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_FEF(value)))
#define LPI2C_BWR_MSR_FEF(base, value) (BME_BFI32(&LPI2C_MSR_REG(base), ((uint32_t)(value) << LPI2C_MSR_FEF_SHIFT), LPI2C_MSR_FEF_SHIFT, LPI2C_MSR_FEF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field PLTF[13] (W1C)
 *
 * Will set when the SCL and/or SDA input is low for more than PINLOW cycles,
 * even when the LPI2C master is idle. Software is responsible for resolving the
 * pin low condition. This flag cannot be cleared for as long as the pin low
 * timeout continues and must be cleared before the LPI2C can initiate a START
 * condition.
 *
 * Values:
 * - 0b0 - Pin low timeout has not occurred or is disabled.
 * - 0b1 - Pin low timeout has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_PLTF field. */
#define LPI2C_RD_MSR_PLTF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_PLTF_MASK) >> LPI2C_MSR_PLTF_SHIFT)
#define LPI2C_BRD_MSR_PLTF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_PLTF_SHIFT, LPI2C_MSR_PLTF_WIDTH))

/*! @brief Set the PLTF field to a new value. */
#define LPI2C_WR_MSR_PLTF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_PLTF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_PLTF(value)))
#define LPI2C_BWR_MSR_PLTF(base, value) (BME_BFI32(&LPI2C_MSR_REG(base), ((uint32_t)(value) << LPI2C_MSR_PLTF_SHIFT), LPI2C_MSR_PLTF_SHIFT, LPI2C_MSR_PLTF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field DMF[14] (W1C)
 *
 * Indicates that the received data has matched the MATCH0 and/or MATCH1 fields
 * as configured by MATCFG. Received data that is discarded due to CMD field does
 * not cause this flag to set.
 *
 * Values:
 * - 0b0 - Have not received matching data.
 * - 0b1 - Have received matching data.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_DMF field. */
#define LPI2C_RD_MSR_DMF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_DMF_MASK) >> LPI2C_MSR_DMF_SHIFT)
#define LPI2C_BRD_MSR_DMF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_DMF_SHIFT, LPI2C_MSR_DMF_WIDTH))

/*! @brief Set the DMF field to a new value. */
#define LPI2C_WR_MSR_DMF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_DMF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK), LPI2C_MSR_DMF(value)))
#define LPI2C_BWR_MSR_DMF(base, value) (BME_BFI32(&LPI2C_MSR_REG(base), ((uint32_t)(value) << LPI2C_MSR_DMF_SHIFT), LPI2C_MSR_DMF_SHIFT, LPI2C_MSR_DMF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field MBF[24] (RO)
 *
 * Values:
 * - 0b0 - I2C Master is idle.
 * - 0b1 - I2C Master is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_MBF field. */
#define LPI2C_RD_MSR_MBF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_MBF_MASK) >> LPI2C_MSR_MBF_SHIFT)
#define LPI2C_BRD_MSR_MBF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_MBF_SHIFT, LPI2C_MSR_MBF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field BBF[25] (RO)
 *
 * Values:
 * - 0b0 - I2C Bus is idle.
 * - 0b1 - I2C Bus is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_BBF field. */
#define LPI2C_RD_MSR_BBF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_BBF_MASK) >> LPI2C_MSR_BBF_SHIFT)
#define LPI2C_BRD_MSR_BBF(base) (BME_UBFX32(&LPI2C_MSR_REG(base), LPI2C_MSR_BBF_SHIFT, LPI2C_MSR_BBF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MIER - Master Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MIER - Master Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MIER register
 */
/*@{*/
#define LPI2C_RD_MIER(base)      (LPI2C_MIER_REG(base))
#define LPI2C_WR_MIER(base, value) (LPI2C_MIER_REG(base) = (value))
#define LPI2C_RMW_MIER(base, mask, value) (LPI2C_WR_MIER(base, (LPI2C_RD_MIER(base) & ~(mask)) | (value)))
#define LPI2C_SET_MIER(base, value) (BME_OR32(&LPI2C_MIER_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MIER(base, value) (BME_AND32(&LPI2C_MIER_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MIER(base, value) (BME_XOR32(&LPI2C_MIER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MIER bitfields
 */

/*!
 * @name Register LPI2C_MIER, field TDIE[0] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_TDIE field. */
#define LPI2C_RD_MIER_TDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_TDIE_MASK) >> LPI2C_MIER_TDIE_SHIFT)
#define LPI2C_BRD_MIER_TDIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_TDIE_SHIFT, LPI2C_MIER_TDIE_WIDTH))

/*! @brief Set the TDIE field to a new value. */
#define LPI2C_WR_MIER_TDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_TDIE_MASK, LPI2C_MIER_TDIE(value)))
#define LPI2C_BWR_MIER_TDIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_TDIE_SHIFT), LPI2C_MIER_TDIE_SHIFT, LPI2C_MIER_TDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field RDIE[1] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_RDIE field. */
#define LPI2C_RD_MIER_RDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_RDIE_MASK) >> LPI2C_MIER_RDIE_SHIFT)
#define LPI2C_BRD_MIER_RDIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_RDIE_SHIFT, LPI2C_MIER_RDIE_WIDTH))

/*! @brief Set the RDIE field to a new value. */
#define LPI2C_WR_MIER_RDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_RDIE_MASK, LPI2C_MIER_RDIE(value)))
#define LPI2C_BWR_MIER_RDIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_RDIE_SHIFT), LPI2C_MIER_RDIE_SHIFT, LPI2C_MIER_RDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field EPIE[8] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_EPIE field. */
#define LPI2C_RD_MIER_EPIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_EPIE_MASK) >> LPI2C_MIER_EPIE_SHIFT)
#define LPI2C_BRD_MIER_EPIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_EPIE_SHIFT, LPI2C_MIER_EPIE_WIDTH))

/*! @brief Set the EPIE field to a new value. */
#define LPI2C_WR_MIER_EPIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_EPIE_MASK, LPI2C_MIER_EPIE(value)))
#define LPI2C_BWR_MIER_EPIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_EPIE_SHIFT), LPI2C_MIER_EPIE_SHIFT, LPI2C_MIER_EPIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field SDIE[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_SDIE field. */
#define LPI2C_RD_MIER_SDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_SDIE_MASK) >> LPI2C_MIER_SDIE_SHIFT)
#define LPI2C_BRD_MIER_SDIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_SDIE_SHIFT, LPI2C_MIER_SDIE_WIDTH))

/*! @brief Set the SDIE field to a new value. */
#define LPI2C_WR_MIER_SDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_SDIE_MASK, LPI2C_MIER_SDIE(value)))
#define LPI2C_BWR_MIER_SDIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_SDIE_SHIFT), LPI2C_MIER_SDIE_SHIFT, LPI2C_MIER_SDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field NDIE[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_NDIE field. */
#define LPI2C_RD_MIER_NDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_NDIE_MASK) >> LPI2C_MIER_NDIE_SHIFT)
#define LPI2C_BRD_MIER_NDIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_NDIE_SHIFT, LPI2C_MIER_NDIE_WIDTH))

/*! @brief Set the NDIE field to a new value. */
#define LPI2C_WR_MIER_NDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_NDIE_MASK, LPI2C_MIER_NDIE(value)))
#define LPI2C_BWR_MIER_NDIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_NDIE_SHIFT), LPI2C_MIER_NDIE_SHIFT, LPI2C_MIER_NDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field ALIE[11] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_ALIE field. */
#define LPI2C_RD_MIER_ALIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_ALIE_MASK) >> LPI2C_MIER_ALIE_SHIFT)
#define LPI2C_BRD_MIER_ALIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_ALIE_SHIFT, LPI2C_MIER_ALIE_WIDTH))

/*! @brief Set the ALIE field to a new value. */
#define LPI2C_WR_MIER_ALIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_ALIE_MASK, LPI2C_MIER_ALIE(value)))
#define LPI2C_BWR_MIER_ALIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_ALIE_SHIFT), LPI2C_MIER_ALIE_SHIFT, LPI2C_MIER_ALIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field FEIE[12] (RW)
 *
 * Values:
 * - 0b0 - Interrupt enabled.
 * - 0b1 - Interrupt disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_FEIE field. */
#define LPI2C_RD_MIER_FEIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_FEIE_MASK) >> LPI2C_MIER_FEIE_SHIFT)
#define LPI2C_BRD_MIER_FEIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_FEIE_SHIFT, LPI2C_MIER_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define LPI2C_WR_MIER_FEIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_FEIE_MASK, LPI2C_MIER_FEIE(value)))
#define LPI2C_BWR_MIER_FEIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_FEIE_SHIFT), LPI2C_MIER_FEIE_SHIFT, LPI2C_MIER_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field PLTIE[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_PLTIE field. */
#define LPI2C_RD_MIER_PLTIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_PLTIE_MASK) >> LPI2C_MIER_PLTIE_SHIFT)
#define LPI2C_BRD_MIER_PLTIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_PLTIE_SHIFT, LPI2C_MIER_PLTIE_WIDTH))

/*! @brief Set the PLTIE field to a new value. */
#define LPI2C_WR_MIER_PLTIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_PLTIE_MASK, LPI2C_MIER_PLTIE(value)))
#define LPI2C_BWR_MIER_PLTIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_PLTIE_SHIFT), LPI2C_MIER_PLTIE_SHIFT, LPI2C_MIER_PLTIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field DMIE[14] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_DMIE field. */
#define LPI2C_RD_MIER_DMIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_DMIE_MASK) >> LPI2C_MIER_DMIE_SHIFT)
#define LPI2C_BRD_MIER_DMIE(base) (BME_UBFX32(&LPI2C_MIER_REG(base), LPI2C_MIER_DMIE_SHIFT, LPI2C_MIER_DMIE_WIDTH))

/*! @brief Set the DMIE field to a new value. */
#define LPI2C_WR_MIER_DMIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_DMIE_MASK, LPI2C_MIER_DMIE(value)))
#define LPI2C_BWR_MIER_DMIE(base, value) (BME_BFI32(&LPI2C_MIER_REG(base), ((uint32_t)(value) << LPI2C_MIER_DMIE_SHIFT), LPI2C_MIER_DMIE_SHIFT, LPI2C_MIER_DMIE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MDER - Master DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MDER - Master DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MDER register
 */
/*@{*/
#define LPI2C_RD_MDER(base)      (LPI2C_MDER_REG(base))
#define LPI2C_WR_MDER(base, value) (LPI2C_MDER_REG(base) = (value))
#define LPI2C_RMW_MDER(base, mask, value) (LPI2C_WR_MDER(base, (LPI2C_RD_MDER(base) & ~(mask)) | (value)))
#define LPI2C_SET_MDER(base, value) (BME_OR32(&LPI2C_MDER_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MDER(base, value) (BME_AND32(&LPI2C_MDER_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MDER(base, value) (BME_XOR32(&LPI2C_MDER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MDER bitfields
 */

/*!
 * @name Register LPI2C_MDER, field TDDE[0] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDER_TDDE field. */
#define LPI2C_RD_MDER_TDDE(base) ((LPI2C_MDER_REG(base) & LPI2C_MDER_TDDE_MASK) >> LPI2C_MDER_TDDE_SHIFT)
#define LPI2C_BRD_MDER_TDDE(base) (BME_UBFX32(&LPI2C_MDER_REG(base), LPI2C_MDER_TDDE_SHIFT, LPI2C_MDER_TDDE_WIDTH))

/*! @brief Set the TDDE field to a new value. */
#define LPI2C_WR_MDER_TDDE(base, value) (LPI2C_RMW_MDER(base, LPI2C_MDER_TDDE_MASK, LPI2C_MDER_TDDE(value)))
#define LPI2C_BWR_MDER_TDDE(base, value) (BME_BFI32(&LPI2C_MDER_REG(base), ((uint32_t)(value) << LPI2C_MDER_TDDE_SHIFT), LPI2C_MDER_TDDE_SHIFT, LPI2C_MDER_TDDE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MDER, field RDDE[1] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDER_RDDE field. */
#define LPI2C_RD_MDER_RDDE(base) ((LPI2C_MDER_REG(base) & LPI2C_MDER_RDDE_MASK) >> LPI2C_MDER_RDDE_SHIFT)
#define LPI2C_BRD_MDER_RDDE(base) (BME_UBFX32(&LPI2C_MDER_REG(base), LPI2C_MDER_RDDE_SHIFT, LPI2C_MDER_RDDE_WIDTH))

/*! @brief Set the RDDE field to a new value. */
#define LPI2C_WR_MDER_RDDE(base, value) (LPI2C_RMW_MDER(base, LPI2C_MDER_RDDE_MASK, LPI2C_MDER_RDDE(value)))
#define LPI2C_BWR_MDER_RDDE(base, value) (BME_BFI32(&LPI2C_MDER_REG(base), ((uint32_t)(value) << LPI2C_MDER_RDDE_SHIFT), LPI2C_MDER_RDDE_SHIFT, LPI2C_MDER_RDDE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR0 - Master Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR0 - Master Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR0 register
 */
/*@{*/
#define LPI2C_RD_MCFGR0(base)    (LPI2C_MCFGR0_REG(base))
#define LPI2C_WR_MCFGR0(base, value) (LPI2C_MCFGR0_REG(base) = (value))
#define LPI2C_RMW_MCFGR0(base, mask, value) (LPI2C_WR_MCFGR0(base, (LPI2C_RD_MCFGR0(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR0(base, value) (BME_OR32(&LPI2C_MCFGR0_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MCFGR0(base, value) (BME_AND32(&LPI2C_MCFGR0_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MCFGR0(base, value) (BME_XOR32(&LPI2C_MCFGR0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR0 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR0, field HREN[0] (RW)
 *
 * When enabled, the LPI2C master will only initiate a START condition if the
 * host request input is asserted and the bus is idle. A repeated START is not
 * affected by the host request.
 *
 * Values:
 * - 0b0 - Host request input is disabled.
 * - 0b1 - Host request input is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HREN field. */
#define LPI2C_RD_MCFGR0_HREN(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HREN_MASK) >> LPI2C_MCFGR0_HREN_SHIFT)
#define LPI2C_BRD_MCFGR0_HREN(base) (BME_UBFX32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HREN_SHIFT, LPI2C_MCFGR0_HREN_WIDTH))

/*! @brief Set the HREN field to a new value. */
#define LPI2C_WR_MCFGR0_HREN(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HREN_MASK, LPI2C_MCFGR0_HREN(value)))
#define LPI2C_BWR_MCFGR0_HREN(base, value) (BME_BFI32(&LPI2C_MCFGR0_REG(base), ((uint32_t)(value) << LPI2C_MCFGR0_HREN_SHIFT), LPI2C_MCFGR0_HREN_SHIFT, LPI2C_MCFGR0_HREN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field HRPOL[1] (RW)
 *
 * Configures the polarity of the host request input pin.
 *
 * Values:
 * - 0b0 - Active low.
 * - 0b1 - Active high.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HRPOL field. */
#define LPI2C_RD_MCFGR0_HRPOL(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HRPOL_MASK) >> LPI2C_MCFGR0_HRPOL_SHIFT)
#define LPI2C_BRD_MCFGR0_HRPOL(base) (BME_UBFX32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRPOL_SHIFT, LPI2C_MCFGR0_HRPOL_WIDTH))

/*! @brief Set the HRPOL field to a new value. */
#define LPI2C_WR_MCFGR0_HRPOL(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HRPOL_MASK, LPI2C_MCFGR0_HRPOL(value)))
#define LPI2C_BWR_MCFGR0_HRPOL(base, value) (BME_BFI32(&LPI2C_MCFGR0_REG(base), ((uint32_t)(value) << LPI2C_MCFGR0_HRPOL_SHIFT), LPI2C_MCFGR0_HRPOL_SHIFT, LPI2C_MCFGR0_HRPOL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field HRSEL[2] (RW)
 *
 * Selects the source of the host request input.
 *
 * Values:
 * - 0b0 - Host request input is pin LPI2C_HREQ.
 * - 0b1 - Host request input is input trigger.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HRSEL field. */
#define LPI2C_RD_MCFGR0_HRSEL(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HRSEL_MASK) >> LPI2C_MCFGR0_HRSEL_SHIFT)
#define LPI2C_BRD_MCFGR0_HRSEL(base) (BME_UBFX32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRSEL_SHIFT, LPI2C_MCFGR0_HRSEL_WIDTH))

/*! @brief Set the HRSEL field to a new value. */
#define LPI2C_WR_MCFGR0_HRSEL(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HRSEL_MASK, LPI2C_MCFGR0_HRSEL(value)))
#define LPI2C_BWR_MCFGR0_HRSEL(base, value) (BME_BFI32(&LPI2C_MCFGR0_REG(base), ((uint32_t)(value) << LPI2C_MCFGR0_HRSEL_SHIFT), LPI2C_MCFGR0_HRSEL_SHIFT, LPI2C_MCFGR0_HRSEL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field CIRFIFO[8] (RW)
 *
 * When enabled, the transmit FIFO read pointer is saved to a temporary
 * register. The transmit FIFO will be emptied as normal, but once the LPI2C master is
 * idle and the transmit FIFO is empty, then the read pointer value will be
 * restored from the temporary register. This will cause the contents of the transmit
 * FIFO to be cycled through repeatedly. If AUTOSTOP is set, a STOP condition will
 * be sent whenever the transmit FIFO is empty and the read pointer is restored.
 *
 * Values:
 * - 0b0 - Circular FIFO is disabled.
 * - 0b1 - Circular FIFO is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_CIRFIFO field. */
#define LPI2C_RD_MCFGR0_CIRFIFO(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_CIRFIFO_MASK) >> LPI2C_MCFGR0_CIRFIFO_SHIFT)
#define LPI2C_BRD_MCFGR0_CIRFIFO(base) (BME_UBFX32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_CIRFIFO_SHIFT, LPI2C_MCFGR0_CIRFIFO_WIDTH))

/*! @brief Set the CIRFIFO field to a new value. */
#define LPI2C_WR_MCFGR0_CIRFIFO(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_CIRFIFO_MASK, LPI2C_MCFGR0_CIRFIFO(value)))
#define LPI2C_BWR_MCFGR0_CIRFIFO(base, value) (BME_BFI32(&LPI2C_MCFGR0_REG(base), ((uint32_t)(value) << LPI2C_MCFGR0_CIRFIFO_SHIFT), LPI2C_MCFGR0_CIRFIFO_SHIFT, LPI2C_MCFGR0_CIRFIFO_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field RDMO[9] (RW)
 *
 * When enabled, all received data that does not cause DMF to set is discarded.
 * Once DMF is set, the RDMO configuration is ignored. When disabling RDMO, clear
 * RDMO before clearing DMF to ensure no receive data is lost.
 *
 * Values:
 * - 0b0 - Received data is stored in the receive FIFO as normal.
 * - 0b1 - Received data is discarded unless the RMF is set.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_RDMO field. */
#define LPI2C_RD_MCFGR0_RDMO(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_RDMO_MASK) >> LPI2C_MCFGR0_RDMO_SHIFT)
#define LPI2C_BRD_MCFGR0_RDMO(base) (BME_UBFX32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_RDMO_SHIFT, LPI2C_MCFGR0_RDMO_WIDTH))

/*! @brief Set the RDMO field to a new value. */
#define LPI2C_WR_MCFGR0_RDMO(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_RDMO_MASK, LPI2C_MCFGR0_RDMO(value)))
#define LPI2C_BWR_MCFGR0_RDMO(base, value) (BME_BFI32(&LPI2C_MCFGR0_REG(base), ((uint32_t)(value) << LPI2C_MCFGR0_RDMO_SHIFT), LPI2C_MCFGR0_RDMO_SHIFT, LPI2C_MCFGR0_RDMO_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR1 - Master Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR1 - Master Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR1 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR1 register
 */
/*@{*/
#define LPI2C_RD_MCFGR1(base)    (LPI2C_MCFGR1_REG(base))
#define LPI2C_WR_MCFGR1(base, value) (LPI2C_MCFGR1_REG(base) = (value))
#define LPI2C_RMW_MCFGR1(base, mask, value) (LPI2C_WR_MCFGR1(base, (LPI2C_RD_MCFGR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR1(base, value) (BME_OR32(&LPI2C_MCFGR1_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MCFGR1(base, value) (BME_AND32(&LPI2C_MCFGR1_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MCFGR1(base, value) (BME_XOR32(&LPI2C_MCFGR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR1 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR1, field PRESCALE[2:0] (RW)
 *
 * Configures the clock prescaler used for all LPI2C master logic, except the
 * digital glitch filters.
 *
 * Values:
 * - 0b000 - Divide by 1.
 * - 0b001 - Divide by 2.
 * - 0b010 - Divide by 4.
 * - 0b011 - Divide by 8.
 * - 0b100 - Divide by 16.
 * - 0b101 - Divide by 32.
 * - 0b110 - Divide by 64.
 * - 0b111 - Divide by 128.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_PRESCALE field. */
#define LPI2C_RD_MCFGR1_PRESCALE(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_PRESCALE_MASK) >> LPI2C_MCFGR1_PRESCALE_SHIFT)
#define LPI2C_BRD_MCFGR1_PRESCALE(base) (BME_UBFX32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_PRESCALE_SHIFT, LPI2C_MCFGR1_PRESCALE_WIDTH))

/*! @brief Set the PRESCALE field to a new value. */
#define LPI2C_WR_MCFGR1_PRESCALE(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_PRESCALE_MASK, LPI2C_MCFGR1_PRESCALE(value)))
#define LPI2C_BWR_MCFGR1_PRESCALE(base, value) (BME_BFI32(&LPI2C_MCFGR1_REG(base), ((uint32_t)(value) << LPI2C_MCFGR1_PRESCALE_SHIFT), LPI2C_MCFGR1_PRESCALE_SHIFT, LPI2C_MCFGR1_PRESCALE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field AUTOSTOP[8] (RW)
 *
 * When enabled, a STOP condition is generated whenever the LPI2C master is busy
 * and the transmit FIFO is empty. The STOP condition can also be generated
 * using a transmit FIFO command.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - STOP condition is automatically generated whenever the transmit FIFO
 *     is empty and LPI2C master is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_AUTOSTOP field. */
#define LPI2C_RD_MCFGR1_AUTOSTOP(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_AUTOSTOP_MASK) >> LPI2C_MCFGR1_AUTOSTOP_SHIFT)
#define LPI2C_BRD_MCFGR1_AUTOSTOP(base) (BME_UBFX32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_AUTOSTOP_SHIFT, LPI2C_MCFGR1_AUTOSTOP_WIDTH))

/*! @brief Set the AUTOSTOP field to a new value. */
#define LPI2C_WR_MCFGR1_AUTOSTOP(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_AUTOSTOP_MASK, LPI2C_MCFGR1_AUTOSTOP(value)))
#define LPI2C_BWR_MCFGR1_AUTOSTOP(base, value) (BME_BFI32(&LPI2C_MCFGR1_REG(base), ((uint32_t)(value) << LPI2C_MCFGR1_AUTOSTOP_SHIFT), LPI2C_MCFGR1_AUTOSTOP_SHIFT, LPI2C_MCFGR1_AUTOSTOP_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field IGNACK[9] (RW)
 *
 * When set, the received NACK field is ignored and assumed to be ACK. This bit
 * is required to be set in Ultra-Fast Mode.
 *
 * Values:
 * - 0b0 - LPI2C Master will receive ACK and NACK normally.
 * - 0b1 - LPI2C Master will treat a received NACK as if it was an ACK.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_IGNACK field. */
#define LPI2C_RD_MCFGR1_IGNACK(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_IGNACK_MASK) >> LPI2C_MCFGR1_IGNACK_SHIFT)
#define LPI2C_BRD_MCFGR1_IGNACK(base) (BME_UBFX32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_IGNACK_SHIFT, LPI2C_MCFGR1_IGNACK_WIDTH))

/*! @brief Set the IGNACK field to a new value. */
#define LPI2C_WR_MCFGR1_IGNACK(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_IGNACK_MASK, LPI2C_MCFGR1_IGNACK(value)))
#define LPI2C_BWR_MCFGR1_IGNACK(base, value) (BME_BFI32(&LPI2C_MCFGR1_REG(base), ((uint32_t)(value) << LPI2C_MCFGR1_IGNACK_SHIFT), LPI2C_MCFGR1_IGNACK_SHIFT, LPI2C_MCFGR1_IGNACK_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field TIMECFG[10] (RW)
 *
 * Values:
 * - 0b0 - Pin Low Timeout Flag will set if SCL is low for longer than the
 *     configured timeout.
 * - 0b1 - Pin Low Timeout Flag will set if either SCL or SDA is low for longer
 *     than the configured timeout.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_TIMECFG field. */
#define LPI2C_RD_MCFGR1_TIMECFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_TIMECFG_MASK) >> LPI2C_MCFGR1_TIMECFG_SHIFT)
#define LPI2C_BRD_MCFGR1_TIMECFG(base) (BME_UBFX32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_TIMECFG_SHIFT, LPI2C_MCFGR1_TIMECFG_WIDTH))

/*! @brief Set the TIMECFG field to a new value. */
#define LPI2C_WR_MCFGR1_TIMECFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_TIMECFG_MASK, LPI2C_MCFGR1_TIMECFG(value)))
#define LPI2C_BWR_MCFGR1_TIMECFG(base, value) (BME_BFI32(&LPI2C_MCFGR1_REG(base), ((uint32_t)(value) << LPI2C_MCFGR1_TIMECFG_SHIFT), LPI2C_MCFGR1_TIMECFG_SHIFT, LPI2C_MCFGR1_TIMECFG_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field MATCFG[18:16] (RW)
 *
 * Configures the condition that will cause the DMF to set.
 *
 * Values:
 * - 0b000 - Match disabled.
 * - 0b001 - Reserved.
 * - 0b010 - Match enabled (1st data word equals MATCH0 OR MATCH1).
 * - 0b011 - Match enabled (any data word equals MATCH0 OR MATCH1).
 * - 0b100 - Match enabled (1st data word equals MATCH0 AND 2nd data word equals
 *     MATCH1).
 * - 0b101 - Match enabled (any data word equals MATCH0 AND next data word
 *     equals MATCH1).
 * - 0b110 - Match enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1).
 * - 0b111 - Match enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_MATCFG field. */
#define LPI2C_RD_MCFGR1_MATCFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_MATCFG_MASK) >> LPI2C_MCFGR1_MATCFG_SHIFT)
#define LPI2C_BRD_MCFGR1_MATCFG(base) (BME_UBFX32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_MATCFG_SHIFT, LPI2C_MCFGR1_MATCFG_WIDTH))

/*! @brief Set the MATCFG field to a new value. */
#define LPI2C_WR_MCFGR1_MATCFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_MATCFG_MASK, LPI2C_MCFGR1_MATCFG(value)))
#define LPI2C_BWR_MCFGR1_MATCFG(base, value) (BME_BFI32(&LPI2C_MCFGR1_REG(base), ((uint32_t)(value) << LPI2C_MCFGR1_MATCFG_SHIFT), LPI2C_MCFGR1_MATCFG_SHIFT, LPI2C_MCFGR1_MATCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field PINCFG[26:24] (RW)
 *
 * Configures the pin mode.
 *
 * Values:
 * - 0b000 - LPI2C configured for 2-pin open drain mode.
 * - 0b001 - LPI2C configured for 2-pin output only mode (ultra-fast mode).
 * - 0b010 - LPI2C configured for 2-pin push-pull mode.
 * - 0b011 - LPI2C configured for 4-pin push-pull mode.
 * - 0b100 - LPI2C configured for 2-pin open drain mode with separate LPI2C
 *     slave.
 * - 0b101 - LPI2C configured for 2-pin output only mode (ultra-fast mode) with
 *     separate LPI2C slave.
 * - 0b110 - LPI2C configured for 2-pin push-pull mode with separate LPI2C slave.
 * - 0b111 - LPI2C configured for 4-pin push-pull mode (inverted outputs).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_PINCFG field. */
#define LPI2C_RD_MCFGR1_PINCFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_PINCFG_MASK) >> LPI2C_MCFGR1_PINCFG_SHIFT)
#define LPI2C_BRD_MCFGR1_PINCFG(base) (BME_UBFX32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_PINCFG_SHIFT, LPI2C_MCFGR1_PINCFG_WIDTH))

/*! @brief Set the PINCFG field to a new value. */
#define LPI2C_WR_MCFGR1_PINCFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_PINCFG_MASK, LPI2C_MCFGR1_PINCFG(value)))
#define LPI2C_BWR_MCFGR1_PINCFG(base, value) (BME_BFI32(&LPI2C_MCFGR1_REG(base), ((uint32_t)(value) << LPI2C_MCFGR1_PINCFG_SHIFT), LPI2C_MCFGR1_PINCFG_SHIFT, LPI2C_MCFGR1_PINCFG_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR2 - Master Configuration Register 2
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR2 - Master Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR2 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR2 register
 */
/*@{*/
#define LPI2C_RD_MCFGR2(base)    (LPI2C_MCFGR2_REG(base))
#define LPI2C_WR_MCFGR2(base, value) (LPI2C_MCFGR2_REG(base) = (value))
#define LPI2C_RMW_MCFGR2(base, mask, value) (LPI2C_WR_MCFGR2(base, (LPI2C_RD_MCFGR2(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR2(base, value) (BME_OR32(&LPI2C_MCFGR2_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MCFGR2(base, value) (BME_AND32(&LPI2C_MCFGR2_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MCFGR2(base, value) (BME_XOR32(&LPI2C_MCFGR2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR2 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR2, field BUSIDLE[11:0] (RW)
 *
 * Configures the bus idle timeout period in clock cycles. If both SCL and SDA
 * are high for longer than BUSIDLE cycles, then the I2C bus is assumed to be idle
 * and the master can generate a START condition. When set to zero, this feature
 * is disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_BUSIDLE field. */
#define LPI2C_RD_MCFGR2_BUSIDLE(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_BUSIDLE_MASK) >> LPI2C_MCFGR2_BUSIDLE_SHIFT)
#define LPI2C_BRD_MCFGR2_BUSIDLE(base) (LPI2C_RD_MCFGR2_BUSIDLE(base))

/*! @brief Set the BUSIDLE field to a new value. */
#define LPI2C_WR_MCFGR2_BUSIDLE(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_BUSIDLE_MASK, LPI2C_MCFGR2_BUSIDLE(value)))
#define LPI2C_BWR_MCFGR2_BUSIDLE(base, value) (LPI2C_WR_MCFGR2_BUSIDLE(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR2, field FILTSCL[19:16] (RW)
 *
 * Configures the I2C master digital glitch filters for SCL input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSCL
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSCL cycles and must be configured less than the minimum
 * SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration and is automatically bypassed in High Speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_FILTSCL field. */
#define LPI2C_RD_MCFGR2_FILTSCL(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_FILTSCL_MASK) >> LPI2C_MCFGR2_FILTSCL_SHIFT)
#define LPI2C_BRD_MCFGR2_FILTSCL(base) (BME_UBFX32(&LPI2C_MCFGR2_REG(base), LPI2C_MCFGR2_FILTSCL_SHIFT, LPI2C_MCFGR2_FILTSCL_WIDTH))

/*! @brief Set the FILTSCL field to a new value. */
#define LPI2C_WR_MCFGR2_FILTSCL(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_FILTSCL_MASK, LPI2C_MCFGR2_FILTSCL(value)))
#define LPI2C_BWR_MCFGR2_FILTSCL(base, value) (BME_BFI32(&LPI2C_MCFGR2_REG(base), ((uint32_t)(value) << LPI2C_MCFGR2_FILTSCL_SHIFT), LPI2C_MCFGR2_FILTSCL_SHIFT, LPI2C_MCFGR2_FILTSCL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR2, field FILTSDA[27:24] (RW)
 *
 * Configures the I2C master digital glitch filters for SDA input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSDA
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSDA cycles and must be configured less than the minimum
 * SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration and is automatically bypassed in High Speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_FILTSDA field. */
#define LPI2C_RD_MCFGR2_FILTSDA(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_FILTSDA_MASK) >> LPI2C_MCFGR2_FILTSDA_SHIFT)
#define LPI2C_BRD_MCFGR2_FILTSDA(base) (BME_UBFX32(&LPI2C_MCFGR2_REG(base), LPI2C_MCFGR2_FILTSDA_SHIFT, LPI2C_MCFGR2_FILTSDA_WIDTH))

/*! @brief Set the FILTSDA field to a new value. */
#define LPI2C_WR_MCFGR2_FILTSDA(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_FILTSDA_MASK, LPI2C_MCFGR2_FILTSDA(value)))
#define LPI2C_BWR_MCFGR2_FILTSDA(base, value) (BME_BFI32(&LPI2C_MCFGR2_REG(base), ((uint32_t)(value) << LPI2C_MCFGR2_FILTSDA_SHIFT), LPI2C_MCFGR2_FILTSDA_SHIFT, LPI2C_MCFGR2_FILTSDA_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR3 - Master Configuration Register 3
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR3 - Master Configuration Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR3 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR3 register
 */
/*@{*/
#define LPI2C_RD_MCFGR3(base)    (LPI2C_MCFGR3_REG(base))
#define LPI2C_WR_MCFGR3(base, value) (LPI2C_MCFGR3_REG(base) = (value))
#define LPI2C_RMW_MCFGR3(base, mask, value) (LPI2C_WR_MCFGR3(base, (LPI2C_RD_MCFGR3(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR3(base, value) (BME_OR32(&LPI2C_MCFGR3_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MCFGR3(base, value) (BME_AND32(&LPI2C_MCFGR3_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MCFGR3(base, value) (BME_XOR32(&LPI2C_MCFGR3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR3 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR3, field PINLOW[19:8] (RW)
 *
 * Configures the pin low timeout flag in clock cycles. If SCL and/or SDA is low
 * for longer than (PINLOW * 256) cycles then PLTF is set. When set to zero,
 * this feature is disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR3_PINLOW field. */
#define LPI2C_RD_MCFGR3_PINLOW(base) ((LPI2C_MCFGR3_REG(base) & LPI2C_MCFGR3_PINLOW_MASK) >> LPI2C_MCFGR3_PINLOW_SHIFT)
#define LPI2C_BRD_MCFGR3_PINLOW(base) (LPI2C_RD_MCFGR3_PINLOW(base))

/*! @brief Set the PINLOW field to a new value. */
#define LPI2C_WR_MCFGR3_PINLOW(base, value) (LPI2C_RMW_MCFGR3(base, LPI2C_MCFGR3_PINLOW_MASK, LPI2C_MCFGR3_PINLOW(value)))
#define LPI2C_BWR_MCFGR3_PINLOW(base, value) (LPI2C_WR_MCFGR3_PINLOW(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MDMR - Master Data Match Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MDMR - Master Data Match Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MDMR register
 */
/*@{*/
#define LPI2C_RD_MDMR(base)      (LPI2C_MDMR_REG(base))
#define LPI2C_WR_MDMR(base, value) (LPI2C_MDMR_REG(base) = (value))
#define LPI2C_RMW_MDMR(base, mask, value) (LPI2C_WR_MDMR(base, (LPI2C_RD_MDMR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MDMR(base, value) (BME_OR32(&LPI2C_MDMR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MDMR(base, value) (BME_AND32(&LPI2C_MDMR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MDMR(base, value) (BME_XOR32(&LPI2C_MDMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MDMR bitfields
 */

/*!
 * @name Register LPI2C_MDMR, field MATCH0[7:0] (RW)
 *
 * Compared against the received data when receive data match is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDMR_MATCH0 field. */
#define LPI2C_RD_MDMR_MATCH0(base) ((LPI2C_MDMR_REG(base) & LPI2C_MDMR_MATCH0_MASK) >> LPI2C_MDMR_MATCH0_SHIFT)
#define LPI2C_BRD_MDMR_MATCH0(base) (BME_UBFX32(&LPI2C_MDMR_REG(base), LPI2C_MDMR_MATCH0_SHIFT, LPI2C_MDMR_MATCH0_WIDTH))

/*! @brief Set the MATCH0 field to a new value. */
#define LPI2C_WR_MDMR_MATCH0(base, value) (LPI2C_RMW_MDMR(base, LPI2C_MDMR_MATCH0_MASK, LPI2C_MDMR_MATCH0(value)))
#define LPI2C_BWR_MDMR_MATCH0(base, value) (BME_BFI32(&LPI2C_MDMR_REG(base), ((uint32_t)(value) << LPI2C_MDMR_MATCH0_SHIFT), LPI2C_MDMR_MATCH0_SHIFT, LPI2C_MDMR_MATCH0_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MDMR, field MATCH1[23:16] (RW)
 *
 * Compared against the received data when receive data match is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDMR_MATCH1 field. */
#define LPI2C_RD_MDMR_MATCH1(base) ((LPI2C_MDMR_REG(base) & LPI2C_MDMR_MATCH1_MASK) >> LPI2C_MDMR_MATCH1_SHIFT)
#define LPI2C_BRD_MDMR_MATCH1(base) (BME_UBFX32(&LPI2C_MDMR_REG(base), LPI2C_MDMR_MATCH1_SHIFT, LPI2C_MDMR_MATCH1_WIDTH))

/*! @brief Set the MATCH1 field to a new value. */
#define LPI2C_WR_MDMR_MATCH1(base, value) (LPI2C_RMW_MDMR(base, LPI2C_MDMR_MATCH1_MASK, LPI2C_MDMR_MATCH1(value)))
#define LPI2C_BWR_MDMR_MATCH1(base, value) (BME_BFI32(&LPI2C_MDMR_REG(base), ((uint32_t)(value) << LPI2C_MDMR_MATCH1_SHIFT), LPI2C_MDMR_MATCH1_SHIFT, LPI2C_MDMR_MATCH1_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MCCR0 - Master Clock Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPI2C_MCCR0 - Master Clock Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCCR0 cannot be changed when the I2C master is enabled and is used for
 * standard, fast, fast-mode plus and ultra-fast transfers.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCCR0 register
 */
/*@{*/
#define LPI2C_RD_MCCR0(base)     (LPI2C_MCCR0_REG(base))
#define LPI2C_WR_MCCR0(base, value) (LPI2C_MCCR0_REG(base) = (value))
#define LPI2C_RMW_MCCR0(base, mask, value) (LPI2C_WR_MCCR0(base, (LPI2C_RD_MCCR0(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCCR0(base, value) (BME_OR32(&LPI2C_MCCR0_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MCCR0(base, value) (BME_AND32(&LPI2C_MCCR0_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MCCR0(base, value) (BME_XOR32(&LPI2C_MCCR0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCCR0 bitfields
 */

/*!
 * @name Register LPI2C_MCCR0, field CLKLO[5:0] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven low by the
 * master. This value is also used for the minimum bus free time between a STOP
 * and a START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_CLKLO field. */
#define LPI2C_RD_MCCR0_CLKLO(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_CLKLO_MASK) >> LPI2C_MCCR0_CLKLO_SHIFT)
#define LPI2C_BRD_MCCR0_CLKLO(base) (BME_UBFX32(&LPI2C_MCCR0_REG(base), LPI2C_MCCR0_CLKLO_SHIFT, LPI2C_MCCR0_CLKLO_WIDTH))

/*! @brief Set the CLKLO field to a new value. */
#define LPI2C_WR_MCCR0_CLKLO(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_CLKLO_MASK, LPI2C_MCCR0_CLKLO(value)))
#define LPI2C_BWR_MCCR0_CLKLO(base, value) (BME_BFI32(&LPI2C_MCCR0_REG(base), ((uint32_t)(value) << LPI2C_MCCR0_CLKLO_SHIFT), LPI2C_MCCR0_CLKLO_SHIFT, LPI2C_MCCR0_CLKLO_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field CLKHI[13:8] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven high by the
 * master. The SCL high time is extended by the time it takes to detect a rising
 * edge on the external SCL pin. Ignoring any additional board delay due to
 * external loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_CLKHI field. */
#define LPI2C_RD_MCCR0_CLKHI(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_CLKHI_MASK) >> LPI2C_MCCR0_CLKHI_SHIFT)
#define LPI2C_BRD_MCCR0_CLKHI(base) (BME_UBFX32(&LPI2C_MCCR0_REG(base), LPI2C_MCCR0_CLKHI_SHIFT, LPI2C_MCCR0_CLKHI_WIDTH))

/*! @brief Set the CLKHI field to a new value. */
#define LPI2C_WR_MCCR0_CLKHI(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_CLKHI_MASK, LPI2C_MCCR0_CLKHI(value)))
#define LPI2C_BWR_MCCR0_CLKHI(base, value) (BME_BFI32(&LPI2C_MCCR0_REG(base), ((uint32_t)(value) << LPI2C_MCCR0_CLKHI_SHIFT), LPI2C_MCCR0_CLKHI_SHIFT, LPI2C_MCCR0_CLKHI_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field SETHOLD[21:16] (RW)
 *
 * Minimum number of cycles (minus one) that is used by the master as the setup
 * and hold time for a (repeated) START condition and setup time for a STOP
 * condition. The setup time is extended by the time it takes to detect a rising edge
 * on the external SCL pin. Ignoring any additional board delay due to external
 * loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_SETHOLD field. */
#define LPI2C_RD_MCCR0_SETHOLD(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_SETHOLD_MASK) >> LPI2C_MCCR0_SETHOLD_SHIFT)
#define LPI2C_BRD_MCCR0_SETHOLD(base) (BME_UBFX32(&LPI2C_MCCR0_REG(base), LPI2C_MCCR0_SETHOLD_SHIFT, LPI2C_MCCR0_SETHOLD_WIDTH))

/*! @brief Set the SETHOLD field to a new value. */
#define LPI2C_WR_MCCR0_SETHOLD(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_SETHOLD_MASK, LPI2C_MCCR0_SETHOLD(value)))
#define LPI2C_BWR_MCCR0_SETHOLD(base, value) (BME_BFI32(&LPI2C_MCCR0_REG(base), ((uint32_t)(value) << LPI2C_MCCR0_SETHOLD_SHIFT), LPI2C_MCCR0_SETHOLD_SHIFT, LPI2C_MCCR0_SETHOLD_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field DATAVD[29:24] (RW)
 *
 * Minimum number of cycles (minus one) that is used as the data hold time for
 * SDA. Must be configured less than the minimum SCL low period.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_DATAVD field. */
#define LPI2C_RD_MCCR0_DATAVD(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_DATAVD_MASK) >> LPI2C_MCCR0_DATAVD_SHIFT)
#define LPI2C_BRD_MCCR0_DATAVD(base) (BME_UBFX32(&LPI2C_MCCR0_REG(base), LPI2C_MCCR0_DATAVD_SHIFT, LPI2C_MCCR0_DATAVD_WIDTH))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_MCCR0_DATAVD(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_DATAVD_MASK, LPI2C_MCCR0_DATAVD(value)))
#define LPI2C_BWR_MCCR0_DATAVD(base, value) (BME_BFI32(&LPI2C_MCCR0_REG(base), ((uint32_t)(value) << LPI2C_MCCR0_DATAVD_SHIFT), LPI2C_MCCR0_DATAVD_SHIFT, LPI2C_MCCR0_DATAVD_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MCCR1 - Master Clock Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_MCCR1 - Master Clock Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCCR1 cannot be changed when the I2C master is enabled and is used for
 * high speed mode transfers. The separate clock configuration for high speed mode
 * allows arbitration to take place in Fast mode (with timing configured by
 * MCCR0), before switching to high speed mode (with timing configured by MCCR1).
 */
/*!
 * @name Constants and macros for entire LPI2C_MCCR1 register
 */
/*@{*/
#define LPI2C_RD_MCCR1(base)     (LPI2C_MCCR1_REG(base))
#define LPI2C_WR_MCCR1(base, value) (LPI2C_MCCR1_REG(base) = (value))
#define LPI2C_RMW_MCCR1(base, mask, value) (LPI2C_WR_MCCR1(base, (LPI2C_RD_MCCR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCCR1(base, value) (BME_OR32(&LPI2C_MCCR1_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MCCR1(base, value) (BME_AND32(&LPI2C_MCCR1_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MCCR1(base, value) (BME_XOR32(&LPI2C_MCCR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCCR1 bitfields
 */

/*!
 * @name Register LPI2C_MCCR1, field CLKLO[5:0] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven low by the
 * master. This value is also used for the minimum bus free time between a STOP
 * and a START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_CLKLO field. */
#define LPI2C_RD_MCCR1_CLKLO(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_CLKLO_MASK) >> LPI2C_MCCR1_CLKLO_SHIFT)
#define LPI2C_BRD_MCCR1_CLKLO(base) (BME_UBFX32(&LPI2C_MCCR1_REG(base), LPI2C_MCCR1_CLKLO_SHIFT, LPI2C_MCCR1_CLKLO_WIDTH))

/*! @brief Set the CLKLO field to a new value. */
#define LPI2C_WR_MCCR1_CLKLO(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_CLKLO_MASK, LPI2C_MCCR1_CLKLO(value)))
#define LPI2C_BWR_MCCR1_CLKLO(base, value) (BME_BFI32(&LPI2C_MCCR1_REG(base), ((uint32_t)(value) << LPI2C_MCCR1_CLKLO_SHIFT), LPI2C_MCCR1_CLKLO_SHIFT, LPI2C_MCCR1_CLKLO_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field CLKHI[13:8] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven high by the
 * master. The SCL high time is extended by the time it takes to detect a rising
 * edge on the external SCL pin. Ignoring any additional board delay due to
 * external loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_CLKHI field. */
#define LPI2C_RD_MCCR1_CLKHI(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_CLKHI_MASK) >> LPI2C_MCCR1_CLKHI_SHIFT)
#define LPI2C_BRD_MCCR1_CLKHI(base) (BME_UBFX32(&LPI2C_MCCR1_REG(base), LPI2C_MCCR1_CLKHI_SHIFT, LPI2C_MCCR1_CLKHI_WIDTH))

/*! @brief Set the CLKHI field to a new value. */
#define LPI2C_WR_MCCR1_CLKHI(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_CLKHI_MASK, LPI2C_MCCR1_CLKHI(value)))
#define LPI2C_BWR_MCCR1_CLKHI(base, value) (BME_BFI32(&LPI2C_MCCR1_REG(base), ((uint32_t)(value) << LPI2C_MCCR1_CLKHI_SHIFT), LPI2C_MCCR1_CLKHI_SHIFT, LPI2C_MCCR1_CLKHI_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field SETHOLD[21:16] (RW)
 *
 * Minimum number of cycles (minus one) that is used by the master as the setup
 * and hold time for a (repeated) START condition and setup time for a STOP
 * condition. The setup time is extended by the time it takes to detect a rising edge
 * on the external SCL pin. Ignoring any additional board delay due to external
 * loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_SETHOLD field. */
#define LPI2C_RD_MCCR1_SETHOLD(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_SETHOLD_MASK) >> LPI2C_MCCR1_SETHOLD_SHIFT)
#define LPI2C_BRD_MCCR1_SETHOLD(base) (BME_UBFX32(&LPI2C_MCCR1_REG(base), LPI2C_MCCR1_SETHOLD_SHIFT, LPI2C_MCCR1_SETHOLD_WIDTH))

/*! @brief Set the SETHOLD field to a new value. */
#define LPI2C_WR_MCCR1_SETHOLD(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_SETHOLD_MASK, LPI2C_MCCR1_SETHOLD(value)))
#define LPI2C_BWR_MCCR1_SETHOLD(base, value) (BME_BFI32(&LPI2C_MCCR1_REG(base), ((uint32_t)(value) << LPI2C_MCCR1_SETHOLD_SHIFT), LPI2C_MCCR1_SETHOLD_SHIFT, LPI2C_MCCR1_SETHOLD_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field DATAVD[29:24] (RW)
 *
 * Minimum number of cycles (minus one) that is used as the data hold time for
 * SDA. Must be configured less than the minimum SCL low period.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_DATAVD field. */
#define LPI2C_RD_MCCR1_DATAVD(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_DATAVD_MASK) >> LPI2C_MCCR1_DATAVD_SHIFT)
#define LPI2C_BRD_MCCR1_DATAVD(base) (BME_UBFX32(&LPI2C_MCCR1_REG(base), LPI2C_MCCR1_DATAVD_SHIFT, LPI2C_MCCR1_DATAVD_WIDTH))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_MCCR1_DATAVD(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_DATAVD_MASK, LPI2C_MCCR1_DATAVD(value)))
#define LPI2C_BWR_MCCR1_DATAVD(base, value) (BME_BFI32(&LPI2C_MCCR1_REG(base), ((uint32_t)(value) << LPI2C_MCCR1_DATAVD_SHIFT), LPI2C_MCCR1_DATAVD_SHIFT, LPI2C_MCCR1_DATAVD_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MFCR - Master FIFO Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MFCR - Master FIFO Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MFCR register
 */
/*@{*/
#define LPI2C_RD_MFCR(base)      (LPI2C_MFCR_REG(base))
#define LPI2C_WR_MFCR(base, value) (LPI2C_MFCR_REG(base) = (value))
#define LPI2C_RMW_MFCR(base, mask, value) (LPI2C_WR_MFCR(base, (LPI2C_RD_MFCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MFCR(base, value) (BME_OR32(&LPI2C_MFCR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_MFCR(base, value) (BME_AND32(&LPI2C_MFCR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_MFCR(base, value) (BME_XOR32(&LPI2C_MFCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MFCR bitfields
 */

/*!
 * @name Register LPI2C_MFCR, field TXWATER[7:0] (RW)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER. Writing a value equal or greater than the
 * FIFO size will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFCR_TXWATER field. */
#define LPI2C_RD_MFCR_TXWATER(base) ((LPI2C_MFCR_REG(base) & LPI2C_MFCR_TXWATER_MASK) >> LPI2C_MFCR_TXWATER_SHIFT)
#define LPI2C_BRD_MFCR_TXWATER(base) (BME_UBFX32(&LPI2C_MFCR_REG(base), LPI2C_MFCR_TXWATER_SHIFT, LPI2C_MFCR_TXWATER_WIDTH))

/*! @brief Set the TXWATER field to a new value. */
#define LPI2C_WR_MFCR_TXWATER(base, value) (LPI2C_RMW_MFCR(base, LPI2C_MFCR_TXWATER_MASK, LPI2C_MFCR_TXWATER(value)))
#define LPI2C_BWR_MFCR_TXWATER(base, value) (BME_BFI32(&LPI2C_MFCR_REG(base), ((uint32_t)(value) << LPI2C_MFCR_TXWATER_SHIFT), LPI2C_MFCR_TXWATER_SHIFT, LPI2C_MFCR_TXWATER_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MFCR, field RXWATER[23:16] (RW)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER. Writing a value equal or greater than the FIFO size
 * will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFCR_RXWATER field. */
#define LPI2C_RD_MFCR_RXWATER(base) ((LPI2C_MFCR_REG(base) & LPI2C_MFCR_RXWATER_MASK) >> LPI2C_MFCR_RXWATER_SHIFT)
#define LPI2C_BRD_MFCR_RXWATER(base) (BME_UBFX32(&LPI2C_MFCR_REG(base), LPI2C_MFCR_RXWATER_SHIFT, LPI2C_MFCR_RXWATER_WIDTH))

/*! @brief Set the RXWATER field to a new value. */
#define LPI2C_WR_MFCR_RXWATER(base, value) (LPI2C_RMW_MFCR(base, LPI2C_MFCR_RXWATER_MASK, LPI2C_MFCR_RXWATER(value)))
#define LPI2C_BWR_MFCR_RXWATER(base, value) (BME_BFI32(&LPI2C_MFCR_REG(base), ((uint32_t)(value) << LPI2C_MFCR_RXWATER_SHIFT), LPI2C_MFCR_RXWATER_SHIFT, LPI2C_MFCR_RXWATER_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MFSR - Master FIFO Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MFSR - Master FIFO Status Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MFSR register
 */
/*@{*/
#define LPI2C_RD_MFSR(base)      (LPI2C_MFSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MFSR bitfields
 */

/*!
 * @name Register LPI2C_MFSR, field TXCOUNT[7:0] (RO)
 *
 * Returns the number of words in the transmit FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFSR_TXCOUNT field. */
#define LPI2C_RD_MFSR_TXCOUNT(base) ((LPI2C_MFSR_REG(base) & LPI2C_MFSR_TXCOUNT_MASK) >> LPI2C_MFSR_TXCOUNT_SHIFT)
#define LPI2C_BRD_MFSR_TXCOUNT(base) (BME_UBFX32(&LPI2C_MFSR_REG(base), LPI2C_MFSR_TXCOUNT_SHIFT, LPI2C_MFSR_TXCOUNT_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MFSR, field RXCOUNT[23:16] (RO)
 *
 * Returns the number of words in the receive FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFSR_RXCOUNT field. */
#define LPI2C_RD_MFSR_RXCOUNT(base) ((LPI2C_MFSR_REG(base) & LPI2C_MFSR_RXCOUNT_MASK) >> LPI2C_MFSR_RXCOUNT_SHIFT)
#define LPI2C_BRD_MFSR_RXCOUNT(base) (BME_UBFX32(&LPI2C_MFSR_REG(base), LPI2C_MFSR_RXCOUNT_SHIFT, LPI2C_MFSR_RXCOUNT_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_MTDR - Master Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MTDR - Master Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 *
 * An 8-bit write to the CMD field will store the data in the Command FIFO, but
 * does not increment the FIFO write pointer. An 8-bit write to the DATA field
 * will zero extend the CMD field unless the CMD field has been written separately
 * since the last FIFO write, it also increments the FIFO write pointer. A 16-bit
 * or 32-bit will write both the CMD and DATA fields and increment the FIFO.
 */
/*!
 * @name Constants and macros for entire LPI2C_MTDR register
 */
/*@{*/
#define LPI2C_RD_MTDR(base)      (LPI2C_MTDR_REG(base))
#define LPI2C_WR_MTDR(base, value) (LPI2C_MTDR_REG(base) = (value))
#define LPI2C_RMW_MTDR(base, mask, value) (LPI2C_WR_MTDR(base, (LPI2C_RD_MTDR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MTDR bitfields
 */

/*!
 * @name Register LPI2C_MTDR, field DATA[7:0] (WO)
 *
 * Performing an 8-bit write to DATA will zero extend the CMD field.
 */
/*@{*/
/*! @brief Set the DATA field to a new value. */
#define LPI2C_WR_MTDR_DATA(base, value) (LPI2C_RMW_MTDR(base, LPI2C_MTDR_DATA_MASK, LPI2C_MTDR_DATA(value)))
#define LPI2C_BWR_MTDR_DATA(base, value) (LPI2C_WR_MTDR_DATA(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MTDR, field CMD[10:8] (WO)
 *
 * Values:
 * - 0b000 - Transmit DATA[7:0].
 * - 0b001 - Receive (DATA[7:0] + 1) bytes.
 * - 0b010 - Generate STOP condition.
 * - 0b011 - Receive and discard (DATA[7:0] + 1) bytes.
 * - 0b100 - Generate (repeated) START and transmit address in DATA[7:0].
 * - 0b101 - Generate (repeated) START and transmit address in DATA[7:0]. This
 *     transfer expects a NACK to be returned.
 * - 0b110 - Generate (repeated) START and transmit address in DATA[7:0] using
 *     high speed mode.
 * - 0b111 - Generate (repeated) START and transmit address in DATA[7:0] using
 *     high speed mode. This transfer expects a NACK to be returned.
 */
/*@{*/
/*! @brief Set the CMD field to a new value. */
#define LPI2C_WR_MTDR_CMD(base, value) (LPI2C_RMW_MTDR(base, LPI2C_MTDR_CMD_MASK, LPI2C_MTDR_CMD(value)))
#define LPI2C_BWR_MTDR_CMD(base, value) (LPI2C_WR_MTDR_CMD(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MRDR - Master Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MRDR - Master Receive Data Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MRDR register
 */
/*@{*/
#define LPI2C_RD_MRDR(base)      (LPI2C_MRDR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MRDR bitfields
 */

/*!
 * @name Register LPI2C_MRDR, field DATA[7:0] (RO)
 *
 * Reading this register returns the data received by the I2C master that has
 * not been discarded. Receive data can be discarded due to the CMD field or the
 * master can be configured to discard non-matching data.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MRDR_DATA field. */
#define LPI2C_RD_MRDR_DATA(base) ((LPI2C_MRDR_REG(base) & LPI2C_MRDR_DATA_MASK) >> LPI2C_MRDR_DATA_SHIFT)
#define LPI2C_BRD_MRDR_DATA(base) (BME_UBFX32(&LPI2C_MRDR_REG(base), LPI2C_MRDR_DATA_SHIFT, LPI2C_MRDR_DATA_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_MRDR, field RXEMPTY[14] (RO)
 *
 * Values:
 * - 0b0 - Receive FIFO is not empty.
 * - 0b1 - Receive FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MRDR_RXEMPTY field. */
#define LPI2C_RD_MRDR_RXEMPTY(base) ((LPI2C_MRDR_REG(base) & LPI2C_MRDR_RXEMPTY_MASK) >> LPI2C_MRDR_RXEMPTY_SHIFT)
#define LPI2C_BRD_MRDR_RXEMPTY(base) (BME_UBFX32(&LPI2C_MRDR_REG(base), LPI2C_MRDR_RXEMPTY_SHIFT, LPI2C_MRDR_RXEMPTY_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_SCR - Slave Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SCR - Slave Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SCR register
 */
/*@{*/
#define LPI2C_RD_SCR(base)       (LPI2C_SCR_REG(base))
#define LPI2C_WR_SCR(base, value) (LPI2C_SCR_REG(base) = (value))
#define LPI2C_RMW_SCR(base, mask, value) (LPI2C_WR_SCR(base, (LPI2C_RD_SCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCR(base, value) (BME_OR32(&LPI2C_SCR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_SCR(base, value) (BME_AND32(&LPI2C_SCR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_SCR(base, value) (BME_XOR32(&LPI2C_SCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCR bitfields
 */

/*!
 * @name Register LPI2C_SCR, field SEN[0] (RW)
 *
 * Values:
 * - 0b0 - Slave mode is disabled.
 * - 0b1 - Slave mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_SEN field. */
#define LPI2C_RD_SCR_SEN(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_SEN_MASK) >> LPI2C_SCR_SEN_SHIFT)
#define LPI2C_BRD_SCR_SEN(base) (BME_UBFX32(&LPI2C_SCR_REG(base), LPI2C_SCR_SEN_SHIFT, LPI2C_SCR_SEN_WIDTH))

/*! @brief Set the SEN field to a new value. */
#define LPI2C_WR_SCR_SEN(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_SEN_MASK, LPI2C_SCR_SEN(value)))
#define LPI2C_BWR_SCR_SEN(base, value) (BME_BFI32(&LPI2C_SCR_REG(base), ((uint32_t)(value) << LPI2C_SCR_SEN_SHIFT), LPI2C_SCR_SEN_SHIFT, LPI2C_SCR_SEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RST[1] (RW)
 *
 * Values:
 * - 0b0 - Slave logic is not reset.
 * - 0b1 - Slave logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_RST field. */
#define LPI2C_RD_SCR_RST(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_RST_MASK) >> LPI2C_SCR_RST_SHIFT)
#define LPI2C_BRD_SCR_RST(base) (BME_UBFX32(&LPI2C_SCR_REG(base), LPI2C_SCR_RST_SHIFT, LPI2C_SCR_RST_WIDTH))

/*! @brief Set the RST field to a new value. */
#define LPI2C_WR_SCR_RST(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RST_MASK, LPI2C_SCR_RST(value)))
#define LPI2C_BWR_SCR_RST(base, value) (BME_BFI32(&LPI2C_SCR_REG(base), ((uint32_t)(value) << LPI2C_SCR_RST_SHIFT), LPI2C_SCR_RST_SHIFT, LPI2C_SCR_RST_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field FILTEN[4] (RW)
 *
 * Values:
 * - 0b0 - Disable digital filter and output delay counter for slave mode.
 * - 0b1 - Enable digital filter and output delay counter for slave mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_FILTEN field. */
#define LPI2C_RD_SCR_FILTEN(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_FILTEN_MASK) >> LPI2C_SCR_FILTEN_SHIFT)
#define LPI2C_BRD_SCR_FILTEN(base) (BME_UBFX32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTEN_SHIFT, LPI2C_SCR_FILTEN_WIDTH))

/*! @brief Set the FILTEN field to a new value. */
#define LPI2C_WR_SCR_FILTEN(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_FILTEN_MASK, LPI2C_SCR_FILTEN(value)))
#define LPI2C_BWR_SCR_FILTEN(base, value) (BME_BFI32(&LPI2C_SCR_REG(base), ((uint32_t)(value) << LPI2C_SCR_FILTEN_SHIFT), LPI2C_SCR_FILTEN_SHIFT, LPI2C_SCR_FILTEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field FILTDZ[5] (RW)
 *
 * Values:
 * - 0b0 - Filter remains enabled in Doze mode.
 * - 0b1 - Filter is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_FILTDZ field. */
#define LPI2C_RD_SCR_FILTDZ(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_FILTDZ_MASK) >> LPI2C_SCR_FILTDZ_SHIFT)
#define LPI2C_BRD_SCR_FILTDZ(base) (BME_UBFX32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTDZ_SHIFT, LPI2C_SCR_FILTDZ_WIDTH))

/*! @brief Set the FILTDZ field to a new value. */
#define LPI2C_WR_SCR_FILTDZ(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_FILTDZ_MASK, LPI2C_SCR_FILTDZ(value)))
#define LPI2C_BWR_SCR_FILTDZ(base, value) (BME_BFI32(&LPI2C_SCR_REG(base), ((uint32_t)(value) << LPI2C_SCR_FILTDZ_SHIFT), LPI2C_SCR_FILTDZ_SHIFT, LPI2C_SCR_FILTDZ_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RTF[8] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Transmit Data Register is now empty.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPI2C_WR_SCR_RTF(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RTF_MASK, LPI2C_SCR_RTF(value)))
#define LPI2C_BWR_SCR_RTF(base, value) (BME_BFI32(&LPI2C_SCR_REG(base), ((uint32_t)(value) << LPI2C_SCR_RTF_SHIFT), LPI2C_SCR_RTF_SHIFT, LPI2C_SCR_RTF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RRF[9] (WORZ)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Receive Data Register is now empty.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPI2C_WR_SCR_RRF(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RRF_MASK, LPI2C_SCR_RRF(value)))
#define LPI2C_BWR_SCR_RRF(base, value) (BME_BFI32(&LPI2C_SCR_REG(base), ((uint32_t)(value) << LPI2C_SCR_RRF_SHIFT), LPI2C_SCR_RRF_SHIFT, LPI2C_SCR_RRF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_SSR - Slave Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SSR - Slave Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SSR register
 */
/*@{*/
#define LPI2C_RD_SSR(base)       (LPI2C_SSR_REG(base))
#define LPI2C_WR_SSR(base, value) (LPI2C_SSR_REG(base) = (value))
#define LPI2C_RMW_SSR(base, mask, value) (LPI2C_WR_SSR(base, (LPI2C_RD_SSR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SSR(base, value) (BME_OR32(&LPI2C_SSR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_SSR(base, value) (BME_AND32(&LPI2C_SSR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_SSR(base, value) (BME_XOR32(&LPI2C_SSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SSR bitfields
 */

/*!
 * @name Register LPI2C_SSR, field TDF[0] (RO)
 *
 * This flag is cleared by writing the transmit data register. When TXCFG is
 * clear, it is also cleared if a NACK or Repeated START or STOP condition is
 * detected.
 *
 * Values:
 * - 0b0 - Transmit data not requested.
 * - 0b1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_TDF field. */
#define LPI2C_RD_SSR_TDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_TDF_MASK) >> LPI2C_SSR_TDF_SHIFT)
#define LPI2C_BRD_SSR_TDF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_TDF_SHIFT, LPI2C_SSR_TDF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field RDF[1] (RO)
 *
 * This flag is cleared by reading the receive data register. When RXCFG is set,
 * this flag is not cleared when reading the receive data register and AVF is
 * set.
 *
 * Values:
 * - 0b0 - Receive Data is not ready.
 * - 0b1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_RDF field. */
#define LPI2C_RD_SSR_RDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_RDF_MASK) >> LPI2C_SSR_RDF_SHIFT)
#define LPI2C_BRD_SSR_RDF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_RDF_SHIFT, LPI2C_SSR_RDF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AVF[2] (RO)
 *
 * This flag is cleared by reading the address status register. When RXCFG is
 * set, this flag is also cleared by reading the receive data register.
 *
 * Values:
 * - 0b0 - Address Status Register is not valid.
 * - 0b1 - Address Status Register is valid.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AVF field. */
#define LPI2C_RD_SSR_AVF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AVF_MASK) >> LPI2C_SSR_AVF_SHIFT)
#define LPI2C_BRD_SSR_AVF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_AVF_SHIFT, LPI2C_SSR_AVF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field TAF[3] (RO)
 *
 * This flag is cleared by writing the transmit ACK register.
 *
 * Values:
 * - 0b0 - Transmit ACK/NACK is not required.
 * - 0b1 - Transmit ACK/NACK is required.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_TAF field. */
#define LPI2C_RD_SSR_TAF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_TAF_MASK) >> LPI2C_SSR_TAF_SHIFT)
#define LPI2C_BRD_SSR_TAF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_TAF_SHIFT, LPI2C_SSR_TAF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field RSF[8] (W1C)
 *
 * This flag will set when the LPI2C slave detects a repeated START condition,
 * provided the LPI2C slave matched the last address byte. It does not set when
 * the slave first detects a START condition.
 *
 * Values:
 * - 0b0 - Slave has not detected a Repeated START condition.
 * - 0b1 - Slave has detected a Repeated START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_RSF field. */
#define LPI2C_RD_SSR_RSF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_RSF_MASK) >> LPI2C_SSR_RSF_SHIFT)
#define LPI2C_BRD_SSR_RSF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_RSF_SHIFT, LPI2C_SSR_RSF_WIDTH))

/*! @brief Set the RSF field to a new value. */
#define LPI2C_WR_SSR_RSF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_BEF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_RSF(value)))
#define LPI2C_BWR_SSR_RSF(base, value) (BME_BFI32(&LPI2C_SSR_REG(base), ((uint32_t)(value) << LPI2C_SSR_RSF_SHIFT), LPI2C_SSR_RSF_SHIFT, LPI2C_SSR_RSF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SDF[9] (W1C)
 *
 * This flag will set when the LPI2C slave detects a STOP condition, provided
 * the LPI2C slave matched the last address byte.
 *
 * Values:
 * - 0b0 - Slave has not detected a STOP condition.
 * - 0b1 - Slave has detected a STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SDF field. */
#define LPI2C_RD_SSR_SDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SDF_MASK) >> LPI2C_SSR_SDF_SHIFT)
#define LPI2C_BRD_SSR_SDF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_SDF_SHIFT, LPI2C_SSR_SDF_WIDTH))

/*! @brief Set the SDF field to a new value. */
#define LPI2C_WR_SSR_SDF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_SDF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_BEF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_SDF(value)))
#define LPI2C_BWR_SSR_SDF(base, value) (BME_BFI32(&LPI2C_SSR_REG(base), ((uint32_t)(value) << LPI2C_SSR_SDF_SHIFT), LPI2C_SSR_SDF_SHIFT, LPI2C_SSR_SDF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field BEF[10] (W1C)
 *
 * This flag will set if the LPI2C slave transmits a logic one and detects a
 * logic zero on the I2C bus. The slave will ignore the rest of the transfer until
 * the next (repeated) START condition.
 *
 * Values:
 * - 0b0 - Slave has not detected a bit error.
 * - 0b1 - Slave has detected a bit error.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_BEF field. */
#define LPI2C_RD_SSR_BEF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_BEF_MASK) >> LPI2C_SSR_BEF_SHIFT)
#define LPI2C_BRD_SSR_BEF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_BEF_SHIFT, LPI2C_SSR_BEF_WIDTH))

/*! @brief Set the BEF field to a new value. */
#define LPI2C_WR_SSR_BEF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_BEF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_BEF(value)))
#define LPI2C_BWR_SSR_BEF(base, value) (BME_BFI32(&LPI2C_SSR_REG(base), ((uint32_t)(value) << LPI2C_SSR_BEF_SHIFT), LPI2C_SSR_BEF_SHIFT, LPI2C_SSR_BEF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field FEF[11] (W1C)
 *
 * FIFO error flag can only set when clock stretching is disabled.
 *
 * Values:
 * - 0b0 - FIFO underflow or overflow not detected.
 * - 0b1 - FIFO underflow or overflow detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_FEF field. */
#define LPI2C_RD_SSR_FEF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_FEF_MASK) >> LPI2C_SSR_FEF_SHIFT)
#define LPI2C_BRD_SSR_FEF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_FEF_SHIFT, LPI2C_SSR_FEF_WIDTH))

/*! @brief Set the FEF field to a new value. */
#define LPI2C_WR_SSR_FEF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_FEF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_BEF_MASK), LPI2C_SSR_FEF(value)))
#define LPI2C_BWR_SSR_FEF(base, value) (BME_BFI32(&LPI2C_SSR_REG(base), ((uint32_t)(value) << LPI2C_SSR_FEF_SHIFT), LPI2C_SSR_FEF_SHIFT, LPI2C_SSR_FEF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AM0F[12] (RO)
 *
 * Indicates that the received address has matched the ADDR0 field as configured
 * by ADDRCFG. This flag is cleared by reading the Address Status Register. This
 * flag cannot generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - Have not received ADDR0 matching address.
 * - 0b1 - Have received ADDR0 matching address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AM0F field. */
#define LPI2C_RD_SSR_AM0F(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AM0F_MASK) >> LPI2C_SSR_AM0F_SHIFT)
#define LPI2C_BRD_SSR_AM0F(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_AM0F_SHIFT, LPI2C_SSR_AM0F_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AM1F[13] (RO)
 *
 * Indicates that the received address has matched the ADDR1 field or ADDR0 to
 * ADDR1 range as configured by ADDRCFG. This flag is cleared by reading the
 * Address Status Register. This flag cannot generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - Have not received ADDR1 or ADDR0/ADDR1 range matching address.
 * - 0b1 - Have received ADDR1 or ADDR0/ADDR1 range matching address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AM1F field. */
#define LPI2C_RD_SSR_AM1F(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AM1F_MASK) >> LPI2C_SSR_AM1F_SHIFT)
#define LPI2C_BRD_SSR_AM1F(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_AM1F_SHIFT, LPI2C_SSR_AM1F_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field GCF[14] (RO)
 *
 * This flag is cleared by reading the Address Status Register. This flag cannot
 * generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - Slave has not detected the General Call Address or General Call
 *     Address disabled.
 * - 0b1 - Slave has detected the General Call Address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_GCF field. */
#define LPI2C_RD_SSR_GCF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_GCF_MASK) >> LPI2C_SSR_GCF_SHIFT)
#define LPI2C_BRD_SSR_GCF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_GCF_SHIFT, LPI2C_SSR_GCF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SARF[15] (RO)
 *
 * This flag is cleared by reading the Address Status Register. This flag cannot
 * generate an asynchronous wakeup.
 *
 * Values:
 * - 0b0 - SMBus Alert Response disabled or not detected.
 * - 0b1 - SMBus Alert Response enabled and detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SARF field. */
#define LPI2C_RD_SSR_SARF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SARF_MASK) >> LPI2C_SSR_SARF_SHIFT)
#define LPI2C_BRD_SSR_SARF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_SARF_SHIFT, LPI2C_SSR_SARF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SBF[24] (RO)
 *
 * Values:
 * - 0b0 - I2C Slave is idle.
 * - 0b1 - I2C Slave is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SBF field. */
#define LPI2C_RD_SSR_SBF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SBF_MASK) >> LPI2C_SSR_SBF_SHIFT)
#define LPI2C_BRD_SSR_SBF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_SBF_SHIFT, LPI2C_SSR_SBF_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field BBF[25] (RO)
 *
 * Values:
 * - 0b0 - I2C Bus is idle.
 * - 0b1 - I2C Bus is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_BBF field. */
#define LPI2C_RD_SSR_BBF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_BBF_MASK) >> LPI2C_SSR_BBF_SHIFT)
#define LPI2C_BRD_SSR_BBF(base) (BME_UBFX32(&LPI2C_SSR_REG(base), LPI2C_SSR_BBF_SHIFT, LPI2C_SSR_BBF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_SIER - Slave Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SIER - Slave Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SIER register
 */
/*@{*/
#define LPI2C_RD_SIER(base)      (LPI2C_SIER_REG(base))
#define LPI2C_WR_SIER(base, value) (LPI2C_SIER_REG(base) = (value))
#define LPI2C_RMW_SIER(base, mask, value) (LPI2C_WR_SIER(base, (LPI2C_RD_SIER(base) & ~(mask)) | (value)))
#define LPI2C_SET_SIER(base, value) (BME_OR32(&LPI2C_SIER_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_SIER(base, value) (BME_AND32(&LPI2C_SIER_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_SIER(base, value) (BME_XOR32(&LPI2C_SIER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SIER bitfields
 */

/*!
 * @name Register LPI2C_SIER, field TDIE[0] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_TDIE field. */
#define LPI2C_RD_SIER_TDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_TDIE_MASK) >> LPI2C_SIER_TDIE_SHIFT)
#define LPI2C_BRD_SIER_TDIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_TDIE_SHIFT, LPI2C_SIER_TDIE_WIDTH))

/*! @brief Set the TDIE field to a new value. */
#define LPI2C_WR_SIER_TDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_TDIE_MASK, LPI2C_SIER_TDIE(value)))
#define LPI2C_BWR_SIER_TDIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_TDIE_SHIFT), LPI2C_SIER_TDIE_SHIFT, LPI2C_SIER_TDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field RDIE[1] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_RDIE field. */
#define LPI2C_RD_SIER_RDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_RDIE_MASK) >> LPI2C_SIER_RDIE_SHIFT)
#define LPI2C_BRD_SIER_RDIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_RDIE_SHIFT, LPI2C_SIER_RDIE_WIDTH))

/*! @brief Set the RDIE field to a new value. */
#define LPI2C_WR_SIER_RDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_RDIE_MASK, LPI2C_SIER_RDIE(value)))
#define LPI2C_BWR_SIER_RDIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_RDIE_SHIFT), LPI2C_SIER_RDIE_SHIFT, LPI2C_SIER_RDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AVIE[2] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AVIE field. */
#define LPI2C_RD_SIER_AVIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AVIE_MASK) >> LPI2C_SIER_AVIE_SHIFT)
#define LPI2C_BRD_SIER_AVIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_AVIE_SHIFT, LPI2C_SIER_AVIE_WIDTH))

/*! @brief Set the AVIE field to a new value. */
#define LPI2C_WR_SIER_AVIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AVIE_MASK, LPI2C_SIER_AVIE(value)))
#define LPI2C_BWR_SIER_AVIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_AVIE_SHIFT), LPI2C_SIER_AVIE_SHIFT, LPI2C_SIER_AVIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field TAIE[3] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_TAIE field. */
#define LPI2C_RD_SIER_TAIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_TAIE_MASK) >> LPI2C_SIER_TAIE_SHIFT)
#define LPI2C_BRD_SIER_TAIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_TAIE_SHIFT, LPI2C_SIER_TAIE_WIDTH))

/*! @brief Set the TAIE field to a new value. */
#define LPI2C_WR_SIER_TAIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_TAIE_MASK, LPI2C_SIER_TAIE(value)))
#define LPI2C_BWR_SIER_TAIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_TAIE_SHIFT), LPI2C_SIER_TAIE_SHIFT, LPI2C_SIER_TAIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field RSIE[8] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_RSIE field. */
#define LPI2C_RD_SIER_RSIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_RSIE_MASK) >> LPI2C_SIER_RSIE_SHIFT)
#define LPI2C_BRD_SIER_RSIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_RSIE_SHIFT, LPI2C_SIER_RSIE_WIDTH))

/*! @brief Set the RSIE field to a new value. */
#define LPI2C_WR_SIER_RSIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_RSIE_MASK, LPI2C_SIER_RSIE(value)))
#define LPI2C_BWR_SIER_RSIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_RSIE_SHIFT), LPI2C_SIER_RSIE_SHIFT, LPI2C_SIER_RSIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field SDIE[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_SDIE field. */
#define LPI2C_RD_SIER_SDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_SDIE_MASK) >> LPI2C_SIER_SDIE_SHIFT)
#define LPI2C_BRD_SIER_SDIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_SDIE_SHIFT, LPI2C_SIER_SDIE_WIDTH))

/*! @brief Set the SDIE field to a new value. */
#define LPI2C_WR_SIER_SDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_SDIE_MASK, LPI2C_SIER_SDIE(value)))
#define LPI2C_BWR_SIER_SDIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_SDIE_SHIFT), LPI2C_SIER_SDIE_SHIFT, LPI2C_SIER_SDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field BEIE[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_BEIE field. */
#define LPI2C_RD_SIER_BEIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_BEIE_MASK) >> LPI2C_SIER_BEIE_SHIFT)
#define LPI2C_BRD_SIER_BEIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_BEIE_SHIFT, LPI2C_SIER_BEIE_WIDTH))

/*! @brief Set the BEIE field to a new value. */
#define LPI2C_WR_SIER_BEIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_BEIE_MASK, LPI2C_SIER_BEIE(value)))
#define LPI2C_BWR_SIER_BEIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_BEIE_SHIFT), LPI2C_SIER_BEIE_SHIFT, LPI2C_SIER_BEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field FEIE[11] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_FEIE field. */
#define LPI2C_RD_SIER_FEIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_FEIE_MASK) >> LPI2C_SIER_FEIE_SHIFT)
#define LPI2C_BRD_SIER_FEIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_FEIE_SHIFT, LPI2C_SIER_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define LPI2C_WR_SIER_FEIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_FEIE_MASK, LPI2C_SIER_FEIE(value)))
#define LPI2C_BWR_SIER_FEIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_FEIE_SHIFT), LPI2C_SIER_FEIE_SHIFT, LPI2C_SIER_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AM0IE[12] (RW)
 *
 * Values:
 * - 0b0 - Interrupt enabled.
 * - 0b1 - Interrupt disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AM0IE field. */
#define LPI2C_RD_SIER_AM0IE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AM0IE_MASK) >> LPI2C_SIER_AM0IE_SHIFT)
#define LPI2C_BRD_SIER_AM0IE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM0IE_SHIFT, LPI2C_SIER_AM0IE_WIDTH))

/*! @brief Set the AM0IE field to a new value. */
#define LPI2C_WR_SIER_AM0IE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AM0IE_MASK, LPI2C_SIER_AM0IE(value)))
#define LPI2C_BWR_SIER_AM0IE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_AM0IE_SHIFT), LPI2C_SIER_AM0IE_SHIFT, LPI2C_SIER_AM0IE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AM1F[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AM1F field. */
#define LPI2C_RD_SIER_AM1F(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AM1F_MASK) >> LPI2C_SIER_AM1F_SHIFT)
#define LPI2C_BRD_SIER_AM1F(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM1F_SHIFT, LPI2C_SIER_AM1F_WIDTH))

/*! @brief Set the AM1F field to a new value. */
#define LPI2C_WR_SIER_AM1F(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AM1F_MASK, LPI2C_SIER_AM1F(value)))
#define LPI2C_BWR_SIER_AM1F(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_AM1F_SHIFT), LPI2C_SIER_AM1F_SHIFT, LPI2C_SIER_AM1F_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field GCIE[14] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_GCIE field. */
#define LPI2C_RD_SIER_GCIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_GCIE_MASK) >> LPI2C_SIER_GCIE_SHIFT)
#define LPI2C_BRD_SIER_GCIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_GCIE_SHIFT, LPI2C_SIER_GCIE_WIDTH))

/*! @brief Set the GCIE field to a new value. */
#define LPI2C_WR_SIER_GCIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_GCIE_MASK, LPI2C_SIER_GCIE(value)))
#define LPI2C_BWR_SIER_GCIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_GCIE_SHIFT), LPI2C_SIER_GCIE_SHIFT, LPI2C_SIER_GCIE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field SARIE[15] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_SARIE field. */
#define LPI2C_RD_SIER_SARIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_SARIE_MASK) >> LPI2C_SIER_SARIE_SHIFT)
#define LPI2C_BRD_SIER_SARIE(base) (BME_UBFX32(&LPI2C_SIER_REG(base), LPI2C_SIER_SARIE_SHIFT, LPI2C_SIER_SARIE_WIDTH))

/*! @brief Set the SARIE field to a new value. */
#define LPI2C_WR_SIER_SARIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_SARIE_MASK, LPI2C_SIER_SARIE(value)))
#define LPI2C_BWR_SIER_SARIE(base, value) (BME_BFI32(&LPI2C_SIER_REG(base), ((uint32_t)(value) << LPI2C_SIER_SARIE_SHIFT), LPI2C_SIER_SARIE_SHIFT, LPI2C_SIER_SARIE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_SDER - Slave DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SDER - Slave DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SDER register
 */
/*@{*/
#define LPI2C_RD_SDER(base)      (LPI2C_SDER_REG(base))
#define LPI2C_WR_SDER(base, value) (LPI2C_SDER_REG(base) = (value))
#define LPI2C_RMW_SDER(base, mask, value) (LPI2C_WR_SDER(base, (LPI2C_RD_SDER(base) & ~(mask)) | (value)))
#define LPI2C_SET_SDER(base, value) (BME_OR32(&LPI2C_SDER_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_SDER(base, value) (BME_AND32(&LPI2C_SDER_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_SDER(base, value) (BME_XOR32(&LPI2C_SDER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SDER bitfields
 */

/*!
 * @name Register LPI2C_SDER, field TDDE[0] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_TDDE field. */
#define LPI2C_RD_SDER_TDDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_TDDE_MASK) >> LPI2C_SDER_TDDE_SHIFT)
#define LPI2C_BRD_SDER_TDDE(base) (BME_UBFX32(&LPI2C_SDER_REG(base), LPI2C_SDER_TDDE_SHIFT, LPI2C_SDER_TDDE_WIDTH))

/*! @brief Set the TDDE field to a new value. */
#define LPI2C_WR_SDER_TDDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_TDDE_MASK, LPI2C_SDER_TDDE(value)))
#define LPI2C_BWR_SDER_TDDE(base, value) (BME_BFI32(&LPI2C_SDER_REG(base), ((uint32_t)(value) << LPI2C_SDER_TDDE_SHIFT), LPI2C_SDER_TDDE_SHIFT, LPI2C_SDER_TDDE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SDER, field RDDE[1] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_RDDE field. */
#define LPI2C_RD_SDER_RDDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_RDDE_MASK) >> LPI2C_SDER_RDDE_SHIFT)
#define LPI2C_BRD_SDER_RDDE(base) (BME_UBFX32(&LPI2C_SDER_REG(base), LPI2C_SDER_RDDE_SHIFT, LPI2C_SDER_RDDE_WIDTH))

/*! @brief Set the RDDE field to a new value. */
#define LPI2C_WR_SDER_RDDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_RDDE_MASK, LPI2C_SDER_RDDE(value)))
#define LPI2C_BWR_SDER_RDDE(base, value) (BME_BFI32(&LPI2C_SDER_REG(base), ((uint32_t)(value) << LPI2C_SDER_RDDE_SHIFT), LPI2C_SDER_RDDE_SHIFT, LPI2C_SDER_RDDE_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SDER, field AVDE[2] (RW)
 *
 * The Address Valid DMA request is shared with the Receive Data DMA request. If
 * both are enabled, then set RXCFG to allow the DMA to read the address from
 * the Receive Data Register.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_AVDE field. */
#define LPI2C_RD_SDER_AVDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_AVDE_MASK) >> LPI2C_SDER_AVDE_SHIFT)
#define LPI2C_BRD_SDER_AVDE(base) (BME_UBFX32(&LPI2C_SDER_REG(base), LPI2C_SDER_AVDE_SHIFT, LPI2C_SDER_AVDE_WIDTH))

/*! @brief Set the AVDE field to a new value. */
#define LPI2C_WR_SDER_AVDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_AVDE_MASK, LPI2C_SDER_AVDE(value)))
#define LPI2C_BWR_SDER_AVDE(base, value) (BME_BFI32(&LPI2C_SDER_REG(base), ((uint32_t)(value) << LPI2C_SDER_AVDE_SHIFT), LPI2C_SDER_AVDE_SHIFT, LPI2C_SDER_AVDE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_SCFGR1 - Slave Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_SCFGR1 - Slave Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SCFGR1 should only be written when the I2C Slave is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_SCFGR1 register
 */
/*@{*/
#define LPI2C_RD_SCFGR1(base)    (LPI2C_SCFGR1_REG(base))
#define LPI2C_WR_SCFGR1(base, value) (LPI2C_SCFGR1_REG(base) = (value))
#define LPI2C_RMW_SCFGR1(base, mask, value) (LPI2C_WR_SCFGR1(base, (LPI2C_RD_SCFGR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCFGR1(base, value) (BME_OR32(&LPI2C_SCFGR1_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_SCFGR1(base, value) (BME_AND32(&LPI2C_SCFGR1_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_SCFGR1(base, value) (BME_XOR32(&LPI2C_SCFGR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCFGR1 bitfields
 */

/*!
 * @name Register LPI2C_SCFGR1, field ADRSTALL[0] (RW)
 *
 * Enables SCL clock stretching when the address valid flag is asserted. Clock
 * stretching only occurs following the 9th bit and is therefore compatible with
 * high speed mode.
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ADRSTALL field. */
#define LPI2C_RD_SCFGR1_ADRSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ADRSTALL_MASK) >> LPI2C_SCFGR1_ADRSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_ADRSTALL(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ADRSTALL_SHIFT, LPI2C_SCFGR1_ADRSTALL_WIDTH))

/*! @brief Set the ADRSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_ADRSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ADRSTALL_MASK, LPI2C_SCFGR1_ADRSTALL(value)))
#define LPI2C_BWR_SCFGR1_ADRSTALL(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_ADRSTALL_SHIFT), LPI2C_SCFGR1_ADRSTALL_SHIFT, LPI2C_SCFGR1_ADRSTALL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field RXSTALL[1] (RW)
 *
 * Enables SCL clock stretching when receive data flag is set during a
 * slave-receive transfer. Clock stretching occurs following the 9th bit and is therefore
 * compatible with high speed mode.
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_RXSTALL field. */
#define LPI2C_RD_SCFGR1_RXSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_RXSTALL_MASK) >> LPI2C_SCFGR1_RXSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_RXSTALL(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXSTALL_SHIFT, LPI2C_SCFGR1_RXSTALL_WIDTH))

/*! @brief Set the RXSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_RXSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_RXSTALL_MASK, LPI2C_SCFGR1_RXSTALL(value)))
#define LPI2C_BWR_SCFGR1_RXSTALL(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_RXSTALL_SHIFT), LPI2C_SCFGR1_RXSTALL_SHIFT, LPI2C_SCFGR1_RXSTALL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field TXDSTALL[2] (RW)
 *
 * Enables SCL clock stretching when the transmit data flag is set during a
 * slave-transmit transfer. Clock stretching occurs following the 9th bit and is
 * therefore compatible with high speed mode.
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_TXDSTALL field. */
#define LPI2C_RD_SCFGR1_TXDSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_TXDSTALL_MASK) >> LPI2C_SCFGR1_TXDSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_TXDSTALL(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXDSTALL_SHIFT, LPI2C_SCFGR1_TXDSTALL_WIDTH))

/*! @brief Set the TXDSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_TXDSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_TXDSTALL_MASK, LPI2C_SCFGR1_TXDSTALL(value)))
#define LPI2C_BWR_SCFGR1_TXDSTALL(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_TXDSTALL_SHIFT), LPI2C_SCFGR1_TXDSTALL_SHIFT, LPI2C_SCFGR1_TXDSTALL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field ACKSTALL[3] (RW)
 *
 * Enables SCL clock stretching during slave-transmit address byte(s) and
 * slave-receiver address and data byte(s) to allow software to write the Transmit ACK
 * Register before the ACK or NACK is transmitted. Clock stretching occurs when
 * transmitting the 9th bit and is therefore not compatible with high speed mode.
 * When ACKSTALL is enabled, there is no need to set either RXSTALL or ADRSTALL
 *
 * Values:
 * - 0b0 - Clock stretching disabled.
 * - 0b1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ACKSTALL field. */
#define LPI2C_RD_SCFGR1_ACKSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ACKSTALL_MASK) >> LPI2C_SCFGR1_ACKSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_ACKSTALL(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ACKSTALL_SHIFT, LPI2C_SCFGR1_ACKSTALL_WIDTH))

/*! @brief Set the ACKSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_ACKSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ACKSTALL_MASK, LPI2C_SCFGR1_ACKSTALL(value)))
#define LPI2C_BWR_SCFGR1_ACKSTALL(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_ACKSTALL_SHIFT), LPI2C_SCFGR1_ACKSTALL_SHIFT, LPI2C_SCFGR1_ACKSTALL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field GCEN[8] (RW)
 *
 * Values:
 * - 0b0 - General Call address is disabled.
 * - 0b1 - General call address is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_GCEN field. */
#define LPI2C_RD_SCFGR1_GCEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_GCEN_MASK) >> LPI2C_SCFGR1_GCEN_SHIFT)
#define LPI2C_BRD_SCFGR1_GCEN(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_GCEN_SHIFT, LPI2C_SCFGR1_GCEN_WIDTH))

/*! @brief Set the GCEN field to a new value. */
#define LPI2C_WR_SCFGR1_GCEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_GCEN_MASK, LPI2C_SCFGR1_GCEN(value)))
#define LPI2C_BWR_SCFGR1_GCEN(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_GCEN_SHIFT), LPI2C_SCFGR1_GCEN_SHIFT, LPI2C_SCFGR1_GCEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field SAEN[9] (RW)
 *
 * Values:
 * - 0b0 - Disables match on SMBus Alert.
 * - 0b1 - Enables match on SMBus Alert.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_SAEN field. */
#define LPI2C_RD_SCFGR1_SAEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_SAEN_MASK) >> LPI2C_SCFGR1_SAEN_SHIFT)
#define LPI2C_BRD_SCFGR1_SAEN(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_SAEN_SHIFT, LPI2C_SCFGR1_SAEN_WIDTH))

/*! @brief Set the SAEN field to a new value. */
#define LPI2C_WR_SCFGR1_SAEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_SAEN_MASK, LPI2C_SCFGR1_SAEN(value)))
#define LPI2C_BWR_SCFGR1_SAEN(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_SAEN_SHIFT), LPI2C_SCFGR1_SAEN_SHIFT, LPI2C_SCFGR1_SAEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field TXCFG[10] (RW)
 *
 * The transmit data flag will always assert before a NACK is detected at the
 * end of a slave-transmit transfer. This can cause an extra word to be written to
 * the transmit data FIFO. When TXCFG=0, the transmit data register is
 * automatically emptied when a slave-transmit transfer is detected. This cause the
 * transmit data flag to assert whenever a slave-transmit transfer is detected and
 * negate at the end of the slave-transmit transfer. When TXCFG=1, the transmit data
 * flag will assert whenver the transit data register is empty and negate when the
 * transmit data register is full. This allows the transmit data register to be
 * filled before a slave-transmit transfer is detected, but can cause the
 * transmit data register to be written before a NACK is detected on the last byte of a
 * slave transmit transfer.
 *
 * Values:
 * - 0b0 - Transmit Data Flag will only assert during a slave-transmit transfer
 *     when the transmit data register is empty.
 * - 0b1 - Transmit Data Flag will assert whenever the transmit data register is
 *     empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_TXCFG field. */
#define LPI2C_RD_SCFGR1_TXCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_TXCFG_MASK) >> LPI2C_SCFGR1_TXCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_TXCFG(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXCFG_SHIFT, LPI2C_SCFGR1_TXCFG_WIDTH))

/*! @brief Set the TXCFG field to a new value. */
#define LPI2C_WR_SCFGR1_TXCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_TXCFG_MASK, LPI2C_SCFGR1_TXCFG(value)))
#define LPI2C_BWR_SCFGR1_TXCFG(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_TXCFG_SHIFT), LPI2C_SCFGR1_TXCFG_SHIFT, LPI2C_SCFGR1_TXCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field RXCFG[11] (RW)
 *
 * Values:
 * - 0b0 - Reading the receive data register will return receive data and clear
 *     the receive data flag.
 * - 0b1 - Reading the receive data register when the address valid flag is set
 *     will return the address status register and clear the address valid flag.
 *     Reading the receive data register when the address valid flag is clear
 *     will return receive data and clear the receive data flag.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_RXCFG field. */
#define LPI2C_RD_SCFGR1_RXCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_RXCFG_MASK) >> LPI2C_SCFGR1_RXCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_RXCFG(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXCFG_SHIFT, LPI2C_SCFGR1_RXCFG_WIDTH))

/*! @brief Set the RXCFG field to a new value. */
#define LPI2C_WR_SCFGR1_RXCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_RXCFG_MASK, LPI2C_SCFGR1_RXCFG(value)))
#define LPI2C_BWR_SCFGR1_RXCFG(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_RXCFG_SHIFT), LPI2C_SCFGR1_RXCFG_SHIFT, LPI2C_SCFGR1_RXCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field IGNACK[12] (RW)
 *
 * When set, the LPI2C slave will continue transfers after a NACK is detected.
 * This bit is required to be set in Ultra-Fast Mode.
 *
 * Values:
 * - 0b0 - Slave will end transfer when NACK detected.
 * - 0b1 - Slave will not end transfer when NACK detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_IGNACK field. */
#define LPI2C_RD_SCFGR1_IGNACK(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_IGNACK_MASK) >> LPI2C_SCFGR1_IGNACK_SHIFT)
#define LPI2C_BRD_SCFGR1_IGNACK(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_IGNACK_SHIFT, LPI2C_SCFGR1_IGNACK_WIDTH))

/*! @brief Set the IGNACK field to a new value. */
#define LPI2C_WR_SCFGR1_IGNACK(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_IGNACK_MASK, LPI2C_SCFGR1_IGNACK(value)))
#define LPI2C_BWR_SCFGR1_IGNACK(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_IGNACK_SHIFT), LPI2C_SCFGR1_IGNACK_SHIFT, LPI2C_SCFGR1_IGNACK_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field HSMEN[13] (RW)
 *
 * Enables detection of the High-speed Mode master code of slave address
 * 0000_1XX, but does not cause an address match on this code. When set and any Hs-mode
 * master code is detected, the FILTEN and ACKSTALL bits are ignored until the
 * next STOP condition is detected.
 *
 * Values:
 * - 0b0 - Disables detection of Hs-mode master code.
 * - 0b1 - Enables detection of Hs-mode master code.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_HSMEN field. */
#define LPI2C_RD_SCFGR1_HSMEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_HSMEN_MASK) >> LPI2C_SCFGR1_HSMEN_SHIFT)
#define LPI2C_BRD_SCFGR1_HSMEN(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_HSMEN_SHIFT, LPI2C_SCFGR1_HSMEN_WIDTH))

/*! @brief Set the HSMEN field to a new value. */
#define LPI2C_WR_SCFGR1_HSMEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_HSMEN_MASK, LPI2C_SCFGR1_HSMEN(value)))
#define LPI2C_BWR_SCFGR1_HSMEN(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_HSMEN_SHIFT), LPI2C_SCFGR1_HSMEN_SHIFT, LPI2C_SCFGR1_HSMEN_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field ADDRCFG[18:16] (RW)
 *
 * Configures the condition that will cause an address to match.
 *
 * Values:
 * - 0b000 - Address match 0 (7-bit).
 * - 0b001 - Address match 0 (10-bit).
 * - 0b010 - Address match 0 (7-bit) or Address match 1 (7-bit).
 * - 0b011 - Address match 0 (10-bit) or Address match 1 (10-bit).
 * - 0b100 - Address match 0 (7-bit) or Address match 1 (10-bit).
 * - 0b101 - Address match 0 (10-bit) or Address match 1 (7-bit).
 * - 0b110 - From Address match 0 (7-bit) to Address match 1 (7-bit).
 * - 0b111 - From Address match 0 (10-bit) to Address match 1 (10-bit).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ADDRCFG field. */
#define LPI2C_RD_SCFGR1_ADDRCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ADDRCFG_MASK) >> LPI2C_SCFGR1_ADDRCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_ADDRCFG(base) (BME_UBFX32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ADDRCFG_SHIFT, LPI2C_SCFGR1_ADDRCFG_WIDTH))

/*! @brief Set the ADDRCFG field to a new value. */
#define LPI2C_WR_SCFGR1_ADDRCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ADDRCFG_MASK, LPI2C_SCFGR1_ADDRCFG(value)))
#define LPI2C_BWR_SCFGR1_ADDRCFG(base, value) (BME_BFI32(&LPI2C_SCFGR1_REG(base), ((uint32_t)(value) << LPI2C_SCFGR1_ADDRCFG_SHIFT), LPI2C_SCFGR1_ADDRCFG_SHIFT, LPI2C_SCFGR1_ADDRCFG_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_SCFGR2 - Slave Configuration Register 2
 ******************************************************************************/

/*!
 * @brief LPI2C_SCFGR2 - Slave Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SCFGR2 should only be written when the I2C Slave is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_SCFGR2 register
 */
/*@{*/
#define LPI2C_RD_SCFGR2(base)    (LPI2C_SCFGR2_REG(base))
#define LPI2C_WR_SCFGR2(base, value) (LPI2C_SCFGR2_REG(base) = (value))
#define LPI2C_RMW_SCFGR2(base, mask, value) (LPI2C_WR_SCFGR2(base, (LPI2C_RD_SCFGR2(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCFGR2(base, value) (BME_OR32(&LPI2C_SCFGR2_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_SCFGR2(base, value) (BME_AND32(&LPI2C_SCFGR2_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_SCFGR2(base, value) (BME_XOR32(&LPI2C_SCFGR2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCFGR2 bitfields
 */

/*!
 * @name Register LPI2C_SCFGR2, field CLKHOLD[3:0] (RW)
 *
 * Configures the minimum clock hold time for the I2C slave, when clock
 * stretching is enabled. The minimum hold time is equal to CLKHOLD+3 cycles. The I2C
 * slave clock hold time is not affected by the PRESCALE configuration, and is
 * disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_CLKHOLD field. */
#define LPI2C_RD_SCFGR2_CLKHOLD(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_CLKHOLD_MASK) >> LPI2C_SCFGR2_CLKHOLD_SHIFT)
#define LPI2C_BRD_SCFGR2_CLKHOLD(base) (BME_UBFX32(&LPI2C_SCFGR2_REG(base), LPI2C_SCFGR2_CLKHOLD_SHIFT, LPI2C_SCFGR2_CLKHOLD_WIDTH))

/*! @brief Set the CLKHOLD field to a new value. */
#define LPI2C_WR_SCFGR2_CLKHOLD(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_CLKHOLD_MASK, LPI2C_SCFGR2_CLKHOLD(value)))
#define LPI2C_BWR_SCFGR2_CLKHOLD(base, value) (BME_BFI32(&LPI2C_SCFGR2_REG(base), ((uint32_t)(value) << LPI2C_SCFGR2_CLKHOLD_SHIFT), LPI2C_SCFGR2_CLKHOLD_SHIFT, LPI2C_SCFGR2_CLKHOLD_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field DATAVD[13:8] (RW)
 *
 * Configures the SDA data valid delay time for the I2C slave equal to
 * FILTSCL+DATAVD+3 cycles. This data valid delay must be configured to less than the
 * minimum SCL low period. The I2C slave data valid delay time is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_DATAVD field. */
#define LPI2C_RD_SCFGR2_DATAVD(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_DATAVD_MASK) >> LPI2C_SCFGR2_DATAVD_SHIFT)
#define LPI2C_BRD_SCFGR2_DATAVD(base) (BME_UBFX32(&LPI2C_SCFGR2_REG(base), LPI2C_SCFGR2_DATAVD_SHIFT, LPI2C_SCFGR2_DATAVD_WIDTH))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_SCFGR2_DATAVD(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_DATAVD_MASK, LPI2C_SCFGR2_DATAVD(value)))
#define LPI2C_BWR_SCFGR2_DATAVD(base, value) (BME_BFI32(&LPI2C_SCFGR2_REG(base), ((uint32_t)(value) << LPI2C_SCFGR2_DATAVD_SHIFT), LPI2C_SCFGR2_DATAVD_SHIFT, LPI2C_SCFGR2_DATAVD_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field FILTSCL[19:16] (RW)
 *
 * Configures the I2C slave digital glitch filters for SCL input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSCL
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSCL+3 cycles and must be configured less than the
 * minimum SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_FILTSCL field. */
#define LPI2C_RD_SCFGR2_FILTSCL(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_FILTSCL_MASK) >> LPI2C_SCFGR2_FILTSCL_SHIFT)
#define LPI2C_BRD_SCFGR2_FILTSCL(base) (BME_UBFX32(&LPI2C_SCFGR2_REG(base), LPI2C_SCFGR2_FILTSCL_SHIFT, LPI2C_SCFGR2_FILTSCL_WIDTH))

/*! @brief Set the FILTSCL field to a new value. */
#define LPI2C_WR_SCFGR2_FILTSCL(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_FILTSCL_MASK, LPI2C_SCFGR2_FILTSCL(value)))
#define LPI2C_BWR_SCFGR2_FILTSCL(base, value) (BME_BFI32(&LPI2C_SCFGR2_REG(base), ((uint32_t)(value) << LPI2C_SCFGR2_FILTSCL_SHIFT), LPI2C_SCFGR2_FILTSCL_SHIFT, LPI2C_SCFGR2_FILTSCL_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field FILTSDA[27:24] (RW)
 *
 * Configures the I2C slave digital glitch filters for SDA input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSDA
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSDA+3 cycles and must be configured less than the
 * minimum SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_FILTSDA field. */
#define LPI2C_RD_SCFGR2_FILTSDA(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_FILTSDA_MASK) >> LPI2C_SCFGR2_FILTSDA_SHIFT)
#define LPI2C_BRD_SCFGR2_FILTSDA(base) (BME_UBFX32(&LPI2C_SCFGR2_REG(base), LPI2C_SCFGR2_FILTSDA_SHIFT, LPI2C_SCFGR2_FILTSDA_WIDTH))

/*! @brief Set the FILTSDA field to a new value. */
#define LPI2C_WR_SCFGR2_FILTSDA(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_FILTSDA_MASK, LPI2C_SCFGR2_FILTSDA(value)))
#define LPI2C_BWR_SCFGR2_FILTSDA(base, value) (BME_BFI32(&LPI2C_SCFGR2_REG(base), ((uint32_t)(value) << LPI2C_SCFGR2_FILTSDA_SHIFT), LPI2C_SCFGR2_FILTSDA_SHIFT, LPI2C_SCFGR2_FILTSDA_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_SAMR - Slave Address Match Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SAMR - Slave Address Match Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SAMR register
 */
/*@{*/
#define LPI2C_RD_SAMR(base)      (LPI2C_SAMR_REG(base))
#define LPI2C_WR_SAMR(base, value) (LPI2C_SAMR_REG(base) = (value))
#define LPI2C_RMW_SAMR(base, mask, value) (LPI2C_WR_SAMR(base, (LPI2C_RD_SAMR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SAMR(base, value) (BME_OR32(&LPI2C_SAMR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_SAMR(base, value) (BME_AND32(&LPI2C_SAMR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_SAMR(base, value) (BME_XOR32(&LPI2C_SAMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SAMR bitfields
 */

/*!
 * @name Register LPI2C_SAMR, field ADDR0[10:1] (RW)
 *
 * Compared against the received address to detect the Slave Address. In 10-bit
 * mode, the first address byte is compared to { 11110, ADDR0[10:9] } and the
 * second address byte is compared to ADDR0[8:1]. In 7-bit mode, the address is
 * compared to ADDR0[7:1].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SAMR_ADDR0 field. */
#define LPI2C_RD_SAMR_ADDR0(base) ((LPI2C_SAMR_REG(base) & LPI2C_SAMR_ADDR0_MASK) >> LPI2C_SAMR_ADDR0_SHIFT)
#define LPI2C_BRD_SAMR_ADDR0(base) (LPI2C_RD_SAMR_ADDR0(base))

/*! @brief Set the ADDR0 field to a new value. */
#define LPI2C_WR_SAMR_ADDR0(base, value) (LPI2C_RMW_SAMR(base, LPI2C_SAMR_ADDR0_MASK, LPI2C_SAMR_ADDR0(value)))
#define LPI2C_BWR_SAMR_ADDR0(base, value) (LPI2C_WR_SAMR_ADDR0(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SAMR, field ADDR1[26:17] (RW)
 *
 * Compared against the received address to detect the Slave Address. In 10-bit
 * mode, the first address byte is compared to { 11110, ADDR1[10:9] } and the
 * second address byte is compared to ADDR1[8:1]. In 7-bit mode, the address is
 * compared to ADDR1[7:1].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SAMR_ADDR1 field. */
#define LPI2C_RD_SAMR_ADDR1(base) ((LPI2C_SAMR_REG(base) & LPI2C_SAMR_ADDR1_MASK) >> LPI2C_SAMR_ADDR1_SHIFT)
#define LPI2C_BRD_SAMR_ADDR1(base) (LPI2C_RD_SAMR_ADDR1(base))

/*! @brief Set the ADDR1 field to a new value. */
#define LPI2C_WR_SAMR_ADDR1(base, value) (LPI2C_RMW_SAMR(base, LPI2C_SAMR_ADDR1_MASK, LPI2C_SAMR_ADDR1(value)))
#define LPI2C_BWR_SAMR_ADDR1(base, value) (LPI2C_WR_SAMR_ADDR1(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SASR - Slave Address Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SASR - Slave Address Status Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SASR register
 */
/*@{*/
#define LPI2C_RD_SASR(base)      (LPI2C_SASR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SASR bitfields
 */

/*!
 * @name Register LPI2C_SASR, field RADDR[10:0] (RO)
 *
 * RADDR updates whenever the AMF is set and the AMF is cleared by reading this
 * register. In 7-bit mode, the address byte is store in RADDR[7:0]. In 10-bit
 * mode, the first address byte is { 11110, RADDR[10:9], RADDR[0] } and the second
 * address byte is RADDR[8:1]. The R/W bit is therefore always stored in RADDR[0].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SASR_RADDR field. */
#define LPI2C_RD_SASR_RADDR(base) ((LPI2C_SASR_REG(base) & LPI2C_SASR_RADDR_MASK) >> LPI2C_SASR_RADDR_SHIFT)
#define LPI2C_BRD_SASR_RADDR(base) (LPI2C_RD_SASR_RADDR(base))
/*@}*/

/*!
 * @name Register LPI2C_SASR, field ANV[14] (RO)
 *
 * Values:
 * - 0b0 - RADDR is valid.
 * - 0b1 - RADDR is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SASR_ANV field. */
#define LPI2C_RD_SASR_ANV(base) ((LPI2C_SASR_REG(base) & LPI2C_SASR_ANV_MASK) >> LPI2C_SASR_ANV_SHIFT)
#define LPI2C_BRD_SASR_ANV(base) (BME_UBFX32(&LPI2C_SASR_REG(base), LPI2C_SASR_ANV_SHIFT, LPI2C_SASR_ANV_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_STAR - Slave Transmit ACK Register
 ******************************************************************************/

/*!
 * @brief LPI2C_STAR - Slave Transmit ACK Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_STAR register
 */
/*@{*/
#define LPI2C_RD_STAR(base)      (LPI2C_STAR_REG(base))
#define LPI2C_WR_STAR(base, value) (LPI2C_STAR_REG(base) = (value))
#define LPI2C_RMW_STAR(base, mask, value) (LPI2C_WR_STAR(base, (LPI2C_RD_STAR(base) & ~(mask)) | (value)))
#define LPI2C_SET_STAR(base, value) (BME_OR32(&LPI2C_STAR_REG(base), (uint32_t)(value)))
#define LPI2C_CLR_STAR(base, value) (BME_AND32(&LPI2C_STAR_REG(base), (uint32_t)(~(value))))
#define LPI2C_TOG_STAR(base, value) (BME_XOR32(&LPI2C_STAR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_STAR bitfields
 */

/*!
 * @name Register LPI2C_STAR, field TXNACK[0] (RW)
 *
 * When NACKSTALL is set, must be written once for each matching address byte
 * and each received word. Can also be written when LPI2C Slave is disabled or idle
 * to configure the default ACK/NACK.
 *
 * Values:
 * - 0b0 - Transmit ACK for received word.
 * - 0b1 - Transmit NACK for received word.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_STAR_TXNACK field. */
#define LPI2C_RD_STAR_TXNACK(base) ((LPI2C_STAR_REG(base) & LPI2C_STAR_TXNACK_MASK) >> LPI2C_STAR_TXNACK_SHIFT)
#define LPI2C_BRD_STAR_TXNACK(base) (BME_UBFX32(&LPI2C_STAR_REG(base), LPI2C_STAR_TXNACK_SHIFT, LPI2C_STAR_TXNACK_WIDTH))

/*! @brief Set the TXNACK field to a new value. */
#define LPI2C_WR_STAR_TXNACK(base, value) (LPI2C_RMW_STAR(base, LPI2C_STAR_TXNACK_MASK, LPI2C_STAR_TXNACK(value)))
#define LPI2C_BWR_STAR_TXNACK(base, value) (BME_BFI32(&LPI2C_STAR_REG(base), ((uint32_t)(value) << LPI2C_STAR_TXNACK_SHIFT), LPI2C_STAR_TXNACK_SHIFT, LPI2C_STAR_TXNACK_WIDTH))
/*@}*/

/*******************************************************************************
 * LPI2C_STDR - Slave Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_STDR - Slave Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_STDR register
 */
/*@{*/
#define LPI2C_RD_STDR(base)      (LPI2C_STDR_REG(base))
#define LPI2C_WR_STDR(base, value) (LPI2C_STDR_REG(base) = (value))
#define LPI2C_RMW_STDR(base, mask, value) (LPI2C_WR_STDR(base, (LPI2C_RD_STDR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_STDR bitfields
 */

/*!
 * @name Register LPI2C_STDR, field DATA[7:0] (WO)
 *
 * Writing this register will store I2C slave transmit data in the transmit
 * register.
 */
/*@{*/
/*! @brief Set the DATA field to a new value. */
#define LPI2C_WR_STDR_DATA(base, value) (LPI2C_RMW_STDR(base, LPI2C_STDR_DATA_MASK, LPI2C_STDR_DATA(value)))
#define LPI2C_BWR_STDR_DATA(base, value) (LPI2C_WR_STDR_DATA(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SRDR - Slave Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SRDR - Slave Receive Data Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SRDR register
 */
/*@{*/
#define LPI2C_RD_SRDR(base)      (LPI2C_SRDR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SRDR bitfields
 */

/*!
 * @name Register LPI2C_SRDR, field DATA[7:0] (RO)
 *
 * Reading this register returns the data received by the I2C slave.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_DATA field. */
#define LPI2C_RD_SRDR_DATA(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_DATA_MASK) >> LPI2C_SRDR_DATA_SHIFT)
#define LPI2C_BRD_SRDR_DATA(base) (BME_UBFX32(&LPI2C_SRDR_REG(base), LPI2C_SRDR_DATA_SHIFT, LPI2C_SRDR_DATA_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SRDR, field RXEMPTY[14] (RO)
 *
 * Values:
 * - 0b0 - The Receive Data Register is not empty.
 * - 0b1 - The Receive Data Register is empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_RXEMPTY field. */
#define LPI2C_RD_SRDR_RXEMPTY(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_RXEMPTY_MASK) >> LPI2C_SRDR_RXEMPTY_SHIFT)
#define LPI2C_BRD_SRDR_RXEMPTY(base) (BME_UBFX32(&LPI2C_SRDR_REG(base), LPI2C_SRDR_RXEMPTY_SHIFT, LPI2C_SRDR_RXEMPTY_WIDTH))
/*@}*/

/*!
 * @name Register LPI2C_SRDR, field SOF[15] (RO)
 *
 * Values:
 * - 0b0 - Indicates this is not the first data word since a (repeated) START or
 *     STOP condition.
 * - 0b1 - Indicates this is the first data word since a (repeated) START or
 *     STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_SOF field. */
#define LPI2C_RD_SRDR_SOF(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_SOF_MASK) >> LPI2C_SRDR_SOF_SHIFT)
#define LPI2C_BRD_SRDR_SOF(base) (BME_UBFX32(&LPI2C_SRDR_REG(base), LPI2C_SRDR_SOF_SHIFT, LPI2C_SRDR_SOF_WIDTH))
/*@}*/

/*
 * MKL28Z7 LPIT
 *
 * Low Power Periodic Interrupt Timer (LPIT)
 *
 * Registers defined in this header file:
 * - LPIT_VERID - Version ID Register
 * - LPIT_PARAM - Parameter Register
 * - LPIT_MCR - Module Control Register
 * - LPIT_MSR - Module Status Register
 * - LPIT_MIER - Module Interrupt Enable Register
 * - LPIT_SETTEN - Set Timer Enable Register
 * - LPIT_CLRTEN - Clear Timer Enable Register
 * - LPIT_TVAL - Timer Value Register
 * - LPIT_CVAL - Current Timer Value
 * - LPIT_TCTRL - Timer Control Register
 */

#define LPIT_INSTANCE_COUNT (2U) /*!< Number of instances of the LPIT module. */
#define LPIT0_IDX (0U) /*!< Instance number for LPIT0. */
#define LPIT1_IDX (1U) /*!< Instance number for LPIT1. */

/*******************************************************************************
 * LPIT_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPIT_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire LPIT_VERID register
 */
/*@{*/
#define LPIT_RD_VERID(base)      (LPIT_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPIT_VERID bitfields
 */

/*!
 * @name Register LPIT_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 */
/*@{*/
/*! @brief Read current value of the LPIT_VERID_FEATURE field. */
#define LPIT_RD_VERID_FEATURE(base) ((LPIT_VERID_REG(base) & LPIT_VERID_FEATURE_MASK) >> LPIT_VERID_FEATURE_SHIFT)
#define LPIT_BRD_VERID_FEATURE(base) (LPIT_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPIT_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification
 */
/*@{*/
/*! @brief Read current value of the LPIT_VERID_MINOR field. */
#define LPIT_RD_VERID_MINOR(base) ((LPIT_VERID_REG(base) & LPIT_VERID_MINOR_MASK) >> LPIT_VERID_MINOR_SHIFT)
#define LPIT_BRD_VERID_MINOR(base) (BME_UBFX32(&LPIT_VERID_REG(base), LPIT_VERID_MINOR_SHIFT, LPIT_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification
 */
/*@{*/
/*! @brief Read current value of the LPIT_VERID_MAJOR field. */
#define LPIT_RD_VERID_MAJOR(base) ((LPIT_VERID_REG(base) & LPIT_VERID_MAJOR_MASK) >> LPIT_VERID_MAJOR_SHIFT)
#define LPIT_BRD_VERID_MAJOR(base) (BME_UBFX32(&LPIT_VERID_REG(base), LPIT_VERID_MAJOR_SHIFT, LPIT_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * LPIT_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPIT_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000404U
 *
 * This register provides details on the parameter settings that were used while
 * including this module in the device.
 */
/*!
 * @name Constants and macros for entire LPIT_PARAM register
 */
/*@{*/
#define LPIT_RD_PARAM(base)      (LPIT_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPIT_PARAM bitfields
 */

/*!
 * @name Register LPIT_PARAM, field CHANNEL[7:0] (RO)
 *
 * Number of timer channels implemented.
 */
/*@{*/
/*! @brief Read current value of the LPIT_PARAM_CHANNEL field. */
#define LPIT_RD_PARAM_CHANNEL(base) ((LPIT_PARAM_REG(base) & LPIT_PARAM_CHANNEL_MASK) >> LPIT_PARAM_CHANNEL_SHIFT)
#define LPIT_BRD_PARAM_CHANNEL(base) (BME_UBFX32(&LPIT_PARAM_REG(base), LPIT_PARAM_CHANNEL_SHIFT, LPIT_PARAM_CHANNEL_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_PARAM, field EXT_TRIG[15:8] (RO)
 *
 * Number of external triggers implemented.
 */
/*@{*/
/*! @brief Read current value of the LPIT_PARAM_EXT_TRIG field. */
#define LPIT_RD_PARAM_EXT_TRIG(base) ((LPIT_PARAM_REG(base) & LPIT_PARAM_EXT_TRIG_MASK) >> LPIT_PARAM_EXT_TRIG_SHIFT)
#define LPIT_BRD_PARAM_EXT_TRIG(base) (BME_UBFX32(&LPIT_PARAM_REG(base), LPIT_PARAM_EXT_TRIG_SHIFT, LPIT_PARAM_EXT_TRIG_WIDTH))
/*@}*/

/*******************************************************************************
 * LPIT_MCR - Module Control Register
 ******************************************************************************/

/*!
 * @brief LPIT_MCR - Module Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_MCR register
 */
/*@{*/
#define LPIT_RD_MCR(base)        (LPIT_MCR_REG(base))
#define LPIT_WR_MCR(base, value) (LPIT_MCR_REG(base) = (value))
#define LPIT_RMW_MCR(base, mask, value) (LPIT_WR_MCR(base, (LPIT_RD_MCR(base) & ~(mask)) | (value)))
#define LPIT_SET_MCR(base, value) (BME_OR32(&LPIT_MCR_REG(base), (uint32_t)(value)))
#define LPIT_CLR_MCR(base, value) (BME_AND32(&LPIT_MCR_REG(base), (uint32_t)(~(value))))
#define LPIT_TOG_MCR(base, value) (BME_XOR32(&LPIT_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_MCR bitfields
 */

/*!
 * @name Register LPIT_MCR, field M_CEN[0] (RW)
 *
 * Enables the peripheral clock to the module timers. This bit must be asserted
 * when writing to timer registers. Both clocks (bus clock and peripheral clock)
 * must be enabled to allow for clock synchronization and update of register
 * bits. Writing to the SETTEN , CLRTEN, TCTRL, and TVAL while M_CEN = 0, will lead
 * to assertion of transfer error for that bus cycle. Writing to CVAL and Reserved
 * registers will always generate transfer error.
 *
 * Values:
 * - 0b0 - Protocol clock to timers is disabled
 * - 0b1 - Protocol clock to timers is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_M_CEN field. */
#define LPIT_RD_MCR_M_CEN(base) ((LPIT_MCR_REG(base) & LPIT_MCR_M_CEN_MASK) >> LPIT_MCR_M_CEN_SHIFT)
#define LPIT_BRD_MCR_M_CEN(base) (BME_UBFX32(&LPIT_MCR_REG(base), LPIT_MCR_M_CEN_SHIFT, LPIT_MCR_M_CEN_WIDTH))

/*! @brief Set the M_CEN field to a new value. */
#define LPIT_WR_MCR_M_CEN(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_M_CEN_MASK, LPIT_MCR_M_CEN(value)))
#define LPIT_BWR_MCR_M_CEN(base, value) (BME_BFI32(&LPIT_MCR_REG(base), ((uint32_t)(value) << LPIT_MCR_M_CEN_SHIFT), LPIT_MCR_M_CEN_SHIFT, LPIT_MCR_M_CEN_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MCR, field SW_RST[1] (RW)
 *
 * Resets all channels and registers, except the Module Control Register.
 * Remains set until cleared by software.
 *
 * Values:
 * - 0b0 - Timer channels and registers are not reset
 * - 0b1 - Timer channels and registers are reset
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_SW_RST field. */
#define LPIT_RD_MCR_SW_RST(base) ((LPIT_MCR_REG(base) & LPIT_MCR_SW_RST_MASK) >> LPIT_MCR_SW_RST_SHIFT)
#define LPIT_BRD_MCR_SW_RST(base) (BME_UBFX32(&LPIT_MCR_REG(base), LPIT_MCR_SW_RST_SHIFT, LPIT_MCR_SW_RST_WIDTH))

/*! @brief Set the SW_RST field to a new value. */
#define LPIT_WR_MCR_SW_RST(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_SW_RST_MASK, LPIT_MCR_SW_RST(value)))
#define LPIT_BWR_MCR_SW_RST(base, value) (BME_BFI32(&LPIT_MCR_REG(base), ((uint32_t)(value) << LPIT_MCR_SW_RST_SHIFT), LPIT_MCR_SW_RST_SHIFT, LPIT_MCR_SW_RST_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MCR, field DOZE_EN[2] (RW)
 *
 * Allows the timer channels to be stopped or continue to run when the device
 * enters the DOZE mode
 *
 * Values:
 * - 0b0 - Timer channels are stopped in DOZE mode
 * - 0b1 - Timer channels continue to run in DOZE mode
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_DOZE_EN field. */
#define LPIT_RD_MCR_DOZE_EN(base) ((LPIT_MCR_REG(base) & LPIT_MCR_DOZE_EN_MASK) >> LPIT_MCR_DOZE_EN_SHIFT)
#define LPIT_BRD_MCR_DOZE_EN(base) (BME_UBFX32(&LPIT_MCR_REG(base), LPIT_MCR_DOZE_EN_SHIFT, LPIT_MCR_DOZE_EN_WIDTH))

/*! @brief Set the DOZE_EN field to a new value. */
#define LPIT_WR_MCR_DOZE_EN(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_DOZE_EN_MASK, LPIT_MCR_DOZE_EN(value)))
#define LPIT_BWR_MCR_DOZE_EN(base, value) (BME_BFI32(&LPIT_MCR_REG(base), ((uint32_t)(value) << LPIT_MCR_DOZE_EN_SHIFT), LPIT_MCR_DOZE_EN_SHIFT, LPIT_MCR_DOZE_EN_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MCR, field DBG_EN[3] (RW)
 *
 * Allows the timer channels to be stopped when the device enters the Debug mode
 *
 * Values:
 * - 0b0 - Timer channels are stopped in Debug mode
 * - 0b1 - Timer channels continue to run in Debug mode
 */
/*@{*/
/*! @brief Read current value of the LPIT_MCR_DBG_EN field. */
#define LPIT_RD_MCR_DBG_EN(base) ((LPIT_MCR_REG(base) & LPIT_MCR_DBG_EN_MASK) >> LPIT_MCR_DBG_EN_SHIFT)
#define LPIT_BRD_MCR_DBG_EN(base) (BME_UBFX32(&LPIT_MCR_REG(base), LPIT_MCR_DBG_EN_SHIFT, LPIT_MCR_DBG_EN_WIDTH))

/*! @brief Set the DBG_EN field to a new value. */
#define LPIT_WR_MCR_DBG_EN(base, value) (LPIT_RMW_MCR(base, LPIT_MCR_DBG_EN_MASK, LPIT_MCR_DBG_EN(value)))
#define LPIT_BWR_MCR_DBG_EN(base, value) (BME_BFI32(&LPIT_MCR_REG(base), ((uint32_t)(value) << LPIT_MCR_DBG_EN_SHIFT), LPIT_MCR_DBG_EN_SHIFT, LPIT_MCR_DBG_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * LPIT_MSR - Module Status Register
 ******************************************************************************/

/*!
 * @brief LPIT_MSR - Module Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_MSR register
 */
/*@{*/
#define LPIT_RD_MSR(base)        (LPIT_MSR_REG(base))
#define LPIT_WR_MSR(base, value) (LPIT_MSR_REG(base) = (value))
#define LPIT_RMW_MSR(base, mask, value) (LPIT_WR_MSR(base, (LPIT_RD_MSR(base) & ~(mask)) | (value)))
#define LPIT_SET_MSR(base, value) (BME_OR32(&LPIT_MSR_REG(base), (uint32_t)(value)))
#define LPIT_CLR_MSR(base, value) (BME_AND32(&LPIT_MSR_REG(base), (uint32_t)(~(value))))
#define LPIT_TOG_MSR(base, value) (BME_XOR32(&LPIT_MSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_MSR bitfields
 */

/*!
 * @name Register LPIT_MSR, field TIF0[0] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF0 field. */
#define LPIT_RD_MSR_TIF0(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF0_MASK) >> LPIT_MSR_TIF0_SHIFT)
#define LPIT_BRD_MSR_TIF0(base) (BME_UBFX32(&LPIT_MSR_REG(base), LPIT_MSR_TIF0_SHIFT, LPIT_MSR_TIF0_WIDTH))

/*! @brief Set the TIF0 field to a new value. */
#define LPIT_WR_MSR_TIF0(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF2_MASK | LPIT_MSR_TIF3_MASK), LPIT_MSR_TIF0(value)))
#define LPIT_BWR_MSR_TIF0(base, value) (BME_BFI32(&LPIT_MSR_REG(base), ((uint32_t)(value) << LPIT_MSR_TIF0_SHIFT), LPIT_MSR_TIF0_SHIFT, LPIT_MSR_TIF0_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MSR, field TIF1[1] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF1 field. */
#define LPIT_RD_MSR_TIF1(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF1_MASK) >> LPIT_MSR_TIF1_SHIFT)
#define LPIT_BRD_MSR_TIF1(base) (BME_UBFX32(&LPIT_MSR_REG(base), LPIT_MSR_TIF1_SHIFT, LPIT_MSR_TIF1_WIDTH))

/*! @brief Set the TIF1 field to a new value. */
#define LPIT_WR_MSR_TIF1(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF2_MASK | LPIT_MSR_TIF3_MASK), LPIT_MSR_TIF1(value)))
#define LPIT_BWR_MSR_TIF1(base, value) (BME_BFI32(&LPIT_MSR_REG(base), ((uint32_t)(value) << LPIT_MSR_TIF1_SHIFT), LPIT_MSR_TIF1_SHIFT, LPIT_MSR_TIF1_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MSR, field TIF2[2] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF2 field. */
#define LPIT_RD_MSR_TIF2(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF2_MASK) >> LPIT_MSR_TIF2_SHIFT)
#define LPIT_BRD_MSR_TIF2(base) (BME_UBFX32(&LPIT_MSR_REG(base), LPIT_MSR_TIF2_SHIFT, LPIT_MSR_TIF2_WIDTH))

/*! @brief Set the TIF2 field to a new value. */
#define LPIT_WR_MSR_TIF2(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF2_MASK | LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF3_MASK), LPIT_MSR_TIF2(value)))
#define LPIT_BWR_MSR_TIF2(base, value) (BME_BFI32(&LPIT_MSR_REG(base), ((uint32_t)(value) << LPIT_MSR_TIF2_SHIFT), LPIT_MSR_TIF2_SHIFT, LPIT_MSR_TIF2_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MSR, field TIF3[3] (W1C)
 *
 * In compare modes, sets to 1 at the end of the timer period. In capture modes,
 * sets to 1 when the trigger asserts. Writing logic 1 to this flag clears it.
 * Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - Timer has not timed out
 * - 0b1 - Timeout has occurred
 */
/*@{*/
/*! @brief Read current value of the LPIT_MSR_TIF3 field. */
#define LPIT_RD_MSR_TIF3(base) ((LPIT_MSR_REG(base) & LPIT_MSR_TIF3_MASK) >> LPIT_MSR_TIF3_SHIFT)
#define LPIT_BRD_MSR_TIF3(base) (BME_UBFX32(&LPIT_MSR_REG(base), LPIT_MSR_TIF3_SHIFT, LPIT_MSR_TIF3_WIDTH))

/*! @brief Set the TIF3 field to a new value. */
#define LPIT_WR_MSR_TIF3(base, value) (LPIT_RMW_MSR(base, (LPIT_MSR_TIF3_MASK | LPIT_MSR_TIF0_MASK | LPIT_MSR_TIF1_MASK | LPIT_MSR_TIF2_MASK), LPIT_MSR_TIF3(value)))
#define LPIT_BWR_MSR_TIF3(base, value) (BME_BFI32(&LPIT_MSR_REG(base), ((uint32_t)(value) << LPIT_MSR_TIF3_SHIFT), LPIT_MSR_TIF3_SHIFT, LPIT_MSR_TIF3_WIDTH))
/*@}*/

/*******************************************************************************
 * LPIT_MIER - Module Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPIT_MIER - Module Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_MIER register
 */
/*@{*/
#define LPIT_RD_MIER(base)       (LPIT_MIER_REG(base))
#define LPIT_WR_MIER(base, value) (LPIT_MIER_REG(base) = (value))
#define LPIT_RMW_MIER(base, mask, value) (LPIT_WR_MIER(base, (LPIT_RD_MIER(base) & ~(mask)) | (value)))
#define LPIT_SET_MIER(base, value) (BME_OR32(&LPIT_MIER_REG(base), (uint32_t)(value)))
#define LPIT_CLR_MIER(base, value) (BME_AND32(&LPIT_MIER_REG(base), (uint32_t)(~(value))))
#define LPIT_TOG_MIER(base, value) (BME_XOR32(&LPIT_MIER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_MIER bitfields
 */

/*!
 * @name Register LPIT_MIER, field TIE0[0] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE0 field. */
#define LPIT_RD_MIER_TIE0(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE0_MASK) >> LPIT_MIER_TIE0_SHIFT)
#define LPIT_BRD_MIER_TIE0(base) (BME_UBFX32(&LPIT_MIER_REG(base), LPIT_MIER_TIE0_SHIFT, LPIT_MIER_TIE0_WIDTH))

/*! @brief Set the TIE0 field to a new value. */
#define LPIT_WR_MIER_TIE0(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE0_MASK, LPIT_MIER_TIE0(value)))
#define LPIT_BWR_MIER_TIE0(base, value) (BME_BFI32(&LPIT_MIER_REG(base), ((uint32_t)(value) << LPIT_MIER_TIE0_SHIFT), LPIT_MIER_TIE0_SHIFT, LPIT_MIER_TIE0_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MIER, field TIE1[1] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE1 field. */
#define LPIT_RD_MIER_TIE1(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE1_MASK) >> LPIT_MIER_TIE1_SHIFT)
#define LPIT_BRD_MIER_TIE1(base) (BME_UBFX32(&LPIT_MIER_REG(base), LPIT_MIER_TIE1_SHIFT, LPIT_MIER_TIE1_WIDTH))

/*! @brief Set the TIE1 field to a new value. */
#define LPIT_WR_MIER_TIE1(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE1_MASK, LPIT_MIER_TIE1(value)))
#define LPIT_BWR_MIER_TIE1(base, value) (BME_BFI32(&LPIT_MIER_REG(base), ((uint32_t)(value) << LPIT_MIER_TIE1_SHIFT), LPIT_MIER_TIE1_SHIFT, LPIT_MIER_TIE1_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MIER, field TIE2[2] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE2 field. */
#define LPIT_RD_MIER_TIE2(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE2_MASK) >> LPIT_MIER_TIE2_SHIFT)
#define LPIT_BRD_MIER_TIE2(base) (BME_UBFX32(&LPIT_MIER_REG(base), LPIT_MIER_TIE2_SHIFT, LPIT_MIER_TIE2_WIDTH))

/*! @brief Set the TIE2 field to a new value. */
#define LPIT_WR_MIER_TIE2(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE2_MASK, LPIT_MIER_TIE2(value)))
#define LPIT_BWR_MIER_TIE2(base, value) (BME_BFI32(&LPIT_MIER_REG(base), ((uint32_t)(value) << LPIT_MIER_TIE2_SHIFT), LPIT_MIER_TIE2_SHIFT, LPIT_MIER_TIE2_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_MIER, field TIE3[3] (RW)
 *
 * Enables interrupt generation when this bit is set to 1 and if corresponding
 * Timer Interrupt Flag is asserted.
 *
 * Values:
 * - 0b0 - Interrupt generation is disabled
 * - 0b1 - Interrupt generation is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_MIER_TIE3 field. */
#define LPIT_RD_MIER_TIE3(base) ((LPIT_MIER_REG(base) & LPIT_MIER_TIE3_MASK) >> LPIT_MIER_TIE3_SHIFT)
#define LPIT_BRD_MIER_TIE3(base) (BME_UBFX32(&LPIT_MIER_REG(base), LPIT_MIER_TIE3_SHIFT, LPIT_MIER_TIE3_WIDTH))

/*! @brief Set the TIE3 field to a new value. */
#define LPIT_WR_MIER_TIE3(base, value) (LPIT_RMW_MIER(base, LPIT_MIER_TIE3_MASK, LPIT_MIER_TIE3(value)))
#define LPIT_BWR_MIER_TIE3(base, value) (BME_BFI32(&LPIT_MIER_REG(base), ((uint32_t)(value) << LPIT_MIER_TIE3_SHIFT), LPIT_MIER_TIE3_SHIFT, LPIT_MIER_TIE3_WIDTH))
/*@}*/

/*******************************************************************************
 * LPIT_SETTEN - Set Timer Enable Register
 ******************************************************************************/

/*!
 * @brief LPIT_SETTEN - Set Timer Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register allows simulataneous enabling of timer channels. Timer channels
 * can be enabled either by writing '1' to T_EN in respective TCTRLn register or
 * setting the corresponding bit in this register. Writing a '0' to this
 * register has no effect. CLRTEN register should be used to disable timer channels
 * simultaneously.
 */
/*!
 * @name Constants and macros for entire LPIT_SETTEN register
 */
/*@{*/
#define LPIT_RD_SETTEN(base)     (LPIT_SETTEN_REG(base))
#define LPIT_WR_SETTEN(base, value) (LPIT_SETTEN_REG(base) = (value))
#define LPIT_RMW_SETTEN(base, mask, value) (LPIT_WR_SETTEN(base, (LPIT_RD_SETTEN(base) & ~(mask)) | (value)))
#define LPIT_SET_SETTEN(base, value) (BME_OR32(&LPIT_SETTEN_REG(base), (uint32_t)(value)))
#define LPIT_CLR_SETTEN(base, value) (BME_AND32(&LPIT_SETTEN_REG(base), (uint32_t)(~(value))))
#define LPIT_TOG_SETTEN(base, value) (BME_XOR32(&LPIT_SETTEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_SETTEN bitfields
 */

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_0[0] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 0. This bit can be used
 * in addition to T_EN bit in TCTRL0 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL0 is set to 0 or '1'
 * is written to the CLR_T_EN_0 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No effect
 * - 0b1 - Enables the Timer Channel 0
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_0 field. */
#define LPIT_RD_SETTEN_SET_T_EN_0(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_0_MASK) >> LPIT_SETTEN_SET_T_EN_0_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_0(base) (BME_UBFX32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_0_SHIFT, LPIT_SETTEN_SET_T_EN_0_WIDTH))

/*! @brief Set the SET_T_EN_0 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_0(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_0_MASK, LPIT_SETTEN_SET_T_EN_0(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_0(base, value) (BME_BFI32(&LPIT_SETTEN_REG(base), ((uint32_t)(value) << LPIT_SETTEN_SET_T_EN_0_SHIFT), LPIT_SETTEN_SET_T_EN_0_SHIFT, LPIT_SETTEN_SET_T_EN_0_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_1[1] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 1. This bit can be used
 * in addition to T_EN bit in TCTRL1 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL1 is set to '0' or '1'
 * is written to the CLR_T_EN_1 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No Effect
 * - 0b1 - Enables the Timer Channel 1
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_1 field. */
#define LPIT_RD_SETTEN_SET_T_EN_1(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_1_MASK) >> LPIT_SETTEN_SET_T_EN_1_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_1(base) (BME_UBFX32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_1_SHIFT, LPIT_SETTEN_SET_T_EN_1_WIDTH))

/*! @brief Set the SET_T_EN_1 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_1(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_1_MASK, LPIT_SETTEN_SET_T_EN_1(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_1(base, value) (BME_BFI32(&LPIT_SETTEN_REG(base), ((uint32_t)(value) << LPIT_SETTEN_SET_T_EN_1_SHIFT), LPIT_SETTEN_SET_T_EN_1_SHIFT, LPIT_SETTEN_SET_T_EN_1_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_2[2] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 2. This bit can be used
 * in addition to T_EN bit in TCTRL2 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL2 is set to '0' or '1'
 * is written to the CLR_T_EN_2 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No Effect
 * - 0b1 - Enables the Timer Channel 2
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_2 field. */
#define LPIT_RD_SETTEN_SET_T_EN_2(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_2_MASK) >> LPIT_SETTEN_SET_T_EN_2_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_2(base) (BME_UBFX32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_2_SHIFT, LPIT_SETTEN_SET_T_EN_2_WIDTH))

/*! @brief Set the SET_T_EN_2 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_2(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_2_MASK, LPIT_SETTEN_SET_T_EN_2(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_2(base, value) (BME_BFI32(&LPIT_SETTEN_REG(base), ((uint32_t)(value) << LPIT_SETTEN_SET_T_EN_2_SHIFT), LPIT_SETTEN_SET_T_EN_2_SHIFT, LPIT_SETTEN_SET_T_EN_2_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_SETTEN, field SET_T_EN_3[3] (RW)
 *
 * Writing '1' to this bit will enable the timer channel 3. This bit can be used
 * in addition to T_EN bit in TCTRL3 register. Writing a 0 will not disable the
 * counter. This bit will be cleared when T_EN bit in TCTRL3 is set to '0' or '1'
 * is written to the CLR_T_EN_3 bit in CLRTEN register.
 *
 * Values:
 * - 0b0 - No effect
 * - 0b1 - Enables the Timer Channel 3
 */
/*@{*/
/*! @brief Read current value of the LPIT_SETTEN_SET_T_EN_3 field. */
#define LPIT_RD_SETTEN_SET_T_EN_3(base) ((LPIT_SETTEN_REG(base) & LPIT_SETTEN_SET_T_EN_3_MASK) >> LPIT_SETTEN_SET_T_EN_3_SHIFT)
#define LPIT_BRD_SETTEN_SET_T_EN_3(base) (BME_UBFX32(&LPIT_SETTEN_REG(base), LPIT_SETTEN_SET_T_EN_3_SHIFT, LPIT_SETTEN_SET_T_EN_3_WIDTH))

/*! @brief Set the SET_T_EN_3 field to a new value. */
#define LPIT_WR_SETTEN_SET_T_EN_3(base, value) (LPIT_RMW_SETTEN(base, LPIT_SETTEN_SET_T_EN_3_MASK, LPIT_SETTEN_SET_T_EN_3(value)))
#define LPIT_BWR_SETTEN_SET_T_EN_3(base, value) (BME_BFI32(&LPIT_SETTEN_REG(base), ((uint32_t)(value) << LPIT_SETTEN_SET_T_EN_3_SHIFT), LPIT_SETTEN_SET_T_EN_3_SHIFT, LPIT_SETTEN_SET_T_EN_3_WIDTH))
/*@}*/

/*******************************************************************************
 * LPIT_CLRTEN - Clear Timer Enable Register
 ******************************************************************************/

/*!
 * @brief LPIT_CLRTEN - Clear Timer Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPIT_CLRTEN register
 */
/*@{*/
#define LPIT_RD_CLRTEN(base)     (LPIT_CLRTEN_REG(base))
#define LPIT_WR_CLRTEN(base, value) (LPIT_CLRTEN_REG(base) = (value))
#define LPIT_RMW_CLRTEN(base, mask, value) (LPIT_WR_CLRTEN(base, (LPIT_RD_CLRTEN(base) & ~(mask)) | (value)))
#define LPIT_SET_CLRTEN(base, value) (BME_OR32(&LPIT_CLRTEN_REG(base), (uint32_t)(value)))
#define LPIT_CLR_CLRTEN(base, value) (BME_AND32(&LPIT_CLRTEN_REG(base), (uint32_t)(~(value))))
#define LPIT_TOG_CLRTEN(base, value) (BME_XOR32(&LPIT_CLRTEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_CLRTEN bitfields
 */

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_0[0] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 0. This bit can be
 * used in addition to T_EN bit in TCTRL0 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No action
 * - 0b1 - Clear T_EN bit for Timer Channel 0
 */
/*@{*/
/*! @brief Set the CLR_T_EN_0 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_0(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_0_MASK, LPIT_CLRTEN_CLR_T_EN_0(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_0(base, value) (BME_BFI32(&LPIT_CLRTEN_REG(base), ((uint32_t)(value) << LPIT_CLRTEN_CLR_T_EN_0_SHIFT), LPIT_CLRTEN_CLR_T_EN_0_SHIFT, LPIT_CLRTEN_CLR_T_EN_0_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_1[1] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 1. This bit can be
 * used in addition to T_EN bit in TCTRL1 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No Action
 * - 0b1 - Clear T_EN bit for Timer Channel 1
 */
/*@{*/
/*! @brief Set the CLR_T_EN_1 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_1(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_1_MASK, LPIT_CLRTEN_CLR_T_EN_1(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_1(base, value) (BME_BFI32(&LPIT_CLRTEN_REG(base), ((uint32_t)(value) << LPIT_CLRTEN_CLR_T_EN_1_SHIFT), LPIT_CLRTEN_CLR_T_EN_1_SHIFT, LPIT_CLRTEN_CLR_T_EN_1_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_2[2] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 2. This bit can be
 * used in addition to T_EN bit in TCTRL2 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No Action
 * - 0b1 - Clear T_EN bit for Timer Channel 2
 */
/*@{*/
/*! @brief Set the CLR_T_EN_2 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_2(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_2_MASK, LPIT_CLRTEN_CLR_T_EN_2(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_2(base, value) (BME_BFI32(&LPIT_CLRTEN_REG(base), ((uint32_t)(value) << LPIT_CLRTEN_CLR_T_EN_2_SHIFT), LPIT_CLRTEN_CLR_T_EN_2_SHIFT, LPIT_CLRTEN_CLR_T_EN_2_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_CLRTEN, field CLR_T_EN_3[3] (WORZ)
 *
 * Writing a '1' to this bit will disable the timer channel 3. This bit can be
 * used in addition to T_EN bit in TCTRL3 register. Writing a 1 will not enable
 * the counter. This bit is self clearing and will always read 0.
 *
 * Values:
 * - 0b0 - No Action
 * - 0b1 - Clear T_EN bit for Timer Channel 3
 */
/*@{*/
/*! @brief Set the CLR_T_EN_3 field to a new value. */
#define LPIT_WR_CLRTEN_CLR_T_EN_3(base, value) (LPIT_RMW_CLRTEN(base, LPIT_CLRTEN_CLR_T_EN_3_MASK, LPIT_CLRTEN_CLR_T_EN_3(value)))
#define LPIT_BWR_CLRTEN_CLR_T_EN_3(base, value) (BME_BFI32(&LPIT_CLRTEN_REG(base), ((uint32_t)(value) << LPIT_CLRTEN_CLR_T_EN_3_SHIFT), LPIT_CLRTEN_CLR_T_EN_3_SHIFT, LPIT_CLRTEN_CLR_T_EN_3_WIDTH))
/*@}*/

/*******************************************************************************
 * LPIT_TVAL - Timer Value Register
 ******************************************************************************/

/*!
 * @brief LPIT_TVAL - Timer Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * In compare modes, these registers select the timeout period for the timer
 * channels. In capture modes, these registers are loaded with the value of the
 * counter when the trigger asserts.
 */
/*!
 * @name Constants and macros for entire LPIT_TVAL register
 */
/*@{*/
#define LPIT_RD_TVAL(base, index) (LPIT_TVAL_REG(base, index))
#define LPIT_WR_TVAL(base, index, value) (LPIT_TVAL_REG(base, index) = (value))
#define LPIT_RMW_TVAL(base, index, mask, value) (LPIT_WR_TVAL(base, index, (LPIT_RD_TVAL(base, index) & ~(mask)) | (value)))
#define LPIT_SET_TVAL(base, index, value) (BME_OR32(&LPIT_TVAL_REG(base, index), (uint32_t)(value)))
#define LPIT_CLR_TVAL(base, index, value) (BME_AND32(&LPIT_TVAL_REG(base, index), (uint32_t)(~(value))))
#define LPIT_TOG_TVAL(base, index, value) (BME_XOR32(&LPIT_TVAL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LPIT_CVAL - Current Timer Value
 ******************************************************************************/

/*!
 * @brief LPIT_CVAL - Current Timer Value (RO)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * These registers indicate the current timer counter value.
 */
/*!
 * @name Constants and macros for entire LPIT_CVAL register
 */
/*@{*/
#define LPIT_RD_CVAL(base, index) (LPIT_CVAL_REG(base, index))
/*@}*/

/*******************************************************************************
 * LPIT_TCTRL - Timer Control Register
 ******************************************************************************/

/*!
 * @brief LPIT_TCTRL - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer channel
 */
/*!
 * @name Constants and macros for entire LPIT_TCTRL register
 */
/*@{*/
#define LPIT_RD_TCTRL(base, index) (LPIT_TCTRL_REG(base, index))
#define LPIT_WR_TCTRL(base, index, value) (LPIT_TCTRL_REG(base, index) = (value))
#define LPIT_RMW_TCTRL(base, index, mask, value) (LPIT_WR_TCTRL(base, index, (LPIT_RD_TCTRL(base, index) & ~(mask)) | (value)))
#define LPIT_SET_TCTRL(base, index, value) (BME_OR32(&LPIT_TCTRL_REG(base, index), (uint32_t)(value)))
#define LPIT_CLR_TCTRL(base, index, value) (BME_AND32(&LPIT_TCTRL_REG(base, index), (uint32_t)(~(value))))
#define LPIT_TOG_TCTRL(base, index, value) (BME_XOR32(&LPIT_TCTRL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPIT_TCTRL bitfields
 */

/*!
 * @name Register LPIT_TCTRL, field T_EN[0] (RW)
 *
 * Enables or disables the Timer Channel
 *
 * Values:
 * - 0b0 - Timer Channel is disabled
 * - 0b1 - Timer Channel is enabled
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_T_EN field. */
#define LPIT_RD_TCTRL_T_EN(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_T_EN_MASK) >> LPIT_TCTRL_T_EN_SHIFT)
#define LPIT_BRD_TCTRL_T_EN(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_T_EN_SHIFT, LPIT_TCTRL_T_EN_WIDTH))

/*! @brief Set the T_EN field to a new value. */
#define LPIT_WR_TCTRL_T_EN(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_T_EN_MASK, LPIT_TCTRL_T_EN(value)))
#define LPIT_BWR_TCTRL_T_EN(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_T_EN_SHIFT), LPIT_TCTRL_T_EN_SHIFT, LPIT_TCTRL_T_EN_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_TCTRL, field CHAIN[1] (RW)
 *
 * When enabled, timer channel will decrement when channel N-1 trigger asserts.
 * Channel 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Channel Chaining is disabled. Channel Timer runs independently.
 * - 0b1 - Channel Chaining is enabled. Timer decrements on previous channel's
 *     timeout
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_CHAIN field. */
#define LPIT_RD_TCTRL_CHAIN(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_CHAIN_MASK) >> LPIT_TCTRL_CHAIN_SHIFT)
#define LPIT_BRD_TCTRL_CHAIN(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_CHAIN_SHIFT, LPIT_TCTRL_CHAIN_WIDTH))

/*! @brief Set the CHAIN field to a new value. */
#define LPIT_WR_TCTRL_CHAIN(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_CHAIN_MASK, LPIT_TCTRL_CHAIN(value)))
#define LPIT_BWR_TCTRL_CHAIN(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_CHAIN_SHIFT), LPIT_TCTRL_CHAIN_SHIFT, LPIT_TCTRL_CHAIN_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_TCTRL, field MODE[3:2] (RW)
 *
 * Configures the Channel Timer Mode of Operation. The mode bits control how the
 * timer decrements. See Functional Description for more details.
 *
 * Values:
 * - 0b00 - 32-bit Periodic Counter
 * - 0b01 - Dual 16-bit Periodic Counter
 * - 0b10 - 32-bit Trigger Accumulator
 * - 0b11 - 32-bit Trigger Input Capture
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_MODE field. */
#define LPIT_RD_TCTRL_MODE(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_MODE_MASK) >> LPIT_TCTRL_MODE_SHIFT)
#define LPIT_BRD_TCTRL_MODE(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_MODE_SHIFT, LPIT_TCTRL_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define LPIT_WR_TCTRL_MODE(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_MODE_MASK, LPIT_TCTRL_MODE(value)))
#define LPIT_BWR_TCTRL_MODE(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_MODE_SHIFT), LPIT_TCTRL_MODE_SHIFT, LPIT_TCTRL_MODE_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_TCTRL, field TSOT[16] (RW)
 *
 * This bit controls when the timer starts decrementing.
 *
 * Values:
 * - 0b0 - Timer starts to decrement immediately based on restart condition
 *     (controlled by TSOI bit)
 * - 0b1 - Timer starts to decrement when rising edge on selected trigger is
 *     detected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_TSOT field. */
#define LPIT_RD_TCTRL_TSOT(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_TSOT_MASK) >> LPIT_TCTRL_TSOT_SHIFT)
#define LPIT_BRD_TCTRL_TSOT(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_TSOT_SHIFT, LPIT_TCTRL_TSOT_WIDTH))

/*! @brief Set the TSOT field to a new value. */
#define LPIT_WR_TCTRL_TSOT(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_TSOT_MASK, LPIT_TCTRL_TSOT(value)))
#define LPIT_BWR_TCTRL_TSOT(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_TSOT_SHIFT), LPIT_TCTRL_TSOT_SHIFT, LPIT_TCTRL_TSOT_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_TCTRL, field TSOI[17] (RW)
 *
 * This bit controls whether the channel timer will stop after it times out and
 * when it can restart (when TSOT = 0). If TSOT = 1, then the timer will stop on
 * timeout and will restart after a rising edge on the selected trigger is
 * detected. If TSOT = 0, then this bit controls when the timer restarts.
 *
 * Values:
 * - 0b0 - Timer does not stop after timeout
 * - 0b1 - Timer will stop after timeout and will restart after rising edge on
 *     the T_EN bit is detected (i.e. timer channel is disabled and then enabled)
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_TSOI field. */
#define LPIT_RD_TCTRL_TSOI(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_TSOI_MASK) >> LPIT_TCTRL_TSOI_SHIFT)
#define LPIT_BRD_TCTRL_TSOI(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_TSOI_SHIFT, LPIT_TCTRL_TSOI_WIDTH))

/*! @brief Set the TSOI field to a new value. */
#define LPIT_WR_TCTRL_TSOI(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_TSOI_MASK, LPIT_TCTRL_TSOI(value)))
#define LPIT_BWR_TCTRL_TSOI(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_TSOI_SHIFT), LPIT_TCTRL_TSOI_SHIFT, LPIT_TCTRL_TSOI_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_TCTRL, field TROT[18] (RW)
 *
 * When set, the LPIT timer will reload when a rising edge is detected on the
 * selected trigger input. The trigger input is ignored if the LPIT is disabled
 * during debug mode or DOZE mode (DOZE_EN or DBGEN = 0)
 *
 * Values:
 * - 0b0 - Timer will not reload on selected trigger
 * - 0b1 - Timer will reload on selected trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_TROT field. */
#define LPIT_RD_TCTRL_TROT(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_TROT_MASK) >> LPIT_TCTRL_TROT_SHIFT)
#define LPIT_BRD_TCTRL_TROT(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_TROT_SHIFT, LPIT_TCTRL_TROT_WIDTH))

/*! @brief Set the TROT field to a new value. */
#define LPIT_WR_TCTRL_TROT(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_TROT_MASK, LPIT_TCTRL_TROT(value)))
#define LPIT_BWR_TCTRL_TROT(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_TROT_SHIFT), LPIT_TCTRL_TROT_SHIFT, LPIT_TCTRL_TROT_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_TCTRL, field TRG_SRC[23] (RW)
 *
 * Selects between internal or external trigger sources. The final trigger is
 * selected by TRG_SEL depending on which trigger source out of internal triggers
 * or external triggers are selected by TRG_SRC. Refer to the chip configuration
 * section for available external trigger options. If a channel does not have an
 * associated external trigger then this bit for that channel should be set to 1.
 *
 * Values:
 * - 0b0 - Trigger source selected in external
 * - 0b1 - Trigger source selected is the internal trigger
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_TRG_SRC field. */
#define LPIT_RD_TCTRL_TRG_SRC(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_TRG_SRC_MASK) >> LPIT_TCTRL_TRG_SRC_SHIFT)
#define LPIT_BRD_TCTRL_TRG_SRC(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_TRG_SRC_SHIFT, LPIT_TCTRL_TRG_SRC_WIDTH))

/*! @brief Set the TRG_SRC field to a new value. */
#define LPIT_WR_TCTRL_TRG_SRC(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_TRG_SRC_MASK, LPIT_TCTRL_TRG_SRC(value)))
#define LPIT_BWR_TCTRL_TRG_SRC(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_TRG_SRC_SHIFT), LPIT_TCTRL_TRG_SRC_SHIFT, LPIT_TCTRL_TRG_SRC_WIDTH))
/*@}*/

/*!
 * @name Register LPIT_TCTRL, field TRG_SEL[27:24] (RW)
 *
 * Selects the trigger to use for starting and/or reloading the LPIT timer. This
 * field should only be changed when the LPIT timer channel is disabled. The
 * TRG_SRC bit selects between internal and external trigger signals for each
 * channel. The TRG_SEL bits select one trigger from the set of internal or external
 * triggers selected by TRG_SRC.
 *
 * Values:
 * - 0b0000 - Timer channel 0 trigger source is selected
 * - 0b0001 - Timer channel 1 trigger source is selected
 */
/*@{*/
/*! @brief Read current value of the LPIT_TCTRL_TRG_SEL field. */
#define LPIT_RD_TCTRL_TRG_SEL(base, index) ((LPIT_TCTRL_REG(base, index) & LPIT_TCTRL_TRG_SEL_MASK) >> LPIT_TCTRL_TRG_SEL_SHIFT)
#define LPIT_BRD_TCTRL_TRG_SEL(base, index) (BME_UBFX32(&LPIT_TCTRL_REG(base, index), LPIT_TCTRL_TRG_SEL_SHIFT, LPIT_TCTRL_TRG_SEL_WIDTH))

/*! @brief Set the TRG_SEL field to a new value. */
#define LPIT_WR_TCTRL_TRG_SEL(base, index, value) (LPIT_RMW_TCTRL(base, index, LPIT_TCTRL_TRG_SEL_MASK, LPIT_TCTRL_TRG_SEL(value)))
#define LPIT_BWR_TCTRL_TRG_SEL(base, index, value) (BME_BFI32(&LPIT_TCTRL_REG(base, index), ((uint32_t)(value) << LPIT_TCTRL_TRG_SEL_SHIFT), LPIT_TCTRL_TRG_SEL_SHIFT, LPIT_TCTRL_TRG_SEL_WIDTH))
/*@}*/

/*
 * MKL28Z7 LPSPI
 *
 * The LPSPI Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - LPSPI_VERID - Version ID Register
 * - LPSPI_PARAM - Parameter Register
 * - LPSPI_CR - Control Register
 * - LPSPI_SR - Status Register
 * - LPSPI_IER - Interrupt Enable Register
 * - LPSPI_DER - DMA Enable Register
 * - LPSPI_CFGR0 - Configuration Register 0
 * - LPSPI_CFGR1 - Configuration Register 1
 * - LPSPI_DMR0 - Data Match Register 0
 * - LPSPI_DMR1 - Data Match Register 1
 * - LPSPI_CCR - Clock Configuration Register
 * - LPSPI_FCR - FIFO Control Register
 * - LPSPI_FSR - FIFO Status Register
 * - LPSPI_TCR - Transmit Command Register
 * - LPSPI_TDR - Transmit Data Register
 * - LPSPI_RSR - Receive Status Register
 * - LPSPI_RDR - Receive Data Register
 */

#define LPSPI_INSTANCE_COUNT (3U) /*!< Number of instances of the LPSPI module. */
#define LPSPI0_IDX (0U) /*!< Instance number for LPSPI0. */
#define LPSPI1_IDX (1U) /*!< Instance number for LPSPI1. */
#define LPSPI2_IDX (2U) /*!< Instance number for LPSPI2. */

/*******************************************************************************
 * LPSPI_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPSPI_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000004U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPSPI_VERID register
 */
/*@{*/
#define LPSPI_RD_VERID(base)     (LPSPI_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_VERID bitfields
 */

/*!
 * @name Register LPSPI_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000100 - Standard feature set supporting 32-bit shift register.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_VERID_FEATURE field. */
#define LPSPI_RD_VERID_FEATURE(base) ((LPSPI_VERID_REG(base) & LPSPI_VERID_FEATURE_MASK) >> LPSPI_VERID_FEATURE_SHIFT)
#define LPSPI_BRD_VERID_FEATURE(base) (LPSPI_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPSPI_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_VERID_MINOR field. */
#define LPSPI_RD_VERID_MINOR(base) ((LPSPI_VERID_REG(base) & LPSPI_VERID_MINOR_MASK) >> LPSPI_VERID_MINOR_SHIFT)
#define LPSPI_BRD_VERID_MINOR(base) (BME_UBFX32(&LPSPI_VERID_REG(base), LPSPI_VERID_MINOR_SHIFT, LPSPI_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_VERID_MAJOR field. */
#define LPSPI_RD_VERID_MAJOR(base) ((LPSPI_VERID_REG(base) & LPSPI_VERID_MAJOR_MASK) >> LPSPI_VERID_MAJOR_SHIFT)
#define LPSPI_BRD_VERID_MAJOR(base) (BME_UBFX32(&LPSPI_VERID_REG(base), LPSPI_VERID_MAJOR_SHIFT, LPSPI_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPSPI_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000202U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPSPI_PARAM register
 */
/*@{*/
#define LPSPI_RD_PARAM(base)     (LPSPI_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_PARAM bitfields
 */

/*!
 * @name Register LPSPI_PARAM, field TXFIFO[7:0] (RO)
 *
 * The number of words in the transmit FIFO is 2**TXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_PARAM_TXFIFO field. */
#define LPSPI_RD_PARAM_TXFIFO(base) ((LPSPI_PARAM_REG(base) & LPSPI_PARAM_TXFIFO_MASK) >> LPSPI_PARAM_TXFIFO_SHIFT)
#define LPSPI_BRD_PARAM_TXFIFO(base) (BME_UBFX32(&LPSPI_PARAM_REG(base), LPSPI_PARAM_TXFIFO_SHIFT, LPSPI_PARAM_TXFIFO_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_PARAM, field RXFIFO[15:8] (RO)
 *
 * The number of words in the receive FIFO is 2**RXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_PARAM_RXFIFO field. */
#define LPSPI_RD_PARAM_RXFIFO(base) ((LPSPI_PARAM_REG(base) & LPSPI_PARAM_RXFIFO_MASK) >> LPSPI_PARAM_RXFIFO_SHIFT)
#define LPSPI_BRD_PARAM_RXFIFO(base) (BME_UBFX32(&LPSPI_PARAM_REG(base), LPSPI_PARAM_RXFIFO_SHIFT, LPSPI_PARAM_RXFIFO_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_CR - Control Register
 ******************************************************************************/

/*!
 * @brief LPSPI_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_CR register
 */
/*@{*/
#define LPSPI_RD_CR(base)        (LPSPI_CR_REG(base))
#define LPSPI_WR_CR(base, value) (LPSPI_CR_REG(base) = (value))
#define LPSPI_RMW_CR(base, mask, value) (LPSPI_WR_CR(base, (LPSPI_RD_CR(base) & ~(mask)) | (value)))
#define LPSPI_SET_CR(base, value) (BME_OR32(&LPSPI_CR_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_CR(base, value) (BME_AND32(&LPSPI_CR_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_CR(base, value) (BME_XOR32(&LPSPI_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CR bitfields
 */

/*!
 * @name Register LPSPI_CR, field MEN[0] (RW)
 *
 * Values:
 * - 0b0 - Module is disabled.
 * - 0b1 - Module is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_MEN field. */
#define LPSPI_RD_CR_MEN(base) ((LPSPI_CR_REG(base) & LPSPI_CR_MEN_MASK) >> LPSPI_CR_MEN_SHIFT)
#define LPSPI_BRD_CR_MEN(base) (BME_UBFX32(&LPSPI_CR_REG(base), LPSPI_CR_MEN_SHIFT, LPSPI_CR_MEN_WIDTH))

/*! @brief Set the MEN field to a new value. */
#define LPSPI_WR_CR_MEN(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_MEN_MASK, LPSPI_CR_MEN(value)))
#define LPSPI_BWR_CR_MEN(base, value) (BME_BFI32(&LPSPI_CR_REG(base), ((uint32_t)(value) << LPSPI_CR_MEN_SHIFT), LPSPI_CR_MEN_SHIFT, LPSPI_CR_MEN_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CR, field RST[1] (RW)
 *
 * Reset all internal logic and registers, except the Control Register. Remains
 * set until cleared by software.
 *
 * Values:
 * - 0b0 - Master logic is not reset.
 * - 0b1 - Master logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_RST field. */
#define LPSPI_RD_CR_RST(base) ((LPSPI_CR_REG(base) & LPSPI_CR_RST_MASK) >> LPSPI_CR_RST_SHIFT)
#define LPSPI_BRD_CR_RST(base) (BME_UBFX32(&LPSPI_CR_REG(base), LPSPI_CR_RST_SHIFT, LPSPI_CR_RST_WIDTH))

/*! @brief Set the RST field to a new value. */
#define LPSPI_WR_CR_RST(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_RST_MASK, LPSPI_CR_RST(value)))
#define LPSPI_BWR_CR_RST(base, value) (BME_BFI32(&LPSPI_CR_REG(base), ((uint32_t)(value) << LPSPI_CR_RST_SHIFT), LPSPI_CR_RST_SHIFT, LPSPI_CR_RST_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CR, field DOZEN[2] (RW)
 *
 * Enables or disables Doze mode
 *
 * Values:
 * - 0b0 - Module is enabled in Doze mode.
 * - 0b1 - Module is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_DOZEN field. */
#define LPSPI_RD_CR_DOZEN(base) ((LPSPI_CR_REG(base) & LPSPI_CR_DOZEN_MASK) >> LPSPI_CR_DOZEN_SHIFT)
#define LPSPI_BRD_CR_DOZEN(base) (BME_UBFX32(&LPSPI_CR_REG(base), LPSPI_CR_DOZEN_SHIFT, LPSPI_CR_DOZEN_WIDTH))

/*! @brief Set the DOZEN field to a new value. */
#define LPSPI_WR_CR_DOZEN(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_DOZEN_MASK, LPSPI_CR_DOZEN(value)))
#define LPSPI_BWR_CR_DOZEN(base, value) (BME_BFI32(&LPSPI_CR_REG(base), ((uint32_t)(value) << LPSPI_CR_DOZEN_SHIFT), LPSPI_CR_DOZEN_SHIFT, LPSPI_CR_DOZEN_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CR, field DBGEN[3] (RW)
 *
 * Values:
 * - 0b0 - Module is disabled in debug mode.
 * - 0b1 - Module is enabled in debug mode.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CR_DBGEN field. */
#define LPSPI_RD_CR_DBGEN(base) ((LPSPI_CR_REG(base) & LPSPI_CR_DBGEN_MASK) >> LPSPI_CR_DBGEN_SHIFT)
#define LPSPI_BRD_CR_DBGEN(base) (BME_UBFX32(&LPSPI_CR_REG(base), LPSPI_CR_DBGEN_SHIFT, LPSPI_CR_DBGEN_WIDTH))

/*! @brief Set the DBGEN field to a new value. */
#define LPSPI_WR_CR_DBGEN(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_DBGEN_MASK, LPSPI_CR_DBGEN(value)))
#define LPSPI_BWR_CR_DBGEN(base, value) (BME_BFI32(&LPSPI_CR_REG(base), ((uint32_t)(value) << LPSPI_CR_DBGEN_SHIFT), LPSPI_CR_DBGEN_SHIFT, LPSPI_CR_DBGEN_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CR, field RTF[8] (WO)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Transmit FIFO is reset.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPSPI_WR_CR_RTF(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_RTF_MASK, LPSPI_CR_RTF(value)))
#define LPSPI_BWR_CR_RTF(base, value) (LPSPI_WR_CR_RTF(base, value))
/*@}*/

/*!
 * @name Register LPSPI_CR, field RRF[9] (WO)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Receive FIFO is reset.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPSPI_WR_CR_RRF(base, value) (LPSPI_RMW_CR(base, LPSPI_CR_RRF_MASK, LPSPI_CR_RRF(value)))
#define LPSPI_BWR_CR_RRF(base, value) (LPSPI_WR_CR_RRF(base, value))
/*@}*/

/*******************************************************************************
 * LPSPI_SR - Status Register
 ******************************************************************************/

/*!
 * @brief LPSPI_SR - Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire LPSPI_SR register
 */
/*@{*/
#define LPSPI_RD_SR(base)        (LPSPI_SR_REG(base))
#define LPSPI_WR_SR(base, value) (LPSPI_SR_REG(base) = (value))
#define LPSPI_RMW_SR(base, mask, value) (LPSPI_WR_SR(base, (LPSPI_RD_SR(base) & ~(mask)) | (value)))
#define LPSPI_SET_SR(base, value) (BME_OR32(&LPSPI_SR_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_SR(base, value) (BME_AND32(&LPSPI_SR_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_SR(base, value) (BME_XOR32(&LPSPI_SR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_SR bitfields
 */

/*!
 * @name Register LPSPI_SR, field TDF[0] (RO)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER.
 *
 * Values:
 * - 0b0 - Transmit data not requested.
 * - 0b1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_TDF field. */
#define LPSPI_RD_SR_TDF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_TDF_MASK) >> LPSPI_SR_TDF_SHIFT)
#define LPSPI_BRD_SR_TDF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_TDF_SHIFT, LPSPI_SR_TDF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field RDF[1] (RO)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER.
 *
 * Values:
 * - 0b0 - Receive Data is not ready.
 * - 0b1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_RDF field. */
#define LPSPI_RD_SR_RDF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_RDF_MASK) >> LPSPI_SR_RDF_SHIFT)
#define LPSPI_BRD_SR_RDF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_RDF_SHIFT, LPSPI_SR_RDF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field WCF[8] (W1C)
 *
 * This flag will set when the last bit of a received word is sampled.
 *
 * Values:
 * - 0b0 - Transfer word not completed.
 * - 0b1 - Transfer word completed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_WCF field. */
#define LPSPI_RD_SR_WCF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_WCF_MASK) >> LPSPI_SR_WCF_SHIFT)
#define LPSPI_BRD_SR_WCF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_WCF_SHIFT, LPSPI_SR_WCF_WIDTH))

/*! @brief Set the WCF field to a new value. */
#define LPSPI_WR_SR_WCF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_WCF(value)))
#define LPSPI_BWR_SR_WCF(base, value) (BME_BFI32(&LPSPI_SR_REG(base), ((uint32_t)(value) << LPSPI_SR_WCF_SHIFT), LPSPI_SR_WCF_SHIFT, LPSPI_SR_WCF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field FCF[9] (W1C)
 *
 * This flag will set at the end of each frame transfer, when the PCS negates.
 *
 * Values:
 * - 0b0 - Frame transfer has not completed.
 * - 0b1 - Frame transfer has completed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_FCF field. */
#define LPSPI_RD_SR_FCF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_FCF_MASK) >> LPSPI_SR_FCF_SHIFT)
#define LPSPI_BRD_SR_FCF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_FCF_SHIFT, LPSPI_SR_FCF_WIDTH))

/*! @brief Set the FCF field to a new value. */
#define LPSPI_WR_SR_FCF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_FCF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_FCF(value)))
#define LPSPI_BWR_SR_FCF(base, value) (BME_BFI32(&LPSPI_SR_REG(base), ((uint32_t)(value) << LPSPI_SR_FCF_SHIFT), LPSPI_SR_FCF_SHIFT, LPSPI_SR_FCF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field TCF[10] (W1C)
 *
 * This flag will set in master mode when the LPSPI returns to idle state with
 * the transmit FIFO empty.
 *
 * Values:
 * - 0b0 - All transfers have not completed.
 * - 0b1 - All transfers have completed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_TCF field. */
#define LPSPI_RD_SR_TCF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_TCF_MASK) >> LPSPI_SR_TCF_SHIFT)
#define LPSPI_BRD_SR_TCF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_TCF_SHIFT, LPSPI_SR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define LPSPI_WR_SR_TCF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_TCF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_TCF(value)))
#define LPSPI_BWR_SR_TCF(base, value) (BME_BFI32(&LPSPI_SR_REG(base), ((uint32_t)(value) << LPSPI_SR_TCF_SHIFT), LPSPI_SR_TCF_SHIFT, LPSPI_SR_TCF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field TEF[11] (W1C)
 *
 * This flag will set when the Transmit FIFO underruns.
 *
 * Values:
 * - 0b0 - Transmit FIFO underrun has not occurred.
 * - 0b1 - Transmit FIFO underrun has occurred
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_TEF field. */
#define LPSPI_RD_SR_TEF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_TEF_MASK) >> LPSPI_SR_TEF_SHIFT)
#define LPSPI_BRD_SR_TEF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_TEF_SHIFT, LPSPI_SR_TEF_WIDTH))

/*! @brief Set the TEF field to a new value. */
#define LPSPI_WR_SR_TEF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_TEF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_REF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_TEF(value)))
#define LPSPI_BWR_SR_TEF(base, value) (BME_BFI32(&LPSPI_SR_REG(base), ((uint32_t)(value) << LPSPI_SR_TEF_SHIFT), LPSPI_SR_TEF_SHIFT, LPSPI_SR_TEF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field REF[12] (W1C)
 *
 * This flag will set when the Receiver FIFO overflows.
 *
 * Values:
 * - 0b0 - Receive FIFO has not overflowed.
 * - 0b1 - Receive FIFO has overflowed.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_REF field. */
#define LPSPI_RD_SR_REF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_REF_MASK) >> LPSPI_SR_REF_SHIFT)
#define LPSPI_BRD_SR_REF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_REF_SHIFT, LPSPI_SR_REF_WIDTH))

/*! @brief Set the REF field to a new value. */
#define LPSPI_WR_SR_REF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_REF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_DMF_MASK), LPSPI_SR_REF(value)))
#define LPSPI_BWR_SR_REF(base, value) (BME_BFI32(&LPSPI_SR_REG(base), ((uint32_t)(value) << LPSPI_SR_REF_SHIFT), LPSPI_SR_REF_SHIFT, LPSPI_SR_REF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field DMF[13] (W1C)
 *
 * Indicates that the received data has matched the MATCH0 and/or MATCH1 fields
 * as configured by MATCFG.
 *
 * Values:
 * - 0b0 - Have not received matching data.
 * - 0b1 - Have received matching data.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_DMF field. */
#define LPSPI_RD_SR_DMF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_DMF_MASK) >> LPSPI_SR_DMF_SHIFT)
#define LPSPI_BRD_SR_DMF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_DMF_SHIFT, LPSPI_SR_DMF_WIDTH))

/*! @brief Set the DMF field to a new value. */
#define LPSPI_WR_SR_DMF(base, value) (LPSPI_RMW_SR(base, (LPSPI_SR_DMF_MASK | LPSPI_SR_WCF_MASK | LPSPI_SR_FCF_MASK | LPSPI_SR_TCF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK), LPSPI_SR_DMF(value)))
#define LPSPI_BWR_SR_DMF(base, value) (BME_BFI32(&LPSPI_SR_REG(base), ((uint32_t)(value) << LPSPI_SR_DMF_SHIFT), LPSPI_SR_DMF_SHIFT, LPSPI_SR_DMF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_SR, field MBF[24] (RO)
 *
 * Values:
 * - 0b0 - LPSPI is idle.
 * - 0b1 - LPSPI is busy.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_SR_MBF field. */
#define LPSPI_RD_SR_MBF(base) ((LPSPI_SR_REG(base) & LPSPI_SR_MBF_MASK) >> LPSPI_SR_MBF_SHIFT)
#define LPSPI_BRD_SR_MBF(base) (BME_UBFX32(&LPSPI_SR_REG(base), LPSPI_SR_MBF_SHIFT, LPSPI_SR_MBF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_IER - Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPSPI_IER - Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_IER register
 */
/*@{*/
#define LPSPI_RD_IER(base)       (LPSPI_IER_REG(base))
#define LPSPI_WR_IER(base, value) (LPSPI_IER_REG(base) = (value))
#define LPSPI_RMW_IER(base, mask, value) (LPSPI_WR_IER(base, (LPSPI_RD_IER(base) & ~(mask)) | (value)))
#define LPSPI_SET_IER(base, value) (BME_OR32(&LPSPI_IER_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_IER(base, value) (BME_AND32(&LPSPI_IER_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_IER(base, value) (BME_XOR32(&LPSPI_IER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_IER bitfields
 */

/*!
 * @name Register LPSPI_IER, field TDIE[0] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_TDIE field. */
#define LPSPI_RD_IER_TDIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_TDIE_MASK) >> LPSPI_IER_TDIE_SHIFT)
#define LPSPI_BRD_IER_TDIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_TDIE_SHIFT, LPSPI_IER_TDIE_WIDTH))

/*! @brief Set the TDIE field to a new value. */
#define LPSPI_WR_IER_TDIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_TDIE_MASK, LPSPI_IER_TDIE(value)))
#define LPSPI_BWR_IER_TDIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_TDIE_SHIFT), LPSPI_IER_TDIE_SHIFT, LPSPI_IER_TDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_IER, field RDIE[1] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_RDIE field. */
#define LPSPI_RD_IER_RDIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_RDIE_MASK) >> LPSPI_IER_RDIE_SHIFT)
#define LPSPI_BRD_IER_RDIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_RDIE_SHIFT, LPSPI_IER_RDIE_WIDTH))

/*! @brief Set the RDIE field to a new value. */
#define LPSPI_WR_IER_RDIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_RDIE_MASK, LPSPI_IER_RDIE(value)))
#define LPSPI_BWR_IER_RDIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_RDIE_SHIFT), LPSPI_IER_RDIE_SHIFT, LPSPI_IER_RDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_IER, field WCIE[8] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_WCIE field. */
#define LPSPI_RD_IER_WCIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_WCIE_MASK) >> LPSPI_IER_WCIE_SHIFT)
#define LPSPI_BRD_IER_WCIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_WCIE_SHIFT, LPSPI_IER_WCIE_WIDTH))

/*! @brief Set the WCIE field to a new value. */
#define LPSPI_WR_IER_WCIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_WCIE_MASK, LPSPI_IER_WCIE(value)))
#define LPSPI_BWR_IER_WCIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_WCIE_SHIFT), LPSPI_IER_WCIE_SHIFT, LPSPI_IER_WCIE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_IER, field FCIE[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_FCIE field. */
#define LPSPI_RD_IER_FCIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_FCIE_MASK) >> LPSPI_IER_FCIE_SHIFT)
#define LPSPI_BRD_IER_FCIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_FCIE_SHIFT, LPSPI_IER_FCIE_WIDTH))

/*! @brief Set the FCIE field to a new value. */
#define LPSPI_WR_IER_FCIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_FCIE_MASK, LPSPI_IER_FCIE(value)))
#define LPSPI_BWR_IER_FCIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_FCIE_SHIFT), LPSPI_IER_FCIE_SHIFT, LPSPI_IER_FCIE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_IER, field TCIE[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_TCIE field. */
#define LPSPI_RD_IER_TCIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_TCIE_MASK) >> LPSPI_IER_TCIE_SHIFT)
#define LPSPI_BRD_IER_TCIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_TCIE_SHIFT, LPSPI_IER_TCIE_WIDTH))

/*! @brief Set the TCIE field to a new value. */
#define LPSPI_WR_IER_TCIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_TCIE_MASK, LPSPI_IER_TCIE(value)))
#define LPSPI_BWR_IER_TCIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_TCIE_SHIFT), LPSPI_IER_TCIE_SHIFT, LPSPI_IER_TCIE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_IER, field TEIE[11] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_TEIE field. */
#define LPSPI_RD_IER_TEIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_TEIE_MASK) >> LPSPI_IER_TEIE_SHIFT)
#define LPSPI_BRD_IER_TEIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_TEIE_SHIFT, LPSPI_IER_TEIE_WIDTH))

/*! @brief Set the TEIE field to a new value. */
#define LPSPI_WR_IER_TEIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_TEIE_MASK, LPSPI_IER_TEIE(value)))
#define LPSPI_BWR_IER_TEIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_TEIE_SHIFT), LPSPI_IER_TEIE_SHIFT, LPSPI_IER_TEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_IER, field REIE[12] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_REIE field. */
#define LPSPI_RD_IER_REIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_REIE_MASK) >> LPSPI_IER_REIE_SHIFT)
#define LPSPI_BRD_IER_REIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_REIE_SHIFT, LPSPI_IER_REIE_WIDTH))

/*! @brief Set the REIE field to a new value. */
#define LPSPI_WR_IER_REIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_REIE_MASK, LPSPI_IER_REIE(value)))
#define LPSPI_BWR_IER_REIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_REIE_SHIFT), LPSPI_IER_REIE_SHIFT, LPSPI_IER_REIE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_IER, field DMIE[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_IER_DMIE field. */
#define LPSPI_RD_IER_DMIE(base) ((LPSPI_IER_REG(base) & LPSPI_IER_DMIE_MASK) >> LPSPI_IER_DMIE_SHIFT)
#define LPSPI_BRD_IER_DMIE(base) (BME_UBFX32(&LPSPI_IER_REG(base), LPSPI_IER_DMIE_SHIFT, LPSPI_IER_DMIE_WIDTH))

/*! @brief Set the DMIE field to a new value. */
#define LPSPI_WR_IER_DMIE(base, value) (LPSPI_RMW_IER(base, LPSPI_IER_DMIE_MASK, LPSPI_IER_DMIE(value)))
#define LPSPI_BWR_IER_DMIE(base, value) (BME_BFI32(&LPSPI_IER_REG(base), ((uint32_t)(value) << LPSPI_IER_DMIE_SHIFT), LPSPI_IER_DMIE_SHIFT, LPSPI_IER_DMIE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_DER - DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPSPI_DER - DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_DER register
 */
/*@{*/
#define LPSPI_RD_DER(base)       (LPSPI_DER_REG(base))
#define LPSPI_WR_DER(base, value) (LPSPI_DER_REG(base) = (value))
#define LPSPI_RMW_DER(base, mask, value) (LPSPI_WR_DER(base, (LPSPI_RD_DER(base) & ~(mask)) | (value)))
#define LPSPI_SET_DER(base, value) (BME_OR32(&LPSPI_DER_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_DER(base, value) (BME_AND32(&LPSPI_DER_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_DER(base, value) (BME_XOR32(&LPSPI_DER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_DER bitfields
 */

/*!
 * @name Register LPSPI_DER, field TDDE[0] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPSPI_DER_TDDE field. */
#define LPSPI_RD_DER_TDDE(base) ((LPSPI_DER_REG(base) & LPSPI_DER_TDDE_MASK) >> LPSPI_DER_TDDE_SHIFT)
#define LPSPI_BRD_DER_TDDE(base) (BME_UBFX32(&LPSPI_DER_REG(base), LPSPI_DER_TDDE_SHIFT, LPSPI_DER_TDDE_WIDTH))

/*! @brief Set the TDDE field to a new value. */
#define LPSPI_WR_DER_TDDE(base, value) (LPSPI_RMW_DER(base, LPSPI_DER_TDDE_MASK, LPSPI_DER_TDDE(value)))
#define LPSPI_BWR_DER_TDDE(base, value) (BME_BFI32(&LPSPI_DER_REG(base), ((uint32_t)(value) << LPSPI_DER_TDDE_SHIFT), LPSPI_DER_TDDE_SHIFT, LPSPI_DER_TDDE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_DER, field RDDE[1] (RW)
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_DER_RDDE field. */
#define LPSPI_RD_DER_RDDE(base) ((LPSPI_DER_REG(base) & LPSPI_DER_RDDE_MASK) >> LPSPI_DER_RDDE_SHIFT)
#define LPSPI_BRD_DER_RDDE(base) (BME_UBFX32(&LPSPI_DER_REG(base), LPSPI_DER_RDDE_SHIFT, LPSPI_DER_RDDE_WIDTH))

/*! @brief Set the RDDE field to a new value. */
#define LPSPI_WR_DER_RDDE(base, value) (LPSPI_RMW_DER(base, LPSPI_DER_RDDE_MASK, LPSPI_DER_RDDE(value)))
#define LPSPI_BWR_DER_RDDE(base, value) (BME_BFI32(&LPSPI_DER_REG(base), ((uint32_t)(value) << LPSPI_DER_RDDE_SHIFT), LPSPI_DER_RDDE_SHIFT, LPSPI_DER_RDDE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_CFGR0 - Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPSPI_CFGR0 - Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_CFGR0 register
 */
/*@{*/
#define LPSPI_RD_CFGR0(base)     (LPSPI_CFGR0_REG(base))
#define LPSPI_WR_CFGR0(base, value) (LPSPI_CFGR0_REG(base) = (value))
#define LPSPI_RMW_CFGR0(base, mask, value) (LPSPI_WR_CFGR0(base, (LPSPI_RD_CFGR0(base) & ~(mask)) | (value)))
#define LPSPI_SET_CFGR0(base, value) (BME_OR32(&LPSPI_CFGR0_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_CFGR0(base, value) (BME_AND32(&LPSPI_CFGR0_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_CFGR0(base, value) (BME_XOR32(&LPSPI_CFGR0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CFGR0 bitfields
 */

/*!
 * @name Register LPSPI_CFGR0, field HREN[0] (RW)
 *
 * When enabled in master mode, the LPSPI will only initiate a SPI bus transfer
 * if the host request input is asserted.
 *
 * Values:
 * - 0b0 - Host request is disabled.
 * - 0b1 - Host request is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_HREN field. */
#define LPSPI_RD_CFGR0_HREN(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_HREN_MASK) >> LPSPI_CFGR0_HREN_SHIFT)
#define LPSPI_BRD_CFGR0_HREN(base) (BME_UBFX32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HREN_SHIFT, LPSPI_CFGR0_HREN_WIDTH))

/*! @brief Set the HREN field to a new value. */
#define LPSPI_WR_CFGR0_HREN(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_HREN_MASK, LPSPI_CFGR0_HREN(value)))
#define LPSPI_BWR_CFGR0_HREN(base, value) (BME_BFI32(&LPSPI_CFGR0_REG(base), ((uint32_t)(value) << LPSPI_CFGR0_HREN_SHIFT), LPSPI_CFGR0_HREN_SHIFT, LPSPI_CFGR0_HREN_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field HRPOL[1] (RW)
 *
 * Configures the polarity of the host request pin.
 *
 * Values:
 * - 0b0 - Active low.
 * - 0b1 - Active high.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_HRPOL field. */
#define LPSPI_RD_CFGR0_HRPOL(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_HRPOL_MASK) >> LPSPI_CFGR0_HRPOL_SHIFT)
#define LPSPI_BRD_CFGR0_HRPOL(base) (BME_UBFX32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HRPOL_SHIFT, LPSPI_CFGR0_HRPOL_WIDTH))

/*! @brief Set the HRPOL field to a new value. */
#define LPSPI_WR_CFGR0_HRPOL(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_HRPOL_MASK, LPSPI_CFGR0_HRPOL(value)))
#define LPSPI_BWR_CFGR0_HRPOL(base, value) (BME_BFI32(&LPSPI_CFGR0_REG(base), ((uint32_t)(value) << LPSPI_CFGR0_HRPOL_SHIFT), LPSPI_CFGR0_HRPOL_SHIFT, LPSPI_CFGR0_HRPOL_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field HRSEL[2] (RW)
 *
 * Selects the source of the host request input. When the host request function
 * is enabled with the LPSPI_HREQ pin, the LPSPI_PCS[1] function is disabled.
 *
 * Values:
 * - 0b0 - Host request input is pin LPSPI_HREQ.
 * - 0b1 - Host request input is input trigger.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_HRSEL field. */
#define LPSPI_RD_CFGR0_HRSEL(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_HRSEL_MASK) >> LPSPI_CFGR0_HRSEL_SHIFT)
#define LPSPI_BRD_CFGR0_HRSEL(base) (BME_UBFX32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_HRSEL_SHIFT, LPSPI_CFGR0_HRSEL_WIDTH))

/*! @brief Set the HRSEL field to a new value. */
#define LPSPI_WR_CFGR0_HRSEL(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_HRSEL_MASK, LPSPI_CFGR0_HRSEL(value)))
#define LPSPI_BWR_CFGR0_HRSEL(base, value) (BME_BFI32(&LPSPI_CFGR0_REG(base), ((uint32_t)(value) << LPSPI_CFGR0_HRSEL_SHIFT), LPSPI_CFGR0_HRSEL_SHIFT, LPSPI_CFGR0_HRSEL_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field CIRFIFO[8] (RW)
 *
 * When enabled, the transmit FIFO read pointer is saved to a temporary
 * register. The transmit FIFO will be emptied as normal, but once the LPSPI is idle and
 * the transmit FIFO is empty, then the read pointer value will be restored from
 * the temporary register. This will cause the contents of the transmit FIFO to
 * be cycled through repeatedly.
 *
 * Values:
 * - 0b0 - Circular FIFO is disabled.
 * - 0b1 - Circular FIFO is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_CIRFIFO field. */
#define LPSPI_RD_CFGR0_CIRFIFO(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_CIRFIFO_MASK) >> LPSPI_CFGR0_CIRFIFO_SHIFT)
#define LPSPI_BRD_CFGR0_CIRFIFO(base) (BME_UBFX32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_CIRFIFO_SHIFT, LPSPI_CFGR0_CIRFIFO_WIDTH))

/*! @brief Set the CIRFIFO field to a new value. */
#define LPSPI_WR_CFGR0_CIRFIFO(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_CIRFIFO_MASK, LPSPI_CFGR0_CIRFIFO(value)))
#define LPSPI_BWR_CFGR0_CIRFIFO(base, value) (BME_BFI32(&LPSPI_CFGR0_REG(base), ((uint32_t)(value) << LPSPI_CFGR0_CIRFIFO_SHIFT), LPSPI_CFGR0_CIRFIFO_SHIFT, LPSPI_CFGR0_CIRFIFO_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR0, field RDMO[9] (RW)
 *
 * When enabled, all received data that does not cause DMF to set is discarded.
 * Once DMF is set, the RDMO configuration is ignored. When disabling RDMO, clear
 * RDMO before clearing DMF to ensure no receive data is lost.
 *
 * Values:
 * - 0b0 - Received data is stored in the receive FIFO as normal.
 * - 0b1 - Received data is discarded unless the DMF is set.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR0_RDMO field. */
#define LPSPI_RD_CFGR0_RDMO(base) ((LPSPI_CFGR0_REG(base) & LPSPI_CFGR0_RDMO_MASK) >> LPSPI_CFGR0_RDMO_SHIFT)
#define LPSPI_BRD_CFGR0_RDMO(base) (BME_UBFX32(&LPSPI_CFGR0_REG(base), LPSPI_CFGR0_RDMO_SHIFT, LPSPI_CFGR0_RDMO_WIDTH))

/*! @brief Set the RDMO field to a new value. */
#define LPSPI_WR_CFGR0_RDMO(base, value) (LPSPI_RMW_CFGR0(base, LPSPI_CFGR0_RDMO_MASK, LPSPI_CFGR0_RDMO(value)))
#define LPSPI_BWR_CFGR0_RDMO(base, value) (BME_BFI32(&LPSPI_CFGR0_REG(base), ((uint32_t)(value) << LPSPI_CFGR0_RDMO_SHIFT), LPSPI_CFGR0_RDMO_SHIFT, LPSPI_CFGR0_RDMO_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_CFGR1 - Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPSPI_CFGR1 - Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CFGR1 should only be written when the LPSPI is disabled.
 */
/*!
 * @name Constants and macros for entire LPSPI_CFGR1 register
 */
/*@{*/
#define LPSPI_RD_CFGR1(base)     (LPSPI_CFGR1_REG(base))
#define LPSPI_WR_CFGR1(base, value) (LPSPI_CFGR1_REG(base) = (value))
#define LPSPI_RMW_CFGR1(base, mask, value) (LPSPI_WR_CFGR1(base, (LPSPI_RD_CFGR1(base) & ~(mask)) | (value)))
#define LPSPI_SET_CFGR1(base, value) (BME_OR32(&LPSPI_CFGR1_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_CFGR1(base, value) (BME_AND32(&LPSPI_CFGR1_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_CFGR1(base, value) (BME_XOR32(&LPSPI_CFGR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CFGR1 bitfields
 */

/*!
 * @name Register LPSPI_CFGR1, field MASTER[0] (RW)
 *
 * Configures the LPSPI in master or slave mode. This bit directly controls the
 * direction of the LPSPI_SCK and LPCPI_PCS pins.
 *
 * Values:
 * - 0b0 - Slave mode.
 * - 0b1 - Master mode.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_MASTER field. */
#define LPSPI_RD_CFGR1_MASTER(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_MASTER_MASK) >> LPSPI_CFGR1_MASTER_SHIFT)
#define LPSPI_BRD_CFGR1_MASTER(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_MASTER_SHIFT, LPSPI_CFGR1_MASTER_WIDTH))

/*! @brief Set the MASTER field to a new value. */
#define LPSPI_WR_CFGR1_MASTER(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_MASTER_MASK, LPSPI_CFGR1_MASTER(value)))
#define LPSPI_BWR_CFGR1_MASTER(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_MASTER_SHIFT), LPSPI_CFGR1_MASTER_SHIFT, LPSPI_CFGR1_MASTER_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field SAMPLE[1] (RW)
 *
 * When set, the LPSPI master will sample the input data on a delayed LPSPI_SCK
 * edge. This improves the setup time when sampling data. The input data setup
 * time in master mode with delayed LPSPI_SCK edge is equal to the input data setup
 * time in slave mode. This bit is ignored in slave mode.
 *
 * Values:
 * - 0b0 - Input data sampled on SCK edge.
 * - 0b1 - Input data sampled on delayed SCK edge.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_SAMPLE field. */
#define LPSPI_RD_CFGR1_SAMPLE(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_SAMPLE_MASK) >> LPSPI_CFGR1_SAMPLE_SHIFT)
#define LPSPI_BRD_CFGR1_SAMPLE(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_SAMPLE_SHIFT, LPSPI_CFGR1_SAMPLE_WIDTH))

/*! @brief Set the SAMPLE field to a new value. */
#define LPSPI_WR_CFGR1_SAMPLE(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_SAMPLE_MASK, LPSPI_CFGR1_SAMPLE(value)))
#define LPSPI_BWR_CFGR1_SAMPLE(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_SAMPLE_SHIFT), LPSPI_CFGR1_SAMPLE_SHIFT, LPSPI_CFGR1_SAMPLE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field AUTOPCS[2] (RW)
 *
 * The LPSPI slave normally requires the PCS to negate between frames for
 * correct operation. Setting this bit will cause the LPSPI to generate an internal PCS
 * signal at the end of each transfer word when CPHA=1. When this bit is set,
 * the SCK must remain idle for at least 4 LPSPI functional clock cycles (divided
 * by PRESCALE configuration) between each word to ensure correct operation. This
 * bit is ignored in master mode.
 *
 * Values:
 * - 0b0 - Automatic PCS generation disabled.
 * - 0b1 - Automatic PCS generation enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_AUTOPCS field. */
#define LPSPI_RD_CFGR1_AUTOPCS(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_AUTOPCS_MASK) >> LPSPI_CFGR1_AUTOPCS_SHIFT)
#define LPSPI_BRD_CFGR1_AUTOPCS(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_AUTOPCS_SHIFT, LPSPI_CFGR1_AUTOPCS_WIDTH))

/*! @brief Set the AUTOPCS field to a new value. */
#define LPSPI_WR_CFGR1_AUTOPCS(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_AUTOPCS_MASK, LPSPI_CFGR1_AUTOPCS(value)))
#define LPSPI_BWR_CFGR1_AUTOPCS(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_AUTOPCS_SHIFT), LPSPI_CFGR1_AUTOPCS_SHIFT, LPSPI_CFGR1_AUTOPCS_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field NOSTALL[3] (RW)
 *
 * In master mode, the LPSPI will stall transfers when the transmit FIFO is
 * empty or receive FIFO is full ensuring that no transmit FIFO underrun or receive
 * FIFO overrun can occur. Setting this bit will disable this functionality.
 *
 * Values:
 * - 0b0 - Transfers will stall when transmit FIFO is empty or receive FIFO is
 *     full.
 * - 0b1 - Transfers will not stall, allowing transmit FIFO underrun or receive
 *     FIFO overrun to occur.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_NOSTALL field. */
#define LPSPI_RD_CFGR1_NOSTALL(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_NOSTALL_MASK) >> LPSPI_CFGR1_NOSTALL_SHIFT)
#define LPSPI_BRD_CFGR1_NOSTALL(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_NOSTALL_SHIFT, LPSPI_CFGR1_NOSTALL_WIDTH))

/*! @brief Set the NOSTALL field to a new value. */
#define LPSPI_WR_CFGR1_NOSTALL(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_NOSTALL_MASK, LPSPI_CFGR1_NOSTALL(value)))
#define LPSPI_BWR_CFGR1_NOSTALL(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_NOSTALL_SHIFT), LPSPI_CFGR1_NOSTALL_SHIFT, LPSPI_CFGR1_NOSTALL_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field PCSPOL[11:8] (RW)
 *
 * Configures the polarity of each Peripheral Chip Select pin.
 *
 * Values:
 * - 0b0000 - The PCSx is active low.
 * - 0b0001 - The PCSx is active high.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_PCSPOL field. */
#define LPSPI_RD_CFGR1_PCSPOL(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_PCSPOL_MASK) >> LPSPI_CFGR1_PCSPOL_SHIFT)
#define LPSPI_BRD_CFGR1_PCSPOL(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_PCSPOL_SHIFT, LPSPI_CFGR1_PCSPOL_WIDTH))

/*! @brief Set the PCSPOL field to a new value. */
#define LPSPI_WR_CFGR1_PCSPOL(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_PCSPOL_MASK, LPSPI_CFGR1_PCSPOL(value)))
#define LPSPI_BWR_CFGR1_PCSPOL(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_PCSPOL_SHIFT), LPSPI_CFGR1_PCSPOL_SHIFT, LPSPI_CFGR1_PCSPOL_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field MATCFG[18:16] (RW)
 *
 * Configures the condition that will cause the DMF to set.
 *
 * Values:
 * - 0b000 - Match disabled.
 * - 0b001 - Reserved
 * - 0b010 - Match enabled (1st data word equals MATCH0 OR MATCH1).
 * - 0b011 - Match enabled (any data word equals MATCH0 OR MATCH1).
 * - 0b100 - Match enabled (1st data word equals MATCH0 AND 2nd data word equals
 *     MATCH1).
 * - 0b101 - Match enabled (any data word equals MATCH0 AND next data word
 *     equals MATCH1)
 * - 0b110 - Match enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1)
 * - 0b111 - Match enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1).
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_MATCFG field. */
#define LPSPI_RD_CFGR1_MATCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_MATCFG_MASK) >> LPSPI_CFGR1_MATCFG_SHIFT)
#define LPSPI_BRD_CFGR1_MATCFG(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_MATCFG_SHIFT, LPSPI_CFGR1_MATCFG_WIDTH))

/*! @brief Set the MATCFG field to a new value. */
#define LPSPI_WR_CFGR1_MATCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_MATCFG_MASK, LPSPI_CFGR1_MATCFG(value)))
#define LPSPI_BWR_CFGR1_MATCFG(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_MATCFG_SHIFT), LPSPI_CFGR1_MATCFG_SHIFT, LPSPI_CFGR1_MATCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field PINCFG[25:24] (RW)
 *
 * Configures which pins are used for input and output data during single bit
 * transfers.
 *
 * Values:
 * - 0b00 - SIN is used for input data and SOUT for output data.
 * - 0b01 - SOUT is used for both input and output data.
 * - 0b10 - SDI is used for both input and output data.
 * - 0b11 - SOUT is used for input data and SIN for output data.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_PINCFG field. */
#define LPSPI_RD_CFGR1_PINCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_PINCFG_MASK) >> LPSPI_CFGR1_PINCFG_SHIFT)
#define LPSPI_BRD_CFGR1_PINCFG(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_PINCFG_SHIFT, LPSPI_CFGR1_PINCFG_WIDTH))

/*! @brief Set the PINCFG field to a new value. */
#define LPSPI_WR_CFGR1_PINCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_PINCFG_MASK, LPSPI_CFGR1_PINCFG(value)))
#define LPSPI_BWR_CFGR1_PINCFG(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_PINCFG_SHIFT), LPSPI_CFGR1_PINCFG_SHIFT, LPSPI_CFGR1_PINCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field OUTCFG[26] (RW)
 *
 * Configures if the output data is tristated between accesses (LPSPI_PCS is
 * negated).
 *
 * Values:
 * - 0b0 - Output data retains last value when chip select is negated.
 * - 0b1 - Output data is tristated when chip select is negated.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_OUTCFG field. */
#define LPSPI_RD_CFGR1_OUTCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_OUTCFG_MASK) >> LPSPI_CFGR1_OUTCFG_SHIFT)
#define LPSPI_BRD_CFGR1_OUTCFG(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_OUTCFG_SHIFT, LPSPI_CFGR1_OUTCFG_WIDTH))

/*! @brief Set the OUTCFG field to a new value. */
#define LPSPI_WR_CFGR1_OUTCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_OUTCFG_MASK, LPSPI_CFGR1_OUTCFG(value)))
#define LPSPI_BWR_CFGR1_OUTCFG(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_OUTCFG_SHIFT), LPSPI_CFGR1_OUTCFG_SHIFT, LPSPI_CFGR1_OUTCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CFGR1, field PCSCFG[27] (RW)
 *
 * PCSCFG must be set if performing 4-bit transfers.
 *
 * Values:
 * - 0b0 - PCS[3:2] are enabled.
 * - 0b1 - PCS[3:2] are disabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CFGR1_PCSCFG field. */
#define LPSPI_RD_CFGR1_PCSCFG(base) ((LPSPI_CFGR1_REG(base) & LPSPI_CFGR1_PCSCFG_MASK) >> LPSPI_CFGR1_PCSCFG_SHIFT)
#define LPSPI_BRD_CFGR1_PCSCFG(base) (BME_UBFX32(&LPSPI_CFGR1_REG(base), LPSPI_CFGR1_PCSCFG_SHIFT, LPSPI_CFGR1_PCSCFG_WIDTH))

/*! @brief Set the PCSCFG field to a new value. */
#define LPSPI_WR_CFGR1_PCSCFG(base, value) (LPSPI_RMW_CFGR1(base, LPSPI_CFGR1_PCSCFG_MASK, LPSPI_CFGR1_PCSCFG(value)))
#define LPSPI_BWR_CFGR1_PCSCFG(base, value) (BME_BFI32(&LPSPI_CFGR1_REG(base), ((uint32_t)(value) << LPSPI_CFGR1_PCSCFG_SHIFT), LPSPI_CFGR1_PCSCFG_SHIFT, LPSPI_CFGR1_PCSCFG_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_DMR0 - Data Match Register 0
 ******************************************************************************/

/*!
 * @brief LPSPI_DMR0 - Data Match Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_DMR0 register
 */
/*@{*/
#define LPSPI_RD_DMR0(base)      (LPSPI_DMR0_REG(base))
#define LPSPI_WR_DMR0(base, value) (LPSPI_DMR0_REG(base) = (value))
#define LPSPI_RMW_DMR0(base, mask, value) (LPSPI_WR_DMR0(base, (LPSPI_RD_DMR0(base) & ~(mask)) | (value)))
#define LPSPI_SET_DMR0(base, value) (BME_OR32(&LPSPI_DMR0_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_DMR0(base, value) (BME_AND32(&LPSPI_DMR0_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_DMR0(base, value) (BME_XOR32(&LPSPI_DMR0_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LPSPI_DMR1 - Data Match Register 1
 ******************************************************************************/

/*!
 * @brief LPSPI_DMR1 - Data Match Register 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_DMR1 register
 */
/*@{*/
#define LPSPI_RD_DMR1(base)      (LPSPI_DMR1_REG(base))
#define LPSPI_WR_DMR1(base, value) (LPSPI_DMR1_REG(base) = (value))
#define LPSPI_RMW_DMR1(base, mask, value) (LPSPI_WR_DMR1(base, (LPSPI_RD_DMR1(base) & ~(mask)) | (value)))
#define LPSPI_SET_DMR1(base, value) (BME_OR32(&LPSPI_DMR1_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_DMR1(base, value) (BME_AND32(&LPSPI_DMR1_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_DMR1(base, value) (BME_XOR32(&LPSPI_DMR1_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * LPSPI_CCR - Clock Configuration Register
 ******************************************************************************/

/*!
 * @brief LPSPI_CCR - Clock Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CCR is only used in master mode and cannot be changed when the LPSPI is
 * enabled.
 */
/*!
 * @name Constants and macros for entire LPSPI_CCR register
 */
/*@{*/
#define LPSPI_RD_CCR(base)       (LPSPI_CCR_REG(base))
#define LPSPI_WR_CCR(base, value) (LPSPI_CCR_REG(base) = (value))
#define LPSPI_RMW_CCR(base, mask, value) (LPSPI_WR_CCR(base, (LPSPI_RD_CCR(base) & ~(mask)) | (value)))
#define LPSPI_SET_CCR(base, value) (BME_OR32(&LPSPI_CCR_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_CCR(base, value) (BME_AND32(&LPSPI_CCR_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_CCR(base, value) (BME_XOR32(&LPSPI_CCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_CCR bitfields
 */

/*!
 * @name Register LPSPI_CCR, field SCKDIV[7:0] (RW)
 *
 * Configures the divide ratio of the SCK pin in master mode, from the LPSPI
 * baud rate clock. The SCK period is equal to SCKDIV+2 cycles of the LPSPI baud
 * rate clock and the minimum period is 2 cycles. If the period is an odd number of
 * cycles, then the first half of the period will be one cycle longer than the
 * second half. The LPSPI baud rate clock is itself divided by the PRESCALE
 * setting, which can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_SCKDIV field. */
#define LPSPI_RD_CCR_SCKDIV(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_SCKDIV_MASK) >> LPSPI_CCR_SCKDIV_SHIFT)
#define LPSPI_BRD_CCR_SCKDIV(base) (BME_UBFX32(&LPSPI_CCR_REG(base), LPSPI_CCR_SCKDIV_SHIFT, LPSPI_CCR_SCKDIV_WIDTH))

/*! @brief Set the SCKDIV field to a new value. */
#define LPSPI_WR_CCR_SCKDIV(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_SCKDIV_MASK, LPSPI_CCR_SCKDIV(value)))
#define LPSPI_BWR_CCR_SCKDIV(base, value) (BME_BFI32(&LPSPI_CCR_REG(base), ((uint32_t)(value) << LPSPI_CCR_SCKDIV_SHIFT), LPSPI_CCR_SCKDIV_SHIFT, LPSPI_CCR_SCKDIV_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CCR, field DBT[15:8] (RW)
 *
 * Configures the delay in master mode from the PCS negation to the next PCS
 * assertion. The delay is equal to (DBT + 2) cycles of the LPSPI baud rate clock
 * and the minimum delay is 2 cycles. Note that half the delay occurs before PCS
 * assertion and the other half occurs after PCS negation, the full command word
 * can only update in the middle. The LPSPI baud rate clock is itself divided by
 * the PRESCALE setting, which can vary between transfers. Also configures the
 * delay in master mode from the last SCK edge of a transfer word and the first SCK
 * edge of the next transfer word in a continuous transfer. The delay is equal to
 * (DBT + 1) cycles of the LPSPI baud rate clock and the minimum delay is 1
 * cycle. The LPSPI baud rate clock is itself divided by the PRESCALE setting, which
 * can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_DBT field. */
#define LPSPI_RD_CCR_DBT(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_DBT_MASK) >> LPSPI_CCR_DBT_SHIFT)
#define LPSPI_BRD_CCR_DBT(base) (BME_UBFX32(&LPSPI_CCR_REG(base), LPSPI_CCR_DBT_SHIFT, LPSPI_CCR_DBT_WIDTH))

/*! @brief Set the DBT field to a new value. */
#define LPSPI_WR_CCR_DBT(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_DBT_MASK, LPSPI_CCR_DBT(value)))
#define LPSPI_BWR_CCR_DBT(base, value) (BME_BFI32(&LPSPI_CCR_REG(base), ((uint32_t)(value) << LPSPI_CCR_DBT_SHIFT), LPSPI_CCR_DBT_SHIFT, LPSPI_CCR_DBT_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CCR, field PCSSCK[23:16] (RW)
 *
 * Configures the delay in master mode from the PCS assertion to the first SCK
 * edge. The delay is equal to (PCSSCK + 1) cycles of the LPSPI baud rate clock
 * and the minimum delay is 1 cycle. The LPSPI baud rate clock is itself divided by
 * the PRESCALE setting, which can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_PCSSCK field. */
#define LPSPI_RD_CCR_PCSSCK(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_PCSSCK_MASK) >> LPSPI_CCR_PCSSCK_SHIFT)
#define LPSPI_BRD_CCR_PCSSCK(base) (BME_UBFX32(&LPSPI_CCR_REG(base), LPSPI_CCR_PCSSCK_SHIFT, LPSPI_CCR_PCSSCK_WIDTH))

/*! @brief Set the PCSSCK field to a new value. */
#define LPSPI_WR_CCR_PCSSCK(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_PCSSCK_MASK, LPSPI_CCR_PCSSCK(value)))
#define LPSPI_BWR_CCR_PCSSCK(base, value) (BME_BFI32(&LPSPI_CCR_REG(base), ((uint32_t)(value) << LPSPI_CCR_PCSSCK_SHIFT), LPSPI_CCR_PCSSCK_SHIFT, LPSPI_CCR_PCSSCK_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_CCR, field SCKPCS[31:24] (RW)
 *
 * Configures the delay in master mode from the last SCK edge to the PCS
 * negation. The delay is equal to (PCSSCK + 1) cycles of the LPSPI baud rate clock and
 * the minimum delay is 1 cycle. The LPSPI baud rate clock is itself divided by
 * the PRESCALE setting, which can vary between transfers.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_CCR_SCKPCS field. */
#define LPSPI_RD_CCR_SCKPCS(base) ((LPSPI_CCR_REG(base) & LPSPI_CCR_SCKPCS_MASK) >> LPSPI_CCR_SCKPCS_SHIFT)
#define LPSPI_BRD_CCR_SCKPCS(base) (BME_UBFX32(&LPSPI_CCR_REG(base), LPSPI_CCR_SCKPCS_SHIFT, LPSPI_CCR_SCKPCS_WIDTH))

/*! @brief Set the SCKPCS field to a new value. */
#define LPSPI_WR_CCR_SCKPCS(base, value) (LPSPI_RMW_CCR(base, LPSPI_CCR_SCKPCS_MASK, LPSPI_CCR_SCKPCS(value)))
#define LPSPI_BWR_CCR_SCKPCS(base, value) (BME_BFI32(&LPSPI_CCR_REG(base), ((uint32_t)(value) << LPSPI_CCR_SCKPCS_SHIFT), LPSPI_CCR_SCKPCS_SHIFT, LPSPI_CCR_SCKPCS_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_FCR - FIFO Control Register
 ******************************************************************************/

/*!
 * @brief LPSPI_FCR - FIFO Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_FCR register
 */
/*@{*/
#define LPSPI_RD_FCR(base)       (LPSPI_FCR_REG(base))
#define LPSPI_WR_FCR(base, value) (LPSPI_FCR_REG(base) = (value))
#define LPSPI_RMW_FCR(base, mask, value) (LPSPI_WR_FCR(base, (LPSPI_RD_FCR(base) & ~(mask)) | (value)))
#define LPSPI_SET_FCR(base, value) (BME_OR32(&LPSPI_FCR_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_FCR(base, value) (BME_AND32(&LPSPI_FCR_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_FCR(base, value) (BME_XOR32(&LPSPI_FCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_FCR bitfields
 */

/*!
 * @name Register LPSPI_FCR, field TXWATER[7:0] (RW)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER. Writing a value equal or greater than the
 * FIFO size will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FCR_TXWATER field. */
#define LPSPI_RD_FCR_TXWATER(base) ((LPSPI_FCR_REG(base) & LPSPI_FCR_TXWATER_MASK) >> LPSPI_FCR_TXWATER_SHIFT)
#define LPSPI_BRD_FCR_TXWATER(base) (BME_UBFX32(&LPSPI_FCR_REG(base), LPSPI_FCR_TXWATER_SHIFT, LPSPI_FCR_TXWATER_WIDTH))

/*! @brief Set the TXWATER field to a new value. */
#define LPSPI_WR_FCR_TXWATER(base, value) (LPSPI_RMW_FCR(base, LPSPI_FCR_TXWATER_MASK, LPSPI_FCR_TXWATER(value)))
#define LPSPI_BWR_FCR_TXWATER(base, value) (BME_BFI32(&LPSPI_FCR_REG(base), ((uint32_t)(value) << LPSPI_FCR_TXWATER_SHIFT), LPSPI_FCR_TXWATER_SHIFT, LPSPI_FCR_TXWATER_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_FCR, field RXWATER[23:16] (RW)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER. Writing a value equal or greater than the FIFO size
 * will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FCR_RXWATER field. */
#define LPSPI_RD_FCR_RXWATER(base) ((LPSPI_FCR_REG(base) & LPSPI_FCR_RXWATER_MASK) >> LPSPI_FCR_RXWATER_SHIFT)
#define LPSPI_BRD_FCR_RXWATER(base) (BME_UBFX32(&LPSPI_FCR_REG(base), LPSPI_FCR_RXWATER_SHIFT, LPSPI_FCR_RXWATER_WIDTH))

/*! @brief Set the RXWATER field to a new value. */
#define LPSPI_WR_FCR_RXWATER(base, value) (LPSPI_RMW_FCR(base, LPSPI_FCR_RXWATER_MASK, LPSPI_FCR_RXWATER(value)))
#define LPSPI_BWR_FCR_RXWATER(base, value) (BME_BFI32(&LPSPI_FCR_REG(base), ((uint32_t)(value) << LPSPI_FCR_RXWATER_SHIFT), LPSPI_FCR_RXWATER_SHIFT, LPSPI_FCR_RXWATER_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_FSR - FIFO Status Register
 ******************************************************************************/

/*!
 * @brief LPSPI_FSR - FIFO Status Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_FSR register
 */
/*@{*/
#define LPSPI_RD_FSR(base)       (LPSPI_FSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_FSR bitfields
 */

/*!
 * @name Register LPSPI_FSR, field TXCOUNT[7:0] (RO)
 *
 * Returns the number of words in the transmit FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FSR_TXCOUNT field. */
#define LPSPI_RD_FSR_TXCOUNT(base) ((LPSPI_FSR_REG(base) & LPSPI_FSR_TXCOUNT_MASK) >> LPSPI_FSR_TXCOUNT_SHIFT)
#define LPSPI_BRD_FSR_TXCOUNT(base) (BME_UBFX32(&LPSPI_FSR_REG(base), LPSPI_FSR_TXCOUNT_SHIFT, LPSPI_FSR_TXCOUNT_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_FSR, field RXCOUNT[23:16] (RO)
 *
 * Returns the number of words in the receive FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_FSR_RXCOUNT field. */
#define LPSPI_RD_FSR_RXCOUNT(base) ((LPSPI_FSR_REG(base) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT)
#define LPSPI_BRD_FSR_RXCOUNT(base) (BME_UBFX32(&LPSPI_FSR_REG(base), LPSPI_FSR_RXCOUNT_SHIFT, LPSPI_FSR_RXCOUNT_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_TCR - Transmit Command Register
 ******************************************************************************/

/*!
 * @brief LPSPI_TCR - Transmit Command Register (RW)
 *
 * Reset value: 0x0000001FU
 *
 * Writes to either the Transmit Command Register or Transmit Data Register will
 * push the data into the transmit FIFO in the order they are written. Command
 * Register writes will be tagged and cause the command register to update once
 * that entry reaches the top of the FIFO. This allows changes to the command word
 * and the transmit data itself to be interleaved. Changing the command word will
 * cause all subsequent SPI bus transfer to be performed using the new command
 * word. In master mode, writing a new command word does not initiate a new
 * transfer, unless TXMSK is set. Transfers are initiated by transmit data in the
 * transmit FIFO, or a new command word with TXMSK set. Hardware will clear TXMSK when
 * the LPSPI_PCS negates. In master mode if the command word is changed before
 * an existing frame has completed, then the existing frame will terminate and the
 * command word will then update. The command word can be changed during a
 * continuous transfer, provided CONTC of the new command word is set and the command
 * word is written on a frame size boundary. In slave mode, the command word
 * should be changed only when the LPSPI is idle and there is no SPI bus transfer.
 * Reading the Transmit Command Register will return the current state of the
 * command register.
 */
/*!
 * @name Constants and macros for entire LPSPI_TCR register
 */
/*@{*/
#define LPSPI_RD_TCR(base)       (LPSPI_TCR_REG(base))
#define LPSPI_WR_TCR(base, value) (LPSPI_TCR_REG(base) = (value))
#define LPSPI_RMW_TCR(base, mask, value) (LPSPI_WR_TCR(base, (LPSPI_RD_TCR(base) & ~(mask)) | (value)))
#define LPSPI_SET_TCR(base, value) (BME_OR32(&LPSPI_TCR_REG(base), (uint32_t)(value)))
#define LPSPI_CLR_TCR(base, value) (BME_AND32(&LPSPI_TCR_REG(base), (uint32_t)(~(value))))
#define LPSPI_TOG_TCR(base, value) (BME_XOR32(&LPSPI_TCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPSPI_TCR bitfields
 */

/*!
 * @name Register LPSPI_TCR, field FRAMESZ[11:0] (RW)
 *
 * Configures the frame size in number of bits equal to (FRAMESZ + 1). The
 * minimum frame size is 8 bits. If the frame size is larger than 32 bits, data will
 * be loaded from the transmit FIFO and stored to the receive FIFO every 32 bits.
 * If the size of the transfer word is not divisible by 32, then the last load of
 * the transmit FIFO and store of the receive FIFO will contain the remainder
 * bits (e.g.: a 72-bit transfer will load/store 32-bits from the FIFO and then
 * another 32-bits from the FIFO and then the final 8-bits from the FIFO).
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_FRAMESZ field. */
#define LPSPI_RD_TCR_FRAMESZ(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_FRAMESZ_MASK) >> LPSPI_TCR_FRAMESZ_SHIFT)
#define LPSPI_BRD_TCR_FRAMESZ(base) (LPSPI_RD_TCR_FRAMESZ(base))

/*! @brief Set the FRAMESZ field to a new value. */
#define LPSPI_WR_TCR_FRAMESZ(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_FRAMESZ_MASK, LPSPI_TCR_FRAMESZ(value)))
#define LPSPI_BWR_TCR_FRAMESZ(base, value) (LPSPI_WR_TCR_FRAMESZ(base, value))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field WIDTH[17:16] (RW)
 *
 * Either RXMSK or TXMSK must be set for 2-bit or 4-bit transfers.
 *
 * Values:
 * - 0b00 - Single bit transfer.
 * - 0b01 - Two bit transfer.
 * - 0b10 - Four bit transfer.
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_WIDTH field. */
#define LPSPI_RD_TCR_WIDTH(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_WIDTH_MASK) >> LPSPI_TCR_WIDTH_SHIFT)
#define LPSPI_BRD_TCR_WIDTH(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_WIDTH_SHIFT, LPSPI_TCR_WIDTH_WIDTH))

/*! @brief Set the WIDTH field to a new value. */
#define LPSPI_WR_TCR_WIDTH(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_WIDTH_MASK, LPSPI_TCR_WIDTH(value)))
#define LPSPI_BWR_TCR_WIDTH(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_WIDTH_SHIFT), LPSPI_TCR_WIDTH_SHIFT, LPSPI_TCR_WIDTH_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field TXMSK[18] (RW)
 *
 * When set, transmit data is masked (no data is loaded from transmit FIFO and
 * output pin is tristated). In master mode, this bit will initiate a new transfer
 * which cannot be aborted by another command word and the bit will be cleared
 * by hardware at the end of the transfer.
 *
 * Values:
 * - 0b0 - Normal transfer.
 * - 0b1 - Mask transmit data.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_TXMSK field. */
#define LPSPI_RD_TCR_TXMSK(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_TXMSK_MASK) >> LPSPI_TCR_TXMSK_SHIFT)
#define LPSPI_BRD_TCR_TXMSK(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_TXMSK_SHIFT, LPSPI_TCR_TXMSK_WIDTH))

/*! @brief Set the TXMSK field to a new value. */
#define LPSPI_WR_TCR_TXMSK(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_TXMSK_MASK, LPSPI_TCR_TXMSK(value)))
#define LPSPI_BWR_TCR_TXMSK(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_TXMSK_SHIFT), LPSPI_TCR_TXMSK_SHIFT, LPSPI_TCR_TXMSK_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field RXMSK[19] (RW)
 *
 * When set, receive data is masked (receive data is not stored in receive FIFO).
 *
 * Values:
 * - 0b0 - Normal transfer.
 * - 0b1 - Receive data is masked.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_RXMSK field. */
#define LPSPI_RD_TCR_RXMSK(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_RXMSK_MASK) >> LPSPI_TCR_RXMSK_SHIFT)
#define LPSPI_BRD_TCR_RXMSK(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_RXMSK_SHIFT, LPSPI_TCR_RXMSK_WIDTH))

/*! @brief Set the RXMSK field to a new value. */
#define LPSPI_WR_TCR_RXMSK(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_RXMSK_MASK, LPSPI_TCR_RXMSK(value)))
#define LPSPI_BWR_TCR_RXMSK(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_RXMSK_SHIFT), LPSPI_TCR_RXMSK_SHIFT, LPSPI_TCR_RXMSK_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CONTC[20] (RW)
 *
 * In master mode, this bit allows the command word to be changed within a
 * continuous transfer. The initial command word must enable continuous transfer
 * (CONT=1), the continuing command must set this bit (CONTC=1) and the continuing
 * command word must be loaded on a frame size boundary. For example, if the
 * continuous transfer has a frame size of 64-bits, then a continuing command word must
 * be loaded on a 64-bit boundary.
 *
 * Values:
 * - 0b0 - Command word for start of new transfer.
 * - 0b1 - Command word for continuing transfer.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CONTC field. */
#define LPSPI_RD_TCR_CONTC(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CONTC_MASK) >> LPSPI_TCR_CONTC_SHIFT)
#define LPSPI_BRD_TCR_CONTC(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_CONTC_SHIFT, LPSPI_TCR_CONTC_WIDTH))

/*! @brief Set the CONTC field to a new value. */
#define LPSPI_WR_TCR_CONTC(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CONTC_MASK, LPSPI_TCR_CONTC(value)))
#define LPSPI_BWR_TCR_CONTC(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_CONTC_SHIFT), LPSPI_TCR_CONTC_SHIFT, LPSPI_TCR_CONTC_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CONT[21] (RW)
 *
 * In master mode, continuous transfer will keep the PCS asserted at the end of
 * the frame size, until a command word is received that starts a new frame. In
 * slave mode, when continuous transfer is enabled the LPSPI will only transmit
 * the first FRAMESZ bits, after which it will transmit received data assuming a
 * 32-bit shift register.
 *
 * Values:
 * - 0b0 - Continuous transfer disabled.
 * - 0b1 - Continuous transfer enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CONT field. */
#define LPSPI_RD_TCR_CONT(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CONT_MASK) >> LPSPI_TCR_CONT_SHIFT)
#define LPSPI_BRD_TCR_CONT(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_CONT_SHIFT, LPSPI_TCR_CONT_WIDTH))

/*! @brief Set the CONT field to a new value. */
#define LPSPI_WR_TCR_CONT(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CONT_MASK, LPSPI_TCR_CONT(value)))
#define LPSPI_BWR_TCR_CONT(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_CONT_SHIFT), LPSPI_TCR_CONT_SHIFT, LPSPI_TCR_CONT_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field BYSW[22] (RW)
 *
 * Byte swap will swap the contents of [31:24] with [7:0] and [23:16] with
 * [15:8] for each transmit data word read from the FIFO and each received data word
 * stored to the FIFO (or compared with match registers).
 *
 * Values:
 * - 0b0 - Byte swap disabled.
 * - 0b1 - Byte swap enabled.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_BYSW field. */
#define LPSPI_RD_TCR_BYSW(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_BYSW_MASK) >> LPSPI_TCR_BYSW_SHIFT)
#define LPSPI_BRD_TCR_BYSW(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_BYSW_SHIFT, LPSPI_TCR_BYSW_WIDTH))

/*! @brief Set the BYSW field to a new value. */
#define LPSPI_WR_TCR_BYSW(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_BYSW_MASK, LPSPI_TCR_BYSW(value)))
#define LPSPI_BWR_TCR_BYSW(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_BYSW_SHIFT), LPSPI_TCR_BYSW_SHIFT, LPSPI_TCR_BYSW_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field LSBF[23] (RW)
 *
 * Values:
 * - 0b0 - Data is transferred MSB first.
 * - 0b1 - Data is transferred LSB first.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_LSBF field. */
#define LPSPI_RD_TCR_LSBF(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_LSBF_MASK) >> LPSPI_TCR_LSBF_SHIFT)
#define LPSPI_BRD_TCR_LSBF(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_LSBF_SHIFT, LPSPI_TCR_LSBF_WIDTH))

/*! @brief Set the LSBF field to a new value. */
#define LPSPI_WR_TCR_LSBF(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_LSBF_MASK, LPSPI_TCR_LSBF(value)))
#define LPSPI_BWR_TCR_LSBF(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_LSBF_SHIFT), LPSPI_TCR_LSBF_SHIFT, LPSPI_TCR_LSBF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field PCS[25:24] (RW)
 *
 * Configures the peripheral chip select used for the transfer. This field is
 * only updated between frames.
 *
 * Values:
 * - 0b00 - Transfer using LPSPI_PCS[0]
 * - 0b01 - Transfer using LPSPI_PCS[1]
 * - 0b10 - Transfer using LPSPI_PCS[2]
 * - 0b11 - Transfer using LPSPI_PCS[3]
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_PCS field. */
#define LPSPI_RD_TCR_PCS(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_PCS_MASK) >> LPSPI_TCR_PCS_SHIFT)
#define LPSPI_BRD_TCR_PCS(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_PCS_SHIFT, LPSPI_TCR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define LPSPI_WR_TCR_PCS(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_PCS_MASK, LPSPI_TCR_PCS(value)))
#define LPSPI_BWR_TCR_PCS(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_PCS_SHIFT), LPSPI_TCR_PCS_SHIFT, LPSPI_TCR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field PRESCALE[29:27] (RW)
 *
 * Prescaler applied to the clock configuration register for all SPI bus
 * transfers. This field is only updated between frames.
 *
 * Values:
 * - 0b000 - Divide by 1.
 * - 0b001 - Divide by 2.
 * - 0b010 - Divide by 4.
 * - 0b011 - Divide by 8.
 * - 0b100 - Divide by 16.
 * - 0b101 - Divide by 32.
 * - 0b110 - Divide by 64.
 * - 0b111 - Divide by 128.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_PRESCALE field. */
#define LPSPI_RD_TCR_PRESCALE(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_PRESCALE_MASK) >> LPSPI_TCR_PRESCALE_SHIFT)
#define LPSPI_BRD_TCR_PRESCALE(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_PRESCALE_SHIFT, LPSPI_TCR_PRESCALE_WIDTH))

/*! @brief Set the PRESCALE field to a new value. */
#define LPSPI_WR_TCR_PRESCALE(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_PRESCALE_MASK, LPSPI_TCR_PRESCALE(value)))
#define LPSPI_BWR_TCR_PRESCALE(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_PRESCALE_SHIFT), LPSPI_TCR_PRESCALE_SHIFT, LPSPI_TCR_PRESCALE_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CPHA[30] (RW)
 *
 * This field is only updated between frames.
 *
 * Values:
 * - 0b0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 0b1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CPHA field. */
#define LPSPI_RD_TCR_CPHA(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CPHA_MASK) >> LPSPI_TCR_CPHA_SHIFT)
#define LPSPI_BRD_TCR_CPHA(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_CPHA_SHIFT, LPSPI_TCR_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define LPSPI_WR_TCR_CPHA(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CPHA_MASK, LPSPI_TCR_CPHA(value)))
#define LPSPI_BWR_TCR_CPHA(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_CPHA_SHIFT), LPSPI_TCR_CPHA_SHIFT, LPSPI_TCR_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_TCR, field CPOL[31] (RW)
 *
 * This field is only updated between frames.
 *
 * Values:
 * - 0b0 - The inactive state value of SCK is low.
 * - 0b1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_TCR_CPOL field. */
#define LPSPI_RD_TCR_CPOL(base) ((LPSPI_TCR_REG(base) & LPSPI_TCR_CPOL_MASK) >> LPSPI_TCR_CPOL_SHIFT)
#define LPSPI_BRD_TCR_CPOL(base) (BME_UBFX32(&LPSPI_TCR_REG(base), LPSPI_TCR_CPOL_SHIFT, LPSPI_TCR_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define LPSPI_WR_TCR_CPOL(base, value) (LPSPI_RMW_TCR(base, LPSPI_TCR_CPOL_MASK, LPSPI_TCR_CPOL(value)))
#define LPSPI_BWR_TCR_CPOL(base, value) (BME_BFI32(&LPSPI_TCR_REG(base), ((uint32_t)(value) << LPSPI_TCR_CPOL_SHIFT), LPSPI_TCR_CPOL_SHIFT, LPSPI_TCR_CPOL_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_TDR - Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPSPI_TDR - Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 *
 * Writes to either the Transmit Command Register or Transmit Data Register will
 * push the data into the transmit FIFO in the order it was written.
 */
/*!
 * @name Constants and macros for entire LPSPI_TDR register
 */
/*@{*/
#define LPSPI_WR_TDR(base, value) (LPSPI_TDR_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * LPSPI_RSR - Receive Status Register
 ******************************************************************************/

/*!
 * @brief LPSPI_RSR - Receive Status Register (RO)
 *
 * Reset value: 0x00000002U
 */
/*!
 * @name Constants and macros for entire LPSPI_RSR register
 */
/*@{*/
#define LPSPI_RD_RSR(base)       (LPSPI_RSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPSPI_RSR bitfields
 */

/*!
 * @name Register LPSPI_RSR, field SOF[0] (RO)
 *
 * Indicates that this is the first data word received after LPSPI_PCS assertion.
 *
 * Values:
 * - 0b0 - Subsequent data word received after LPSPI_PCS assertion.
 * - 0b1 - First data word received after LPSPI_PCS assertion.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_RSR_SOF field. */
#define LPSPI_RD_RSR_SOF(base) ((LPSPI_RSR_REG(base) & LPSPI_RSR_SOF_MASK) >> LPSPI_RSR_SOF_SHIFT)
#define LPSPI_BRD_RSR_SOF(base) (BME_UBFX32(&LPSPI_RSR_REG(base), LPSPI_RSR_SOF_SHIFT, LPSPI_RSR_SOF_WIDTH))
/*@}*/

/*!
 * @name Register LPSPI_RSR, field RXEMPTY[1] (RO)
 *
 * Values:
 * - 0b0 - RX FIFO is not empty.
 * - 0b1 - RX FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the LPSPI_RSR_RXEMPTY field. */
#define LPSPI_RD_RSR_RXEMPTY(base) ((LPSPI_RSR_REG(base) & LPSPI_RSR_RXEMPTY_MASK) >> LPSPI_RSR_RXEMPTY_SHIFT)
#define LPSPI_BRD_RSR_RXEMPTY(base) (BME_UBFX32(&LPSPI_RSR_REG(base), LPSPI_RSR_RXEMPTY_SHIFT, LPSPI_RSR_RXEMPTY_WIDTH))
/*@}*/

/*******************************************************************************
 * LPSPI_RDR - Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPSPI_RDR - Receive Data Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPSPI_RDR register
 */
/*@{*/
#define LPSPI_RD_RDR(base)       (LPSPI_RDR_REG(base))
/*@}*/

/*
 * MKL28Z7 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (2U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */
#define LPTMR1_IDX (1U) /*!< Instance number for LPTMR1. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (BME_OR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CSR(base, value) (BME_AND32(&LPTMR_CSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CSR(base, value) (BME_XOR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0b0 - LPTMR is disabled and internal logic is reset.
 * - 0b1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TEN_SHIFT), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0b0 - Time Counter mode.
 * - 0b1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TMS_SHIFT), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0b0 - CNR is reset whenever TCF is set.
 * - 0b1 - CNR is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TFC_SHIFT), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 0b1 - Pulse Counter input source is active-low, and the CNR will increment
 *     on the falling-edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPP_SHIFT), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the chip configuration information about connections to these inputs.
 *
 * Values:
 * - 0b00 - Pulse counter input 0 is selected.
 * - 0b01 - Pulse counter input 1 is selected.
 * - 0b10 - Pulse counter input 2 is selected.
 * - 0b11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPS_SHIFT), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0b0 - Timer interrupt disabled.
 * - 0b1 - Timer interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TIE_SHIFT), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0b0 - The value of CNR is not equal to CMR and increments.
 * - 0b1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TCF_SHIFT), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TDRE[8] (RW)
 *
 * When TDRE is set, the LPTMR DMA Request is generated whenever TCF is also set
 * and the TCF is cleared when the DMA Controller is done.
 *
 * Values:
 * - 0b0 - Timer DMA Request disabled.
 * - 0b1 - Timer DMA Request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TDRE field. */
#define LPTMR_RD_CSR_TDRE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TDRE_MASK) >> LPTMR_CSR_TDRE_SHIFT)
#define LPTMR_BRD_CSR_TDRE(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TDRE_SHIFT, LPTMR_CSR_TDRE_WIDTH))

/*! @brief Set the TDRE field to a new value. */
#define LPTMR_WR_CSR_TDRE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TDRE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TDRE(value)))
#define LPTMR_BWR_CSR_TDRE(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TDRE_SHIFT), LPTMR_CSR_TDRE_SHIFT, LPTMR_CSR_TDRE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (BME_OR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_PSR(base, value) (BME_AND32(&LPTMR_PSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_PSR(base, value) (BME_XOR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 0b00 - Prescaler/glitch filter clock 0 selected.
 * - 0b01 - Prescaler/glitch filter clock 1 selected.
 * - 0b10 - Prescaler/glitch filter clock 2 selected.
 * - 0b11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PCS_SHIFT), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Prescaler/glitch filter is enabled.
 * - 0b1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PBYP_SHIFT), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0b0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0b0001 - Prescaler divides the prescaler clock by 4; glitch filter
 *     recognizes change on input pin after 2 rising clock edges.
 * - 0b0010 - Prescaler divides the prescaler clock by 8; glitch filter
 *     recognizes change on input pin after 4 rising clock edges.
 * - 0b0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0b0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0b0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0b0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0b0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 0b1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 0b1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 0b1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 0b1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 0b1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 0b1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 0b1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 0b1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PRESCALE_SHIFT), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (BME_OR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CMR(base, value) (BME_AND32(&LPTMR_CMR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CMR(base, value) (BME_XOR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (LPTMR_RD_CMR_COMPARE(base))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (LPTMR_WR_CMR_COMPARE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
#define LPTMR_WR_CNR(base, value) (LPTMR_CNR_REG(base) = (value))
#define LPTMR_RMW_CNR(base, mask, value) (LPTMR_WR_CNR(base, (LPTMR_RD_CNR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CNR(base, value) (BME_OR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CNR(base, value) (BME_AND32(&LPTMR_CNR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CNR(base, value) (BME_XOR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 *
 * The CNR returns the current value of the LPTMR counter at the time this
 * register was last written.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (LPTMR_RD_CNR_COUNTER(base))

/*! @brief Set the COUNTER field to a new value. */
#define LPTMR_WR_CNR_COUNTER(base, value) (LPTMR_RMW_CNR(base, LPTMR_CNR_COUNTER_MASK, LPTMR_CNR_COUNTER(value)))
#define LPTMR_BWR_CNR_COUNTER(base, value) (LPTMR_WR_CNR_COUNTER(base, value))
/*@}*/

/*
 * MKL28Z7 LPUART
 *
 * Universal Asynchronous Receiver/Transmitter
 *
 * Registers defined in this header file:
 * - LPUART_BAUD - LPUART Baud Rate Register
 * - LPUART_STAT - LPUART Status Register
 * - LPUART_CTRL - LPUART Control Register
 * - LPUART_DATA - LPUART Data Register
 * - LPUART_MATCH - LPUART Match Address Register
 * - LPUART_MODIR - LPUART Modem IrDA Register
 * - LPUART_FIFO - LPUART FIFO Register
 * - LPUART_WATER - LPUART Watermark Register
 */

#define LPUART_INSTANCE_COUNT (3U) /*!< Number of instances of the LPUART module. */
#define LPUART0_IDX (0U) /*!< Instance number for LPUART0. */
#define LPUART1_IDX (1U) /*!< Instance number for LPUART1. */
#define LPUART2_IDX (2U) /*!< Instance number for LPUART2. */

/*******************************************************************************
 * LPUART_BAUD - LPUART Baud Rate Register
 ******************************************************************************/

/*!
 * @brief LPUART_BAUD - LPUART Baud Rate Register (RW)
 *
 * Reset value: 0x0F000004U
 */
/*!
 * @name Constants and macros for entire LPUART_BAUD register
 */
/*@{*/
#define LPUART_RD_BAUD(base)     (LPUART_BAUD_REG(base))
#define LPUART_WR_BAUD(base, value) (LPUART_BAUD_REG(base) = (value))
#define LPUART_RMW_BAUD(base, mask, value) (LPUART_WR_BAUD(base, (LPUART_RD_BAUD(base) & ~(mask)) | (value)))
#define LPUART_SET_BAUD(base, value) (BME_OR32(&LPUART_BAUD_REG(base), (uint32_t)(value)))
#define LPUART_CLR_BAUD(base, value) (BME_AND32(&LPUART_BAUD_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_BAUD(base, value) (BME_XOR32(&LPUART_BAUD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_BAUD bitfields
 */

/*!
 * @name Register LPUART_BAUD, field SBR[12:0] (RW)
 *
 * The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate
 * generator. When SBR is 1 - 8191, the baud rate equals "baud clock / ((OSR+1) * SBR)".
 * The 13-bit baud rate setting [SBR12:SBR0] must only be updated when the
 * transmitter and receiver are both disabled (LPUART_CTRL[RE] and LPUART_CTRL[TE] are
 * both 0).
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBR field. */
#define LPUART_RD_BAUD_SBR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBR_MASK) >> LPUART_BAUD_SBR_SHIFT)
#define LPUART_BRD_BAUD_SBR(base) (LPUART_RD_BAUD_SBR(base))

/*! @brief Set the SBR field to a new value. */
#define LPUART_WR_BAUD_SBR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBR_MASK, LPUART_BAUD_SBR(value)))
#define LPUART_BWR_BAUD_SBR(base, value) (LPUART_WR_BAUD_SBR(base, value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field SBNS[13] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - One stop bit.
 * - 0b1 - Two stop bits.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBNS field. */
#define LPUART_RD_BAUD_SBNS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBNS_MASK) >> LPUART_BAUD_SBNS_SHIFT)
#define LPUART_BRD_BAUD_SBNS(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBNS_SHIFT, LPUART_BAUD_SBNS_WIDTH))

/*! @brief Set the SBNS field to a new value. */
#define LPUART_WR_BAUD_SBNS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBNS_MASK, LPUART_BAUD_SBNS(value)))
#define LPUART_BWR_BAUD_SBNS(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_SBNS_SHIFT), LPUART_BAUD_SBNS_SHIFT, LPUART_BAUD_SBNS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RXEDGIE[14] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests. Changing CTRL[LOOP] or CTRL[RSRC] when RXEDGIE is set can cause the RXEDGIF
 * to set.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RXEDGIE field. */
#define LPUART_RD_BAUD_RXEDGIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RXEDGIE_MASK) >> LPUART_BAUD_RXEDGIE_SHIFT)
#define LPUART_BRD_BAUD_RXEDGIE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RXEDGIE_SHIFT, LPUART_BAUD_RXEDGIE_WIDTH))

/*! @brief Set the RXEDGIE field to a new value. */
#define LPUART_WR_BAUD_RXEDGIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RXEDGIE_MASK, LPUART_BAUD_RXEDGIE(value)))
#define LPUART_BWR_BAUD_RXEDGIE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RXEDGIE_SHIFT), LPUART_BAUD_RXEDGIE_SHIFT, LPUART_BAUD_RXEDGIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field LBKDIE[15] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
 * - 0b1 - Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_LBKDIE field. */
#define LPUART_RD_BAUD_LBKDIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_LBKDIE_MASK) >> LPUART_BAUD_LBKDIE_SHIFT)
#define LPUART_BRD_BAUD_LBKDIE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_LBKDIE_SHIFT, LPUART_BAUD_LBKDIE_WIDTH))

/*! @brief Set the LBKDIE field to a new value. */
#define LPUART_WR_BAUD_LBKDIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_LBKDIE_MASK, LPUART_BAUD_LBKDIE(value)))
#define LPUART_BWR_BAUD_LBKDIE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_LBKDIE_SHIFT), LPUART_BAUD_LBKDIE_SHIFT, LPUART_BAUD_LBKDIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RESYNCDIS[16] (RW)
 *
 * When set, disables the resynchronization of the received data word when a
 * data one followed by data zero transition is detected. This bit should only be
 * changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Resynchronization during received data word is supported
 * - 0b1 - Resynchronization during received data word is disabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RESYNCDIS field. */
#define LPUART_RD_BAUD_RESYNCDIS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RESYNCDIS_MASK) >> LPUART_BAUD_RESYNCDIS_SHIFT)
#define LPUART_BRD_BAUD_RESYNCDIS(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RESYNCDIS_SHIFT, LPUART_BAUD_RESYNCDIS_WIDTH))

/*! @brief Set the RESYNCDIS field to a new value. */
#define LPUART_WR_BAUD_RESYNCDIS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RESYNCDIS_MASK, LPUART_BAUD_RESYNCDIS(value)))
#define LPUART_BWR_BAUD_RESYNCDIS(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RESYNCDIS_SHIFT), LPUART_BAUD_RESYNCDIS_SHIFT, LPUART_BAUD_RESYNCDIS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field BOTHEDGE[17] (RW)
 *
 * Enables sampling of the received data on both edges of the baud rate clock,
 * effectively doubling the number of times the receiver samples the input data
 * for a given oversampling ratio. This bit must be set for oversampling ratios
 * between x4 and x7 and is optional for higher oversampling ratios. This bit should
 * only be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - Receiver samples input data using the rising edge of the baud rate
 *     clock.
 * - 0b1 - Receiver samples input data using the rising and falling edge of the
 *     baud rate clock.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_BOTHEDGE field. */
#define LPUART_RD_BAUD_BOTHEDGE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_BOTHEDGE_MASK) >> LPUART_BAUD_BOTHEDGE_SHIFT)
#define LPUART_BRD_BAUD_BOTHEDGE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_BOTHEDGE_SHIFT, LPUART_BAUD_BOTHEDGE_WIDTH))

/*! @brief Set the BOTHEDGE field to a new value. */
#define LPUART_WR_BAUD_BOTHEDGE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_BOTHEDGE_MASK, LPUART_BAUD_BOTHEDGE(value)))
#define LPUART_BWR_BAUD_BOTHEDGE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_BOTHEDGE_SHIFT), LPUART_BAUD_BOTHEDGE_SHIFT, LPUART_BAUD_BOTHEDGE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MATCFG[19:18] (RW)
 *
 * Configures the match addressing mode used.
 *
 * Values:
 * - 0b00 - Address Match Wakeup
 * - 0b01 - Idle Match Wakeup
 * - 0b10 - Match On and Match Off
 * - 0b11 - Enables RWU on Data Match and Match On/Off for transmitter CTS input
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MATCFG field. */
#define LPUART_RD_BAUD_MATCFG(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MATCFG_MASK) >> LPUART_BAUD_MATCFG_SHIFT)
#define LPUART_BRD_BAUD_MATCFG(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MATCFG_SHIFT, LPUART_BAUD_MATCFG_WIDTH))

/*! @brief Set the MATCFG field to a new value. */
#define LPUART_WR_BAUD_MATCFG(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MATCFG_MASK, LPUART_BAUD_MATCFG(value)))
#define LPUART_BWR_BAUD_MATCFG(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MATCFG_SHIFT), LPUART_BAUD_MATCFG_SHIFT, LPUART_BAUD_MATCFG_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RDMAE[21] (RW)
 *
 * RDMAE configures the receiver data register full flag, LPUART_STAT[RDRF], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RDMAE field. */
#define LPUART_RD_BAUD_RDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RDMAE_MASK) >> LPUART_BAUD_RDMAE_SHIFT)
#define LPUART_BRD_BAUD_RDMAE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_RDMAE_SHIFT, LPUART_BAUD_RDMAE_WIDTH))

/*! @brief Set the RDMAE field to a new value. */
#define LPUART_WR_BAUD_RDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RDMAE_MASK, LPUART_BAUD_RDMAE(value)))
#define LPUART_BWR_BAUD_RDMAE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_RDMAE_SHIFT), LPUART_BAUD_RDMAE_SHIFT, LPUART_BAUD_RDMAE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field TDMAE[23] (RW)
 *
 * TDMAE configures the transmit data register empty flag, LPUART_STAT[TDRE], to
 * generate a DMA request.
 *
 * Values:
 * - 0b0 - DMA request disabled.
 * - 0b1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_TDMAE field. */
#define LPUART_RD_BAUD_TDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_TDMAE_MASK) >> LPUART_BAUD_TDMAE_SHIFT)
#define LPUART_BRD_BAUD_TDMAE(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_TDMAE_SHIFT, LPUART_BAUD_TDMAE_WIDTH))

/*! @brief Set the TDMAE field to a new value. */
#define LPUART_WR_BAUD_TDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_TDMAE_MASK, LPUART_BAUD_TDMAE(value)))
#define LPUART_BWR_BAUD_TDMAE(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_TDMAE_SHIFT), LPUART_BAUD_TDMAE_SHIFT, LPUART_BAUD_TDMAE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field OSR[28:24] (RW)
 *
 * This field configures the oversampling ratio for the receiver between 4x
 * (00011) and 32x (11111). Writing an invalid oversampling ratio will default to an
 * oversampling ratio of 16 (01111). This field should only be changed when the
 * transmitter and receiver are both disabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_OSR field. */
#define LPUART_RD_BAUD_OSR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_OSR_MASK) >> LPUART_BAUD_OSR_SHIFT)
#define LPUART_BRD_BAUD_OSR(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_OSR_SHIFT, LPUART_BAUD_OSR_WIDTH))

/*! @brief Set the OSR field to a new value. */
#define LPUART_WR_BAUD_OSR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_OSR_MASK, LPUART_BAUD_OSR(value)))
#define LPUART_BWR_BAUD_OSR(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_OSR_SHIFT), LPUART_BAUD_OSR_SHIFT, LPUART_BAUD_OSR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field M10[29] (RW)
 *
 * The M10 bit causes a tenth bit to be part of the serial transmission. This
 * bit should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit or 9-bit data characters.
 * - 0b1 - Receiver and transmitter use 10-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_M10 field. */
#define LPUART_RD_BAUD_M10(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_M10_MASK) >> LPUART_BAUD_M10_SHIFT)
#define LPUART_BRD_BAUD_M10(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_M10_SHIFT, LPUART_BAUD_M10_WIDTH))

/*! @brief Set the M10 field to a new value. */
#define LPUART_WR_BAUD_M10(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_M10_MASK, LPUART_BAUD_M10(value)))
#define LPUART_BWR_BAUD_M10(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_M10_SHIFT), LPUART_BAUD_M10_SHIFT, LPUART_BAUD_M10_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN2[30] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA2].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN2 field. */
#define LPUART_RD_BAUD_MAEN2(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN2_MASK) >> LPUART_BAUD_MAEN2_SHIFT)
#define LPUART_BRD_BAUD_MAEN2(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN2_SHIFT, LPUART_BAUD_MAEN2_WIDTH))

/*! @brief Set the MAEN2 field to a new value. */
#define LPUART_WR_BAUD_MAEN2(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN2_MASK, LPUART_BAUD_MAEN2(value)))
#define LPUART_BWR_BAUD_MAEN2(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MAEN2_SHIFT), LPUART_BAUD_MAEN2_SHIFT, LPUART_BAUD_MAEN2_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN1[31] (RW)
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Enables automatic address matching or data matching mode for
 *     MATCH[MA1].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN1 field. */
#define LPUART_RD_BAUD_MAEN1(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN1_MASK) >> LPUART_BAUD_MAEN1_SHIFT)
#define LPUART_BRD_BAUD_MAEN1(base) (BME_UBFX32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN1_SHIFT, LPUART_BAUD_MAEN1_WIDTH))

/*! @brief Set the MAEN1 field to a new value. */
#define LPUART_WR_BAUD_MAEN1(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN1_MASK, LPUART_BAUD_MAEN1(value)))
#define LPUART_BWR_BAUD_MAEN1(base, value) (BME_BFI32(&LPUART_BAUD_REG(base), ((uint32_t)(value) << LPUART_BAUD_MAEN1_SHIFT), LPUART_BAUD_MAEN1_SHIFT, LPUART_BAUD_MAEN1_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_STAT - LPUART Status Register
 ******************************************************************************/

/*!
 * @brief LPUART_STAT - LPUART Status Register (RW)
 *
 * Reset value: 0x00C00000U
 */
/*!
 * @name Constants and macros for entire LPUART_STAT register
 */
/*@{*/
#define LPUART_RD_STAT(base)     (LPUART_STAT_REG(base))
#define LPUART_WR_STAT(base, value) (LPUART_STAT_REG(base) = (value))
#define LPUART_RMW_STAT(base, mask, value) (LPUART_WR_STAT(base, (LPUART_RD_STAT(base) & ~(mask)) | (value)))
#define LPUART_SET_STAT(base, value) (BME_OR32(&LPUART_STAT_REG(base), (uint32_t)(value)))
#define LPUART_CLR_STAT(base, value) (BME_AND32(&LPUART_STAT_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_STAT(base, value) (BME_XOR32(&LPUART_STAT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_STAT bitfields
 */

/*!
 * @name Register LPUART_STAT, field MA2F[14] (W1C)
 *
 * MA2F is set whenever the next character to be read from LPUART_DATA matches
 * MA2. To clear MA2F, write a logic one to the MA2F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA2
 * - 0b1 - Received data is equal to MA2
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA2F field. */
#define LPUART_RD_STAT_MA2F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA2F_MASK) >> LPUART_STAT_MA2F_SHIFT)
#define LPUART_BRD_STAT_MA2F(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MA2F_SHIFT, LPUART_STAT_MA2F_WIDTH))

/*! @brief Set the MA2F field to a new value. */
#define LPUART_WR_STAT_MA2F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA2F(value)))
#define LPUART_BWR_STAT_MA2F(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MA2F_SHIFT), LPUART_STAT_MA2F_SHIFT, LPUART_STAT_MA2F_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MA1F[15] (W1C)
 *
 * MA1F is set whenever the next character to be read from LPUART_DATA matches
 * MA1. To clear MA1F, write a logic one to the MA1F.
 *
 * Values:
 * - 0b0 - Received data is not equal to MA1
 * - 0b1 - Received data is equal to MA1
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA1F field. */
#define LPUART_RD_STAT_MA1F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA1F_MASK) >> LPUART_STAT_MA1F_SHIFT)
#define LPUART_BRD_STAT_MA1F(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MA1F_SHIFT, LPUART_STAT_MA1F_WIDTH))

/*! @brief Set the MA1F field to a new value. */
#define LPUART_WR_STAT_MA1F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA1F(value)))
#define LPUART_BWR_STAT_MA1F(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MA1F_SHIFT), LPUART_STAT_MA1F_SHIFT, LPUART_STAT_MA1F_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field PF[16] (W1C)
 *
 * PF is set whenever the next character to be read from LPUART_DATA was
 * received when parity is enabled (PE = 1) and the parity bit in the received character
 * does not agree with the expected parity value. To clear PF, write a logic one
 * to the PF.
 *
 * Values:
 * - 0b0 - No parity error.
 * - 0b1 - Parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_PF field. */
#define LPUART_RD_STAT_PF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_PF_MASK) >> LPUART_STAT_PF_SHIFT)
#define LPUART_BRD_STAT_PF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_PF_SHIFT, LPUART_STAT_PF_WIDTH))

/*! @brief Set the PF field to a new value. */
#define LPUART_WR_STAT_PF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_PF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_PF(value)))
#define LPUART_BWR_STAT_PF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_PF_SHIFT), LPUART_STAT_PF_SHIFT, LPUART_STAT_PF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field FE[17] (W1C)
 *
 * FE is set whenever the next character to be read from LPUART_DATA was
 * received with logic 0 detected where a stop bit was expected. To clear NF, write
 * logic one to the NF.
 *
 * Values:
 * - 0b0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 0b1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_FE field. */
#define LPUART_RD_STAT_FE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_FE_MASK) >> LPUART_STAT_FE_SHIFT)
#define LPUART_BRD_STAT_FE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_FE_SHIFT, LPUART_STAT_FE_WIDTH))

/*! @brief Set the FE field to a new value. */
#define LPUART_WR_STAT_FE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_FE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_FE(value)))
#define LPUART_BWR_STAT_FE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_FE_SHIFT), LPUART_STAT_FE_SHIFT, LPUART_STAT_FE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field NF[18] (W1C)
 *
 * The advanced sampling technique used in the receiver takes three samples in
 * each of the received bits. If any of these samples disagrees with the rest of
 * the samples within any bit time in the frame then noise is detected for that
 * character. NF is set whenever the next character to be read from LPUART_DATA was
 * received with noise detected within the character. To clear NF, write logic
 * one to the NF.
 *
 * Values:
 * - 0b0 - No noise detected.
 * - 0b1 - Noise detected in the received character in LPUART_DATA.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_NF field. */
#define LPUART_RD_STAT_NF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_NF_MASK) >> LPUART_STAT_NF_SHIFT)
#define LPUART_BRD_STAT_NF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_NF_SHIFT, LPUART_STAT_NF_WIDTH))

/*! @brief Set the NF field to a new value. */
#define LPUART_WR_STAT_NF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_NF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_NF(value)))
#define LPUART_BWR_STAT_NF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_NF_SHIFT), LPUART_STAT_NF_SHIFT, LPUART_STAT_NF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field OR[19] (W1C)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the LPUART data registers is not
 * affected. If LBKDE is enabled and a LIN Break is detected, the OR field asserts
 * if LBKDIF is not cleared before the next data character is received. While
 * the OR flag is set, no additional data is stored in the data buffer even if
 * sufficient room exists. To clear OR, write logic 1 to the OR flag.
 *
 * Values:
 * - 0b0 - No overrun.
 * - 0b1 - Receive overrun (new LPUART data lost).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_OR field. */
#define LPUART_RD_STAT_OR(base) ((LPUART_STAT_REG(base) & LPUART_STAT_OR_MASK) >> LPUART_STAT_OR_SHIFT)
#define LPUART_BRD_STAT_OR(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_OR_SHIFT, LPUART_STAT_OR_WIDTH))

/*! @brief Set the OR field to a new value. */
#define LPUART_WR_STAT_OR(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_OR_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_OR(value)))
#define LPUART_BWR_STAT_OR(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_OR_SHIFT), LPUART_STAT_OR_SHIFT, LPUART_STAT_OR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field IDLE[20] (W1C)
 *
 * IDLE is set when the LPUART receive line becomes idle for a full character
 * time after a period of activity. When ILT is cleared, the receiver starts
 * counting idle bit times after the start bit. If the receive character is all 1s,
 * these bit times and the stop bits time count toward the full character time of
 * logic high, 10 to 13 bit times, needed for the receiver to detect an idle line.
 * When ILT is set, the receiver doesn't start counting idle bit times until
 * after the stop bits. The stop bits and any logic high bit times at the end of the
 * previous character do not count toward the full character time of logic high
 * needed for the receiver to detect an idle line. To clear IDLE, write logic 1 to
 * the IDLE flag. After IDLE has been cleared, it cannot become set again until
 * after a new character has been stored in the receive buffer or a LIN break
 * character has set the LBKDIF flag . IDLE is set only once even if the receive
 * line remains idle for an extended period.
 *
 * Values:
 * - 0b0 - No idle line detected.
 * - 0b1 - Idle line was detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_IDLE field. */
#define LPUART_RD_STAT_IDLE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_IDLE_MASK) >> LPUART_STAT_IDLE_SHIFT)
#define LPUART_BRD_STAT_IDLE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_IDLE_SHIFT, LPUART_STAT_IDLE_WIDTH))

/*! @brief Set the IDLE field to a new value. */
#define LPUART_WR_STAT_IDLE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_IDLE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_IDLE(value)))
#define LPUART_BWR_STAT_IDLE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_IDLE_SHIFT), LPUART_STAT_IDLE_SHIFT, LPUART_STAT_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RDRF[21] (RO)
 *
 * When the receive FIFO is enabled, RDRF is set when the number of datawords in
 * the receive buffer is equal to or more than the number indicated by
 * LPUART_WATER[RXWATER]. To clear RDRF, read LPUART_DATA until the number of datawords in
 * the receive data buffer is less than the number indicated by
 * LPUART_WATER[RXWATER]. When the receive FIFO is disabled,RDRF is set when the receive buffer
 * (LPUART_DATA) is full. To clear RDRF, read the LPUART_DATA register. A
 * character that is in the process of being received does not cause a change in RDRF
 * until the entire character is received. Even if RDRF is set, the character will
 * continue to be received until an overrun condition occurs once the entire
 * character is received.
 *
 * Values:
 * - 0b0 - Receive data buffer empty.
 * - 0b1 - Receive data buffer full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RDRF field. */
#define LPUART_RD_STAT_RDRF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RDRF_MASK) >> LPUART_STAT_RDRF_SHIFT)
#define LPUART_BRD_STAT_RDRF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RDRF_SHIFT, LPUART_STAT_RDRF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TC[22] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). TC is cleared by writing to
 * LPUART_DATA to transmit new data, queuing a preamble by clearing and then
 * setting LPUART_CTRL[TE], queuing a break character by writing 1 to
 * LPUART_CTRL[SBK].
 *
 * Values:
 * - 0b0 - Transmitter active (sending data, a preamble, or a break).
 * - 0b1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TC field. */
#define LPUART_RD_STAT_TC(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TC_MASK) >> LPUART_STAT_TC_SHIFT)
#define LPUART_BRD_STAT_TC(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_TC_SHIFT, LPUART_STAT_TC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TDRE[23] (RO)
 *
 * When the transmit FIFO is enabled, TDRE will set when the number of datawords
 * in the transmit FIFO (LPUART_DATA) is equal to or less than the number
 * indicated by LPUART_WATER[TXWATER]). To clear TDRE, write to the LPUART data
 * register (LPUART_DATA) until the number of words in the transmit FIFO is greater than
 * the number indicated by LPUART_WATER[TXWATER]. When the transmit FIFO is
 * disabled,TDRE will set when the transmit data register (LPUART_DATA) is empty. To
 * clear TDRE, write to the LPUART data register (LPUART_DATA). TDRE is not
 * affected by a character that is in the process of being transmitted, it is updated
 * at the start of each transmitted character.
 *
 * Values:
 * - 0b0 - Transmit data buffer full.
 * - 0b1 - Transmit data buffer empty.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TDRE field. */
#define LPUART_RD_STAT_TDRE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TDRE_MASK) >> LPUART_STAT_TDRE_SHIFT)
#define LPUART_BRD_STAT_TDRE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_TDRE_SHIFT, LPUART_STAT_TDRE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RAF[24] (RO)
 *
 * RAF is set when the receiver detects the beginning of a valid start bit, and
 * RAF is cleared automatically when the receiver detects an idle line.
 *
 * Values:
 * - 0b0 - LPUART receiver idle waiting for a start bit.
 * - 0b1 - LPUART receiver active (LPUART_RX input not idle).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RAF field. */
#define LPUART_RD_STAT_RAF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RAF_MASK) >> LPUART_STAT_RAF_SHIFT)
#define LPUART_BRD_STAT_RAF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RAF_SHIFT, LPUART_STAT_RAF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDE[25] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * receive data is not stored in the receive data buffer.
 *
 * Values:
 * - 0b0 - Break character is detected at length 10 bit times (if M = 0, SBNS =
 *     0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1
 *     or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is detected at length of 11 bit times (if M = 0, SBNS
 *     = 0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS
 *     = 1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDE field. */
#define LPUART_RD_STAT_LBKDE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDE_MASK) >> LPUART_STAT_LBKDE_SHIFT)
#define LPUART_BRD_STAT_LBKDE(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDE_SHIFT, LPUART_STAT_LBKDE_WIDTH))

/*! @brief Set the LBKDE field to a new value. */
#define LPUART_WR_STAT_LBKDE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_LBKDE(value)))
#define LPUART_BWR_STAT_LBKDE(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_LBKDE_SHIFT), LPUART_STAT_LBKDE_SHIFT, LPUART_STAT_LBKDE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field BRK13[26] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit. This bit should only be
 * changed when the transmitter is disabled.
 *
 * Values:
 * - 0b0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 0b1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_BRK13 field. */
#define LPUART_RD_STAT_BRK13(base) ((LPUART_STAT_REG(base) & LPUART_STAT_BRK13_MASK) >> LPUART_STAT_BRK13_SHIFT)
#define LPUART_BRD_STAT_BRK13(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_BRK13_SHIFT, LPUART_STAT_BRK13_WIDTH))

/*! @brief Set the BRK13 field to a new value. */
#define LPUART_WR_STAT_BRK13(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_BRK13_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_BRK13(value)))
#define LPUART_BWR_STAT_BRK13(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_BRK13_SHIFT), LPUART_STAT_BRK13_SHIFT, LPUART_STAT_BRK13_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RWUID[27] (RW)
 *
 * For RWU on idle character, RWUID controls whether the idle character that
 * wakes up the receiver sets the IDLE bit. For address match wakeup, RWUID controls
 * if the IDLE bit is set when the address does not match. This bit should only
 * be changed when the receiver is disabled.
 *
 * Values:
 * - 0b0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character. During address match wakeup, the
 *     IDLE bit does not get set when an address does not match.
 * - 0b1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character. During address match wakeup, the IDLE bit
 *     does get set when an address does not match.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RWUID field. */
#define LPUART_RD_STAT_RWUID(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RWUID_MASK) >> LPUART_STAT_RWUID_SHIFT)
#define LPUART_BRD_STAT_RWUID(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RWUID_SHIFT, LPUART_STAT_RWUID_WIDTH))

/*! @brief Set the RWUID field to a new value. */
#define LPUART_WR_STAT_RWUID(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RWUID_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RWUID(value)))
#define LPUART_BWR_STAT_RWUID(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RWUID_SHIFT), LPUART_STAT_RWUID_SHIFT, LPUART_STAT_RWUID_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the LPUART_RX input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0b0 - Receive data not inverted.
 * - 0b1 - Receive data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXINV field. */
#define LPUART_RD_STAT_RXINV(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXINV_MASK) >> LPUART_STAT_RXINV_SHIFT)
#define LPUART_BRD_STAT_RXINV(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RXINV_SHIFT, LPUART_STAT_RXINV_WIDTH))

/*! @brief Set the RXINV field to a new value. */
#define LPUART_WR_STAT_RXINV(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXINV_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXINV(value)))
#define LPUART_BWR_STAT_RXINV(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RXINV_SHIFT), LPUART_STAT_RXINV_SHIFT, LPUART_STAT_RXINV_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MSBF[29] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0b0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 0b1 - MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit depending on the setting of CTRL[M], CTRL[PE] and
 *     BAUD[M10]. Further, the first bit received after the start bit is
 *     identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and
 *     CTRL[PE].
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MSBF field. */
#define LPUART_RD_STAT_MSBF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MSBF_MASK) >> LPUART_STAT_MSBF_SHIFT)
#define LPUART_BRD_STAT_MSBF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_MSBF_SHIFT, LPUART_STAT_MSBF_WIDTH))

/*! @brief Set the MSBF field to a new value. */
#define LPUART_WR_STAT_MSBF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MSBF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MSBF(value)))
#define LPUART_BWR_STAT_MSBF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_MSBF_SHIFT), LPUART_STAT_MSBF_SHIFT, LPUART_STAT_MSBF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXEDGIF[30] (W1C)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the LPUART_RX pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No active edge on the receive pin has occurred.
 * - 0b1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXEDGIF field. */
#define LPUART_RD_STAT_RXEDGIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXEDGIF_MASK) >> LPUART_STAT_RXEDGIF_SHIFT)
#define LPUART_BRD_STAT_RXEDGIF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_RXEDGIF_SHIFT, LPUART_STAT_RXEDGIF_WIDTH))

/*! @brief Set the RXEDGIF field to a new value. */
#define LPUART_WR_STAT_RXEDGIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXEDGIF(value)))
#define LPUART_BWR_STAT_RXEDGIF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_RXEDGIF_SHIFT), LPUART_STAT_RXEDGIF_SHIFT, LPUART_STAT_RXEDGIF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDIF[31] (W1C)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No LIN break character has been detected.
 * - 0b1 - LIN break character has been detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDIF field. */
#define LPUART_RD_STAT_LBKDIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDIF_MASK) >> LPUART_STAT_LBKDIF_SHIFT)
#define LPUART_BRD_STAT_LBKDIF(base) (BME_UBFX32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDIF_SHIFT, LPUART_STAT_LBKDIF_WIDTH))

/*! @brief Set the LBKDIF field to a new value. */
#define LPUART_WR_STAT_LBKDIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK), LPUART_STAT_LBKDIF(value)))
#define LPUART_BWR_STAT_LBKDIF(base, value) (BME_BFI32(&LPUART_STAT_REG(base), ((uint32_t)(value) << LPUART_STAT_LBKDIF_SHIFT), LPUART_STAT_LBKDIF_SHIFT, LPUART_STAT_LBKDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_CTRL - LPUART Control Register
 ******************************************************************************/

/*!
 * @brief LPUART_CTRL - LPUART Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This read/write register controls various optional features of the LPUART
 * system. This register should only be altered when the transmitter and receiver
 * are both disabled.
 */
/*!
 * @name Constants and macros for entire LPUART_CTRL register
 */
/*@{*/
#define LPUART_RD_CTRL(base)     (LPUART_CTRL_REG(base))
#define LPUART_WR_CTRL(base, value) (LPUART_CTRL_REG(base) = (value))
#define LPUART_RMW_CTRL(base, mask, value) (LPUART_WR_CTRL(base, (LPUART_RD_CTRL(base) & ~(mask)) | (value)))
#define LPUART_SET_CTRL(base, value) (BME_OR32(&LPUART_CTRL_REG(base), (uint32_t)(value)))
#define LPUART_CLR_CTRL(base, value) (BME_AND32(&LPUART_CTRL_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_CTRL(base, value) (BME_XOR32(&LPUART_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_CTRL bitfields
 */

/*!
 * @name Register LPUART_CTRL, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0b0 - Even parity.
 * - 0b1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PT field. */
#define LPUART_RD_CTRL_PT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PT_MASK) >> LPUART_CTRL_PT_SHIFT)
#define LPUART_BRD_CTRL_PT(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PT_SHIFT, LPUART_CTRL_PT_WIDTH))

/*! @brief Set the PT field to a new value. */
#define LPUART_WR_CTRL_PT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PT_MASK, LPUART_CTRL_PT(value)))
#define LPUART_BWR_CTRL_PT(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PT_SHIFT), LPUART_CTRL_PT_SHIFT, LPUART_CTRL_PT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * bit immediately before the stop bit is treated as the parity bit.
 *
 * Values:
 * - 0b0 - No hardware parity generation or checking.
 * - 0b1 - Parity enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PE field. */
#define LPUART_RD_CTRL_PE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PE_MASK) >> LPUART_CTRL_PE_SHIFT)
#define LPUART_BRD_CTRL_PE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PE_SHIFT, LPUART_CTRL_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define LPUART_WR_CTRL_PE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PE_MASK, LPUART_CTRL_PE(value)))
#define LPUART_BWR_CTRL_PE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PE_SHIFT), LPUART_CTRL_PE_SHIFT, LPUART_CTRL_PE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the LPUART is programmed with ILT = 1, a
 * logic 0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count.
 *
 * Values:
 * - 0b0 - Idle character bit count starts after start bit.
 * - 0b1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILT field. */
#define LPUART_RD_CTRL_ILT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILT_MASK) >> LPUART_CTRL_ILT_SHIFT)
#define LPUART_BRD_CTRL_ILT(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILT_SHIFT, LPUART_CTRL_ILT_WIDTH))

/*! @brief Set the ILT field to a new value. */
#define LPUART_WR_CTRL_ILT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILT_MASK, LPUART_CTRL_ILT(value)))
#define LPUART_BWR_CTRL_ILT(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ILT_SHIFT), LPUART_CTRL_ILT_SHIFT, LPUART_CTRL_ILT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field WAKE[3] (RW)
 *
 * Determines which condition wakes the LPUART when RWU=1: Address mark in the
 * most significant bit position of a received data character, or An idle
 * condition on the receive pin input signal.
 *
 * Values:
 * - 0b0 - Configures RWU for idle-line wakeup.
 * - 0b1 - Configures RWU with address-mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_WAKE field. */
#define LPUART_RD_CTRL_WAKE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_WAKE_MASK) >> LPUART_CTRL_WAKE_SHIFT)
#define LPUART_BRD_CTRL_WAKE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_WAKE_SHIFT, LPUART_CTRL_WAKE_WIDTH))

/*! @brief Set the WAKE field to a new value. */
#define LPUART_WR_CTRL_WAKE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_WAKE_MASK, LPUART_CTRL_WAKE(value)))
#define LPUART_BWR_CTRL_WAKE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_WAKE_SHIFT), LPUART_CTRL_WAKE_SHIFT, LPUART_CTRL_WAKE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field M[4] (RW)
 *
 * Values:
 * - 0b0 - Receiver and transmitter use 8-bit data characters.
 * - 0b1 - Receiver and transmitter use 9-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_M field. */
#define LPUART_RD_CTRL_M(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_M_MASK) >> LPUART_CTRL_M_SHIFT)
#define LPUART_BRD_CTRL_M(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_M_SHIFT, LPUART_CTRL_M_WIDTH))

/*! @brief Set the M field to a new value. */
#define LPUART_WR_CTRL_M(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_M_MASK, LPUART_CTRL_M(value)))
#define LPUART_BWR_CTRL_M(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_M_SHIFT), LPUART_CTRL_M_SHIFT, LPUART_CTRL_M_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0b0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back
 *     mode and the LPUART does not use the LPUART_RX pin.
 * - 0b1 - Single-wire LPUART mode where the LPUART_TX pin is connected to the
 *     transmitter output and receiver input.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RSRC field. */
#define LPUART_RD_CTRL_RSRC(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RSRC_MASK) >> LPUART_CTRL_RSRC_SHIFT)
#define LPUART_BRD_CTRL_RSRC(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RSRC_SHIFT, LPUART_CTRL_RSRC_WIDTH))

/*! @brief Set the RSRC field to a new value. */
#define LPUART_WR_CTRL_RSRC(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RSRC_MASK, LPUART_CTRL_RSRC(value)))
#define LPUART_BWR_CTRL_RSRC(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RSRC_SHIFT), LPUART_CTRL_RSRC_SHIFT, LPUART_CTRL_RSRC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field DOZEEN[6] (RW)
 *
 * Values:
 * - 0b0 - LPUART is enabled in Doze mode.
 * - 0b1 - LPUART is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_DOZEEN field. */
#define LPUART_RD_CTRL_DOZEEN(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_DOZEEN_MASK) >> LPUART_CTRL_DOZEEN_SHIFT)
#define LPUART_BRD_CTRL_DOZEEN(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_DOZEEN_SHIFT, LPUART_CTRL_DOZEEN_WIDTH))

/*! @brief Set the DOZEEN field to a new value. */
#define LPUART_WR_CTRL_DOZEEN(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_DOZEEN_MASK, LPUART_CTRL_DOZEEN(value)))
#define LPUART_BWR_CTRL_DOZEEN(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_DOZEEN_SHIFT), LPUART_CTRL_DOZEEN_SHIFT, LPUART_CTRL_DOZEEN_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the LPUART_RX pin is disconnected from the LPUART and the
 * transmitter output is internally connected to the receiver input. The
 * transmitter and the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0b0 - Normal operation - LPUART_RX and LPUART_TX use separate pins.
 * - 0b1 - Loop mode or single-wire mode where transmitter outputs are
 *     internally connected to receiver input (see RSRC bit).
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_LOOPS field. */
#define LPUART_RD_CTRL_LOOPS(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_LOOPS_MASK) >> LPUART_CTRL_LOOPS_SHIFT)
#define LPUART_BRD_CTRL_LOOPS(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_LOOPS_SHIFT, LPUART_CTRL_LOOPS_WIDTH))

/*! @brief Set the LOOPS field to a new value. */
#define LPUART_WR_CTRL_LOOPS(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_LOOPS_MASK, LPUART_CTRL_LOOPS(value)))
#define LPUART_BWR_CTRL_LOOPS(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_LOOPS_SHIFT), LPUART_CTRL_LOOPS_SHIFT, LPUART_CTRL_LOOPS_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field IDLECFG[10:8] (RW)
 *
 * Configures the number of idle characters that must be received before the
 * IDLE flag is set.
 *
 * Values:
 * - 0b000 - 1 idle character
 * - 0b001 - 2 idle characters
 * - 0b010 - 4 idle characters
 * - 0b011 - 8 idle characters
 * - 0b100 - 16 idle characters
 * - 0b101 - 32 idle characters
 * - 0b110 - 64 idle characters
 * - 0b111 - 128 idle characters
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_IDLECFG field. */
#define LPUART_RD_CTRL_IDLECFG(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_IDLECFG_MASK) >> LPUART_CTRL_IDLECFG_SHIFT)
#define LPUART_BRD_CTRL_IDLECFG(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_IDLECFG_SHIFT, LPUART_CTRL_IDLECFG_WIDTH))

/*! @brief Set the IDLECFG field to a new value. */
#define LPUART_WR_CTRL_IDLECFG(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_IDLECFG_MASK, LPUART_CTRL_IDLECFG(value)))
#define LPUART_BWR_CTRL_IDLECFG(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_IDLECFG_SHIFT), LPUART_CTRL_IDLECFG_SHIFT, LPUART_CTRL_IDLECFG_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA2IE[14] (RW)
 *
 * Values:
 * - 0b0 - MA2F interrupt disabled
 * - 0b1 - MA2F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA2IE field. */
#define LPUART_RD_CTRL_MA2IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA2IE_MASK) >> LPUART_CTRL_MA2IE_SHIFT)
#define LPUART_BRD_CTRL_MA2IE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA2IE_SHIFT, LPUART_CTRL_MA2IE_WIDTH))

/*! @brief Set the MA2IE field to a new value. */
#define LPUART_WR_CTRL_MA2IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA2IE_MASK, LPUART_CTRL_MA2IE(value)))
#define LPUART_BWR_CTRL_MA2IE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_MA2IE_SHIFT), LPUART_CTRL_MA2IE_SHIFT, LPUART_CTRL_MA2IE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA1IE[15] (RW)
 *
 * Values:
 * - 0b0 - MA1F interrupt disabled
 * - 0b1 - MA1F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA1IE field. */
#define LPUART_RD_CTRL_MA1IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA1IE_MASK) >> LPUART_CTRL_MA1IE_SHIFT)
#define LPUART_BRD_CTRL_MA1IE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA1IE_SHIFT, LPUART_CTRL_MA1IE_WIDTH))

/*! @brief Set the MA1IE field to a new value. */
#define LPUART_WR_CTRL_MA1IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA1IE_MASK, LPUART_CTRL_MA1IE(value)))
#define LPUART_BWR_CTRL_MA1IE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_MA1IE_SHIFT), LPUART_CTRL_MA1IE_SHIFT, LPUART_CTRL_MA1IE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field SBK[16] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 to 13, or 13 to 16 if
 * LPUART_STATBRK13] is set, bit times of logic 0 are queued as long as SBK is set. Depending
 * on the timing of the set and clear of SBK relative to the information
 * currently being transmitted, a second break character may be queued before software
 * clears SBK.
 *
 * Values:
 * - 0b0 - Normal transmitter operation.
 * - 0b1 - Queue break character(s) to be sent.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_SBK field. */
#define LPUART_RD_CTRL_SBK(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_SBK_MASK) >> LPUART_CTRL_SBK_SHIFT)
#define LPUART_BRD_CTRL_SBK(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_SBK_SHIFT, LPUART_CTRL_SBK_WIDTH))

/*! @brief Set the SBK field to a new value. */
#define LPUART_WR_CTRL_SBK(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_SBK_MASK, LPUART_CTRL_SBK(value)))
#define LPUART_BWR_CTRL_SBK(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_SBK_SHIFT), LPUART_CTRL_SBK_SHIFT, LPUART_CTRL_SBK_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RWU[17] (RW)
 *
 * This field can be set to place the LPUART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * CTRL[WAKE] is clear or an address match when CTRL[WAKE] is set with STAT[RWUID] is
 * clear. RWU must be set only with CTRL[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by STAT[RAF]. If the flag is
 * set to wake up an IDLE event and the channel is already idle, it is possible
 * that the LPUART will discard data. This is because the data must be received or
 * a LIN break detected after an IDLE is detected before IDLE is allowed to be
 * reasserted.
 *
 * Values:
 * - 0b0 - Normal receiver operation.
 * - 0b1 - LPUART receiver in standby waiting for wakeup condition.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RWU field. */
#define LPUART_RD_CTRL_RWU(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RWU_MASK) >> LPUART_CTRL_RWU_SHIFT)
#define LPUART_BRD_CTRL_RWU(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RWU_SHIFT, LPUART_CTRL_RWU_WIDTH))

/*! @brief Set the RWU field to a new value. */
#define LPUART_WR_CTRL_RWU(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RWU_MASK, LPUART_CTRL_RWU(value)))
#define LPUART_BWR_CTRL_RWU(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RWU_SHIFT), LPUART_CTRL_RWU_SHIFT, LPUART_CTRL_RWU_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RE[18] (RW)
 *
 * Enables the LPUART receiver. When RE is written to 0, this register bit will
 * read as 1 until the receiver finishes receiving the current character (if any).
 *
 * Values:
 * - 0b0 - Receiver disabled.
 * - 0b1 - Receiver enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RE field. */
#define LPUART_RD_CTRL_RE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RE_MASK) >> LPUART_CTRL_RE_SHIFT)
#define LPUART_BRD_CTRL_RE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RE_SHIFT, LPUART_CTRL_RE_WIDTH))

/*! @brief Set the RE field to a new value. */
#define LPUART_WR_CTRL_RE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RE_MASK, LPUART_CTRL_RE(value)))
#define LPUART_BWR_CTRL_RE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RE_SHIFT), LPUART_CTRL_RE_SHIFT, LPUART_CTRL_RE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TE[19] (RW)
 *
 * Enables the LPUART transmitter. TE can also be used to queue an idle preamble
 * by clearing and then setting TE. When TE is cleared, this register bit will
 * read as 1 until the transmitter has completed the current character and the
 * LPUART_TX pin is tristated.
 *
 * Values:
 * - 0b0 - Transmitter disabled.
 * - 0b1 - Transmitter enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TE field. */
#define LPUART_RD_CTRL_TE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TE_MASK) >> LPUART_CTRL_TE_SHIFT)
#define LPUART_BRD_CTRL_TE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TE_SHIFT, LPUART_CTRL_TE_WIDTH))

/*! @brief Set the TE field to a new value. */
#define LPUART_WR_CTRL_TE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TE_MASK, LPUART_CTRL_TE(value)))
#define LPUART_BWR_CTRL_TE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TE_SHIFT), LPUART_CTRL_TE_SHIFT, LPUART_CTRL_TE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILIE[20] (RW)
 *
 * ILIE enables the idle line flag, STAT[IDLE], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from IDLE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILIE field. */
#define LPUART_RD_CTRL_ILIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILIE_MASK) >> LPUART_CTRL_ILIE_SHIFT)
#define LPUART_BRD_CTRL_ILIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILIE_SHIFT, LPUART_CTRL_ILIE_WIDTH))

/*! @brief Set the ILIE field to a new value. */
#define LPUART_WR_CTRL_ILIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILIE_MASK, LPUART_CTRL_ILIE(value)))
#define LPUART_BWR_CTRL_ILIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ILIE_SHIFT), LPUART_CTRL_ILIE_SHIFT, LPUART_CTRL_ILIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RIE[21] (RW)
 *
 * Enables STAT[RDRF] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from RDRF disabled; use polling.
 * - 0b1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RIE field. */
#define LPUART_RD_CTRL_RIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RIE_MASK) >> LPUART_CTRL_RIE_SHIFT)
#define LPUART_BRD_CTRL_RIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_RIE_SHIFT, LPUART_CTRL_RIE_WIDTH))

/*! @brief Set the RIE field to a new value. */
#define LPUART_WR_CTRL_RIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RIE_MASK, LPUART_CTRL_RIE(value)))
#define LPUART_BWR_CTRL_RIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_RIE_SHIFT), LPUART_CTRL_RIE_SHIFT, LPUART_CTRL_RIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TCIE[22] (RW)
 *
 * TCIE enables the transmission complete flag, TC, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TC disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TCIE field. */
#define LPUART_RD_CTRL_TCIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TCIE_MASK) >> LPUART_CTRL_TCIE_SHIFT)
#define LPUART_BRD_CTRL_TCIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TCIE_SHIFT, LPUART_CTRL_TCIE_WIDTH))

/*! @brief Set the TCIE field to a new value. */
#define LPUART_WR_CTRL_TCIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TCIE_MASK, LPUART_CTRL_TCIE(value)))
#define LPUART_BWR_CTRL_TCIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TCIE_SHIFT), LPUART_CTRL_TCIE_SHIFT, LPUART_CTRL_TCIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TIE[23] (RW)
 *
 * Enables STAT[TDRE] to generate interrupt requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from TDRE disabled; use polling.
 * - 0b1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TIE field. */
#define LPUART_RD_CTRL_TIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TIE_MASK) >> LPUART_CTRL_TIE_SHIFT)
#define LPUART_BRD_CTRL_TIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TIE_SHIFT, LPUART_CTRL_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPUART_WR_CTRL_TIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TIE_MASK, LPUART_CTRL_TIE(value)))
#define LPUART_BWR_CTRL_TIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TIE_SHIFT), LPUART_CTRL_TIE_SHIFT, LPUART_CTRL_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PEIE[24] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - PF interrupts disabled; use polling).
 * - 0b1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PEIE field. */
#define LPUART_RD_CTRL_PEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PEIE_MASK) >> LPUART_CTRL_PEIE_SHIFT)
#define LPUART_BRD_CTRL_PEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_PEIE_SHIFT, LPUART_CTRL_PEIE_WIDTH))

/*! @brief Set the PEIE field to a new value. */
#define LPUART_WR_CTRL_PEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PEIE_MASK, LPUART_CTRL_PEIE(value)))
#define LPUART_BWR_CTRL_PEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_PEIE_SHIFT), LPUART_CTRL_PEIE_SHIFT, LPUART_CTRL_PEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field FEIE[25] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - FE interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_FEIE field. */
#define LPUART_RD_CTRL_FEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_FEIE_MASK) >> LPUART_CTRL_FEIE_SHIFT)
#define LPUART_BRD_CTRL_FEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_FEIE_SHIFT, LPUART_CTRL_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define LPUART_WR_CTRL_FEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_FEIE_MASK, LPUART_CTRL_FEIE(value)))
#define LPUART_BWR_CTRL_FEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_FEIE_SHIFT), LPUART_CTRL_FEIE_SHIFT, LPUART_CTRL_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field NEIE[26] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0b0 - NF interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_NEIE field. */
#define LPUART_RD_CTRL_NEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_NEIE_MASK) >> LPUART_CTRL_NEIE_SHIFT)
#define LPUART_BRD_CTRL_NEIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_NEIE_SHIFT, LPUART_CTRL_NEIE_WIDTH))

/*! @brief Set the NEIE field to a new value. */
#define LPUART_WR_CTRL_NEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_NEIE_MASK, LPUART_CTRL_NEIE(value)))
#define LPUART_BWR_CTRL_NEIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_NEIE_SHIFT), LPUART_CTRL_NEIE_SHIFT, LPUART_CTRL_NEIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ORIE[27] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0b0 - OR interrupts disabled; use polling.
 * - 0b1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ORIE field. */
#define LPUART_RD_CTRL_ORIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ORIE_MASK) >> LPUART_CTRL_ORIE_SHIFT)
#define LPUART_BRD_CTRL_ORIE(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_ORIE_SHIFT, LPUART_CTRL_ORIE_WIDTH))

/*! @brief Set the ORIE field to a new value. */
#define LPUART_WR_CTRL_ORIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ORIE_MASK, LPUART_CTRL_ORIE(value)))
#define LPUART_BWR_CTRL_ORIE(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_ORIE_SHIFT), LPUART_CTRL_ORIE_SHIFT, LPUART_CTRL_ORIE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the LPUART_TX output for all cases: data bits, start and stop
 * bits, break, and idle.
 *
 * Values:
 * - 0b0 - Transmit data not inverted.
 * - 0b1 - Transmit data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXINV field. */
#define LPUART_RD_CTRL_TXINV(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXINV_MASK) >> LPUART_CTRL_TXINV_SHIFT)
#define LPUART_BRD_CTRL_TXINV(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXINV_SHIFT, LPUART_CTRL_TXINV_WIDTH))

/*! @brief Set the TXINV field to a new value. */
#define LPUART_WR_CTRL_TXINV(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXINV_MASK, LPUART_CTRL_TXINV(value)))
#define LPUART_BWR_CTRL_TXINV(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TXINV_SHIFT), LPUART_CTRL_TXINV_SHIFT, LPUART_CTRL_TXINV_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXDIR[29] (RW)
 *
 * When the LPUART is configured for single-wire half-duplex operation (LOOPS =
 * RSRC = 1), this bit determines the direction of data at the LPUART_TX pin.
 * When clearing TXDIR, the transmitter will finish receiving the current character
 * (if any) before the receiver starts receiving data from the LPUART_TX pin.
 *
 * Values:
 * - 0b0 - LPUART_TX pin is an input in single-wire mode.
 * - 0b1 - LPUART_TX pin is an output in single-wire mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXDIR field. */
#define LPUART_RD_CTRL_TXDIR(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXDIR_MASK) >> LPUART_CTRL_TXDIR_SHIFT)
#define LPUART_BRD_CTRL_TXDIR(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXDIR_SHIFT, LPUART_CTRL_TXDIR_WIDTH))

/*! @brief Set the TXDIR field to a new value. */
#define LPUART_WR_CTRL_TXDIR(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXDIR_MASK, LPUART_CTRL_TXDIR(value)))
#define LPUART_BWR_CTRL_TXDIR(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_TXDIR_SHIFT), LPUART_CTRL_TXDIR_SHIFT, LPUART_CTRL_TXDIR_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R9T8[30] (RW)
 *
 * R9 is the tenth data bit received when the LPUART is configured for 10-bit
 * data formats. When reading 10-bit data, read R9 before reading LPUART_DATA T8 is
 * the ninth data bit received when the LPUART is configured for 9-bit or 10-bit
 * data formats. When writing 9-bit or 10-bit data, write T8 before writing
 * LPUART_DATA. If T8 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written each
 * time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R9T8 field. */
#define LPUART_RD_CTRL_R9T8(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R9T8_MASK) >> LPUART_CTRL_R9T8_SHIFT)
#define LPUART_BRD_CTRL_R9T8(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_R9T8_SHIFT, LPUART_CTRL_R9T8_WIDTH))

/*! @brief Set the R9T8 field to a new value. */
#define LPUART_WR_CTRL_R9T8(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R9T8_MASK, LPUART_CTRL_R9T8(value)))
#define LPUART_BWR_CTRL_R9T8(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_R9T8_SHIFT), LPUART_CTRL_R9T8_SHIFT, LPUART_CTRL_R9T8_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R8T9[31] (RW)
 *
 * R8 is the ninth data bit received when the LPUART is configured for 9-bit or
 * 10-bit data formats. When reading 9-bit or 10-bit data, read R8 before reading
 * LPUART_DATA. T9 is the tenth data bit received when the LPUART is configured
 * for 10-bit data formats. When writing 10-bit data, write T9 before writing
 * LPUART_DATA. If T9 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written
 * each time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R8T9 field. */
#define LPUART_RD_CTRL_R8T9(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R8T9_MASK) >> LPUART_CTRL_R8T9_SHIFT)
#define LPUART_BRD_CTRL_R8T9(base) (BME_UBFX32(&LPUART_CTRL_REG(base), LPUART_CTRL_R8T9_SHIFT, LPUART_CTRL_R8T9_WIDTH))

/*! @brief Set the R8T9 field to a new value. */
#define LPUART_WR_CTRL_R8T9(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R8T9_MASK, LPUART_CTRL_R8T9(value)))
#define LPUART_BWR_CTRL_R8T9(base, value) (BME_BFI32(&LPUART_CTRL_REG(base), ((uint32_t)(value) << LPUART_CTRL_R8T9_SHIFT), LPUART_CTRL_R8T9_SHIFT, LPUART_CTRL_R8T9_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_DATA - LPUART Data Register
 ******************************************************************************/

/*!
 * @brief LPUART_DATA - LPUART Data Register (RW)
 *
 * Reset value: 0x00001000U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for some of the LPUART status flags.
 */
/*!
 * @name Constants and macros for entire LPUART_DATA register
 */
/*@{*/
#define LPUART_RD_DATA(base)     (LPUART_DATA_REG(base))
#define LPUART_WR_DATA(base, value) (LPUART_DATA_REG(base) = (value))
#define LPUART_RMW_DATA(base, mask, value) (LPUART_WR_DATA(base, (LPUART_RD_DATA(base) & ~(mask)) | (value)))
#define LPUART_SET_DATA(base, value) (BME_OR32(&LPUART_DATA_REG(base), (uint32_t)(value)))
#define LPUART_CLR_DATA(base, value) (BME_AND32(&LPUART_DATA_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_DATA(base, value) (BME_XOR32(&LPUART_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_DATA bitfields
 */

/*!
 * @name Register LPUART_DATA, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R0T0 field. */
#define LPUART_RD_DATA_R0T0(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R0T0_MASK) >> LPUART_DATA_R0T0_SHIFT)
#define LPUART_BRD_DATA_R0T0(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R0T0_SHIFT, LPUART_DATA_R0T0_WIDTH))

/*! @brief Set the R0T0 field to a new value. */
#define LPUART_WR_DATA_R0T0(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R0T0_MASK, LPUART_DATA_R0T0(value)))
#define LPUART_BWR_DATA_R0T0(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R0T0_SHIFT), LPUART_DATA_R0T0_SHIFT, LPUART_DATA_R0T0_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R1T1 field. */
#define LPUART_RD_DATA_R1T1(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R1T1_MASK) >> LPUART_DATA_R1T1_SHIFT)
#define LPUART_BRD_DATA_R1T1(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R1T1_SHIFT, LPUART_DATA_R1T1_WIDTH))

/*! @brief Set the R1T1 field to a new value. */
#define LPUART_WR_DATA_R1T1(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R1T1_MASK, LPUART_DATA_R1T1(value)))
#define LPUART_BWR_DATA_R1T1(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R1T1_SHIFT), LPUART_DATA_R1T1_SHIFT, LPUART_DATA_R1T1_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R2T2 field. */
#define LPUART_RD_DATA_R2T2(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R2T2_MASK) >> LPUART_DATA_R2T2_SHIFT)
#define LPUART_BRD_DATA_R2T2(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R2T2_SHIFT, LPUART_DATA_R2T2_WIDTH))

/*! @brief Set the R2T2 field to a new value. */
#define LPUART_WR_DATA_R2T2(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R2T2_MASK, LPUART_DATA_R2T2(value)))
#define LPUART_BWR_DATA_R2T2(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R2T2_SHIFT), LPUART_DATA_R2T2_SHIFT, LPUART_DATA_R2T2_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R3T3 field. */
#define LPUART_RD_DATA_R3T3(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R3T3_MASK) >> LPUART_DATA_R3T3_SHIFT)
#define LPUART_BRD_DATA_R3T3(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R3T3_SHIFT, LPUART_DATA_R3T3_WIDTH))

/*! @brief Set the R3T3 field to a new value. */
#define LPUART_WR_DATA_R3T3(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R3T3_MASK, LPUART_DATA_R3T3(value)))
#define LPUART_BWR_DATA_R3T3(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R3T3_SHIFT), LPUART_DATA_R3T3_SHIFT, LPUART_DATA_R3T3_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R4T4 field. */
#define LPUART_RD_DATA_R4T4(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R4T4_MASK) >> LPUART_DATA_R4T4_SHIFT)
#define LPUART_BRD_DATA_R4T4(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R4T4_SHIFT, LPUART_DATA_R4T4_WIDTH))

/*! @brief Set the R4T4 field to a new value. */
#define LPUART_WR_DATA_R4T4(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R4T4_MASK, LPUART_DATA_R4T4(value)))
#define LPUART_BWR_DATA_R4T4(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R4T4_SHIFT), LPUART_DATA_R4T4_SHIFT, LPUART_DATA_R4T4_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R5T5 field. */
#define LPUART_RD_DATA_R5T5(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R5T5_MASK) >> LPUART_DATA_R5T5_SHIFT)
#define LPUART_BRD_DATA_R5T5(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R5T5_SHIFT, LPUART_DATA_R5T5_WIDTH))

/*! @brief Set the R5T5 field to a new value. */
#define LPUART_WR_DATA_R5T5(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R5T5_MASK, LPUART_DATA_R5T5(value)))
#define LPUART_BWR_DATA_R5T5(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R5T5_SHIFT), LPUART_DATA_R5T5_SHIFT, LPUART_DATA_R5T5_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R6T6 field. */
#define LPUART_RD_DATA_R6T6(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R6T6_MASK) >> LPUART_DATA_R6T6_SHIFT)
#define LPUART_BRD_DATA_R6T6(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R6T6_SHIFT, LPUART_DATA_R6T6_WIDTH))

/*! @brief Set the R6T6 field to a new value. */
#define LPUART_WR_DATA_R6T6(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R6T6_MASK, LPUART_DATA_R6T6(value)))
#define LPUART_BWR_DATA_R6T6(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R6T6_SHIFT), LPUART_DATA_R6T6_SHIFT, LPUART_DATA_R6T6_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R7T7 field. */
#define LPUART_RD_DATA_R7T7(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R7T7_MASK) >> LPUART_DATA_R7T7_SHIFT)
#define LPUART_BRD_DATA_R7T7(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R7T7_SHIFT, LPUART_DATA_R7T7_WIDTH))

/*! @brief Set the R7T7 field to a new value. */
#define LPUART_WR_DATA_R7T7(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R7T7_MASK, LPUART_DATA_R7T7(value)))
#define LPUART_BWR_DATA_R7T7(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R7T7_SHIFT), LPUART_DATA_R7T7_SHIFT, LPUART_DATA_R7T7_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R8T8[8] (RW)
 *
 * Read receive data buffer 8 or write transmit data buffer 8.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R8T8 field. */
#define LPUART_RD_DATA_R8T8(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R8T8_MASK) >> LPUART_DATA_R8T8_SHIFT)
#define LPUART_BRD_DATA_R8T8(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R8T8_SHIFT, LPUART_DATA_R8T8_WIDTH))

/*! @brief Set the R8T8 field to a new value. */
#define LPUART_WR_DATA_R8T8(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R8T8_MASK, LPUART_DATA_R8T8(value)))
#define LPUART_BWR_DATA_R8T8(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R8T8_SHIFT), LPUART_DATA_R8T8_SHIFT, LPUART_DATA_R8T8_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R9T9[9] (RW)
 *
 * Read receive data buffer 9 or write transmit data buffer 9.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R9T9 field. */
#define LPUART_RD_DATA_R9T9(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R9T9_MASK) >> LPUART_DATA_R9T9_SHIFT)
#define LPUART_BRD_DATA_R9T9(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_R9T9_SHIFT, LPUART_DATA_R9T9_WIDTH))

/*! @brief Set the R9T9 field to a new value. */
#define LPUART_WR_DATA_R9T9(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R9T9_MASK, LPUART_DATA_R9T9(value)))
#define LPUART_BWR_DATA_R9T9(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_R9T9_SHIFT), LPUART_DATA_R9T9_SHIFT, LPUART_DATA_R9T9_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field IDLINE[11] (RO)
 *
 * Indicates the receiver line was idle before receiving the character in
 * DATA[9:0]. Unlike the IDLE flag, this bit can set for the first character received
 * when the receiver is first enabled.
 *
 * Values:
 * - 0b0 - Receiver was not idle before receiving this character.
 * - 0b1 - Receiver was idle before receiving this character.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_IDLINE field. */
#define LPUART_RD_DATA_IDLINE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_IDLINE_MASK) >> LPUART_DATA_IDLINE_SHIFT)
#define LPUART_BRD_DATA_IDLINE(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_IDLINE_SHIFT, LPUART_DATA_IDLINE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field RXEMPT[12] (RO)
 *
 * Asserts when there is no data in the receive buffer. This field does not take
 * into account data that is in the receive shift register.
 *
 * Values:
 * - 0b0 - Receive buffer contains valid data.
 * - 0b1 - Receive buffer is empty, data returned on read is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_RXEMPT field. */
#define LPUART_RD_DATA_RXEMPT(base) ((LPUART_DATA_REG(base) & LPUART_DATA_RXEMPT_MASK) >> LPUART_DATA_RXEMPT_SHIFT)
#define LPUART_BRD_DATA_RXEMPT(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_RXEMPT_SHIFT, LPUART_DATA_RXEMPT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field FRETSC[13] (RW)
 *
 * For reads, indicates the current received dataword contained in DATA[R9:R0]
 * was received with a frame error. For writes, indicates a break or idle
 * character is to be transmitted instead of the contents in DATA[T9:T0]. T9 is used to
 * indicate a break character when 0 and a idle character when 1, he contents of
 * DATA[T8:T0] should be zero.
 *
 * Values:
 * - 0b0 - The dataword was received without a frame error on read, transmit a
 *     normal character on write.
 * - 0b1 - The dataword was received with a frame error, transmit an idle or
 *     break character on transmit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_FRETSC field. */
#define LPUART_RD_DATA_FRETSC(base) ((LPUART_DATA_REG(base) & LPUART_DATA_FRETSC_MASK) >> LPUART_DATA_FRETSC_SHIFT)
#define LPUART_BRD_DATA_FRETSC(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_FRETSC_SHIFT, LPUART_DATA_FRETSC_WIDTH))

/*! @brief Set the FRETSC field to a new value. */
#define LPUART_WR_DATA_FRETSC(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_FRETSC_MASK, LPUART_DATA_FRETSC(value)))
#define LPUART_BWR_DATA_FRETSC(base, value) (BME_BFI32(&LPUART_DATA_REG(base), ((uint32_t)(value) << LPUART_DATA_FRETSC_SHIFT), LPUART_DATA_FRETSC_SHIFT, LPUART_DATA_FRETSC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field PARITYE[14] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with a
 * parity error.
 *
 * Values:
 * - 0b0 - The dataword was received without a parity error.
 * - 0b1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_PARITYE field. */
#define LPUART_RD_DATA_PARITYE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_PARITYE_MASK) >> LPUART_DATA_PARITYE_SHIFT)
#define LPUART_BRD_DATA_PARITYE(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_PARITYE_SHIFT, LPUART_DATA_PARITYE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_DATA, field NOISY[15] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with
 * noise.
 *
 * Values:
 * - 0b0 - The dataword was received without noise.
 * - 0b1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_NOISY field. */
#define LPUART_RD_DATA_NOISY(base) ((LPUART_DATA_REG(base) & LPUART_DATA_NOISY_MASK) >> LPUART_DATA_NOISY_SHIFT)
#define LPUART_BRD_DATA_NOISY(base) (BME_UBFX32(&LPUART_DATA_REG(base), LPUART_DATA_NOISY_SHIFT, LPUART_DATA_NOISY_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_MATCH - LPUART Match Address Register
 ******************************************************************************/

/*!
 * @brief LPUART_MATCH - LPUART Match Address Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_MATCH register
 */
/*@{*/
#define LPUART_RD_MATCH(base)    (LPUART_MATCH_REG(base))
#define LPUART_WR_MATCH(base, value) (LPUART_MATCH_REG(base) = (value))
#define LPUART_RMW_MATCH(base, mask, value) (LPUART_WR_MATCH(base, (LPUART_RD_MATCH(base) & ~(mask)) | (value)))
#define LPUART_SET_MATCH(base, value) (BME_OR32(&LPUART_MATCH_REG(base), (uint32_t)(value)))
#define LPUART_CLR_MATCH(base, value) (BME_AND32(&LPUART_MATCH_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_MATCH(base, value) (BME_XOR32(&LPUART_MATCH_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MATCH bitfields
 */

/*!
 * @name Register LPUART_MATCH, field MA1[9:0] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA1 field. */
#define LPUART_RD_MATCH_MA1(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA1_MASK) >> LPUART_MATCH_MA1_SHIFT)
#define LPUART_BRD_MATCH_MA1(base) (LPUART_RD_MATCH_MA1(base))

/*! @brief Set the MA1 field to a new value. */
#define LPUART_WR_MATCH_MA1(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA1_MASK, LPUART_MATCH_MA1(value)))
#define LPUART_BWR_MATCH_MA1(base, value) (LPUART_WR_MATCH_MA1(base, value))
/*@}*/

/*!
 * @name Register LPUART_MATCH, field MA2[25:16] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA2 field. */
#define LPUART_RD_MATCH_MA2(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA2_MASK) >> LPUART_MATCH_MA2_SHIFT)
#define LPUART_BRD_MATCH_MA2(base) (LPUART_RD_MATCH_MA2(base))

/*! @brief Set the MA2 field to a new value. */
#define LPUART_WR_MATCH_MA2(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA2_MASK, LPUART_MATCH_MA2(value)))
#define LPUART_BWR_MATCH_MA2(base, value) (LPUART_WR_MATCH_MA2(base, value))
/*@}*/

/*******************************************************************************
 * LPUART_MODIR - LPUART Modem IrDA Register
 ******************************************************************************/

/*!
 * @brief LPUART_MODIR - LPUART Modem IrDA Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MODEM register controls options for setting the modem configuration.
 */
/*!
 * @name Constants and macros for entire LPUART_MODIR register
 */
/*@{*/
#define LPUART_RD_MODIR(base)    (LPUART_MODIR_REG(base))
#define LPUART_WR_MODIR(base, value) (LPUART_MODIR_REG(base) = (value))
#define LPUART_RMW_MODIR(base, mask, value) (LPUART_WR_MODIR(base, (LPUART_RD_MODIR(base) & ~(mask)) | (value)))
#define LPUART_SET_MODIR(base, value) (BME_OR32(&LPUART_MODIR_REG(base), (uint32_t)(value)))
#define LPUART_CLR_MODIR(base, value) (BME_AND32(&LPUART_MODIR_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_MODIR(base, value) (BME_XOR32(&LPUART_MODIR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MODIR bitfields
 */

/*!
 * @name Register LPUART_MODIR, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0b0 - CTS has no effect on the transmitter.
 * - 0b1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as
 *     a character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSE field. */
#define LPUART_RD_MODIR_TXCTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSE_MASK) >> LPUART_MODIR_TXCTSE_SHIFT)
#define LPUART_BRD_MODIR_TXCTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSE_SHIFT, LPUART_MODIR_TXCTSE_WIDTH))

/*! @brief Set the TXCTSE field to a new value. */
#define LPUART_WR_MODIR_TXCTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSE_MASK, LPUART_MODIR_TXCTSE(value)))
#define LPUART_BWR_MODIR_TXCTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSE_SHIFT), LPUART_MODIR_TXCTSE_SHIFT, LPUART_MODIR_TXCTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0b0 - The transmitter has no effect on RTS.
 * - 0b1 - When a character is placed into an empty transmitter data buffer ,
 *     RTS asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSE field. */
#define LPUART_RD_MODIR_TXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSE_MASK) >> LPUART_MODIR_TXRTSE_SHIFT)
#define LPUART_BRD_MODIR_TXRTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSE_SHIFT, LPUART_MODIR_TXRTSE_WIDTH))

/*! @brief Set the TXRTSE field to a new value. */
#define LPUART_WR_MODIR_TXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSE_MASK, LPUART_MODIR_TXRTSE(value)))
#define LPUART_BWR_MODIR_TXRTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXRTSE_SHIFT), LPUART_MODIR_TXRTSE_SHIFT, LPUART_MODIR_TXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0b0 - Transmitter RTS is active low.
 * - 0b1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSPOL field. */
#define LPUART_RD_MODIR_TXRTSPOL(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSPOL_MASK) >> LPUART_MODIR_TXRTSPOL_SHIFT)
#define LPUART_BRD_MODIR_TXRTSPOL(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSPOL_SHIFT, LPUART_MODIR_TXRTSPOL_WIDTH))

/*! @brief Set the TXRTSPOL field to a new value. */
#define LPUART_WR_MODIR_TXRTSPOL(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSPOL_MASK, LPUART_MODIR_TXRTSPOL(value)))
#define LPUART_BWR_MODIR_TXRTSPOL(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXRTSPOL_SHIFT), LPUART_MODIR_TXRTSPOL_SHIFT, LPUART_MODIR_TXRTSPOL_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0b0 - The receiver has no effect on RTS.
 * - 0b1 - RTS assertion is configured by the RTSWATER field
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_RXRTSE field. */
#define LPUART_RD_MODIR_RXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_RXRTSE_MASK) >> LPUART_MODIR_RXRTSE_SHIFT)
#define LPUART_BRD_MODIR_RXRTSE(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_RXRTSE_SHIFT, LPUART_MODIR_RXRTSE_WIDTH))

/*! @brief Set the RXRTSE field to a new value. */
#define LPUART_WR_MODIR_RXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_RXRTSE_MASK, LPUART_MODIR_RXRTSE(value)))
#define LPUART_BWR_MODIR_RXRTSE(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_RXRTSE_SHIFT), LPUART_MODIR_RXRTSE_SHIFT, LPUART_MODIR_RXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSC[4] (RW)
 *
 * Configures if the CTS state is checked at the start of each character or only
 * when the transmitter is idle.
 *
 * Values:
 * - 0b0 - CTS input is sampled at the start of each character.
 * - 0b1 - CTS input is sampled when the transmitter is idle.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSC field. */
#define LPUART_RD_MODIR_TXCTSC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSC_MASK) >> LPUART_MODIR_TXCTSC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSC(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSC_SHIFT, LPUART_MODIR_TXCTSC_WIDTH))

/*! @brief Set the TXCTSC field to a new value. */
#define LPUART_WR_MODIR_TXCTSC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSC_MASK, LPUART_MODIR_TXCTSC(value)))
#define LPUART_BWR_MODIR_TXCTSC(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSC_SHIFT), LPUART_MODIR_TXCTSC_SHIFT, LPUART_MODIR_TXCTSC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSSRC[5] (RW)
 *
 * Configures the source of the CTS input.
 *
 * Values:
 * - 0b0 - CTS input is the LPUART_CTS pin.
 * - 0b1 - CTS input is the inverted Receiver Match result.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSSRC field. */
#define LPUART_RD_MODIR_TXCTSSRC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSSRC_MASK) >> LPUART_MODIR_TXCTSSRC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSSRC(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSSRC_SHIFT, LPUART_MODIR_TXCTSSRC_WIDTH))

/*! @brief Set the TXCTSSRC field to a new value. */
#define LPUART_WR_MODIR_TXCTSSRC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSSRC_MASK, LPUART_MODIR_TXCTSSRC(value)))
#define LPUART_BWR_MODIR_TXCTSSRC(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TXCTSSRC_SHIFT), LPUART_MODIR_TXCTSSRC_SHIFT, LPUART_MODIR_TXCTSSRC_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field RTSWATER[15:8] (RW)
 *
 * Configures the point at which the RX RTS output negates based on the number
 * of additional characters that can be stored in the Receive FIFO. When
 * configured to 0, RTS negates when the the start bit is detetected for the character
 * that will cause the FIFO to become full.
 *
 * Values:
 * - 0b00000000 - RTS asserts when the receiver FIFO is full or receiving a
 *     character that causes the FIFO to become full.
 * - 0b00000001 - RTS asserts when the receive FIFO is less than or equal to the
 *     RXWATER configuration and negates when the receive FIFO is greater than
 *     the RXWATER configuration.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_RTSWATER field. */
#define LPUART_RD_MODIR_RTSWATER(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_RTSWATER_MASK) >> LPUART_MODIR_RTSWATER_SHIFT)
#define LPUART_BRD_MODIR_RTSWATER(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_RTSWATER_SHIFT, LPUART_MODIR_RTSWATER_WIDTH))

/*! @brief Set the RTSWATER field to a new value. */
#define LPUART_WR_MODIR_RTSWATER(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_RTSWATER_MASK, LPUART_MODIR_RTSWATER(value)))
#define LPUART_BWR_MODIR_RTSWATER(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_RTSWATER_SHIFT), LPUART_MODIR_RTSWATER_SHIFT, LPUART_MODIR_RTSWATER_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TNP[17:16] (RW)
 *
 * Enables whether the LPUART transmits a 1/OSR, 2/OSR, 3/OSR or 4/OSR narrow
 * pulse.
 *
 * Values:
 * - 0b00 - 1/OSR.
 * - 0b01 - 2/OSR.
 * - 0b10 - 3/OSR.
 * - 0b11 - 4/OSR.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TNP field. */
#define LPUART_RD_MODIR_TNP(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TNP_MASK) >> LPUART_MODIR_TNP_SHIFT)
#define LPUART_BRD_MODIR_TNP(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_TNP_SHIFT, LPUART_MODIR_TNP_WIDTH))

/*! @brief Set the TNP field to a new value. */
#define LPUART_WR_MODIR_TNP(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TNP_MASK, LPUART_MODIR_TNP(value)))
#define LPUART_BWR_MODIR_TNP(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_TNP_SHIFT), LPUART_MODIR_TNP_SHIFT, LPUART_MODIR_TNP_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field IREN[18] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0b0 - IR disabled.
 * - 0b1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_IREN field. */
#define LPUART_RD_MODIR_IREN(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_IREN_MASK) >> LPUART_MODIR_IREN_SHIFT)
#define LPUART_BRD_MODIR_IREN(base) (BME_UBFX32(&LPUART_MODIR_REG(base), LPUART_MODIR_IREN_SHIFT, LPUART_MODIR_IREN_WIDTH))

/*! @brief Set the IREN field to a new value. */
#define LPUART_WR_MODIR_IREN(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_IREN_MASK, LPUART_MODIR_IREN(value)))
#define LPUART_BWR_MODIR_IREN(base, value) (BME_BFI32(&LPUART_MODIR_REG(base), ((uint32_t)(value) << LPUART_MODIR_IREN_SHIFT), LPUART_MODIR_IREN_SHIFT, LPUART_MODIR_IREN_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_FIFO - LPUART FIFO Register
 ******************************************************************************/

/*!
 * @brief LPUART_FIFO - LPUART FIFO Register (RW)
 *
 * Reset value: 0x00000033U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register must be written only
 * when CTRL[RE] and CTRL[TE] are cleared/not set and when the data buffer/FIFO is
 * empty.
 */
/*!
 * @name Constants and macros for entire LPUART_FIFO register
 */
/*@{*/
#define LPUART_RD_FIFO(base)     (LPUART_FIFO_REG(base))
#define LPUART_WR_FIFO(base, value) (LPUART_FIFO_REG(base) = (value))
#define LPUART_RMW_FIFO(base, mask, value) (LPUART_WR_FIFO(base, (LPUART_RD_FIFO(base) & ~(mask)) | (value)))
#define LPUART_SET_FIFO(base, value) (BME_OR32(&LPUART_FIFO_REG(base), (uint32_t)(value)))
#define LPUART_CLR_FIFO(base, value) (BME_AND32(&LPUART_FIFO_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_FIFO(base, value) (BME_XOR32(&LPUART_FIFO_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_FIFO bitfields
 */

/*!
 * @name Register LPUART_FIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 0b000 - Receive FIFO/Buffer depth = 1 dataword.
 * - 0b001 - Receive FIFO/Buffer depth = 4 datawords.
 * - 0b010 - Receive FIFO/Buffer depth = 8 datawords.
 * - 0b011 - Receive FIFO/Buffer depth = 16 datawords.
 * - 0b100 - Receive FIFO/Buffer depth = 32 datawords.
 * - 0b101 - Receive FIFO/Buffer depth = 64 datawords.
 * - 0b110 - Receive FIFO/Buffer depth = 128 datawords.
 * - 0b111 - Receive FIFO/Buffer depth = 256 datawords.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_RXFIFOSIZE field. */
#define LPUART_RD_FIFO_RXFIFOSIZE(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_RXFIFOSIZE_MASK) >> LPUART_FIFO_RXFIFOSIZE_SHIFT)
#define LPUART_BRD_FIFO_RXFIFOSIZE(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_RXFIFOSIZE_SHIFT, LPUART_FIFO_RXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field RXFE[3] (RW)
 *
 * When this field is set, the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field.
 * If this field is not set, the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both CTRL[TE] and CTRL[RE]
 * must be cleared prior to changing this field.
 *
 * Values:
 * - 0b0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 0b1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_RXFE field. */
#define LPUART_RD_FIFO_RXFE(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_RXFE_MASK) >> LPUART_FIFO_RXFE_SHIFT)
#define LPUART_BRD_FIFO_RXFE(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_RXFE_SHIFT, LPUART_FIFO_RXFE_WIDTH))

/*! @brief Set the RXFE field to a new value. */
#define LPUART_WR_FIFO_RXFE(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_RXFE_MASK | LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_RXFE(value)))
#define LPUART_BWR_FIFO_RXFE(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_RXFE_SHIFT), LPUART_FIFO_RXFE_SHIFT, LPUART_FIFO_RXFE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 0b000 - Transmit FIFO/Buffer depth = 1 dataword.
 * - 0b001 - Transmit FIFO/Buffer depth = 4 datawords.
 * - 0b010 - Transmit FIFO/Buffer depth = 8 datawords.
 * - 0b011 - Transmit FIFO/Buffer depth = 16 datawords.
 * - 0b100 - Transmit FIFO/Buffer depth = 32 datawords.
 * - 0b101 - Transmit FIFO/Buffer depth = 64 datawords.
 * - 0b110 - Transmit FIFO/Buffer depth = 128 datawords.
 * - 0b111 - Transmit FIFO/Buffer depth = 256 datawords
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_TXFIFOSIZE field. */
#define LPUART_RD_FIFO_TXFIFOSIZE(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_TXFIFOSIZE_MASK) >> LPUART_FIFO_TXFIFOSIZE_SHIFT)
#define LPUART_BRD_FIFO_TXFIFOSIZE(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_TXFIFOSIZE_SHIFT, LPUART_FIFO_TXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field TXFE[7] (RW)
 *
 * When this field is set, the built in FIFO structure for the transmit buffer
 * is enabled. The size of the FIFO structure is indicated by TXFIFOSIZE. If this
 * field is not set, the transmit buffer operates as a FIFO of depth one dataword
 * regardless of the value in TXFIFOSIZE. Both CTRL[TE] and CTRL[RE] must be
 * cleared prior to changing this field.
 *
 * Values:
 * - 0b0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 0b1 - Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_TXFE field. */
#define LPUART_RD_FIFO_TXFE(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_TXFE_MASK) >> LPUART_FIFO_TXFE_SHIFT)
#define LPUART_BRD_FIFO_TXFE(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_TXFE_SHIFT, LPUART_FIFO_TXFE_WIDTH))

/*! @brief Set the TXFE field to a new value. */
#define LPUART_WR_FIFO_TXFE(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_TXFE_MASK | LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_TXFE(value)))
#define LPUART_BWR_FIFO_TXFE(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_TXFE_SHIFT), LPUART_FIFO_TXFE_SHIFT, LPUART_FIFO_TXFE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field RXUFE[8] (RW)
 *
 * When this field is set, the RXUF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - RXUF flag does not generate an interrupt to the host.
 * - 0b1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_RXUFE field. */
#define LPUART_RD_FIFO_RXUFE(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_RXUFE_MASK) >> LPUART_FIFO_RXUFE_SHIFT)
#define LPUART_BRD_FIFO_RXUFE(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_RXUFE_SHIFT, LPUART_FIFO_RXUFE_WIDTH))

/*! @brief Set the RXUFE field to a new value. */
#define LPUART_WR_FIFO_RXUFE(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_RXUFE_MASK | LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_RXUFE(value)))
#define LPUART_BWR_FIFO_RXUFE(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_RXUFE_SHIFT), LPUART_FIFO_RXUFE_SHIFT, LPUART_FIFO_RXUFE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field TXOFE[9] (RW)
 *
 * When this field is set, the TXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - TXOF flag does not generate an interrupt to the host.
 * - 0b1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_TXOFE field. */
#define LPUART_RD_FIFO_TXOFE(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_TXOFE_MASK) >> LPUART_FIFO_TXOFE_SHIFT)
#define LPUART_BRD_FIFO_TXOFE(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_TXOFE_SHIFT, LPUART_FIFO_TXOFE_WIDTH))

/*! @brief Set the TXOFE field to a new value. */
#define LPUART_WR_FIFO_TXOFE(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_TXOFE_MASK | LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_TXOFE(value)))
#define LPUART_BWR_FIFO_TXOFE(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_TXOFE_SHIFT), LPUART_FIFO_TXOFE_SHIFT, LPUART_FIFO_TXOFE_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field RXIDEN[12:10] (RW)
 *
 * When set, enables the assertion of RDRF when the receiver is idle for a
 * number of idle characters and the FIFO is not empty.
 *
 * Values:
 * - 0b000 - Disable RDRF assertion due to partially filled FIFO when receiver
 *     is idle.
 * - 0b001 - Enable RDRF assertion due to partially filled FIFO when receiver is
 *     idle for 1 character.
 * - 0b010 - Enable RDRF assertion due to partially filled FIFO when receiver is
 *     idle for 2 characters.
 * - 0b011 - Enable RDRF assertion due to partially filled FIFO when receiver is
 *     idle for 4 characters.
 * - 0b100 - Enable RDRF assertion due to partially filled FIFO when receiver is
 *     idle for 8 characters.
 * - 0b101 - Enable RDRF assertion due to partially filled FIFO when receiver is
 *     idle for 16 characters.
 * - 0b110 - Enable RDRF assertion due to partially filled FIFO when receiver is
 *     idle for 32 characters.
 * - 0b111 - Enable RDRF assertion due to partially filled FIFO when receiver is
 *     idle for 64 characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_RXIDEN field. */
#define LPUART_RD_FIFO_RXIDEN(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_RXIDEN_MASK) >> LPUART_FIFO_RXIDEN_SHIFT)
#define LPUART_BRD_FIFO_RXIDEN(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_RXIDEN_SHIFT, LPUART_FIFO_RXIDEN_WIDTH))

/*! @brief Set the RXIDEN field to a new value. */
#define LPUART_WR_FIFO_RXIDEN(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_RXIDEN_MASK | LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_RXIDEN(value)))
#define LPUART_BWR_FIFO_RXIDEN(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_RXIDEN_SHIFT), LPUART_FIFO_RXIDEN_SHIFT, LPUART_FIFO_RXIDEN_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field RXFLUSH[14] (WORZ)
 *
 * Writing to this field causes all data that is stored in the receive
 * FIFO/buffer to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0b0 - No flush operation occurs.
 * - 0b1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
/*! @brief Set the RXFLUSH field to a new value. */
#define LPUART_WR_FIFO_RXFLUSH(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_RXFLUSH_MASK | LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_RXFLUSH(value)))
#define LPUART_BWR_FIFO_RXFLUSH(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_RXFLUSH_SHIFT), LPUART_FIFO_RXFLUSH_SHIFT, LPUART_FIFO_RXFLUSH_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field TXFLUSH[15] (WORZ)
 *
 * Writing to this field causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0b0 - No flush operation occurs.
 * - 0b1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
/*! @brief Set the TXFLUSH field to a new value. */
#define LPUART_WR_FIFO_TXFLUSH(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_TXFLUSH_MASK | LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_TXFLUSH(value)))
#define LPUART_BWR_FIFO_TXFLUSH(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_TXFLUSH_SHIFT), LPUART_FIFO_TXFLUSH_SHIFT, LPUART_FIFO_TXFLUSH_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field RXUF[16] (W1C)
 *
 * Indicates that more data has been read from the receive buffer than was
 * present. This field will assert regardless of the value of RXUFE. However, an
 * interrupt will be issued to the host only if RXUFE is set. This flag is cleared by
 * writing a 1.
 *
 * Values:
 * - 0b0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one receive buffer underflow has occurred since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_RXUF field. */
#define LPUART_RD_FIFO_RXUF(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_RXUF_MASK) >> LPUART_FIFO_RXUF_SHIFT)
#define LPUART_BRD_FIFO_RXUF(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_RXUF_SHIFT, LPUART_FIFO_RXUF_WIDTH))

/*! @brief Set the RXUF field to a new value. */
#define LPUART_WR_FIFO_RXUF(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_RXUF_MASK | LPUART_FIFO_TXOF_MASK), LPUART_FIFO_RXUF(value)))
#define LPUART_BWR_FIFO_RXUF(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_RXUF_SHIFT), LPUART_FIFO_RXUF_SHIFT, LPUART_FIFO_RXUF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field TXOF[17] (W1C)
 *
 * Indicates that more data has been written to the transmit buffer than it can
 * hold. This field will assert regardless of the value of TXOFE. However, an
 * interrupt will be issued to the host only if TXOFE is set. This flag is cleared
 * by writing a 1.
 *
 * Values:
 * - 0b0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one transmit buffer overflow has occurred since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_TXOF field. */
#define LPUART_RD_FIFO_TXOF(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_TXOF_MASK) >> LPUART_FIFO_TXOF_SHIFT)
#define LPUART_BRD_FIFO_TXOF(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_TXOF_SHIFT, LPUART_FIFO_TXOF_WIDTH))

/*! @brief Set the TXOF field to a new value. */
#define LPUART_WR_FIFO_TXOF(base, value) (LPUART_RMW_FIFO(base, (LPUART_FIFO_TXOF_MASK | LPUART_FIFO_RXUF_MASK), LPUART_FIFO_TXOF(value)))
#define LPUART_BWR_FIFO_TXOF(base, value) (BME_BFI32(&LPUART_FIFO_REG(base), ((uint32_t)(value) << LPUART_FIFO_TXOF_SHIFT), LPUART_FIFO_TXOF_SHIFT, LPUART_FIFO_TXOF_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field RXEMPT[22] (RO)
 *
 * Asserts when there is no data in the receive FIFO/Buffer. This field does not
 * take into account data that is in the receive shift register.
 *
 * Values:
 * - 0b0 - Receive buffer is not empty.
 * - 0b1 - Receive buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_RXEMPT field. */
#define LPUART_RD_FIFO_RXEMPT(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_RXEMPT_MASK) >> LPUART_FIFO_RXEMPT_SHIFT)
#define LPUART_BRD_FIFO_RXEMPT(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_RXEMPT_SHIFT, LPUART_FIFO_RXEMPT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_FIFO, field TXEMPT[23] (RO)
 *
 * Asserts when there is no data in the Transmit FIFO/buffer. This field does
 * not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0b0 - Transmit buffer is not empty.
 * - 0b1 - Transmit buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the LPUART_FIFO_TXEMPT field. */
#define LPUART_RD_FIFO_TXEMPT(base) ((LPUART_FIFO_REG(base) & LPUART_FIFO_TXEMPT_MASK) >> LPUART_FIFO_TXEMPT_SHIFT)
#define LPUART_BRD_FIFO_TXEMPT(base) (BME_UBFX32(&LPUART_FIFO_REG(base), LPUART_FIFO_TXEMPT_SHIFT, LPUART_FIFO_TXEMPT_WIDTH))
/*@}*/

/*******************************************************************************
 * LPUART_WATER - LPUART Watermark Register
 ******************************************************************************/

/*!
 * @brief LPUART_WATER - LPUART Watermark Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but must be written only when CTRL[TE] is not set.
 */
/*!
 * @name Constants and macros for entire LPUART_WATER register
 */
/*@{*/
#define LPUART_RD_WATER(base)    (LPUART_WATER_REG(base))
#define LPUART_WR_WATER(base, value) (LPUART_WATER_REG(base) = (value))
#define LPUART_RMW_WATER(base, mask, value) (LPUART_WR_WATER(base, (LPUART_RD_WATER(base) & ~(mask)) | (value)))
#define LPUART_SET_WATER(base, value) (BME_OR32(&LPUART_WATER_REG(base), (uint32_t)(value)))
#define LPUART_CLR_WATER(base, value) (BME_AND32(&LPUART_WATER_REG(base), (uint32_t)(~(value))))
#define LPUART_TOG_WATER(base, value) (BME_XOR32(&LPUART_WATER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_WATER bitfields
 */

/*!
 * @name Register LPUART_WATER, field TXWATER[7:0] (RW)
 *
 * When the number of datawords in the transmit FIFO/buffer is equal to or less
 * than the value in this register field, an interrupt or a DMA request is
 * generated. For proper operation, the value in TXWATER must be set to be less than
 * the size of the transmit buffer/FIFO size as indicated by FIFO[TXFIFOSIZE] and
 * FIFO[TXFE].
 */
/*@{*/
/*! @brief Read current value of the LPUART_WATER_TXWATER field. */
#define LPUART_RD_WATER_TXWATER(base) ((LPUART_WATER_REG(base) & LPUART_WATER_TXWATER_MASK) >> LPUART_WATER_TXWATER_SHIFT)
#define LPUART_BRD_WATER_TXWATER(base) (BME_UBFX32(&LPUART_WATER_REG(base), LPUART_WATER_TXWATER_SHIFT, LPUART_WATER_TXWATER_WIDTH))

/*! @brief Set the TXWATER field to a new value. */
#define LPUART_WR_WATER_TXWATER(base, value) (LPUART_RMW_WATER(base, LPUART_WATER_TXWATER_MASK, LPUART_WATER_TXWATER(value)))
#define LPUART_BWR_WATER_TXWATER(base, value) (BME_BFI32(&LPUART_WATER_REG(base), ((uint32_t)(value) << LPUART_WATER_TXWATER_SHIFT), LPUART_WATER_TXWATER_SHIFT, LPUART_WATER_TXWATER_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_WATER, field TXCOUNT[15:8] (RO)
 *
 * The value in this register indicates the number of datawords that are in the
 * transmit FIFO/buffer. If a dataword is being transmitted, that is, in the
 * transmit shift register, it is not included in the count. This value may be used
 * in conjunction with FIFO[TXFIFOSIZE] to calculate how much room is left in the
 * transmit FIFO/buffer.
 */
/*@{*/
/*! @brief Read current value of the LPUART_WATER_TXCOUNT field. */
#define LPUART_RD_WATER_TXCOUNT(base) ((LPUART_WATER_REG(base) & LPUART_WATER_TXCOUNT_MASK) >> LPUART_WATER_TXCOUNT_SHIFT)
#define LPUART_BRD_WATER_TXCOUNT(base) (BME_UBFX32(&LPUART_WATER_REG(base), LPUART_WATER_TXCOUNT_SHIFT, LPUART_WATER_TXCOUNT_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_WATER, field RXWATER[23:16] (RW)
 *
 * When the number of datawords in the receive FIFO/buffer is equal to or
 * greater than the value in this register field, an interrupt or a DMA request is
 * generated. For proper operation, the value in RXWATER must be set to be less than
 * the receive FIFO/buffer size as indicated by FIFO[RXFIFOSIZE] and FIFO[RXFE]
 * and must be greater than 0.
 */
/*@{*/
/*! @brief Read current value of the LPUART_WATER_RXWATER field. */
#define LPUART_RD_WATER_RXWATER(base) ((LPUART_WATER_REG(base) & LPUART_WATER_RXWATER_MASK) >> LPUART_WATER_RXWATER_SHIFT)
#define LPUART_BRD_WATER_RXWATER(base) (BME_UBFX32(&LPUART_WATER_REG(base), LPUART_WATER_RXWATER_SHIFT, LPUART_WATER_RXWATER_WIDTH))

/*! @brief Set the RXWATER field to a new value. */
#define LPUART_WR_WATER_RXWATER(base, value) (LPUART_RMW_WATER(base, LPUART_WATER_RXWATER_MASK, LPUART_WATER_RXWATER(value)))
#define LPUART_BWR_WATER_RXWATER(base, value) (BME_BFI32(&LPUART_WATER_REG(base), ((uint32_t)(value) << LPUART_WATER_RXWATER_SHIFT), LPUART_WATER_RXWATER_SHIFT, LPUART_WATER_RXWATER_WIDTH))
/*@}*/

/*!
 * @name Register LPUART_WATER, field RXCOUNT[31:24] (RO)
 *
 * The value in this register indicates the number of datawords that are in the
 * receive FIFO/buffer. If a dataword is being received, that is, in the receive
 * shift register, it is not included in the count. This value may be used in
 * conjunction with FIFO[RXFIFOSIZE] to calculate how much room is left in the
 * receive FIFO/buffer.
 */
/*@{*/
/*! @brief Read current value of the LPUART_WATER_RXCOUNT field. */
#define LPUART_RD_WATER_RXCOUNT(base) ((LPUART_WATER_REG(base) & LPUART_WATER_RXCOUNT_MASK) >> LPUART_WATER_RXCOUNT_SHIFT)
#define LPUART_BRD_WATER_RXCOUNT(base) (BME_UBFX32(&LPUART_WATER_REG(base), LPUART_WATER_RXCOUNT_SHIFT, LPUART_WATER_RXCOUNT_WIDTH))
/*@}*/

/*
 * MKL28Z7 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - MCM_PLACR - Platform Control Register
 * - MCM_CPO - Compute Operation Control Register
 */

#define MCM_INSTANCE_COUNT (2U) /*!< Number of instances of the MCM module. */
#define MCM0_IDX (0U) /*!< Instance number for MCM0. */
#define MCM1_IDX (1U) /*!< Instance number for MCM1. */

/*******************************************************************************
 * MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x000FU
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define MCM_RD_PLASC(base)       (MCM_PLASC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus slave connection to AXBS input port n is absent.
 * - 0b00000001 - A bus slave connection to AXBS input port n is present.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define MCM_RD_PLASC_ASC(base) ((MCM_PLASC_REG(base) & MCM_PLASC_ASC_MASK) >> MCM_PLASC_ASC_SHIFT)
#define MCM_BRD_PLASC_ASC(base) (MCM_RD_PLASC_ASC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x000FU
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch. For MCM0_PLAMC, the reset
 * value is 0x000F. For MCM1_PLAMC, the reset value is 0x0007.
 */
/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define MCM_RD_PLAMC(base)       (MCM_PLAMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0b00000000 - A bus master connection to AXBS input port n is absent
 * - 0b00000001 - A bus master connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define MCM_RD_PLAMC_AMC(base) ((MCM_PLAMC_REG(base) & MCM_PLAMC_AMC_MASK) >> MCM_PLAMC_AMC_SHIFT)
#define MCM_BRD_PLAMC_AMC(base) (MCM_RD_PLAMC_AMC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLACR - Platform Control Register
 ******************************************************************************/

/*!
 * @brief MCM_PLACR - Platform Control Register (RW)
 *
 * Reset value: 0x00000240U
 *
 * The PLACR register selects the arbitration policy for the crossbar masters
 * and configures the flash memory controller. The speculation buffer and cache in
 * the flash memory controller is configurable via PLACR[15:10]. The speculation
 * buffer is enabled only for instructions after reset. It is possible to have
 * these states for the speculation buffer: DFCS EFDS Description 0 0 Speculation
 * buffer is on for instruction and off for data. 0 1 Speculation buffer is on for
 * instruction and on for data. 1 X Speculation buffer is off. The cache in
 * flash controller is enabled and caching both instruction and data type fetches
 * after reset. It is possible to have these states for the cache: DFCC DFCIC DFCDA
 * Description 0 0 0 Cache is on for both instruction and data. 0 0 1 Cache is on
 * for instruction and off for data. 0 1 0 Cache is off for instruction and on
 * for data. 0 1 1 Cache is off for both instruction and data. 1 X X Cache is off.
 */
/*!
 * @name Constants and macros for entire MCM_PLACR register
 */
/*@{*/
#define MCM_RD_PLACR(base)       (MCM_PLACR_REG(base))
#define MCM_WR_PLACR(base, value) (MCM_PLACR_REG(base) = (value))
#define MCM_RMW_PLACR(base, mask, value) (MCM_WR_PLACR(base, (MCM_RD_PLACR(base) & ~(mask)) | (value)))
#define MCM_SET_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) |  (value)))
#define MCM_CLR_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) & ~(value)))
#define MCM_TOG_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_PLACR bitfields
 */

/*!
 * @name Register MCM_PLACR, field MMCAU[8] (RO)
 *
 * Values:
 * - 0b0 - MMCAU is disabled
 * - 0b1 - MMCAU is enabled
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_MMCAU field. */
#define MCM_RD_PLACR_MMCAU(base) ((MCM_PLACR_REG(base) & MCM_PLACR_MMCAU_MASK) >> MCM_PLACR_MMCAU_SHIFT)
#define MCM_BRD_PLACR_MMCAU(base) (MCM_RD_PLACR_MMCAU(base))
/*@}*/

/*!
 * @name Register MCM_PLACR, field ARB[9] (RW)
 *
 * Values:
 * - 0b0 - Fixed-priority arbitration for the crossbar masters
 * - 0b1 - Round-robin arbitration for the crossbar masters
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ARB field. */
#define MCM_RD_PLACR_ARB(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ARB_MASK) >> MCM_PLACR_ARB_SHIFT)
#define MCM_BRD_PLACR_ARB(base) (MCM_RD_PLACR_ARB(base))

/*! @brief Set the ARB field to a new value. */
#define MCM_WR_PLACR_ARB(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ARB_MASK, MCM_PLACR_ARB(value)))
#define MCM_BWR_PLACR_ARB(base, value) (MCM_WR_PLACR_ARB(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field CFCC[10] (WORZ)
 *
 * Writing a 1 to this field clears the cache. Writing a 0 to this field is
 * ignored. This field always reads as 0.
 */
/*@{*/
/*! @brief Set the CFCC field to a new value. */
#define MCM_WR_PLACR_CFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_CFCC_MASK, MCM_PLACR_CFCC(value)))
#define MCM_BWR_PLACR_CFCC(base, value) (MCM_WR_PLACR_CFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCDA[11] (RW)
 *
 * Disables flash controller data caching.
 *
 * Values:
 * - 0b0 - Enable flash controller data caching
 * - 0b1 - Disable flash controller data caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCDA field. */
#define MCM_RD_PLACR_DFCDA(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCDA_MASK) >> MCM_PLACR_DFCDA_SHIFT)
#define MCM_BRD_PLACR_DFCDA(base) (MCM_RD_PLACR_DFCDA(base))

/*! @brief Set the DFCDA field to a new value. */
#define MCM_WR_PLACR_DFCDA(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCDA_MASK, MCM_PLACR_DFCDA(value)))
#define MCM_BWR_PLACR_DFCDA(base, value) (MCM_WR_PLACR_DFCDA(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCIC[12] (RW)
 *
 * Disables flash controller instruction caching.
 *
 * Values:
 * - 0b0 - Enable flash controller instruction caching.
 * - 0b1 - Disable flash controller instruction caching.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCIC field. */
#define MCM_RD_PLACR_DFCIC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCIC_MASK) >> MCM_PLACR_DFCIC_SHIFT)
#define MCM_BRD_PLACR_DFCIC(base) (MCM_RD_PLACR_DFCIC(base))

/*! @brief Set the DFCIC field to a new value. */
#define MCM_WR_PLACR_DFCIC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCIC_MASK, MCM_PLACR_DFCIC(value)))
#define MCM_BWR_PLACR_DFCIC(base, value) (MCM_WR_PLACR_DFCIC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCC[13] (RW)
 *
 * Disables flash controller cache.
 *
 * Values:
 * - 0b0 - Enable flash controller cache.
 * - 0b1 - Disable flash controller cache.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCC field. */
#define MCM_RD_PLACR_DFCC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCC_MASK) >> MCM_PLACR_DFCC_SHIFT)
#define MCM_BRD_PLACR_DFCC(base) (MCM_RD_PLACR_DFCC(base))

/*! @brief Set the DFCC field to a new value. */
#define MCM_WR_PLACR_DFCC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCC_MASK, MCM_PLACR_DFCC(value)))
#define MCM_BWR_PLACR_DFCC(base, value) (MCM_WR_PLACR_DFCC(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field EFDS[14] (RW)
 *
 * Enables flash data speculation.
 *
 * Values:
 * - 0b0 - Disable flash data speculation.
 * - 0b1 - Enable flash data speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_EFDS field. */
#define MCM_RD_PLACR_EFDS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_EFDS_MASK) >> MCM_PLACR_EFDS_SHIFT)
#define MCM_BRD_PLACR_EFDS(base) (MCM_RD_PLACR_EFDS(base))

/*! @brief Set the EFDS field to a new value. */
#define MCM_WR_PLACR_EFDS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_EFDS_MASK, MCM_PLACR_EFDS(value)))
#define MCM_BWR_PLACR_EFDS(base, value) (MCM_WR_PLACR_EFDS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field DFCS[15] (RW)
 *
 * Disables flash controller speculation.
 *
 * Values:
 * - 0b0 - Enable flash controller speculation.
 * - 0b1 - Disable flash controller speculation.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_DFCS field. */
#define MCM_RD_PLACR_DFCS(base) ((MCM_PLACR_REG(base) & MCM_PLACR_DFCS_MASK) >> MCM_PLACR_DFCS_SHIFT)
#define MCM_BRD_PLACR_DFCS(base) (MCM_RD_PLACR_DFCS(base))

/*! @brief Set the DFCS field to a new value. */
#define MCM_WR_PLACR_DFCS(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_DFCS_MASK, MCM_PLACR_DFCS(value)))
#define MCM_BWR_PLACR_DFCS(base, value) (MCM_WR_PLACR_DFCS(base, value))
/*@}*/

/*!
 * @name Register MCM_PLACR, field ESFC[16] (RW)
 *
 * Enables stalling flash controller when flash is busy. When software needs to
 * access the flash memory while a flash memory resource is being manipulated by
 * a flash command, software can enable a stall mechanism to avoid a read
 * collision. The stall mechanism allows software to execute code from the same block on
 * which flash operations are being performed. However, software must ensure the
 * sector the flash operations are being performed on is not the same sector
 * from which the code is executing. ESFC enables the stall mechanism. This bit must
 * be set only just before the flash operation is executed and must be cleared
 * when the operation completes.
 *
 * Values:
 * - 0b0 - Disable stalling flash controller when flash is busy.
 * - 0b1 - Enable stalling flash controller when flash is busy.
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ESFC field. */
#define MCM_RD_PLACR_ESFC(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ESFC_MASK) >> MCM_PLACR_ESFC_SHIFT)
#define MCM_BRD_PLACR_ESFC(base) (MCM_RD_PLACR_ESFC(base))

/*! @brief Set the ESFC field to a new value. */
#define MCM_WR_PLACR_ESFC(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ESFC_MASK, MCM_PLACR_ESFC(value)))
#define MCM_BWR_PLACR_ESFC(base, value) (MCM_WR_PLACR_ESFC(base, value))
/*@}*/

/*******************************************************************************
 * MCM_CPO - Compute Operation Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPO - Compute Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Operation.
 */
/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define MCM_RD_CPO(base)         (MCM_CPO_REG(base))
#define MCM_WR_CPO(base, value)  (MCM_CPO_REG(base) = (value))
#define MCM_RMW_CPO(base, mask, value) (MCM_WR_CPO(base, (MCM_RD_CPO(base) & ~(mask)) | (value)))
#define MCM_SET_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) |  (value)))
#define MCM_CLR_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) & ~(value)))
#define MCM_TOG_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This bit is auto-cleared by vector fetching if CPOWOI = 1.
 *
 * Values:
 * - 0b0 - Request is cleared.
 * - 0b1 - Request Compute Operation.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define MCM_RD_CPO_CPOREQ(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOREQ_MASK) >> MCM_CPO_CPOREQ_SHIFT)
#define MCM_BRD_CPO_CPOREQ(base) (MCM_RD_CPO_CPOREQ(base))

/*! @brief Set the CPOREQ field to a new value. */
#define MCM_WR_CPO_CPOREQ(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOREQ_MASK, MCM_CPO_CPOREQ(value)))
#define MCM_BWR_CPO_CPOREQ(base, value) (MCM_WR_CPO_CPOREQ(base, value))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0b0 - Compute operation entry has not completed or compute operation exit
 *     has completed.
 * - 0b1 - Compute operation entry has completed or compute operation exit has
 *     not completed.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define MCM_RD_CPO_CPOACK(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOACK_MASK) >> MCM_CPO_CPOACK_SHIFT)
#define MCM_BRD_CPO_CPOACK(base) (MCM_RD_CPO_CPOACK(base))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOWOI[2] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - When set, the CPOREQ is cleared on any interrupt or exception vector
 *     fetch.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOWOI field. */
#define MCM_RD_CPO_CPOWOI(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOWOI_MASK) >> MCM_CPO_CPOWOI_SHIFT)
#define MCM_BRD_CPO_CPOWOI(base) (MCM_RD_CPO_CPOWOI(base))

/*! @brief Set the CPOWOI field to a new value. */
#define MCM_WR_CPO_CPOWOI(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOWOI_MASK, MCM_CPO_CPOWOI(value)))
#define MCM_BWR_CPO_CPOWOI(base, value) (MCM_WR_CPO_CPOWOI(base, value))
/*@}*/

/*
 * MKL28Z7 MMDVSQ
 *
 * Divide and Square Root
 *
 * Registers defined in this header file:
 * - MMDVSQ_DEND - Dividend Register
 * - MMDVSQ_DSOR - Divisor Register
 * - MMDVSQ_CSR - Control/Status Register
 * - MMDVSQ_RES - Result Register
 * - MMDVSQ_RCND - Radicand Register
 */

#define MMDVSQ_INSTANCE_COUNT (2U) /*!< Number of instances of the MMDVSQ module. */
#define MMDVSQ0_IDX (0U) /*!< Instance number for MMDVSQ0. */
#define MMDVSQ1_IDX (1U) /*!< Instance number for MMDVSQ1. */

/*******************************************************************************
 * MMDVSQ_DEND - Dividend Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_DEND - Dividend Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input dividend operand before a divide
 * operation is initiated. The register is updated by the MMDVSQ hardware during the
 * execution of a divide or square root calculation. Any memory access (read or
 * write) of the DEND register while the module is busy during a calculation causes
 * the access to be stalled (using wait states) until the calculation completes.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_DEND register
 */
/*@{*/
#define MMDVSQ_RD_DEND(base)     (MMDVSQ_DEND_REG(base))
#define MMDVSQ_WR_DEND(base, value) (MMDVSQ_DEND_REG(base) = (value))
#define MMDVSQ_RMW_DEND(base, mask, value) (MMDVSQ_WR_DEND(base, (MMDVSQ_RD_DEND(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_DEND(base, value) (MMDVSQ_WR_DEND(base, MMDVSQ_RD_DEND(base) |  (value)))
#define MMDVSQ_CLR_DEND(base, value) (MMDVSQ_WR_DEND(base, MMDVSQ_RD_DEND(base) & ~(value)))
#define MMDVSQ_TOG_DEND(base, value) (MMDVSQ_WR_DEND(base, MMDVSQ_RD_DEND(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMDVSQ_DSOR - Divisor Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_DSOR - Divisor Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the input divisor operand before a divide
 * operation is initiated. If CSR[DFS] = 0, a write to this register inititates a
 * divide operation. Any memory access (read or write) of the DSOR register while the
 * module is busy during a calculation causes the access to be stalled (using
 * wait states) until the calculation completes. If a divide operation is inititated
 * with DSOR = 0, the hardware signals a divide-by-zero condition and sets RES =
 * 0 and CSR[DZ] = 1. If CSR[DZE] = 1, an attempted read of the RES result is
 * error terminated.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_DSOR register
 */
/*@{*/
#define MMDVSQ_RD_DSOR(base)     (MMDVSQ_DSOR_REG(base))
#define MMDVSQ_WR_DSOR(base, value) (MMDVSQ_DSOR_REG(base) = (value))
#define MMDVSQ_RMW_DSOR(base, mask, value) (MMDVSQ_WR_DSOR(base, (MMDVSQ_RD_DSOR(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_DSOR(base, value) (MMDVSQ_WR_DSOR(base, MMDVSQ_RD_DSOR(base) |  (value)))
#define MMDVSQ_CLR_DSOR(base, value) (MMDVSQ_WR_DSOR(base, MMDVSQ_RD_DSOR(base) & ~(value)))
#define MMDVSQ_TOG_DSOR(base, value) (MMDVSQ_WR_DSOR(base, MMDVSQ_RD_DSOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMDVSQ_CSR - Control/Status Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_CSR - Control/Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the operating configuration of divide operations and
 * provides status information. The upper 3 bits provide busy status indicators,
 * while the low-order byte defines the configuration for divide operations. The
 * read-only status bits in CSR[31:29] are valid for both divide and square root
 * operations; the configuration and status bit in CSR[5:0] are only valid for
 * divides. A memory write access of the CSR register while the module is busy during
 * a calculation causes the access to be stalled (using wait states) until the
 * calculation completes.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_CSR register
 */
/*@{*/
#define MMDVSQ_RD_CSR(base)      (MMDVSQ_CSR_REG(base))
#define MMDVSQ_WR_CSR(base, value) (MMDVSQ_CSR_REG(base) = (value))
#define MMDVSQ_RMW_CSR(base, mask, value) (MMDVSQ_WR_CSR(base, (MMDVSQ_RD_CSR(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_CSR(base, value) (MMDVSQ_WR_CSR(base, MMDVSQ_RD_CSR(base) |  (value)))
#define MMDVSQ_CLR_CSR(base, value) (MMDVSQ_WR_CSR(base, MMDVSQ_RD_CSR(base) & ~(value)))
#define MMDVSQ_TOG_CSR(base, value) (MMDVSQ_WR_CSR(base, MMDVSQ_RD_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MMDVSQ_CSR bitfields
 */

/*!
 * @name Register MMDVSQ_CSR, field SRT[0] (WORZ)
 *
 * When written with a logical one and CSR[DFS] = 1, this flag initiates a
 * divide operation. If written as a logical one with CSR[DFS] = 0, it is ignored.
 * This bit always reads as a zero. The state of the register write data defines
 * this bit's function.
 *
 * Values:
 * - 0b0 - No operation initiated
 * - 0b1 - If CSR[DFS] = 1, then initiate a divide calculation, else ignore
 */
/*@{*/
/*! @brief Set the SRT field to a new value. */
#define MMDVSQ_WR_CSR_SRT(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_SRT_MASK, MMDVSQ_CSR_SRT(value)))
#define MMDVSQ_BWR_CSR_SRT(base, value) (MMDVSQ_WR_CSR_SRT(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field USGN[1] (RW)
 *
 * This indicator selects whether a signed (default) or unsigned divide is
 * performed. See the CSR[REM] description for the encoding of the four possible
 * divide operations.
 *
 * Values:
 * - 0b0 - Perform a signed divide
 * - 0b1 - Perform an unsigned divide
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_USGN field. */
#define MMDVSQ_RD_CSR_USGN(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_USGN_MASK) >> MMDVSQ_CSR_USGN_SHIFT)
#define MMDVSQ_BRD_CSR_USGN(base) (MMDVSQ_RD_CSR_USGN(base))

/*! @brief Set the USGN field to a new value. */
#define MMDVSQ_WR_CSR_USGN(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_USGN_MASK, MMDVSQ_CSR_USGN(value)))
#define MMDVSQ_BWR_CSR_USGN(base, value) (MMDVSQ_WR_CSR_USGN(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field REM[2] (RW)
 *
 * This indicator selects whether the quotient or the remainder is returned in
 * the RES register. The combined CSR[REM] and CSR[USGN] bits define four possible
 * divide operations: If CSR[REM, USGN] = 0b00, perform a signed divide,
 * returning the quotient If CSR[REM, USGN] = 0b01, perform an unsigned divide,
 * returning the quotient If CSR[REM, USGN] = 0b10, perform a signed divide, returning
 * the remainder If CSR[REM, USGN] = 0b11, perform an unsigned divide, returning
 * the remainder
 *
 * Values:
 * - 0b0 - Return the quotient in the RES for the divide calculation
 * - 0b1 - Return the remainder in the RES for the divide calculation
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_REM field. */
#define MMDVSQ_RD_CSR_REM(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_REM_MASK) >> MMDVSQ_CSR_REM_SHIFT)
#define MMDVSQ_BRD_CSR_REM(base) (MMDVSQ_RD_CSR_REM(base))

/*! @brief Set the REM field to a new value. */
#define MMDVSQ_WR_CSR_REM(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_REM_MASK, MMDVSQ_CSR_REM(value)))
#define MMDVSQ_BWR_CSR_REM(base, value) (MMDVSQ_WR_CSR_REM(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DZE[3] (RW)
 *
 * This indicator configures the MMDVSQ's response to divide-by-zero
 * calculations. If both CSR[DZ] and CSR[DZE] are set, then a subsequent read of the RES
 * register is error terminated to signal the processor of the attempted
 * divide-by-zero.
 *
 * Values:
 * - 0b0 - Reads of the RES register return the register contents
 * - 0b1 - If CSR[DZ] = 1, an attempted read of RES register is error terminated
 *     to signal a divide-by-zero, else the register contents are returned
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DZE field. */
#define MMDVSQ_RD_CSR_DZE(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DZE_MASK) >> MMDVSQ_CSR_DZE_SHIFT)
#define MMDVSQ_BRD_CSR_DZE(base) (MMDVSQ_RD_CSR_DZE(base))

/*! @brief Set the DZE field to a new value. */
#define MMDVSQ_WR_CSR_DZE(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_DZE_MASK, MMDVSQ_CSR_DZE(value)))
#define MMDVSQ_BWR_CSR_DZE(base, value) (MMDVSQ_WR_CSR_DZE(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DZ[4] (RO)
 *
 * This read-only status indicator signals the last divide operation had a zero
 * divisor, that is, DSOR = 0x0000_0000. For this case, RES is set to 0x0000_0000
 * and this indicator bit set. After a divide-by-zero operation, a read of the
 * RES register returns either the zero result, or, if CSR[DZE] = 1, terminates
 * the read with an error. The CSR[DZ] indicator is cleared by the hardware at the
 * beginning of each operation.
 *
 * Values:
 * - 0b0 - The last divide operation had a non-zero divisor, that is, DSOR != 0
 * - 0b1 - The last divide operation had a zero divisor, that is, DSOR = 0
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DZ field. */
#define MMDVSQ_RD_CSR_DZ(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DZ_MASK) >> MMDVSQ_CSR_DZ_SHIFT)
#define MMDVSQ_BRD_CSR_DZ(base) (MMDVSQ_RD_CSR_DZ(base))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DFS[5] (RW)
 *
 * The MMDVSQ supports 2 mechanisms for initiating a divide operation. The
 * default mechanism is a "fast start" where a write to the DSOR register begins the
 * divide. Alternatively, the start mechanism can begin after a write to the CSR
 * register with CSR[SRT] set. The CSR[DFS] indicator selects the divide start
 * mechanism.
 *
 * Values:
 * - 0b0 - A divide operation is initiated by a write to the DSOR register
 * - 0b1 - A divide operation is initiated by a write to the CSR register with
 *     CSR[SRT] = 1
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DFS field. */
#define MMDVSQ_RD_CSR_DFS(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DFS_MASK) >> MMDVSQ_CSR_DFS_SHIFT)
#define MMDVSQ_BRD_CSR_DFS(base) (MMDVSQ_RD_CSR_DFS(base))

/*! @brief Set the DFS field to a new value. */
#define MMDVSQ_WR_CSR_DFS(base, value) (MMDVSQ_RMW_CSR(base, MMDVSQ_CSR_DFS_MASK, MMDVSQ_CSR_DFS(value)))
#define MMDVSQ_BWR_CSR_DFS(base, value) (MMDVSQ_WR_CSR_DFS(base, value))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field SQRT[29] (RO)
 *
 * Current or last operation was a square root. This read-only indicator bit
 * signals if the current or last operation performed by the MMDVSQ was a square
 * root.
 *
 * Values:
 * - 0b0 - Current or last MMDVSQ operation was not a square root
 * - 0b1 - Current or last MMDVSQ operation was a square root
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_SQRT field. */
#define MMDVSQ_RD_CSR_SQRT(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_SQRT_MASK) >> MMDVSQ_CSR_SQRT_SHIFT)
#define MMDVSQ_BRD_CSR_SQRT(base) (MMDVSQ_RD_CSR_SQRT(base))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field DIV[30] (RO)
 *
 * Current or last operation was a divide. This read-only indicator bit signals
 * if the current or last operation performed by the MMDVSQ was a divide.
 *
 * Values:
 * - 0b0 - Current or last MMDVSQ operation was not a divide
 * - 0b1 - Current or last MMDVSQ operation was a divide
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_DIV field. */
#define MMDVSQ_RD_CSR_DIV(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_DIV_MASK) >> MMDVSQ_CSR_DIV_SHIFT)
#define MMDVSQ_BRD_CSR_DIV(base) (MMDVSQ_RD_CSR_DIV(base))
/*@}*/

/*!
 * @name Register MMDVSQ_CSR, field BUSY[31] (RO)
 *
 * This read-only bit is asserted when the MMDVSQ is performing a divide or
 * square root. When an operation is initiated, the hardware sets this flag. It
 * remains asserted until the operation completes and the hardware automatically
 * clears the indicator. This bit can be used to poll the DVSQ's execution status. The
 * combined CSR[BUSY, DIV, SQRT] indicators provide an encoded module status: If
 * 0b001, then MMDVSQ is idle and the last calculation was a square root If
 * 0b010, then MMDVSQ is idle and the last calculation was a divide If 0b101, then
 * MMDVSQ is busy processing a square root calculation If 0b110, then MMDVSQ is
 * busy processing a divide calculation The remaining encodings of CSR[BUSY, DIV,
 * SQRT] are reserved.
 *
 * Values:
 * - 0b0 - MMDVSQ is idle
 * - 0b1 - MMDVSQ is busy performing a divide or square root calculation
 */
/*@{*/
/*! @brief Read current value of the MMDVSQ_CSR_BUSY field. */
#define MMDVSQ_RD_CSR_BUSY(base) ((MMDVSQ_CSR_REG(base) & MMDVSQ_CSR_BUSY_MASK) >> MMDVSQ_CSR_BUSY_SHIFT)
#define MMDVSQ_BRD_CSR_BUSY(base) (MMDVSQ_RD_CSR_BUSY(base))
/*@}*/

/*******************************************************************************
 * MMDVSQ_RES - Result Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_RES - Result Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded with the result of the divide or square root
 * calculation. It is updated by the MMDVSQ hardware at the completion of the
 * calculation. When a square root operation is performed (on an unsigned 32-bit number),
 * the result is limited to a 16-bit value with RES[31:16] = 0x0000. Any memory
 * access (read or write) of the RES register while the module is busy during a
 * calculation causes the access to be stalled (using wait states) until the
 * calculation completes and the new result written into the register.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_RES register
 */
/*@{*/
#define MMDVSQ_RD_RES(base)      (MMDVSQ_RES_REG(base))
#define MMDVSQ_WR_RES(base, value) (MMDVSQ_RES_REG(base) = (value))
#define MMDVSQ_RMW_RES(base, mask, value) (MMDVSQ_WR_RES(base, (MMDVSQ_RD_RES(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_RES(base, value) (MMDVSQ_WR_RES(base, MMDVSQ_RD_RES(base) |  (value)))
#define MMDVSQ_CLR_RES(base, value) (MMDVSQ_WR_RES(base, MMDVSQ_RD_RES(base) & ~(value)))
#define MMDVSQ_TOG_RES(base, value) (MMDVSQ_WR_RES(base, MMDVSQ_RD_RES(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MMDVSQ_RCND - Radicand Register
 ******************************************************************************/

/*!
 * @brief MMDVSQ_RCND - Radicand Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The write-only radicand register is loaded with the input "square" number. A
 * memory write to the radicand register initiates a square root calculation.
 * While the MMDVSQ module is busy performing a square root calculation, any memory
 * write access to the RCND register causes the write access to be stalled (using
 * wait states) until the square root calculation finishes. Any attempted read
 * of the radicand register terminates with an error.
 */
/*!
 * @name Constants and macros for entire MMDVSQ_RCND register
 */
/*@{*/
#define MMDVSQ_RD_RCND(base)     (MMDVSQ_RCND_REG(base))
#define MMDVSQ_WR_RCND(base, value) (MMDVSQ_RCND_REG(base) = (value))
#define MMDVSQ_RMW_RCND(base, mask, value) (MMDVSQ_WR_RCND(base, (MMDVSQ_RD_RCND(base) & ~(mask)) | (value)))
#define MMDVSQ_SET_RCND(base, value) (MMDVSQ_WR_RCND(base, MMDVSQ_RD_RCND(base) |  (value)))
#define MMDVSQ_CLR_RCND(base, value) (MMDVSQ_WR_RCND(base, MMDVSQ_RD_RCND(base) & ~(value)))
#define MMDVSQ_TOG_RCND(base, value) (MMDVSQ_WR_RCND(base, MMDVSQ_RD_RCND(base) ^  (value)))
/*@}*/

/*
 * MKL28Z7 MSCM
 *
 * MSCM
 *
 * Registers defined in this header file:
 * - MSCM_CPxTYPE - Processor X Type Register
 * - MSCM_CPxNUM - Processor X Number Register
 * - MSCM_CPxMASTER - Processor X Master Register
 * - MSCM_CPxCOUNT - Processor X Count Register
 * - MSCM_CPxCFG - Processor X Configuration Register
 * - MSCM_CP0TYPE - Processor 0 Type Register
 * - MSCM_CP0NUM - Processor 0 Number Register
 * - MSCM_CP0MASTER - Processor 0 Master Register
 * - MSCM_CP0COUNT - Processor 0 Count Register
 * - MSCM_CP0CFG - Processor 0 Configuration Register
 * - MSCM_CP1TYPE - Processor 1 Type Register
 * - MSCM_CP1NUM - Processor 1 Number Register
 * - MSCM_CP1MASTER - Processor 1 Master Register
 * - MSCM_CP1COUNT - Processor 1 Count Register
 * - MSCM_CP1CFG - Processor 1 Configuration Register
 * - MSCM_OCMDR - On-Chip Memory Descriptor Register
 */

#define MSCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MSCM module. */
#define MSCM_IDX (0U) /*!< Instance number for MSCM. */

/*******************************************************************************
 * MSCM_CPxTYPE - Processor X Type Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxTYPE - Processor X Type Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the personality of
 * the core making the access. The 32-bit response includes 3 ASCII characters
 * that define the CPU type, along with a byte that defines the logical revision
 * number. The logical revision number follows ARM's rYpZ nomenclature.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxTYPE register
 */
/*@{*/
#define MSCM_RD_CPxTYPE(base)    (MSCM_CPxTYPE_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxTYPE bitfields
 */

/*!
 * @name Register MSCM_CPxTYPE, field RYPZ[7:0] (RO)
 *
 * This read-only field defines the processor revision for CPx: 0x00 corresponds
 * to the r0p0 core release. 0x01 corresponds to the r0p1 core release. ...
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxTYPE_RYPZ field. */
#define MSCM_RD_CPxTYPE_RYPZ(base) ((MSCM_CPxTYPE_REG(base) & MSCM_CPxTYPE_RYPZ_MASK) >> MSCM_CPxTYPE_RYPZ_SHIFT)
#define MSCM_BRD_CPxTYPE_RYPZ(base) (BME_UBFX32(&MSCM_CPxTYPE_REG(base), MSCM_CPxTYPE_RYPZ_SHIFT, MSCM_CPxTYPE_RYPZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CPxTYPE, field PERSONALITY[31:8] (RO)
 *
 * This read-only field defines the processor personality for CPx if CPx =
 * Cortex-M0, then PERSONALITY = 0x43_4D_30 ("CM0").
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxTYPE_PERSONALITY field. */
#define MSCM_RD_CPxTYPE_PERSONALITY(base) ((MSCM_CPxTYPE_REG(base) & MSCM_CPxTYPE_PERSONALITY_MASK) >> MSCM_CPxTYPE_PERSONALITY_SHIFT)
#define MSCM_BRD_CPxTYPE_PERSONALITY(base) (MSCM_RD_CPxTYPE_PERSONALITY(base))
/*@}*/

/*******************************************************************************
 * MSCM_CPxNUM - Processor X Number Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxNUM - Processor X Number Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the logical
 * processor number of the core making the access. The boot (or primary) core is assigned
 * the number 0, while the secondary core is defined as number 1.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxNUM register
 */
/*@{*/
#define MSCM_RD_CPxNUM(base)     (MSCM_CPxNUM_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxNUM bitfields
 */

/*!
 * @name Register MSCM_CPxNUM, field CPN[0] (RO)
 *
 * This zero-filled word defines the logical processor number for CPx If boot
 * (primary) core, then CPN = 0 For secondary core, CPN = 1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxNUM_CPN field. */
#define MSCM_RD_CPxNUM_CPN(base) ((MSCM_CPxNUM_REG(base) & MSCM_CPxNUM_CPN_MASK) >> MSCM_CPxNUM_CPN_SHIFT)
#define MSCM_BRD_CPxNUM_CPN(base) (BME_UBFX32(&MSCM_CPxNUM_REG(base), MSCM_CPxNUM_CPN_SHIFT, MSCM_CPxNUM_CPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CPxMASTER - Processor X Master Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxMASTER - Processor X Master Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the physical bus
 * master number of the core that is making the access. The 32-bit response defines
 * the physical master number for processor x. A privileged read from the CM0+
 * returns the appropriate processor information. Reads from any other bus master
 * return all zeroes. Attempted user mode or write accesses are terminated with an
 * error.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxMASTER register
 */
/*@{*/
#define MSCM_RD_CPxMASTER(base)  (MSCM_CPxMASTER_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxMASTER bitfields
 */

/*!
 * @name Register MSCM_CPxMASTER, field PPN[5:0] (RO)
 *
 * This read-only field defines the physical port number for CoreN . For Core0,
 * PPN = 0x00 For Core1, PPN = 0x24
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxMASTER_PPN field. */
#define MSCM_RD_CPxMASTER_PPN(base) ((MSCM_CPxMASTER_REG(base) & MSCM_CPxMASTER_PPN_MASK) >> MSCM_CPxMASTER_PPN_SHIFT)
#define MSCM_BRD_CPxMASTER_PPN(base) (BME_UBFX32(&MSCM_CPxMASTER_REG(base), MSCM_CPxMASTER_PPN_SHIFT, MSCM_CPxMASTER_PPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CPxCOUNT - Processor X Count Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxCOUNT - Processor X Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the total number of
 * processor cores in the chip configuration.
 */
/*!
 * @name Constants and macros for entire MSCM_CPxCOUNT register
 */
/*@{*/
#define MSCM_RD_CPxCOUNT(base)   (MSCM_CPxCOUNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxCOUNT bitfields
 */

/*!
 * @name Register MSCM_CPxCOUNT, field PCNT[1:0] (RO)
 *
 * This read-only field defines the processor count for the chip configuration:
 * PCNT = 01
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxCOUNT_PCNT field. */
#define MSCM_RD_CPxCOUNT_PCNT(base) ((MSCM_CPxCOUNT_REG(base) & MSCM_CPxCOUNT_PCNT_MASK) >> MSCM_CPxCOUNT_PCNT_SHIFT)
#define MSCM_BRD_CPxCOUNT_PCNT(base) (BME_UBFX32(&MSCM_CPxCOUNT_REG(base), MSCM_CPxCOUNT_PCNT_SHIFT, MSCM_CPxCOUNT_PCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CPxCFG - Processor X Configuration Register
 ******************************************************************************/

/*!
 * @brief MSCM_CPxCFG - Processor X Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides information on the Level 1 caches (if present).
 */
/*!
 * @name Constants and macros for entire MSCM_CPxCFG register
 */
/*@{*/
#define MSCM_RD_CPxCFG(base, index) (MSCM_CPxCFG_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_CPxCFG bitfields
 */

/*!
 * @name Register MSCM_CPxCFG, field DCWY[7:0] (RO)
 *
 * This read-only field provides the number of cache ways for the Data Cache.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxCFG_DCWY field. */
#define MSCM_RD_CPxCFG_DCWY(base, index) ((MSCM_CPxCFG_REG(base, index) & MSCM_CPxCFG_DCWY_MASK) >> MSCM_CPxCFG_DCWY_SHIFT)
#define MSCM_BRD_CPxCFG_DCWY(base, index) (BME_UBFX32(&MSCM_CPxCFG_REG(base, index), MSCM_CPxCFG_DCWY_SHIFT, MSCM_CPxCFG_DCWY_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CPxCFG, field DCSZ[15:8] (RO)
 *
 * This read-only field provides an encoded value of the Data Cache size. The
 * capacity of the memory is expressed as Size [bytes] = 2(8+SZ) ,where SZ is
 * non-zero; a SZ = 0 indicates the memory is not present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxCFG_DCSZ field. */
#define MSCM_RD_CPxCFG_DCSZ(base, index) ((MSCM_CPxCFG_REG(base, index) & MSCM_CPxCFG_DCSZ_MASK) >> MSCM_CPxCFG_DCSZ_SHIFT)
#define MSCM_BRD_CPxCFG_DCSZ(base, index) (BME_UBFX32(&MSCM_CPxCFG_REG(base, index), MSCM_CPxCFG_DCSZ_SHIFT, MSCM_CPxCFG_DCSZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CPxCFG, field ICWY[23:16] (RO)
 *
 * This read-only field provides the number of cache ways for the Instruction
 * Cache.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxCFG_ICWY field. */
#define MSCM_RD_CPxCFG_ICWY(base, index) ((MSCM_CPxCFG_REG(base, index) & MSCM_CPxCFG_ICWY_MASK) >> MSCM_CPxCFG_ICWY_SHIFT)
#define MSCM_BRD_CPxCFG_ICWY(base, index) (BME_UBFX32(&MSCM_CPxCFG_REG(base, index), MSCM_CPxCFG_ICWY_SHIFT, MSCM_CPxCFG_ICWY_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CPxCFG, field ICSZ[31:24] (RO)
 *
 * This read-only field provides an encoded value of the Instruction Cache size.
 * The capacity of the memory is expressed as Size [bytes] = 2(8+SZ), where SZ
 * is non-zero; a SZ = 0 indicates the memory is not present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CPxCFG_ICSZ field. */
#define MSCM_RD_CPxCFG_ICSZ(base, index) ((MSCM_CPxCFG_REG(base, index) & MSCM_CPxCFG_ICSZ_MASK) >> MSCM_CPxCFG_ICSZ_SHIFT)
#define MSCM_BRD_CPxCFG_ICSZ(base, index) (BME_UBFX32(&MSCM_CPxCFG_REG(base, index), MSCM_CPxCFG_ICSZ_SHIFT, MSCM_CPxCFG_ICSZ_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP0TYPE - Processor 0 Type Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0TYPE - Processor 0 Type Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the personality of
 * the core making the access. The 32-bit response includes 3 ASCII characters
 * defining the CPU type, along with a byte defining the logical revision number.
 * The logical revision number follows ARM's rYpZ nomenclature.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0TYPE register
 */
/*@{*/
#define MSCM_RD_CP0TYPE(base)    (MSCM_CP0TYPE_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0TYPE bitfields
 */

/*!
 * @name Register MSCM_CP0TYPE, field RYPZ[7:0] (RO)
 *
 * This read-only field defines the processor revision for CPx: 0x00 corresponds
 * to the r0p0 core release. 0x01 corresponds to the r0p1 core release. ...
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0TYPE_RYPZ field. */
#define MSCM_RD_CP0TYPE_RYPZ(base) ((MSCM_CP0TYPE_REG(base) & MSCM_CP0TYPE_RYPZ_MASK) >> MSCM_CP0TYPE_RYPZ_SHIFT)
#define MSCM_BRD_CP0TYPE_RYPZ(base) (BME_UBFX32(&MSCM_CP0TYPE_REG(base), MSCM_CP0TYPE_RYPZ_SHIFT, MSCM_CP0TYPE_RYPZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP0TYPE, field PERSONALITY[31:8] (RO)
 *
 * This read-only field defines the processor personality for CPx if CPx =
 * Cortex-M0, then PERSONALITY = 0x43_4D_30 ("CM0").
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0TYPE_PERSONALITY field. */
#define MSCM_RD_CP0TYPE_PERSONALITY(base) ((MSCM_CP0TYPE_REG(base) & MSCM_CP0TYPE_PERSONALITY_MASK) >> MSCM_CP0TYPE_PERSONALITY_SHIFT)
#define MSCM_BRD_CP0TYPE_PERSONALITY(base) (MSCM_RD_CP0TYPE_PERSONALITY(base))
/*@}*/

/*******************************************************************************
 * MSCM_CP0NUM - Processor 0 Number Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0NUM - Processor 0 Number Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the logical
 * processor number of the core making the access. The boot (or primary) core is assigned
 * the number 0, while the secondary core is defined as number 1.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0NUM register
 */
/*@{*/
#define MSCM_RD_CP0NUM(base)     (MSCM_CP0NUM_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0NUM bitfields
 */

/*!
 * @name Register MSCM_CP0NUM, field CPN[0] (RO)
 *
 * This zero-filled word defines the logical processor number for CPx If boot
 * (primary) core, then CPN = 0 For secondary core, CPN = 1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0NUM_CPN field. */
#define MSCM_RD_CP0NUM_CPN(base) ((MSCM_CP0NUM_REG(base) & MSCM_CP0NUM_CPN_MASK) >> MSCM_CP0NUM_CPN_SHIFT)
#define MSCM_BRD_CP0NUM_CPN(base) (BME_UBFX32(&MSCM_CP0NUM_REG(base), MSCM_CP0NUM_CPN_SHIFT, MSCM_CP0NUM_CPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP0MASTER - Processor 0 Master Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0MASTER - Processor 0 Master Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response, that indicates the physical
 * bus master number of the core making the access. The 32-bit response defines the
 * physical master number for processor x. A privileged read from the CM0+
 * returns the appropriate processor information. Reads from any other bus master
 * return all zeroes. Attempted user mode or write accesses are terminated with an
 * error.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0MASTER register
 */
/*@{*/
#define MSCM_RD_CP0MASTER(base)  (MSCM_CP0MASTER_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0MASTER bitfields
 */

/*!
 * @name Register MSCM_CP0MASTER, field PPN[5:0] (RO)
 *
 * This read-only field defines the physical port number for CPUx. For CPU0, PPN
 * = 0x00 For CPU1, PPN = 0x24
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0MASTER_PPN field. */
#define MSCM_RD_CP0MASTER_PPN(base) ((MSCM_CP0MASTER_REG(base) & MSCM_CP0MASTER_PPN_MASK) >> MSCM_CP0MASTER_PPN_SHIFT)
#define MSCM_BRD_CP0MASTER_PPN(base) (BME_UBFX32(&MSCM_CP0MASTER_REG(base), MSCM_CP0MASTER_PPN_SHIFT, MSCM_CP0MASTER_PPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP0COUNT - Processor 0 Count Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0COUNT - Processor 0 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the total number of
 * processor cores in the chip configuration.
 */
/*!
 * @name Constants and macros for entire MSCM_CP0COUNT register
 */
/*@{*/
#define MSCM_RD_CP0COUNT(base)   (MSCM_CP0COUNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0COUNT bitfields
 */

/*!
 * @name Register MSCM_CP0COUNT, field PCNT[1:0] (RO)
 *
 * This read-only field defines the processor count for the chip configuration:
 * PCNT = 01
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0COUNT_PCNT field. */
#define MSCM_RD_CP0COUNT_PCNT(base) ((MSCM_CP0COUNT_REG(base) & MSCM_CP0COUNT_PCNT_MASK) >> MSCM_CP0COUNT_PCNT_SHIFT)
#define MSCM_BRD_CP0COUNT_PCNT(base) (BME_UBFX32(&MSCM_CP0COUNT_REG(base), MSCM_CP0COUNT_PCNT_SHIFT, MSCM_CP0COUNT_PCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP0CFG - Processor 0 Configuration Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP0CFG - Processor 0 Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides information on the Level 1 caches (if present).
 */
/*!
 * @name Constants and macros for entire MSCM_CP0CFG register
 */
/*@{*/
#define MSCM_RD_CP0CFG(base, index) (MSCM_CP0CFG_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP0CFG bitfields
 */

/*!
 * @name Register MSCM_CP0CFG, field DCWY[7:0] (RO)
 *
 * This read-only field provides the number of cache ways for the Data Cache.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0CFG_DCWY field. */
#define MSCM_RD_CP0CFG_DCWY(base, index) ((MSCM_CP0CFG_REG(base, index) & MSCM_CP0CFG_DCWY_MASK) >> MSCM_CP0CFG_DCWY_SHIFT)
#define MSCM_BRD_CP0CFG_DCWY(base, index) (BME_UBFX32(&MSCM_CP0CFG_REG(base, index), MSCM_CP0CFG_DCWY_SHIFT, MSCM_CP0CFG_DCWY_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP0CFG, field DCSZ[15:8] (RO)
 *
 * This read-only field provides an encoded value of the Data Cache size. The
 * capacity of the memory is expressed as Size [bytes] = 2(8+SZ) ,where SZ is
 * non-zero; a SZ = 0 indicates the memory is not present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0CFG_DCSZ field. */
#define MSCM_RD_CP0CFG_DCSZ(base, index) ((MSCM_CP0CFG_REG(base, index) & MSCM_CP0CFG_DCSZ_MASK) >> MSCM_CP0CFG_DCSZ_SHIFT)
#define MSCM_BRD_CP0CFG_DCSZ(base, index) (BME_UBFX32(&MSCM_CP0CFG_REG(base, index), MSCM_CP0CFG_DCSZ_SHIFT, MSCM_CP0CFG_DCSZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP0CFG, field ICWY[23:16] (RO)
 *
 * This read-only field provides the number of cache ways for the Instruction
 * Cache.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0CFG_ICWY field. */
#define MSCM_RD_CP0CFG_ICWY(base, index) ((MSCM_CP0CFG_REG(base, index) & MSCM_CP0CFG_ICWY_MASK) >> MSCM_CP0CFG_ICWY_SHIFT)
#define MSCM_BRD_CP0CFG_ICWY(base, index) (BME_UBFX32(&MSCM_CP0CFG_REG(base, index), MSCM_CP0CFG_ICWY_SHIFT, MSCM_CP0CFG_ICWY_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP0CFG, field ICSZ[31:24] (RO)
 *
 * This read-only field provides an encoded value of the Instruction Cache size.
 * The capacity of the memory is expressed as Size [bytes] = 2(8+SZ), where SZ
 * is non-zero; a SZ = 0 indicates the memory is not present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP0CFG_ICSZ field. */
#define MSCM_RD_CP0CFG_ICSZ(base, index) ((MSCM_CP0CFG_REG(base, index) & MSCM_CP0CFG_ICSZ_MASK) >> MSCM_CP0CFG_ICSZ_SHIFT)
#define MSCM_BRD_CP0CFG_ICSZ(base, index) (BME_UBFX32(&MSCM_CP0CFG_REG(base, index), MSCM_CP0CFG_ICSZ_SHIFT, MSCM_CP0CFG_ICSZ_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP1TYPE - Processor 1 Type Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP1TYPE - Processor 1 Type Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the personality of
 * the core making the access. The 32-bit response includes 3 ASCII characters
 * defining the CPU type, along with a byte defining the logical revision number.
 * The logical revision number follows ARM's rYpZ nomenclature.
 */
/*!
 * @name Constants and macros for entire MSCM_CP1TYPE register
 */
/*@{*/
#define MSCM_RD_CP1TYPE(base)    (MSCM_CP1TYPE_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP1TYPE bitfields
 */

/*!
 * @name Register MSCM_CP1TYPE, field RYPZ[7:0] (RO)
 *
 * This read-only field defines the processor revision for CPx: 0x00 corresponds
 * to the r0p0 core release. 0x01 corresponds to the r0p1 core release. ...
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1TYPE_RYPZ field. */
#define MSCM_RD_CP1TYPE_RYPZ(base) ((MSCM_CP1TYPE_REG(base) & MSCM_CP1TYPE_RYPZ_MASK) >> MSCM_CP1TYPE_RYPZ_SHIFT)
#define MSCM_BRD_CP1TYPE_RYPZ(base) (BME_UBFX32(&MSCM_CP1TYPE_REG(base), MSCM_CP1TYPE_RYPZ_SHIFT, MSCM_CP1TYPE_RYPZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP1TYPE, field PERSONALITY[31:8] (RO)
 *
 * This read-only field defines the processor personality for CPx if CPx =
 * Cortex-M0, then PERSONALITY = 0x43_4D_30 ("CM0").
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1TYPE_PERSONALITY field. */
#define MSCM_RD_CP1TYPE_PERSONALITY(base) ((MSCM_CP1TYPE_REG(base) & MSCM_CP1TYPE_PERSONALITY_MASK) >> MSCM_CP1TYPE_PERSONALITY_SHIFT)
#define MSCM_BRD_CP1TYPE_PERSONALITY(base) (MSCM_RD_CP1TYPE_PERSONALITY(base))
/*@}*/

/*******************************************************************************
 * MSCM_CP1NUM - Processor 1 Number Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP1NUM - Processor 1 Number Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the logical
 * processor number of the core making the access. The boot (or primary) core is assigned
 * the number 0, while the secondary core is defined as number 1.
 */
/*!
 * @name Constants and macros for entire MSCM_CP1NUM register
 */
/*@{*/
#define MSCM_RD_CP1NUM(base)     (MSCM_CP1NUM_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP1NUM bitfields
 */

/*!
 * @name Register MSCM_CP1NUM, field CPN[0] (RO)
 *
 * This zero-filled word defines the logical processor number for CPx If boot
 * (primary) core, then CPN = 0 For the secondary core, CPN = 1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1NUM_CPN field. */
#define MSCM_RD_CP1NUM_CPN(base) ((MSCM_CP1NUM_REG(base) & MSCM_CP1NUM_CPN_MASK) >> MSCM_CP1NUM_CPN_SHIFT)
#define MSCM_BRD_CP1NUM_CPN(base) (BME_UBFX32(&MSCM_CP1NUM_REG(base), MSCM_CP1NUM_CPN_SHIFT, MSCM_CP1NUM_CPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP1MASTER - Processor 1 Master Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP1MASTER - Processor 1 Master Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response, that indicates the physical
 * bus master number of the core making the access. The 32-bit response defines the
 * physical master number for processor x. A privileged read from the CM0+
 * returns the appropriate processor information. Reads from any other bus master
 * return all zeroes. Attempted user mode or write accesses are terminated with an
 * error.
 */
/*!
 * @name Constants and macros for entire MSCM_CP1MASTER register
 */
/*@{*/
#define MSCM_RD_CP1MASTER(base)  (MSCM_CP1MASTER_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP1MASTER bitfields
 */

/*!
 * @name Register MSCM_CP1MASTER, field PPN[5:0] (RO)
 *
 * This read-only field defines the physical port number for CPUx. For CPU0, PPN
 * = 0x00 For CPU1, PPN = 0x24
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1MASTER_PPN field. */
#define MSCM_RD_CP1MASTER_PPN(base) ((MSCM_CP1MASTER_REG(base) & MSCM_CP1MASTER_PPN_MASK) >> MSCM_CP1MASTER_PPN_SHIFT)
#define MSCM_BRD_CP1MASTER_PPN(base) (BME_UBFX32(&MSCM_CP1MASTER_REG(base), MSCM_CP1MASTER_PPN_SHIFT, MSCM_CP1MASTER_PPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP1COUNT - Processor 1 Count Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP1COUNT - Processor 1 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the total number of
 * processor cores in the chip configuration.
 */
/*!
 * @name Constants and macros for entire MSCM_CP1COUNT register
 */
/*@{*/
#define MSCM_RD_CP1COUNT(base)   (MSCM_CP1COUNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP1COUNT bitfields
 */

/*!
 * @name Register MSCM_CP1COUNT, field PCNT[1:0] (RO)
 *
 * This read-only field defines the processor count for the chip configuration:
 * PCNT = 01
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1COUNT_PCNT field. */
#define MSCM_RD_CP1COUNT_PCNT(base) ((MSCM_CP1COUNT_REG(base) & MSCM_CP1COUNT_PCNT_MASK) >> MSCM_CP1COUNT_PCNT_SHIFT)
#define MSCM_BRD_CP1COUNT_PCNT(base) (BME_UBFX32(&MSCM_CP1COUNT_REG(base), MSCM_CP1COUNT_PCNT_SHIFT, MSCM_CP1COUNT_PCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CP1CFG - Processor 1 Configuration Register
 ******************************************************************************/

/*!
 * @brief MSCM_CP1CFG - Processor 1 Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides information on the Level 1 caches (if present).
 */
/*!
 * @name Constants and macros for entire MSCM_CP1CFG register
 */
/*@{*/
#define MSCM_RD_CP1CFG(base, index) (MSCM_CP1CFG_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_CP1CFG bitfields
 */

/*!
 * @name Register MSCM_CP1CFG, field DCWY[7:0] (RO)
 *
 * This read-only field provides the number of cache ways for the Data Cache.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1CFG_DCWY field. */
#define MSCM_RD_CP1CFG_DCWY(base, index) ((MSCM_CP1CFG_REG(base, index) & MSCM_CP1CFG_DCWY_MASK) >> MSCM_CP1CFG_DCWY_SHIFT)
#define MSCM_BRD_CP1CFG_DCWY(base, index) (BME_UBFX32(&MSCM_CP1CFG_REG(base, index), MSCM_CP1CFG_DCWY_SHIFT, MSCM_CP1CFG_DCWY_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP1CFG, field DCSZ[15:8] (RO)
 *
 * This read-only field provides an encoded value of the Data Cache size. The
 * capacity of the memory is expressed as Size [bytes] = 2(8+SZ) ,where SZ is
 * non-zero; a SZ = 0 indicates the memory is not present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1CFG_DCSZ field. */
#define MSCM_RD_CP1CFG_DCSZ(base, index) ((MSCM_CP1CFG_REG(base, index) & MSCM_CP1CFG_DCSZ_MASK) >> MSCM_CP1CFG_DCSZ_SHIFT)
#define MSCM_BRD_CP1CFG_DCSZ(base, index) (BME_UBFX32(&MSCM_CP1CFG_REG(base, index), MSCM_CP1CFG_DCSZ_SHIFT, MSCM_CP1CFG_DCSZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP1CFG, field ICWY[23:16] (RO)
 *
 * This read-only field provides the number of cache ways for the Instruction
 * Cache.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1CFG_ICWY field. */
#define MSCM_RD_CP1CFG_ICWY(base, index) ((MSCM_CP1CFG_REG(base, index) & MSCM_CP1CFG_ICWY_MASK) >> MSCM_CP1CFG_ICWY_SHIFT)
#define MSCM_BRD_CP1CFG_ICWY(base, index) (BME_UBFX32(&MSCM_CP1CFG_REG(base, index), MSCM_CP1CFG_ICWY_SHIFT, MSCM_CP1CFG_ICWY_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CP1CFG, field ICSZ[31:24] (RO)
 *
 * This read-only field provides an encoded value of the Instruction Cache size.
 * The capacity of the memory is expressed as Size [bytes] = 2(8+SZ), where SZ
 * is non-zero; a SZ = 0 indicates the memory is not present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CP1CFG_ICSZ field. */
#define MSCM_RD_CP1CFG_ICSZ(base, index) ((MSCM_CP1CFG_REG(base, index) & MSCM_CP1CFG_ICSZ_MASK) >> MSCM_CP1CFG_ICSZ_SHIFT)
#define MSCM_BRD_CP1CFG_ICSZ(base, index) (BME_UBFX32(&MSCM_CP1CFG_REG(base, index), MSCM_CP1CFG_ICSZ_SHIFT, MSCM_CP1CFG_ICSZ_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_OCMDR - On-Chip Memory Descriptor Register
 ******************************************************************************/

/*!
 * @brief MSCM_OCMDR - On-Chip Memory Descriptor Register (RO)
 *
 * Reset value: 0x40000000U
 *
 * This section of the programming model is an array of 32-bit generic on-chip
 * memory descriptor registers that provide static information about the attached
 * memories, as well as configurable controls (where appropriate). Privileged
 * 32-bit reads from a processor core or the debugger return the appropriate
 * processor information. Reads from any other bus master return all zeroes. Privileged
 * writes from a processor core or the debugger to writeable registers update the
 * appropriate fields. Privileged writes from other bus masters are ignored.
 * Attempted user mode accesses or any access with a size other than 32 bits are
 * terminated with an error.
 */
/*!
 * @name Constants and macros for entire MSCM_OCMDR register
 */
/*@{*/
#define MSCM_RD_OCMDR(base, index) (MSCM_OCMDR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_OCMDR bitfields
 */

/*!
 * @name Register MSCM_OCMDR, field OCMPU[12] (RO)
 *
 * OCMEM Memory Protection Unit. This read-only field identifies a memory
 * protected by an XRDC module.
 *
 * Values:
 * - 0b0 - OCMEMn is not protected by an XRDC module.
 * - 0b1 - OCMEMn is protected by an XRDC module.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMPU field. */
#define MSCM_RD_OCMDR_OCMPU(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMPU_MASK) >> MSCM_OCMDR_OCMPU_SHIFT)
#define MSCM_BRD_OCMDR_OCMPU(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMPU_SHIFT, MSCM_OCMDR_OCMPU_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMT[15:13] (RO)
 *
 * OCMEM Type. This field defines the type of the on-chip memory:
 *
 * Values:
 * - 0b000 - OCMEMn is a system RAM.
 * - 0b001 - OCMEMn is a graphics RAM.
 * - 0b010 - Reserved
 * - 0b011 - OCMEMn is a ROM.
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMT field. */
#define MSCM_RD_OCMDR_OCMT(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMT_MASK) >> MSCM_OCMDR_OCMT_SHIFT)
#define MSCM_BRD_OCMDR_OCMT(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMT_SHIFT, MSCM_OCMDR_OCMT_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field RO[16] (RO)
 *
 * Read-Only. This register bit provides a mechanism to "lock" the configuration
 * state defined by OCMDRn[11:0]. Once asserted, attempted writes to the
 * OCMDRn[11:0] register are ignored until the next reset clears the flag.
 *
 * Values:
 * - 0b0 - Writes to the OCMDRn[11:0] are allowed
 * - 0b1 - Writes to the OCMDRn[11:0] are ignored
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_RO field. */
#define MSCM_RD_OCMDR_RO(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_RO_MASK) >> MSCM_OCMDR_RO_SHIFT)
#define MSCM_BRD_OCMDR_RO(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_RO_SHIFT, MSCM_OCMDR_RO_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMW[19:17] (RO)
 *
 * OCMEM datapath Width. This read-only field defines the width of the on-chip
 * memory:
 *
 * Values:
 * - 0b010 - OCMEMn 32-bits wide
 * - 0b011 - OCMEMn 64-bits wide
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMW field. */
#define MSCM_RD_OCMDR_OCMW(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMW_MASK) >> MSCM_OCMDR_OCMW_SHIFT)
#define MSCM_BRD_OCMDR_OCMW(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMW_SHIFT, MSCM_OCMDR_OCMW_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMSZ[27:24] (RO)
 *
 * OCMEM Size. This read-only field provides an encoded value of the on-chip
 * memory size. The capacity of the memory is expressed as Size [bytes] = 2(8+SZ)
 * where SZ is non-zero; a SZ = 0 indicates the memory is not present.
 *
 * Values:
 * - 0b0000 - no OCMEMn
 * - 0b0100 - 4KB OCMEMn
 * - 0b0101 - 8KB OCMEMn
 * - 0b0110 - 16KB OCMEMn
 * - 0b0111 - 32KB OCMEMn
 * - 0b1111 - 8192KB OCMEMn
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMSZ field. */
#define MSCM_RD_OCMDR_OCMSZ(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMSZ_MASK) >> MSCM_OCMDR_OCMSZ_SHIFT)
#define MSCM_BRD_OCMDR_OCMSZ(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMSZ_SHIFT, MSCM_OCMDR_OCMSZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMSZH[28] (RO)
 *
 * OCMEM Size "Hole". For on-chip memories that are not fully populated, that
 * is, include a memory "hole" in the upper 25% of the address range, this bit is
 * used.
 *
 * Values:
 * - 0b0 - OCMEMn is a power-of-2 capacity.
 * - 0b1 - OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMSZH field. */
#define MSCM_RD_OCMDR_OCMSZH(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMSZH_MASK) >> MSCM_OCMDR_OCMSZH_SHIFT)
#define MSCM_BRD_OCMDR_OCMSZH(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMSZH_SHIFT, MSCM_OCMDR_OCMSZH_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field V[31] (RO)
 *
 * OCMEM Valid bit. This read-only field defines the validity (presence) of the
 * on-chip memory
 *
 * Values:
 * - 0b0 - OCMEMn is not present.
 * - 0b1 - OCMEMn is present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_V field. */
#define MSCM_RD_OCMDR_V(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_V_MASK) >> MSCM_OCMDR_V_SHIFT)
#define MSCM_BRD_OCMDR_V(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_V_SHIFT, MSCM_OCMDR_V_WIDTH))
/*@}*/

/*
 * MKL28Z7 MTB
 *
 * Micro Trace Buffer
 *
 * Registers defined in this header file:
 * - MTB_POSITION - MTB Position Register
 * - MTB_MASTER - MTB Master Register
 * - MTB_FLOW - MTB Flow Register
 * - MTB_BASE - MTB Base Register
 * - MTB_MODECTRL - Integration Mode Control Register
 * - MTB_TAGSET - Claim TAG Set Register
 * - MTB_TAGCLEAR - Claim TAG Clear Register
 * - MTB_LOCKACCESS - Lock Access Register
 * - MTB_LOCKSTAT - Lock Status Register
 * - MTB_AUTHSTAT - Authentication Status Register
 * - MTB_DEVICEARCH - Device Architecture Register
 * - MTB_DEVICECFG - Device Configuration Register
 * - MTB_DEVICETYPID - Device Type Identifier Register
 * - MTB_PERIPHID - Peripheral ID Register
 * - MTB_COMPID - Component ID Register
 */

#define MTB_INSTANCE_COUNT (2U) /*!< Number of instances of the MTB module. */
#define MTB0_IDX (0U) /*!< Instance number for MTB0. */
#define MTB1_IDX (1U) /*!< Instance number for MTB1. */

/*******************************************************************************
 * MTB_POSITION - MTB Position Register
 ******************************************************************************/

/*!
 * @brief MTB_POSITION - MTB Position Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_POSITION register contains the Trace Write Address Pointer and Wrap
 * fields. This register can be modified by the explicit programming model writes.
 * It is also automatically updated by the MTB hardware when trace packets are
 * being recorded. The base address of the system RAM in the memory map dictates
 * special consideration for the placement of the MTB. Consider the following
 * guidelines: For the standard configuration where the size of the MTB is <= 25% of
 * the total RAM capacity, it is recommended the MTB be based at the address
 * defined by the MTB_BASE register. The read-only MTB_BASE register is defined by
 * the expression (0x2000_0000 - (RAM_Size/4)). For this configuration, the
 * MTB_POSITION register is initialized to MTB_BASE & 0x0000_7FF8. If the size of the
 * MTB is more than 25% but less than or equal to 50% of the total RAM capacity, it
 * is recommended the MTB be based at address 0x2000_0000. In this
 * configuration, the MTB_POSITION register is initialized to (0x2000_0000 & 0x0000_7FF8) =
 * 0x0000_00000. Following these two suggested placements provides a full-featured
 * circular memory buffer containing program trace packets. In the unlikely event
 * an even larger trace buffer is required, a write-once capacity of 75% of the
 * total RAM capacity can be based at address 0x2000_0000. The MTB_POSITION
 * register is initialized to (0x2000_0000 & 0x0000_7FF8) = 0x0000_0000. However, this
 * configuration cannot support operation as a circular queue and instead
 * requires the use of the MTB_FLOW[WATERMARK] capability to automatically disable
 * tracing or halting the processor as the number of packet writes approach the
 * buffer capacity. See the MTB_FLOW register description for more details.
 */
/*!
 * @name Constants and macros for entire MTB_POSITION register
 */
/*@{*/
#define MTB_RD_POSITION(base)    (MTB_POSITION_REG(base))
#define MTB_WR_POSITION(base, value) (MTB_POSITION_REG(base) = (value))
#define MTB_RMW_POSITION(base, mask, value) (MTB_WR_POSITION(base, (MTB_RD_POSITION(base) & ~(mask)) | (value)))
#define MTB_SET_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) |  (value)))
#define MTB_CLR_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) & ~(value)))
#define MTB_TOG_POSITION(base, value) (MTB_WR_POSITION(base, MTB_RD_POSITION(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_POSITION bitfields
 */

/*!
 * @name Register MTB_POSITION, field WRAP[2] (RW)
 *
 * This field is set to 1 automatically when the POINTER value wraps (as
 * determined by the MTB_MASTER[MASK] field in the MASTER Trace Control Register). A
 * debug agent might use the WRAP field to determine whether the trace information
 * above and below the pointer address is valid.
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_WRAP field. */
#define MTB_RD_POSITION_WRAP(base) ((MTB_POSITION_REG(base) & MTB_POSITION_WRAP_MASK) >> MTB_POSITION_WRAP_SHIFT)
#define MTB_BRD_POSITION_WRAP(base) (MTB_RD_POSITION_WRAP(base))

/*! @brief Set the WRAP field to a new value. */
#define MTB_WR_POSITION_WRAP(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_WRAP_MASK, MTB_POSITION_WRAP(value)))
#define MTB_BWR_POSITION_WRAP(base, value) (MTB_WR_POSITION_WRAP(base, value))
/*@}*/

/*!
 * @name Register MTB_POSITION, field POINTER[31:3] (RW)
 *
 * Because a packet consists of 2 words, the POINTER field is the address of the
 * first word of a packet. This field contains bits[31:3] of the RAM address
 * where the next trace packet is written. Therefore, it points to an unused
 * location and is automatically incremented. A debug agent can calculate the system
 * memory map address for the current location in the MTB, using the following
 * "generic" equation: Given mtb_size = 1 << (MTB_MASTER[MASK] + 4), systemAddress =
 * MTB_BASE + (((MTB_POSITION & 0xFFFF_FFF8) + (mtb_size - (MTB_BASE &
 * (mtb_size-1)))) & 0x0000_7FF8); For this device, a simpler expression (in pseudo-code)
 * also applies: if ((MTB_POSITION >> 15) == 0x3) systemAddress = (0x1FFF << 16) +
 * (MTB_POSITION & 0xFFF8); else systemAddress = (0x2000 << 16) + (MTB_POSITION &
 * 0x1FFF8); The size of the RAM is parameterized and the most significant bits
 * of the POINTER field are RAZ/WI. For these devices, POSITION[31:17] ==
 * POSITION[POINTER[28:14]] are RAZ/WI. Therefore, the active bits in this field are
 * POSITION[16:3] == POSITION[POINTER[13:0]].
 */
/*@{*/
/*! @brief Read current value of the MTB_POSITION_POINTER field. */
#define MTB_RD_POSITION_POINTER(base) ((MTB_POSITION_REG(base) & MTB_POSITION_POINTER_MASK) >> MTB_POSITION_POINTER_SHIFT)
#define MTB_BRD_POSITION_POINTER(base) (MTB_RD_POSITION_POINTER(base))

/*! @brief Set the POINTER field to a new value. */
#define MTB_WR_POSITION_POINTER(base, value) (MTB_RMW_POSITION(base, MTB_POSITION_POINTER_MASK, MTB_POSITION_POINTER(value)))
#define MTB_BWR_POSITION_POINTER(base, value) (MTB_WR_POSITION_POINTER(base, value))
/*@}*/

/*******************************************************************************
 * MTB_MASTER - MTB Master Register
 ******************************************************************************/

/*!
 * @brief MTB_MASTER - MTB Master Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * The MTB_MASTER register contains the main program trace enable plus other
 * trace controls. This register can be modified by the explicit programming model
 * writes. MTB_MASTER[EN] and MTB_MASTER[HALTREQ] fields are also automatically
 * updated by the MTB hardware. Before MTB_MASTER[EN] or MTB_MASTER[TSTARTEN] are
 * set to 1, the software must initialize the MTB_POSITION and MTB_FLOW registers.
 * If MTB_FLOW[WATERMARK] is used to stop tracing or to halt the processor,
 * MTB_MASTER[MASK] must still be set to a value that prevents MTB_POSITION[POINTER]
 * from wrapping before it reaches the MTB_FLOW[WATERMARK] value. The format of
 * this mask field is different than MTBDWT_MASKn[MASK].
 */
/*!
 * @name Constants and macros for entire MTB_MASTER register
 */
/*@{*/
#define MTB_RD_MASTER(base)      (MTB_MASTER_REG(base))
#define MTB_WR_MASTER(base, value) (MTB_MASTER_REG(base) = (value))
#define MTB_RMW_MASTER(base, mask, value) (MTB_WR_MASTER(base, (MTB_RD_MASTER(base) & ~(mask)) | (value)))
#define MTB_SET_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) |  (value)))
#define MTB_CLR_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) & ~(value)))
#define MTB_TOG_MASTER(base, value) (MTB_WR_MASTER(base, MTB_RD_MASTER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_MASTER bitfields
 */

/*!
 * @name Register MTB_MASTER, field MASK[4:0] (RW)
 *
 * This value determines the maximum size of the trace buffer in RAM. It
 * specifies the most-significant bit of the MTB_POSITION[POINTER] field that can be
 * updated by automatic increment. If the trace tries to advance past this power of
 * 2, the MTB_POSITION[WRAP] bit is set to 1, the MTB_POSITION[MASK+3:3] ==
 * MTB_POSITION[POINTER[MASK:0]] bits are set to 0, and the MTB_POSITION[14:MASK+3] ==
 * MTB_POSITION[POINTER[11:MASK+1]] bits remain unchanged. This field causes the
 * trace packet information to be stored in a circular buffer of size 2^[MASK+4]
 * bytes, that can be positioned in memory at multiples of this size. As
 * detailed in the MTB_POSITION description, typical "upper limits" for the MTB size are
 * RAM_Size/4 or RAM_Size/2. Values greater than the maximum have the same
 * effect as the maximum.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_MASK field. */
#define MTB_RD_MASTER_MASK(base) ((MTB_MASTER_REG(base) & MTB_MASTER_MASK_MASK) >> MTB_MASTER_MASK_SHIFT)
#define MTB_BRD_MASTER_MASK(base) (MTB_RD_MASTER_MASK(base))

/*! @brief Set the MASK field to a new value. */
#define MTB_WR_MASTER_MASK(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_MASK_MASK, MTB_MASTER_MASK(value)))
#define MTB_BWR_MASTER_MASK(base, value) (MTB_WR_MASTER_MASK(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTARTEN[5] (RW)
 *
 * If this field is 1 and the TSTART signal is HIGH, then EN is set to 1.
 * Tracing continues until a stop condition occurs.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTARTEN field. */
#define MTB_RD_MASTER_TSTARTEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTARTEN_MASK) >> MTB_MASTER_TSTARTEN_SHIFT)
#define MTB_BRD_MASTER_TSTARTEN(base) (MTB_RD_MASTER_TSTARTEN(base))

/*! @brief Set the TSTARTEN field to a new value. */
#define MTB_WR_MASTER_TSTARTEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTARTEN_MASK, MTB_MASTER_TSTARTEN(value)))
#define MTB_BWR_MASTER_TSTARTEN(base, value) (MTB_WR_MASTER_TSTARTEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field TSTOPEN[6] (RW)
 *
 * If this field is 1 and the TSTOP signal is HIGH, then EN is set to 0. If a
 * trace packet is being written to memory, the write is completed before tracing
 * is stopped.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_TSTOPEN field. */
#define MTB_RD_MASTER_TSTOPEN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_TSTOPEN_MASK) >> MTB_MASTER_TSTOPEN_SHIFT)
#define MTB_BRD_MASTER_TSTOPEN(base) (MTB_RD_MASTER_TSTOPEN(base))

/*! @brief Set the TSTOPEN field to a new value. */
#define MTB_WR_MASTER_TSTOPEN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_TSTOPEN_MASK, MTB_MASTER_TSTOPEN(value)))
#define MTB_BWR_MASTER_TSTOPEN(base, value) (MTB_WR_MASTER_TSTOPEN(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field SFRWPRIV[7] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the MTB_RAM Special Function Registers (programming model) are permitted. If
 * this field is 1, then only privileged write accesses are permitted; user write
 * accesses are ignored. The HPROT[1] signal determines if an access is user or
 * privileged. Note MTB_RAM SFR read access are not controlled by this bit and are
 * always permitted.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_SFRWPRIV field. */
#define MTB_RD_MASTER_SFRWPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_SFRWPRIV_MASK) >> MTB_MASTER_SFRWPRIV_SHIFT)
#define MTB_BRD_MASTER_SFRWPRIV(base) (MTB_RD_MASTER_SFRWPRIV(base))

/*! @brief Set the SFRWPRIV field to a new value. */
#define MTB_WR_MASTER_SFRWPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_SFRWPRIV_MASK, MTB_MASTER_SFRWPRIV(value)))
#define MTB_BWR_MASTER_SFRWPRIV(base, value) (MTB_WR_MASTER_SFRWPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field RAMPRIV[8] (RW)
 *
 * If this field is 0, then user or privileged AHB read and write accesses to
 * the RAM are permitted. If this field is 1, then only privileged AHB read and
 * write accesses to the RAM are permitted and user accesses are RAZ/WI. The
 * HPROT[1] signal determines if an access is a user or privileged mode reference.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_RAMPRIV field. */
#define MTB_RD_MASTER_RAMPRIV(base) ((MTB_MASTER_REG(base) & MTB_MASTER_RAMPRIV_MASK) >> MTB_MASTER_RAMPRIV_SHIFT)
#define MTB_BRD_MASTER_RAMPRIV(base) (MTB_RD_MASTER_RAMPRIV(base))

/*! @brief Set the RAMPRIV field to a new value. */
#define MTB_WR_MASTER_RAMPRIV(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_RAMPRIV_MASK, MTB_MASTER_RAMPRIV(value)))
#define MTB_BWR_MASTER_RAMPRIV(base, value) (MTB_WR_MASTER_RAMPRIV(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field HALTREQ[9] (RW)
 *
 * This field is connected to the halt request signal of the trace logic,
 * EDBGRQ. When HALTREQ is set to 1, the EDBFGRQ is asserted if DBGEN (invasive debug
 * enable, one of the debug authentication interface signals) is also HIGH.
 * HALTREQ can be automatically set to 1 using MTB_FLOW[WATERMARK].
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_HALTREQ field. */
#define MTB_RD_MASTER_HALTREQ(base) ((MTB_MASTER_REG(base) & MTB_MASTER_HALTREQ_MASK) >> MTB_MASTER_HALTREQ_SHIFT)
#define MTB_BRD_MASTER_HALTREQ(base) (MTB_RD_MASTER_HALTREQ(base))

/*! @brief Set the HALTREQ field to a new value. */
#define MTB_WR_MASTER_HALTREQ(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_HALTREQ_MASK, MTB_MASTER_HALTREQ(value)))
#define MTB_BWR_MASTER_HALTREQ(base, value) (MTB_WR_MASTER_HALTREQ(base, value))
/*@}*/

/*!
 * @name Register MTB_MASTER, field EN[31] (RW)
 *
 * When this field is 1, trace data is written into the RAM memory location
 * addressed by MTB_POSITION[POINTER]. The MTB_POSITION[POINTER] value auto
 * increments after the trace data packet is written. EN can be automatically set to 0
 * using the MTB_FLOW[WATERMARK] field and the MTB_FLOW[AUTOSTOP] bit. EN is
 * automatically set to 1 if TSTARTEN is 1 and the TSTART signal is HIGH. EN is
 * automatically set to 0 if TSTOPEN is 1 and the TSTOP signal is HIGH. If EN is set to 0
 * because MTB_FLOW[WATERMARK] is set, then it is not automatically set to 1 if
 * TSTARTEN is 1 and the TSTART input is HIGH. In this case, tracing can only be
 * restarted if MTB_FLOW[WATERMARK] or MTB_POSITION[POINTER] value is changed by
 * software.
 */
/*@{*/
/*! @brief Read current value of the MTB_MASTER_EN field. */
#define MTB_RD_MASTER_EN(base) ((MTB_MASTER_REG(base) & MTB_MASTER_EN_MASK) >> MTB_MASTER_EN_SHIFT)
#define MTB_BRD_MASTER_EN(base) (MTB_RD_MASTER_EN(base))

/*! @brief Set the EN field to a new value. */
#define MTB_WR_MASTER_EN(base, value) (MTB_RMW_MASTER(base, MTB_MASTER_EN_MASK, MTB_MASTER_EN(value)))
#define MTB_BWR_MASTER_EN(base, value) (MTB_WR_MASTER_EN(base, value))
/*@}*/

/*******************************************************************************
 * MTB_FLOW - MTB Flow Register
 ******************************************************************************/

/*!
 * @brief MTB_FLOW - MTB Flow Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MTB_FLOW register contains the watermark address and the
 * autostop/autohalt control bits. If tracing is stopped using the watermark autostop feature, it
 * cannot be restarted until software clears the watermark autostop. This can be
 * achieved in one of the following ways: Changing the MTB_POSITION[POINTER]
 * field value to point to the beginning of the trace buffer, or Setting
 * MTB_FLOW[AUTOSTOP] = 0. A debug agent can use MTB_FLOW[AUTOSTOP] to fill the trace buffer
 * once only without halting the processor. A debug agent can use
 * MTB_FLOW[AUTOHALT] to fill the trace buffer once before causing the Cortex-M0+ processor to
 * enter the Debug state. To enter Debug state, the Cortex-M0+ processor might
 * have to perform additional branch type operations. Therefore, the
 * MTB_FLOW[WATERMARK] field must be set below the final entry in the trace buffer region.
 */
/*!
 * @name Constants and macros for entire MTB_FLOW register
 */
/*@{*/
#define MTB_RD_FLOW(base)        (MTB_FLOW_REG(base))
#define MTB_WR_FLOW(base, value) (MTB_FLOW_REG(base) = (value))
#define MTB_RMW_FLOW(base, mask, value) (MTB_WR_FLOW(base, (MTB_RD_FLOW(base) & ~(mask)) | (value)))
#define MTB_SET_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) |  (value)))
#define MTB_CLR_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) & ~(value)))
#define MTB_TOG_FLOW(base, value) (MTB_WR_FLOW(base, MTB_RD_FLOW(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MTB_FLOW bitfields
 */

/*!
 * @name Register MTB_FLOW, field AUTOSTOP[0] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[EN] is automatically set to 0. This stops tracing.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOSTOP field. */
#define MTB_RD_FLOW_AUTOSTOP(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOSTOP_MASK) >> MTB_FLOW_AUTOSTOP_SHIFT)
#define MTB_BRD_FLOW_AUTOSTOP(base) (MTB_RD_FLOW_AUTOSTOP(base))

/*! @brief Set the AUTOSTOP field to a new value. */
#define MTB_WR_FLOW_AUTOSTOP(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOSTOP_MASK, MTB_FLOW_AUTOSTOP(value)))
#define MTB_BWR_FLOW_AUTOSTOP(base, value) (MTB_WR_FLOW_AUTOSTOP(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field AUTOHALT[1] (RW)
 *
 * If this field is 1 and WATERMARK is equal to MTB_POSITION[POINTER], then
 * MTB_MASTER[HALTREQ] is automatically set to 1. If the DBGEN signal is HIGH, the
 * MTB asserts this halt request to the Cortex-M0+ processor by asserting the
 * EDBGRQ signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_AUTOHALT field. */
#define MTB_RD_FLOW_AUTOHALT(base) ((MTB_FLOW_REG(base) & MTB_FLOW_AUTOHALT_MASK) >> MTB_FLOW_AUTOHALT_SHIFT)
#define MTB_BRD_FLOW_AUTOHALT(base) (MTB_RD_FLOW_AUTOHALT(base))

/*! @brief Set the AUTOHALT field to a new value. */
#define MTB_WR_FLOW_AUTOHALT(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_AUTOHALT_MASK, MTB_FLOW_AUTOHALT(value)))
#define MTB_BWR_FLOW_AUTOHALT(base, value) (MTB_WR_FLOW_AUTOHALT(base, value))
/*@}*/

/*!
 * @name Register MTB_FLOW, field WATERMARK[31:3] (RW)
 *
 * This field contains an address in the same format as the
 * MTB_POSITION[POINTER] field. When MTB_POSITION[POINTER] matches the WATERMARK field value, actions
 * defined by the AUTOHALT and AUTOSTOP bits are performed.
 */
/*@{*/
/*! @brief Read current value of the MTB_FLOW_WATERMARK field. */
#define MTB_RD_FLOW_WATERMARK(base) ((MTB_FLOW_REG(base) & MTB_FLOW_WATERMARK_MASK) >> MTB_FLOW_WATERMARK_SHIFT)
#define MTB_BRD_FLOW_WATERMARK(base) (MTB_RD_FLOW_WATERMARK(base))

/*! @brief Set the WATERMARK field to a new value. */
#define MTB_WR_FLOW_WATERMARK(base, value) (MTB_RMW_FLOW(base, MTB_FLOW_WATERMARK_MASK, MTB_FLOW_WATERMARK(value)))
#define MTB_BWR_FLOW_WATERMARK(base, value) (MTB_WR_FLOW_WATERMARK(base, value))
/*@}*/

/*******************************************************************************
 * MTB_BASE - MTB Base Register
 ******************************************************************************/

/*!
 * @brief MTB_BASE - MTB Base Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read-only MTB_BASE Register indicates where the RAM is located in the
 * system memory map. This register is provided to enable auto discovery of the MTB
 * RAM location by a debug agent, and is defined by a hardware design parameter.
 */
/*!
 * @name Constants and macros for entire MTB_BASE register
 */
/*@{*/
#define MTB_RD_BASE(base)        (MTB_BASE_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_MODECTRL - Integration Mode Control Register
 ******************************************************************************/

/*!
 * @brief MTB_MODECTRL - Integration Mode Control Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register enables the device to switch from a functional mode, or default
 * behavior, into integration mode. It is hardwired to specific values used
 * during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_MODECTRL register
 */
/*@{*/
#define MTB_RD_MODECTRL(base)    (MTB_MODECTRL_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGSET - Claim TAG Set Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGSET - Claim TAG Set Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Claim Tag Set Register returns the number of bits that can be set on a
 * read, and enables individual bits to be set on a write. It is hardwired to
 * specific values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGSET register
 */
/*@{*/
#define MTB_RD_TAGSET(base)      (MTB_TAGSET_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_TAGCLEAR - Claim TAG Clear Register
 ******************************************************************************/

/*!
 * @brief MTB_TAGCLEAR - Claim TAG Clear Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The read/write Claim Tag Clear Register is used to read the claim status on
 * debug resources. A read indicates the claim tag status. Writing 1 to a specific
 * bit clears the corresponding claim tag to 0. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_TAGCLEAR register
 */
/*@{*/
#define MTB_RD_TAGCLEAR(base)    (MTB_TAGCLEAR_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKACCESS - Lock Access Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKACCESS - Lock Access Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Access Register enables a write access to component registers. It is
 * hardwired to specific values used during the auto-discovery process by an
 * external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKACCESS register
 */
/*@{*/
#define MTB_RD_LOCKACCESS(base)  (MTB_LOCKACCESS_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_LOCKSTAT - Lock Status Register
 ******************************************************************************/

/*!
 * @brief MTB_LOCKSTAT - Lock Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Lock Status Register indicates the status of the lock control mechanism.
 * This register is used in conjunction with the Lock Access Register. It is
 * hardwired to specific values used during the auto-discovery process by an external
 * debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_LOCKSTAT register
 */
/*@{*/
#define MTB_RD_LOCKSTAT(base)    (MTB_LOCKSTAT_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_AUTHSTAT - Authentication Status Register
 ******************************************************************************/

/*!
 * @brief MTB_AUTHSTAT - Authentication Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Authentication Status Register reports the required security level and
 * current status of the security enable bit pairs. Where functionality changes on
 * a given security level, this change must be reported in this register. It is
 * connected to specific signals used during the auto-discovery process by an
 * external debug agent. MTB_AUTHSTAT[3:2] indicates if nonsecure, noninvasive debug
 * is enabled or disabled, while MTB_AUTHSTAT[1:0] indicates the enabled/disabled
 * state of nonsecure, invasive debug. For both 2-bit fields, 0b10 indicates the
 * functionality is disabled and 0b11 indicates it is enabled.
 */
/*!
 * @name Constants and macros for entire MTB_AUTHSTAT register
 */
/*@{*/
#define MTB_RD_AUTHSTAT(base)    (MTB_AUTHSTAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MTB_AUTHSTAT bitfields
 */

/*!
 * @name Register MTB_AUTHSTAT, field BIT0[0] (RO)
 *
 * Connected to DBGEN.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT0 field. */
#define MTB_RD_AUTHSTAT_BIT0(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT0_MASK) >> MTB_AUTHSTAT_BIT0_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT0(base) (MTB_RD_AUTHSTAT_BIT0(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT1[1] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT1 field. */
#define MTB_RD_AUTHSTAT_BIT1(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT1_MASK) >> MTB_AUTHSTAT_BIT1_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT1(base) (MTB_RD_AUTHSTAT_BIT1(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT2[2] (RO)
 *
 * Connected to NIDEN or DBGEN signal.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT2 field. */
#define MTB_RD_AUTHSTAT_BIT2(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT2_MASK) >> MTB_AUTHSTAT_BIT2_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT2(base) (MTB_RD_AUTHSTAT_BIT2(base))
/*@}*/

/*!
 * @name Register MTB_AUTHSTAT, field BIT3[3] (ROO)
 *
 * Hardwired to 1.
 */
/*@{*/
/*! @brief Read current value of the MTB_AUTHSTAT_BIT3 field. */
#define MTB_RD_AUTHSTAT_BIT3(base) ((MTB_AUTHSTAT_REG(base) & MTB_AUTHSTAT_BIT3_MASK) >> MTB_AUTHSTAT_BIT3_SHIFT)
#define MTB_BRD_AUTHSTAT_BIT3(base) (MTB_RD_AUTHSTAT_BIT3(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICEARCH - Device Architecture Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICEARCH - Device Architecture Register (RO)
 *
 * Reset value: 0x47700A31U
 *
 * This register indicates the device architecture. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICEARCH register
 */
/*@{*/
#define MTB_RD_DEVICEARCH(base)  (MTB_DEVICEARCH_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICECFG - Device Configuration Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICECFG - Device Configuration Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register indicates the device configuration. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICECFG register
 */
/*@{*/
#define MTB_RD_DEVICECFG(base)   (MTB_DEVICECFG_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_DEVICETYPID - Device Type Identifier Register
 ******************************************************************************/

/*!
 * @brief MTB_DEVICETYPID - Device Type Identifier Register (RO)
 *
 * Reset value: 0x00000031U
 *
 * This register indicates the device type ID. It is hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_DEVICETYPID register
 */
/*@{*/
#define MTB_RD_DEVICETYPID(base) (MTB_DEVICETYPID_REG(base))
/*@}*/

/*******************************************************************************
 * MTB_PERIPHID - Peripheral ID Register
 ******************************************************************************/

/*!
 * @brief MTB_PERIPHID - Peripheral ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the peripheral IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_PERIPHID register
 */
/*@{*/
#define MTB_RD_PERIPHID(base, index) (MTB_PERIPHID_REG(base, index))
/*@}*/

/*******************************************************************************
 * MTB_COMPID - Component ID Register
 ******************************************************************************/

/*!
 * @brief MTB_COMPID - Component ID Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the component IDs. They are hardwired to specific
 * values used during the auto-discovery process by an external debug agent.
 */
/*!
 * @name Constants and macros for entire MTB_COMPID register
 */
/*@{*/
#define MTB_RD_COMPID(base, index) (MTB_COMPID_REG(base, index))
/*@}*/

/*
 * MKL28Z7 MU
 *
 * MU
 *
 * Registers defined in this header file:
 * - MU_VER - Version ID Register
 * - MU_PAR - Parameter Register
 * - MU_TR - Transmit Register n
 * - MU_RR - Receive Register n
 * - MU_SR - Status Register
 * - MU_CR - Control Register
 */

#define MU_INSTANCE_COUNT (1U) /*!< Number of instances of the MU module. */
#define MU0_A_IDX (0U) /*!< Instance number for MU0_A. */

/*******************************************************************************
 * MU_VER - Version ID Register
 ******************************************************************************/

/*!
 * @brief MU_VER - Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 *
 * Use Version ID register to determine the version ID and feature set number of
 * Processor B/A.
 */
/*!
 * @name Constants and macros for entire MU_VER register
 */
/*@{*/
#define MU_RD_VER(base)          (MU_VER_REG(base))
/*@}*/

/*
 * Constants & macros for individual MU_VER bitfields
 */

/*!
 * @name Register MU_VER, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number for Processor B/A.
 *
 * Values:
 * - 0b0000000000000000 - TBD
 */
/*@{*/
/*! @brief Read current value of the MU_VER_FEATURE field. */
#define MU_RD_VER_FEATURE(base) ((MU_VER_REG(base) & MU_VER_FEATURE_MASK) >> MU_VER_FEATURE_SHIFT)
#define MU_BRD_VER_FEATURE(base) (MU_RD_VER_FEATURE(base))
/*@}*/

/*!
 * @name Register MU_VER, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for Processor B/A.
 */
/*@{*/
/*! @brief Read current value of the MU_VER_MINOR field. */
#define MU_RD_VER_MINOR(base) ((MU_VER_REG(base) & MU_VER_MINOR_MASK) >> MU_VER_MINOR_SHIFT)
#define MU_BRD_VER_MINOR(base) (BME_UBFX32(&MU_VER_REG(base), MU_VER_MINOR_SHIFT, MU_VER_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register MU_VER, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for Processor B/A.
 */
/*@{*/
/*! @brief Read current value of the MU_VER_MAJOR field. */
#define MU_RD_VER_MAJOR(base) ((MU_VER_REG(base) & MU_VER_MAJOR_MASK) >> MU_VER_MAJOR_SHIFT)
#define MU_BRD_VER_MAJOR(base) (BME_UBFX32(&MU_VER_REG(base), MU_VER_MAJOR_SHIFT, MU_VER_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * MU_PAR - Parameter Register
 ******************************************************************************/

/*!
 * @brief MU_PAR - Parameter Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Use Parameter register to determine the parameter settings of Processor B/A.
 */
/*!
 * @name Constants and macros for entire MU_PAR register
 */
/*@{*/
#define MU_RD_PAR(base)          (MU_PAR_REG(base))
/*@}*/

/*******************************************************************************
 * MU_TR - Transmit Register n
 ******************************************************************************/

/*!
 * @brief MU_TR - Transmit Register n (RW)
 *
 * Reset value: 0x00000000U
 *
 * Use Processor A/B Transmit Register n (TRn, 32-bit, write-only) to transmit a
 * message or data to the Processor B/A. You can only write to the TRn register
 * when the TEn bit in SR register is set to "1". Reading the TRn register
 * returns all zeros.
 */
/*!
 * @name Constants and macros for entire MU_TR register
 */
/*@{*/
#define MU_RD_TR(base, index)    (MU_TR_REG(base, index))
#define MU_WR_TR(base, index, value) (MU_TR_REG(base, index) = (value))
#define MU_RMW_TR(base, index, mask, value) (MU_WR_TR(base, index, (MU_RD_TR(base, index) & ~(mask)) | (value)))
#define MU_SET_TR(base, index, value) (BME_OR32(&MU_TR_REG(base, index), (uint32_t)(value)))
#define MU_CLR_TR(base, index, value) (BME_AND32(&MU_TR_REG(base, index), (uint32_t)(~(value))))
#define MU_TOG_TR(base, index, value) (BME_XOR32(&MU_TR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * MU_RR - Receive Register n
 ******************************************************************************/

/*!
 * @brief MU_RR - Receive Register n (RO)
 *
 * Reset value: 0x00000000U
 *
 * Use Processor A/B Receive Register n (RRn, 32-bit, read-only) to receive a
 * message or data from the Processor B/A. Data written to the Processor B/A TRn
 * register is immediately reflected in the Processor A/B RRn register. You can
 * only read the RRn register when the RFn bit in the SR register is set to "1".
 * Writing to the RRn register generates an error response to the Processor A/B.
 */
/*!
 * @name Constants and macros for entire MU_RR register
 */
/*@{*/
#define MU_RD_RR(base, index)    (MU_RR_REG(base, index))
/*@}*/

/*******************************************************************************
 * MU_SR - Status Register
 ******************************************************************************/

/*!
 * @brief MU_SR - Status Register (RW)
 *
 * Reset value: 0x00F00080U
 *
 * Use the Processor A/B Status Register (SR, 32-bit, read-write) to show
 * interrupt status from the Processor B/A, general purpose flags , and to set dual
 * function control-status bits. Some dual-purpose bits are set by the MU logic, and
 * cleared by the Processor A/B-side programmer Other dual-purpose bits are set
 * by the Processor A/B-side programmer, and cleared by the MU logic.
 */
/*!
 * @name Constants and macros for entire MU_SR register
 */
/*@{*/
#define MU_RD_SR(base)           (MU_SR_REG(base))
#define MU_WR_SR(base, value)    (MU_SR_REG(base) = (value))
#define MU_RMW_SR(base, mask, value) (MU_WR_SR(base, (MU_RD_SR(base) & ~(mask)) | (value)))
#define MU_SET_SR(base, value)   (BME_OR32(&MU_SR_REG(base), (uint32_t)(value)))
#define MU_CLR_SR(base, value)   (BME_AND32(&MU_SR_REG(base), (uint32_t)(~(value))))
#define MU_TOG_SR(base, value)   (BME_XOR32(&MU_SR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MU_SR bitfields
 */

/*!
 * @name Register MU_SR, field Fn[2:0] (RW)
 *
 * For n = {0, 1, 2} Processor A/B Side Flag n. (Read-only) Fn bit is the
 * Processor A/B side flag that reflects the values written to the Fn bit in the
 * Processor B/A control register. Every time that the Processor B/A Fn bit in the CR
 * register is written, the Processor B/A Fn bit in the CR register write event
 * updates the Fn bit after the event update latency, which is measured in terms of
 * the number of clocks of the Processor B/A and the Processor A/B.
 *
 * Values:
 * - 0b000 - Processor B/A Fn bit in the CR register is written 0 (default).
 * - 0b001 - Processor B/A Fn bit in the CR register is written 1.
 */
/*@{*/
/*! @brief Read current value of the MU_SR_Fn field. */
#define MU_RD_SR_Fn(base)    ((MU_SR_REG(base) & MU_SR_Fn_MASK) >> MU_SR_Fn_SHIFT)
#define MU_BRD_SR_Fn(base)   (BME_UBFX32(&MU_SR_REG(base), MU_SR_Fn_SHIFT, MU_SR_Fn_WIDTH))

/*! @brief Set the Fn field to a new value. */
#define MU_WR_SR_Fn(base, value) (MU_RMW_SR(base, (MU_SR_Fn_MASK | MU_SR_NMIC_MASK), MU_SR_Fn(value)))
#define MU_BWR_SR_Fn(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_Fn_SHIFT), MU_SR_Fn_SHIFT, MU_SR_Fn_WIDTH))
/*@}*/

/*!
 * @name Register MU_SR, field NMIC[3] (W1C)
 *
 * Processor A/B Non-Maskable-Interrupt Clear. (Write-only) NMIC bit is used by
 * the Processor A/B-side MU Non-Maskable Interrupt service routine to clear the
 * non-maskable interrupt. Writing NMIC bit as "1" signals the MU to clear the
 * NMI bit in the BCR register, thus de-asserting the interrupts and enabling the
 * NMI bit to receive another interrupt. The NMIC bit is always read as "0";
 * therefore it (NMIC bit) cannot be polled. The NMIC bit can only be used as part of
 * the interrupt service routine, in which the NMIC bit should only be written as
 * "1" once. The NMIC bit is cleared when the MU resets.
 *
 * Values:
 * - 0b0 - Default
 * - 0b1 - Writing "1" clears the NMI bit in the BCR register.
 */
/*@{*/
/*! @brief Read current value of the MU_SR_NMIC field. */
#define MU_RD_SR_NMIC(base)  ((MU_SR_REG(base) & MU_SR_NMIC_MASK) >> MU_SR_NMIC_SHIFT)
#define MU_BRD_SR_NMIC(base) (BME_UBFX32(&MU_SR_REG(base), MU_SR_NMIC_SHIFT, MU_SR_NMIC_WIDTH))

/*! @brief Set the NMIC field to a new value. */
#define MU_WR_SR_NMIC(base, value) (MU_RMW_SR(base, MU_SR_NMIC_MASK, MU_SR_NMIC(value)))
#define MU_BWR_SR_NMIC(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_NMIC_SHIFT), MU_SR_NMIC_SHIFT, MU_SR_NMIC_WIDTH))
/*@}*/

/*!
 * @name Register MU_SR, field EP[4] (RW)
 *
 * Processor A/B Side Event Pending. (Read-only) EP bit is set to "1" when the
 * Processor A/B side mechanism sends an event update request to the Processor B/A
 * side. EP bit is cleared when the event update acknowledge is received. An
 * "event" is any hardware message that is reflected in the Processor B/A SR
 * register on the Processor B/A side (for example, "transmit register 0 written").
 * During normal operations, you do not have to deal with the state of the EP bit
 * because the event update mechanism works automatically. To ensure events have
 * been posted to Processor B/A before entering STOP mode, you should verify that
 * the EP bit is cleared. If EP bit is set to "1", you should wait and continue to
 * poll it (EP bit) before entering STOP mode. Reading the Processor A/B SR
 * register (to check the EP bit) should be the last access to the MU that should be
 * performed before entering STOPor WAIT modes; otherwise, the EP bit may be set
 * by subsequent additional actions. The EP bit is cleared when the MU resets.
 *
 * Values:
 * - 0b0 - The Processor A-side event is not pending (default).
 * - 0b1 - The Processor A-side event is pending.
 */
/*@{*/
/*! @brief Read current value of the MU_SR_EP field. */
#define MU_RD_SR_EP(base)    ((MU_SR_REG(base) & MU_SR_EP_MASK) >> MU_SR_EP_SHIFT)
#define MU_BRD_SR_EP(base)   (BME_UBFX32(&MU_SR_REG(base), MU_SR_EP_SHIFT, MU_SR_EP_WIDTH))

/*! @brief Set the EP field to a new value. */
#define MU_WR_SR_EP(base, value) (MU_RMW_SR(base, (MU_SR_EP_MASK | MU_SR_NMIC_MASK), MU_SR_EP(value)))
#define MU_BWR_SR_EP(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_EP_SHIFT), MU_SR_EP_SHIFT, MU_SR_EP_WIDTH))
/*@}*/

/*!
 * @name Register MU_SR, field PM[6:5] (RW)
 *
 * Processor B/A Power Mode. (Read-only) PM[1:0] bits indicate the Processor B/A
 * power mode. The Processor B/A Power Mode is platform-specific.
 *
 * Values:
 * - 0b00 - The Processor B/A is in Run Mode.
 * - 0b01 - The Processor B/A is in WAIT Mode.
 * - 0b10 - The Processor B/A is in STOP/VLPS Mode.
 * - 0b11 - The Processor B/A is in LLS/VLLS Mode.
 */
/*@{*/
#define MU_SR_PM_RUN                   (0U)          /*!< Bit field value for MU_SR_PM: The Processor B/A is in Run Mode. */
#define MU_SR_PM_WAIT                  (0x1U)        /*!< Bit field value for MU_SR_PM: The Processor B/A is in WAIT Mode. */
#define MU_SR_PM_STOP                  (0x2U)        /*!< Bit field value for MU_SR_PM: The Processor B/A is in STOP/VLPS Mode. */
#define MU_SR_PM_DSM                   (0x3U)        /*!< Bit field value for MU_SR_PM: The Processor B/A is in LLS/VLLS Mode. */
/*! @brief Read current value of the MU_SR_PM field. */
#define MU_RD_SR_PM(base)    ((MU_SR_REG(base) & MU_SR_PM_MASK) >> MU_SR_PM_SHIFT)
#define MU_BRD_SR_PM(base)   (BME_UBFX32(&MU_SR_REG(base), MU_SR_PM_SHIFT, MU_SR_PM_WIDTH))

/*! @brief Set the PM field to a new value. */
#define MU_WR_SR_PM(base, value) (MU_RMW_SR(base, (MU_SR_PM_MASK | MU_SR_NMIC_MASK), MU_SR_PM(value)))
#define MU_BWR_SR_PM(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_PM_SHIFT), MU_SR_PM_SHIFT, MU_SR_PM_WIDTH))
/*@}*/

/*!
 * @name Register MU_SR, field FUP[8] (RW)
 *
 * Processor A/B Flags Update Pending. (Read-only) FUP bit is set to "1" when
 * the Processor A/B side sends a Flags Update request to the Processor B/A side. A
 * Flags Update request is generated when there is a change to the Fn[2:0] bits
 * of the Processor A/B CR register. No flag update changes are allowed while the
 * FUP bit is set to "1". Any write to the Fn[2:0] bits of the Processor A/B CR
 * register, while the FUP bit is set to "1", will not generate a Flags Update
 * event, and the Fn[2:0] bits will stay unchanged. FUP bit is cleared when this
 * Flags Update request is internally acknowledged (that the flag is updated) from
 * the MU Processor B/A side, and during MU reset.
 *
 * Values:
 * - 0b0 - No flags updated, initiated by the Processor A, in progress (default)
 * - 0b1 - Processor A/B initiated flags update, processing
 */
/*@{*/
/*! @brief Read current value of the MU_SR_FUP field. */
#define MU_RD_SR_FUP(base)   ((MU_SR_REG(base) & MU_SR_FUP_MASK) >> MU_SR_FUP_SHIFT)
#define MU_BRD_SR_FUP(base)  (BME_UBFX32(&MU_SR_REG(base), MU_SR_FUP_SHIFT, MU_SR_FUP_WIDTH))

/*! @brief Set the FUP field to a new value. */
#define MU_WR_SR_FUP(base, value) (MU_RMW_SR(base, (MU_SR_FUP_MASK | MU_SR_NMIC_MASK), MU_SR_FUP(value)))
#define MU_BWR_SR_FUP(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_FUP_SHIFT), MU_SR_FUP_SHIFT, MU_SR_FUP_WIDTH))
/*@}*/

/*!
 * @name Register MU_SR, field TEn[23:20] (RW)
 *
 * For n = {0, 1, 2, 3} Processor A/B Transmit Register n Empty. (Read-only) The
 * TEn bit is set to "1" after the Processor B/A RRn register is read on the
 * Processor B/A side. After the TEn bit is set to "1", the TEn bit signals the
 * Processor A/B side that the Processor A/B TRn register is ready to be written on
 * the Processor A/B side, and a Transmit n interrupt is issued on the Processor
 * A/B side (if the TEn bit in the Processor A/B CR register is set to "1"). TEn
 * bit is cleared after the Processor A/B TRn register is written on the Processor
 * A/B side. TEn bit is set to "1" when the MU is reset.
 *
 * Values:
 * - 0b0000 - Processor A/B TRn register is not empty.
 * - 0b0001 - Processor A/B TRn register is empty (default).
 */
/*@{*/
/*! @brief Read current value of the MU_SR_TEn field. */
#define MU_RD_SR_TEn(base)   ((MU_SR_REG(base) & MU_SR_TEn_MASK) >> MU_SR_TEn_SHIFT)
#define MU_BRD_SR_TEn(base)  (BME_UBFX32(&MU_SR_REG(base), MU_SR_TEn_SHIFT, MU_SR_TEn_WIDTH))

/*! @brief Set the TEn field to a new value. */
#define MU_WR_SR_TEn(base, value) (MU_RMW_SR(base, (MU_SR_TEn_MASK | MU_SR_NMIC_MASK), MU_SR_TEn(value)))
#define MU_BWR_SR_TEn(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_TEn_SHIFT), MU_SR_TEn_SHIFT, MU_SR_TEn_WIDTH))
/*@}*/

/*!
 * @name Register MU_SR, field RFn[27:24] (RW)
 *
 * For n = {0, 1, 2, 3} Processor A/B Receive Register n Full. (Read-only) The
 * RFn bit is set to "1" when the Processor B/A TRn register is written on the
 * Processor B/A side. After the RFn bit is set to "1", the RFn bit signals the
 * Processor A/B side that new data is ready to be read by the Processor A/B in the
 * Processor A/B RRn register, and a Receive n interrupt is issued on the
 * Processor A/B side (if the RIEn bit in the Processor A/B CR register has been set to
 * "1"). RFn bit is cleared when the Processor A/B RRn register is read, and when
 * the MU is reset.
 *
 * Values:
 * - 0b0000 - Processor A/B RRn register is not full (default).
 * - 0b0001 - Processor A/B RRn register has received data from Processor B/A
 *     TRn register and is ready to be read by the Processor A/B.
 */
/*@{*/
/*! @brief Read current value of the MU_SR_RFn field. */
#define MU_RD_SR_RFn(base)   ((MU_SR_REG(base) & MU_SR_RFn_MASK) >> MU_SR_RFn_SHIFT)
#define MU_BRD_SR_RFn(base)  (BME_UBFX32(&MU_SR_REG(base), MU_SR_RFn_SHIFT, MU_SR_RFn_WIDTH))

/*! @brief Set the RFn field to a new value. */
#define MU_WR_SR_RFn(base, value) (MU_RMW_SR(base, (MU_SR_RFn_MASK | MU_SR_NMIC_MASK), MU_SR_RFn(value)))
#define MU_BWR_SR_RFn(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_RFn_SHIFT), MU_SR_RFn_SHIFT, MU_SR_RFn_WIDTH))
/*@}*/

/*!
 * @name Register MU_SR, field GIPn[31:28] (RW)
 *
 * For n = {0, 1, 2, 3} Processor A/B General Interrupt Request n Pending.
 * (Read-Write) GIPn bit signals the Processor A/B that the GIRn bit in the BCR
 * register on the Processor B-side was set from "0" to "1". If the GIEn bit in the ACR
 * register is set to "1", a General Interrupt n request is issued. The GIPn bit
 * is cleared by writing it back as "1". Writing "0", or writing "1" when the
 * GIPn bit is cleared is ignored. Use this feature in the interrupt routine, where
 * the GIPn bit is cleared in order to de-assert the interrupt request source at
 * the interrupt controller. An example of a proper bit clearing sequence is:
 * clear Processor A register, set the desired bit in it (Processor A register),
 * and write it to the ASR register, thus clearing the GIPn bit. GIPn bit is
 * cleared when the MU is reset.
 *
 * Values:
 * - 0b0000 - Processor A/B general purpose interrupt n is not pending. (default)
 * - 0b0001 - Processor A/B general purpose interrupt n is pending.
 */
/*@{*/
/*! @brief Read current value of the MU_SR_GIPn field. */
#define MU_RD_SR_GIPn(base)  ((MU_SR_REG(base) & MU_SR_GIPn_MASK) >> MU_SR_GIPn_SHIFT)
#define MU_BRD_SR_GIPn(base) (BME_UBFX32(&MU_SR_REG(base), MU_SR_GIPn_SHIFT, MU_SR_GIPn_WIDTH))

/*! @brief Set the GIPn field to a new value. */
#define MU_WR_SR_GIPn(base, value) (MU_RMW_SR(base, (MU_SR_GIPn_MASK | MU_SR_NMIC_MASK), MU_SR_GIPn(value)))
#define MU_BWR_SR_GIPn(base, value) (BME_BFI32(&MU_SR_REG(base), ((uint32_t)(value) << MU_SR_GIPn_SHIFT), MU_SR_GIPn_SHIFT, MU_SR_GIPn_WIDTH))
/*@}*/

/*******************************************************************************
 * MU_CR - Control Register
 ******************************************************************************/

/*!
 * @brief MU_CR - Control Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * Use the Control Register (CR, 32-bit, read-write) to enable the MU interrupts
 * on the Processor A/B-side, and trigger events and interrupts on the Processor
 * B/A-side (general purpose interrupt, flag update).
 */
/*!
 * @name Constants and macros for entire MU_CR register
 */
/*@{*/
#define MU_RD_CR(base)           (MU_CR_REG(base))
#define MU_WR_CR(base, value)    (MU_CR_REG(base) = (value))
#define MU_RMW_CR(base, mask, value) (MU_WR_CR(base, (MU_RD_CR(base) & ~(mask)) | (value)))
#define MU_SET_CR(base, value)   (BME_OR32(&MU_CR_REG(base), (uint32_t)(value)))
#define MU_CLR_CR(base, value)   (BME_AND32(&MU_CR_REG(base), (uint32_t)(~(value))))
#define MU_TOG_CR(base, value)   (BME_XOR32(&MU_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MU_CR bitfields
 */

/*!
 * @name Register MU_CR, field Fn[2:0] (RW)
 *
 * For n = {0, 1, 2} Processor A/B to Processor B/A Flag n. (Read-Write) Fn bit
 * is a read-write flag that is reflected in Fn bit in the Processor B/A SR
 * register on the Processor B/A side. Fn bit is cleared when the MU resets.
 *
 * Values:
 * - 0b000 - Clears the Fn bit in the SR register.
 * - 0b001 - Sets the Fn bit in the SR register.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_Fn field. */
#define MU_RD_CR_Fn(base)    ((MU_CR_REG(base) & MU_CR_Fn_MASK) >> MU_CR_Fn_SHIFT)
#define MU_BRD_CR_Fn(base)   (BME_UBFX32(&MU_CR_REG(base), MU_CR_Fn_SHIFT, MU_CR_Fn_WIDTH))

/*! @brief Set the Fn field to a new value. */
#define MU_WR_CR_Fn(base, value) (MU_RMW_CR(base, MU_CR_Fn_MASK, MU_CR_Fn(value)))
#define MU_BWR_CR_Fn(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_Fn_SHIFT), MU_CR_Fn_SHIFT, MU_CR_Fn_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field NMI[3] (RW)
 *
 * Processor B/A Non-maskable Interrupt. (Read-Write) When NMI bit is set to
 * "1", it initiates a Non-Maskable Interrupt to the Processor B/A. NMI bit is
 * cleared by the MU after the Processor B/A asserts the NMIC bit in the Processor B/A
 * SR register. After the NMI bit is cleared, the Processor A/B can initiate
 * another non-maskable interrupt to the Processor B/A. The NMI bit is cleared when
 * the MU resets.
 *
 * Values:
 * - 0b0 - Non-maskable interrupt is not issued to the Processor B/A by the
 *     Processor A/B (default).
 * - 0b1 - Non-maskable interrupt is issued to the Processor B/A by the
 *     Processor A/B.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_NMI field. */
#define MU_RD_CR_NMI(base)   ((MU_CR_REG(base) & MU_CR_NMI_MASK) >> MU_CR_NMI_SHIFT)
#define MU_BRD_CR_NMI(base)  (BME_UBFX32(&MU_CR_REG(base), MU_CR_NMI_SHIFT, MU_CR_NMI_WIDTH))

/*! @brief Set the NMI field to a new value. */
#define MU_WR_CR_NMI(base, value) (MU_RMW_CR(base, MU_CR_NMI_MASK, MU_CR_NMI(value)))
#define MU_BWR_CR_NMI(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_NMI_SHIFT), MU_CR_NMI_SHIFT, MU_CR_NMI_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field MUR[5] (RW)
 *
 * Processor A MU Reset. Setting MUR bit to "1" resets both the Processor B and
 * the Processor A sides of the MU module, forcing all control and status
 * registers to return to their default values and all internal states to be cleared.
 * Before setting the MUR bit to "1", it is advisable to interrupt the Processor B
 * , because setting the MUR bit may affect the ongoing Processor B program. MUR
 * bit can only be written as "1". MUR bit is always read as "0". MUR bit is
 * cleared during the MU reset sequence. This bit is only available on the Processor
 * A side.
 *
 * Values:
 * - 0b0 - N/A. Self clearing bit (default).
 * - 0b1 - Asserts the Processor A MU reset.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_MUR field. */
#define MU_RD_CR_MUR(base)   ((MU_CR_REG(base) & MU_CR_MUR_MASK) >> MU_CR_MUR_SHIFT)
#define MU_BRD_CR_MUR(base)  (BME_UBFX32(&MU_CR_REG(base), MU_CR_MUR_SHIFT, MU_CR_MUR_WIDTH))

/*! @brief Set the MUR field to a new value. */
#define MU_WR_CR_MUR(base, value) (MU_RMW_CR(base, MU_CR_MUR_MASK, MU_CR_MUR(value)))
#define MU_BWR_CR_MUR(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_MUR_SHIFT), MU_CR_MUR_SHIFT, MU_CR_MUR_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field BRSTH[7] (RW)
 *
 * When set, will cause Processor B to be held in reset following any reset
 * event. When cleared, allows Processor B to be released from reset. Setting this
 * bit will not force Processor B into reset. It will only hold Processor B if it
 * resets itself. This bit is only available on the Processor A side.
 *
 * Values:
 * - 0b0 - Release Processor B from reset
 * - 0b1 - Hold Processor B in reset
 */
/*@{*/
/*! @brief Read current value of the MU_CR_BRSTH field. */
#define MU_RD_CR_BRSTH(base) ((MU_CR_REG(base) & MU_CR_BRSTH_MASK) >> MU_CR_BRSTH_SHIFT)
#define MU_BRD_CR_BRSTH(base) (BME_UBFX32(&MU_CR_REG(base), MU_CR_BRSTH_SHIFT, MU_CR_BRSTH_WIDTH))

/*! @brief Set the BRSTH field to a new value. */
#define MU_WR_CR_BRSTH(base, value) (MU_RMW_CR(base, MU_CR_BRSTH_MASK, MU_CR_BRSTH(value)))
#define MU_BWR_CR_BRSTH(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_BRSTH_SHIFT), MU_CR_BRSTH_SHIFT, MU_CR_BRSTH_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field CLKE[8] (RW)
 *
 * When set, forces Processor B/A platform clock to remain enabled even after
 * Processor B/A has entered a stop mode. When clear, allows Processor B/A to gate
 * its platform clock whenever desired after entering a stop mode. Note that if
 * Processor A/B also enters a stop mode, then this bit is overidden to allow
 * Processor B/A to gate its platform clock.
 *
 * Values:
 * - 0b0 - Processor B/A platform clock gated when Processor B/A enters a stop
 *     mode.
 * - 0b1 - Processor B/A platform clock kept running after Processor B/A enters
 *     a stop mode, until Processor A/B also enters a stop mode.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_CLKE field. */
#define MU_RD_CR_CLKE(base)  ((MU_CR_REG(base) & MU_CR_CLKE_MASK) >> MU_CR_CLKE_SHIFT)
#define MU_BRD_CR_CLKE(base) (BME_UBFX32(&MU_CR_REG(base), MU_CR_CLKE_SHIFT, MU_CR_CLKE_WIDTH))

/*! @brief Set the CLKE field to a new value. */
#define MU_WR_CR_CLKE(base, value) (MU_RMW_CR(base, MU_CR_CLKE_MASK, MU_CR_CLKE(value)))
#define MU_BWR_CR_CLKE(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_CLKE_SHIFT), MU_CR_CLKE_SHIFT, MU_CR_CLKE_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field BBOOT[10:9] (RW)
 *
 * Configures the boot source for Processor B. This bit is only available on the
 * Processor A side.
 *
 * Values:
 * - 0b00 - Boot from 0x0
 * - 0b01 - Boot from DMEM Base
 * - 0b10 - Boot from IMEM Base
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the MU_CR_BBOOT field. */
#define MU_RD_CR_BBOOT(base) ((MU_CR_REG(base) & MU_CR_BBOOT_MASK) >> MU_CR_BBOOT_SHIFT)
#define MU_BRD_CR_BBOOT(base) (BME_UBFX32(&MU_CR_REG(base), MU_CR_BBOOT_SHIFT, MU_CR_BBOOT_WIDTH))

/*! @brief Set the BBOOT field to a new value. */
#define MU_WR_CR_BBOOT(base, value) (MU_RMW_CR(base, MU_CR_BBOOT_MASK, MU_CR_BBOOT(value)))
#define MU_BWR_CR_BBOOT(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_BBOOT_SHIFT), MU_CR_BBOOT_SHIFT, MU_CR_BBOOT_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field GIRn[19:16] (RW)
 *
 * For n = {0, 1, 2, 3} Processor A/B General Purpose Interrupt Request n.
 * (Read-Write) Writing "1" to the GIRn bit sets the GIPn bit in the Processor B/A SR
 * register on the Processor B-side. If the GIEn bit in the Processor B/A CR
 * register is set to "1" on the Processor B/A side, a General Purpose Interrupt n
 * request is triggered. The GIRn bit is cleared if the GIPn bit (in the Processor
 * B/A SR register on the Processor B/A side) is cleared by writing it (GIPn bit)
 * as "1", thereby signalling the Processor A/B that the interrupt was accepted
 * (cleared by the software). The GIPn bit cannot be written as "0" on the
 * Processor A/B side. To ensure proper operations, you must verify that the GIRn bit
 * is cleared (meaning that there is no pending interrupt) before setting it (GIRn
 * bit). GIRn bit is cleared when the MU resets.
 *
 * Values:
 * - 0b0000 - Processor A/B General Interrupt n is not requested to the
 *     Processor B/A (default).
 * - 0b0001 - Processor A/B General Interrupt n is requested to the Processor
 *     B/A.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_GIRn field. */
#define MU_RD_CR_GIRn(base)  ((MU_CR_REG(base) & MU_CR_GIRn_MASK) >> MU_CR_GIRn_SHIFT)
#define MU_BRD_CR_GIRn(base) (BME_UBFX32(&MU_CR_REG(base), MU_CR_GIRn_SHIFT, MU_CR_GIRn_WIDTH))

/*! @brief Set the GIRn field to a new value. */
#define MU_WR_CR_GIRn(base, value) (MU_RMW_CR(base, MU_CR_GIRn_MASK, MU_CR_GIRn(value)))
#define MU_BWR_CR_GIRn(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_GIRn_SHIFT), MU_CR_GIRn_SHIFT, MU_CR_GIRn_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field TIEn[23:20] (RW)
 *
 * For n = {0, 1, 2, 3} Processor A/B Transmit Interrupt Enable n. (Read-Write)
 * TIEn bit enables Processor A/B Transmit Interrupt n. If TIEn bit is set to "1"
 * (enabled), then an Processor A/B Transmit Interrupt n request is issued when
 * the TEn bit in the Processor A/B SR register is set to "1". If TIEn bit is
 * cleared (disabled), then the value of the TEn bit is ignored and no Processor A/B
 * Transmit Interrupt n request will be issued. TIEn bit is cleared when the MU
 * resets.
 *
 * Values:
 * - 0b0000 - Disables Processor A/B Transmit Interrupt n. (default)
 * - 0b0001 - Enables Processor A/B Transmit Interrupt n.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_TIEn field. */
#define MU_RD_CR_TIEn(base)  ((MU_CR_REG(base) & MU_CR_TIEn_MASK) >> MU_CR_TIEn_SHIFT)
#define MU_BRD_CR_TIEn(base) (BME_UBFX32(&MU_CR_REG(base), MU_CR_TIEn_SHIFT, MU_CR_TIEn_WIDTH))

/*! @brief Set the TIEn field to a new value. */
#define MU_WR_CR_TIEn(base, value) (MU_RMW_CR(base, MU_CR_TIEn_MASK, MU_CR_TIEn(value)))
#define MU_BWR_CR_TIEn(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_TIEn_SHIFT), MU_CR_TIEn_SHIFT, MU_CR_TIEn_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field RIEn[27:24] (RW)
 *
 * For n = {0, 1, 2, 3} Processor A/B Receive Interrupt Enable n. (Read-Write)
 * RIEn bit enables Processor A/B Receive Interrupt n. If RIEn bit is set to "1"
 * (enabled), then an Processor A/B Receive Interrupt n request is issued when the
 * RFn bit in the Processor A/B SR register is set to "1". If RIEn bit is
 * cleared (disabled), then the value of the RFn bit is ignored and no Processor A/B
 * Receive Interrupt n request will be issued. RIEn bit is cleared when the MU
 * resets.
 *
 * Values:
 * - 0b0000 - Disables Processor A/B Receive Interrupt n. (default)
 * - 0b0001 - Enables Processor A/B Receive Interrupt n.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_RIEn field. */
#define MU_RD_CR_RIEn(base)  ((MU_CR_REG(base) & MU_CR_RIEn_MASK) >> MU_CR_RIEn_SHIFT)
#define MU_BRD_CR_RIEn(base) (BME_UBFX32(&MU_CR_REG(base), MU_CR_RIEn_SHIFT, MU_CR_RIEn_WIDTH))

/*! @brief Set the RIEn field to a new value. */
#define MU_WR_CR_RIEn(base, value) (MU_RMW_CR(base, MU_CR_RIEn_MASK, MU_CR_RIEn(value)))
#define MU_BWR_CR_RIEn(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_RIEn_SHIFT), MU_CR_RIEn_SHIFT, MU_CR_RIEn_WIDTH))
/*@}*/

/*!
 * @name Register MU_CR, field GIEn[31:28] (RW)
 *
 * For n = {0, 1, 2, 3} Processor A/B General Purpose Interrupt Enable n.
 * (Read-Write) GIEn bit enables Processor A/B General Interrupt n. If GIEn bit is set
 * to "1" (enabled), then a General Interrupt n request is issued when the GIPn
 * bit in the Processor A/B SR register is set to "1". If GIEn is cleared
 * (disabled), then the value of the GIPn bit is ignored and no General Interrupt n
 * request will be issued. GIEn bit is cleared when the MU resets.
 *
 * Values:
 * - 0b0000 - Disables Processor A/B General Interrupt n. (default)
 * - 0b0001 - Enables Processor A/B General Interrupt n.
 */
/*@{*/
/*! @brief Read current value of the MU_CR_GIEn field. */
#define MU_RD_CR_GIEn(base)  ((MU_CR_REG(base) & MU_CR_GIEn_MASK) >> MU_CR_GIEn_SHIFT)
#define MU_BRD_CR_GIEn(base) (BME_UBFX32(&MU_CR_REG(base), MU_CR_GIEn_SHIFT, MU_CR_GIEn_WIDTH))

/*! @brief Set the GIEn field to a new value. */
#define MU_WR_CR_GIEn(base, value) (MU_RMW_CR(base, MU_CR_GIEn_MASK, MU_CR_GIEn(value)))
#define MU_BWR_CR_GIEn(base, value) (BME_BFI32(&MU_CR_REG(base), ((uint32_t)(value) << MU_CR_GIEn_SHIFT), MU_CR_GIEn_SHIFT, MU_CR_GIEn_WIDTH))
/*@}*/

/*
 * MKL28Z7 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - NV_FSEC - Non-volatile Flash Security Register
 * - NV_FOPT - Non-volatile Flash Option Register
 */

#define NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define FTFA_FlashConfig_IDX (0U) /*!< Instance number for FTFA_FlashConfig. */

/*******************************************************************************
 * NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define NV_RD_BACKKEY3(base)     (NV_BACKKEY3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define NV_RD_BACKKEY2(base)     (NV_BACKKEY2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define NV_RD_BACKKEY1(base)     (NV_BACKKEY1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define NV_RD_BACKKEY0(base)     (NV_BACKKEY0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define NV_RD_BACKKEY7(base)     (NV_BACKKEY7_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define NV_RD_BACKKEY6(base)     (NV_BACKKEY6_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define NV_RD_BACKKEY5(base)     (NV_BACKKEY5_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define NV_RD_BACKKEY4(base)     (NV_BACKKEY4_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define NV_RD_FPROT3(base)       (NV_FPROT3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define NV_RD_FPROT2(base)       (NV_FPROT2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define NV_RD_FPROT1(base)       (NV_FPROT1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define NV_RD_FPROT0(base)       (NV_FPROT0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define NV_RD_FSEC(base)         (NV_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 0b10 - MCU security status is unsecure
 * - 0b11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_SEC field. */
#define NV_RD_FSEC_SEC(base) ((NV_FSEC_REG(base) & NV_FSEC_SEC_MASK) >> NV_FSEC_SEC_SHIFT)
#define NV_BRD_FSEC_SEC(base) (NV_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define NV_RD_FSEC_FSLACC(base) ((NV_FSEC_REG(base) & NV_FSEC_FSLACC_MASK) >> NV_FSEC_FSLACC_SHIFT)
#define NV_BRD_FSEC_FSLACC(base) (NV_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define NV_RD_FSEC_MEEN(base) ((NV_FSEC_REG(base) & NV_FSEC_MEEN_MASK) >> NV_FSEC_MEEN_SHIFT)
#define NV_BRD_FSEC_MEEN(base) (NV_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define NV_RD_FSEC_KEYEN(base) ((NV_FSEC_REG(base) & NV_FSEC_KEYEN_MASK) >> NV_FSEC_KEYEN_SHIFT)
#define NV_BRD_FSEC_KEYEN(base) (NV_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0x3DU
 */
/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define NV_RD_FOPT(base)         (NV_FOPT_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT0[0] (RO)
 *
 * Values:
 * - 0b0 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT1=0 or 0x1 (divide by 2) when LPBOOT1=1.
 * - 0b1 - Core and system clock divider (OUTDIV1) is 0x3 (divide by 4) when
 *     LPBOOT1=0 or 0x0 (divide by 1) when LPBOOT1=1.
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT0 field. */
#define NV_RD_FOPT_LPBOOT0(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT0_MASK) >> NV_FOPT_LPBOOT0_SHIFT)
#define NV_BRD_FOPT_LPBOOT0(base) (NV_RD_FOPT_LPBOOT0(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field BOOTPIN_OPT[1] (RO)
 *
 * Values:
 * - 0b0 - Force Boot from ROM if BOOTCFG0 asserted, where BOOTCFG0 is the boot
 *     config function which is muxed with NMI pin
 * - 0b1 - Boot source configured by FOPT (BOOTSRC_SEL) bits
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_BOOTPIN_OPT field. */
#define NV_RD_FOPT_BOOTPIN_OPT(base) ((NV_FOPT_REG(base) & NV_FOPT_BOOTPIN_OPT_MASK) >> NV_FOPT_BOOTPIN_OPT_SHIFT)
#define NV_BRD_FOPT_BOOTPIN_OPT(base) (NV_RD_FOPT_BOOTPIN_OPT(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_DIS[2] (RO)
 *
 * Values:
 * - 0b0 - NMI interrupts are always blocked
 * - 0b1 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_NMI_DIS field. */
#define NV_RD_FOPT_NMI_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_NMI_DIS_MASK) >> NV_FOPT_NMI_DIS_SHIFT)
#define NV_BRD_FOPT_NMI_DIS(base) (NV_RD_FOPT_NMI_DIS(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field RESET_PIN_CFG[3] (RO)
 *
 * Values:
 * - 0b0 - RESET pin is disabled following a POR and cannot be enabled as reset
 *     function
 * - 0b1 - RESET_b pin is dedicated
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_RESET_PIN_CFG field. */
#define NV_RD_FOPT_RESET_PIN_CFG(base) ((NV_FOPT_REG(base) & NV_FOPT_RESET_PIN_CFG_MASK) >> NV_FOPT_RESET_PIN_CFG_SHIFT)
#define NV_BRD_FOPT_RESET_PIN_CFG(base) (NV_RD_FOPT_RESET_PIN_CFG(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field LPBOOT1[4] (RO)
 *
 * Values:
 * - 0b0 - Core and system clock divider (OUTDIV1) is 0x7 (divide by 8) when
 *     LPBOOT0=0 or 0x3 (divide by 4) when LPBOOT0=1.
 * - 0b1 - Core and system clock divider (OUTDIV1) is 0x1 (divide by 2) when
 *     LPBOOT0=0 or 0x0 (divide by 1) when LPBOOT0=1.
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT1 field. */
#define NV_RD_FOPT_LPBOOT1(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT1_MASK) >> NV_FOPT_LPBOOT1_SHIFT)
#define NV_BRD_FOPT_LPBOOT1(base) (NV_RD_FOPT_LPBOOT1(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field FAST_INIT[5] (RO)
 *
 * Values:
 * - 0b0 - Slower initialization
 * - 0b1 - Fast Initialization
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_FAST_INIT field. */
#define NV_RD_FOPT_FAST_INIT(base) ((NV_FOPT_REG(base) & NV_FOPT_FAST_INIT_MASK) >> NV_FOPT_FAST_INIT_SHIFT)
#define NV_BRD_FOPT_FAST_INIT(base) (NV_RD_FOPT_FAST_INIT(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field BOOTSRC_SEL[7:6] (RO)
 *
 * Values:
 * - 0b00 - Boot from Flash
 * - 0b10 - Boot from ROM
 * - 0b11 - Boot from ROM
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_BOOTSRC_SEL field. */
#define NV_RD_FOPT_BOOTSRC_SEL(base) ((NV_FOPT_REG(base) & NV_FOPT_BOOTSRC_SEL_MASK) >> NV_FOPT_BOOTSRC_SEL_SHIFT)
#define NV_BRD_FOPT_BOOTSRC_SEL(base) (NV_RD_FOPT_BOOTSRC_SEL(base))
/*@}*/

/*
 * MKL28Z7 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - OSC_CR - OSC Control Register
 * - OSC_DIV - OSC_DIV
 */

#define OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define OSC_IDX (0U) /*!< Instance number for OSC. */

/*******************************************************************************
 * OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define OSC_RD_CR(base)          (OSC_CR_REG(base))
#define OSC_WR_CR(base, value)   (OSC_CR_REG(base) = (value))
#define OSC_RMW_CR(base, mask, value) (OSC_WR_CR(base, (OSC_RD_CR(base) & ~(mask)) | (value)))
#define OSC_SET_CR(base, value)  (BME_OR8(&OSC_CR_REG(base), (uint8_t)(value)))
#define OSC_CLR_CR(base, value)  (BME_AND8(&OSC_CR_REG(base), (uint8_t)(~(value))))
#define OSC_TOG_CR(base, value)  (BME_XOR8(&OSC_CR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC16P field. */
#define OSC_RD_CR_SC16P(base) ((OSC_CR_REG(base) & OSC_CR_SC16P_MASK) >> OSC_CR_SC16P_SHIFT)
#define OSC_BRD_CR_SC16P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))

/*! @brief Set the SC16P field to a new value. */
#define OSC_WR_CR_SC16P(base, value) (OSC_RMW_CR(base, OSC_CR_SC16P_MASK, OSC_CR_SC16P(value)))
#define OSC_BWR_CR_SC16P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC16P_SHIFT), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC8P field. */
#define OSC_RD_CR_SC8P(base) ((OSC_CR_REG(base) & OSC_CR_SC8P_MASK) >> OSC_CR_SC8P_SHIFT)
#define OSC_BRD_CR_SC8P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))

/*! @brief Set the SC8P field to a new value. */
#define OSC_WR_CR_SC8P(base, value) (OSC_RMW_CR(base, OSC_CR_SC8P_MASK, OSC_CR_SC8P(value)))
#define OSC_BWR_CR_SC8P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC8P_SHIFT), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC4P field. */
#define OSC_RD_CR_SC4P(base) ((OSC_CR_REG(base) & OSC_CR_SC4P_MASK) >> OSC_CR_SC4P_SHIFT)
#define OSC_BRD_CR_SC4P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))

/*! @brief Set the SC4P field to a new value. */
#define OSC_WR_CR_SC4P(base, value) (OSC_RMW_CR(base, OSC_CR_SC4P_MASK, OSC_CR_SC4P(value)))
#define OSC_BWR_CR_SC4P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC4P_SHIFT), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC2P field. */
#define OSC_RD_CR_SC2P(base) ((OSC_CR_REG(base) & OSC_CR_SC2P_MASK) >> OSC_CR_SC2P_SHIFT)
#define OSC_BRD_CR_SC2P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))

/*! @brief Set the SC2P field to a new value. */
#define OSC_WR_CR_SC2P(base, value) (OSC_RMW_CR(base, OSC_CR_SC2P_MASK, OSC_CR_SC2P(value)))
#define OSC_BWR_CR_SC2P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC2P_SHIFT), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0b0 - External reference clock is disabled in Stop mode.
 * - 0b1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define OSC_RD_CR_EREFSTEN(base) ((OSC_CR_REG(base) & OSC_CR_EREFSTEN_MASK) >> OSC_CR_EREFSTEN_SHIFT)
#define OSC_BRD_CR_EREFSTEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))

/*! @brief Set the EREFSTEN field to a new value. */
#define OSC_WR_CR_EREFSTEN(base, value) (OSC_RMW_CR(base, OSC_CR_EREFSTEN_MASK, OSC_CR_EREFSTEN(value)))
#define OSC_BWR_CR_EREFSTEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_EREFSTEN_SHIFT), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK).
 *
 * Values:
 * - 0b0 - External reference clock is inactive.
 * - 0b1 - External reference clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define OSC_RD_CR_ERCLKEN(base) ((OSC_CR_REG(base) & OSC_CR_ERCLKEN_MASK) >> OSC_CR_ERCLKEN_SHIFT)
#define OSC_BRD_CR_ERCLKEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))

/*! @brief Set the ERCLKEN field to a new value. */
#define OSC_WR_CR_ERCLKEN(base, value) (OSC_RMW_CR(base, OSC_CR_ERCLKEN_MASK, OSC_CR_ERCLKEN(value)))
#define OSC_BWR_CR_ERCLKEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_ERCLKEN_SHIFT), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))
/*@}*/

/*******************************************************************************
 * OSC_DIV - OSC_DIV
 ******************************************************************************/

/*!
 * @brief OSC_DIV - OSC_DIV (RW)
 *
 * Reset value: 0x00U
 *
 * OSC CLock divider register.
 */
/*!
 * @name Constants and macros for entire OSC_DIV register
 */
/*@{*/
#define OSC_RD_DIV(base)         (OSC_DIV_REG(base))
#define OSC_WR_DIV(base, value)  (OSC_DIV_REG(base) = (value))
#define OSC_RMW_DIV(base, mask, value) (OSC_WR_DIV(base, (OSC_RD_DIV(base) & ~(mask)) | (value)))
#define OSC_SET_DIV(base, value) (BME_OR8(&OSC_DIV_REG(base), (uint8_t)(value)))
#define OSC_CLR_DIV(base, value) (BME_AND8(&OSC_DIV_REG(base), (uint8_t)(~(value))))
#define OSC_TOG_DIV(base, value) (BME_XOR8(&OSC_DIV_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual OSC_DIV bitfields
 */

/*!
 * @name Register OSC_DIV, field ERPS[7:6] (RW)
 *
 * ERCLK prescaler. These two bits are used to divide the ERCLK output. The
 * un-divided ERCLK output is not affected by these two bits.
 *
 * Values:
 * - 0b00 - The divisor ratio is 1.
 * - 0b01 - The divisor ratio is 2.
 * - 0b10 - The divisor ratio is 4.
 * - 0b11 - The divisor ratio is 8.
 */
/*@{*/
/*! @brief Read current value of the OSC_DIV_ERPS field. */
#define OSC_RD_DIV_ERPS(base) ((OSC_DIV_REG(base) & OSC_DIV_ERPS_MASK) >> OSC_DIV_ERPS_SHIFT)
#define OSC_BRD_DIV_ERPS(base) (BME_UBFX8(&OSC_DIV_REG(base), OSC_DIV_ERPS_SHIFT, OSC_DIV_ERPS_WIDTH))

/*! @brief Set the ERPS field to a new value. */
#define OSC_WR_DIV_ERPS(base, value) (OSC_RMW_DIV(base, OSC_DIV_ERPS_MASK, OSC_DIV_ERPS(value)))
#define OSC_BWR_DIV_ERPS(base, value) (BME_BFI8(&OSC_DIV_REG(base), ((uint8_t)(value) << OSC_DIV_ERPS_SHIFT), OSC_DIV_ERPS_SHIFT, OSC_DIV_ERPS_WIDTH))
/*@}*/

/*
 * MKL28Z7 PCC
 *
 *
 *
 * Registers defined in this header file:
 * - PCC_CLKCFG - PCC CLKCFG Register
 */

#define PCC_INSTANCE_COUNT (2U) /*!< Number of instances of the PCC module. */
#define PCC0_IDX (0U) /*!< Instance number for PCC0. */
#define PCC1_IDX (1U) /*!< Instance number for PCC1. */

/*******************************************************************************
 * PCC_CLKCFG - PCC CLKCFG Register
 ******************************************************************************/

/*!
 * @brief PCC_CLKCFG - PCC CLKCFG Register (RW)
 *
 * Reset value: 0x80000000U
 */
/*!
 * @name Constants and macros for entire PCC_CLKCFG register
 */
/*@{*/
#define PCC_RD_CLKCFG(base, index) (PCC_CLKCFG_REG(base, index))
#define PCC_WR_CLKCFG(base, index, value) (PCC_CLKCFG_REG(base, index) = (value))
#define PCC_RMW_CLKCFG(base, index, mask, value) (PCC_WR_CLKCFG(base, index, (PCC_RD_CLKCFG(base, index) & ~(mask)) | (value)))
#define PCC_SET_CLKCFG(base, index, value) (BME_OR32(&PCC_CLKCFG_REG(base, index), (uint32_t)(value)))
#define PCC_CLR_CLKCFG(base, index, value) (BME_AND32(&PCC_CLKCFG_REG(base, index), (uint32_t)(~(value))))
#define PCC_TOG_CLKCFG(base, index, value) (BME_XOR32(&PCC_CLKCFG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PCC_CLKCFG bitfields
 */

/*!
 * @name Register PCC_CLKCFG, field PCD[2:0] (RW)
 *
 * This read/write bit field is used for peripherals that require a clock
 * divider. At SOC integration, each peripheral is assigned either a divider or not.
 *
 * Values:
 * - 0b000 - Divide by 1 (pass-through, no clock divide).
 * - 0b001 - Divide by 2.
 * - 0b010 - Divide by 3.
 * - 0b011 - Divide by 4.
 * - 0b100 - Divide by 5.
 * - 0b101 - Divide by 6.
 * - 0b110 - Divide by 7.
 * - 0b111 - Divide by 8.
 */
/*@{*/
/*! @brief Read current value of the PCC_CLKCFG_PCD field. */
#define PCC_RD_CLKCFG_PCD(base, index) ((PCC_CLKCFG_REG(base, index) & PCC_CLKCFG_PCD_MASK) >> PCC_CLKCFG_PCD_SHIFT)
#define PCC_BRD_CLKCFG_PCD(base, index) (BME_UBFX32(&PCC_CLKCFG_REG(base, index), PCC_CLKCFG_PCD_SHIFT, PCC_CLKCFG_PCD_WIDTH))

/*! @brief Set the PCD field to a new value. */
#define PCC_WR_CLKCFG_PCD(base, index, value) (PCC_RMW_CLKCFG(base, index, PCC_CLKCFG_PCD_MASK, PCC_CLKCFG_PCD(value)))
#define PCC_BWR_CLKCFG_PCD(base, index, value) (BME_BFI32(&PCC_CLKCFG_REG(base, index), ((uint32_t)(value) << PCC_CLKCFG_PCD_SHIFT), PCC_CLKCFG_PCD_SHIFT, PCC_CLKCFG_PCD_WIDTH))
/*@}*/

/*!
 * @name Register PCC_CLKCFG, field FRAC[3] (RW)
 *
 * This read/write bit field sets the fraction multiply value for the fractional
 * clock divider used as a clock source. Divider output clock = Divider input
 * clock x [(FRAC+1)/(DIV+1)].
 *
 * Values:
 * - 0b0 - Fractional value is 0.
 * - 0b1 - Fractional value is 1.
 */
/*@{*/
/*! @brief Read current value of the PCC_CLKCFG_FRAC field. */
#define PCC_RD_CLKCFG_FRAC(base, index) ((PCC_CLKCFG_REG(base, index) & PCC_CLKCFG_FRAC_MASK) >> PCC_CLKCFG_FRAC_SHIFT)
#define PCC_BRD_CLKCFG_FRAC(base, index) (BME_UBFX32(&PCC_CLKCFG_REG(base, index), PCC_CLKCFG_FRAC_SHIFT, PCC_CLKCFG_FRAC_WIDTH))

/*! @brief Set the FRAC field to a new value. */
#define PCC_WR_CLKCFG_FRAC(base, index, value) (PCC_RMW_CLKCFG(base, index, PCC_CLKCFG_FRAC_MASK, PCC_CLKCFG_FRAC(value)))
#define PCC_BWR_CLKCFG_FRAC(base, index, value) (BME_BFI32(&PCC_CLKCFG_REG(base, index), ((uint32_t)(value) << PCC_CLKCFG_FRAC_SHIFT), PCC_CLKCFG_FRAC_SHIFT, PCC_CLKCFG_FRAC_WIDTH))
/*@}*/

/*!
 * @name Register PCC_CLKCFG, field PCS[26:24] (RW)
 *
 * This read/write bit field is used for peripherals that support various clock
 * selections.
 *
 * Values:
 * - 0b000 - Clock is off (or test clock is enabled).
 * - 0b001 - OSCCLK - System Oscillator Bus Clock(scg_sosc_slow_clk).
 * - 0b010 - SCGIRCLK - Slow IRC Clock(scg_sirc_slow_clk), (maximum is 8MHz).
 * - 0b011 - SCGFIRCLK - Fast IRC Clock(scg_firc_slow_clk), (maximum is 48MHz).
 * - 0b100 - Reserved.
 * - 0b101 - Reserved.
 * - 0b110 - SCGPCLK System PLL clock (scg_spll_slow_clk).
 * - 0b111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PCC_CLKCFG_PCS field. */
#define PCC_RD_CLKCFG_PCS(base, index) ((PCC_CLKCFG_REG(base, index) & PCC_CLKCFG_PCS_MASK) >> PCC_CLKCFG_PCS_SHIFT)
#define PCC_BRD_CLKCFG_PCS(base, index) (BME_UBFX32(&PCC_CLKCFG_REG(base, index), PCC_CLKCFG_PCS_SHIFT, PCC_CLKCFG_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define PCC_WR_CLKCFG_PCS(base, index, value) (PCC_RMW_CLKCFG(base, index, PCC_CLKCFG_PCS_MASK, PCC_CLKCFG_PCS(value)))
#define PCC_BWR_CLKCFG_PCS(base, index, value) (BME_BFI32(&PCC_CLKCFG_REG(base, index), ((uint32_t)(value) << PCC_CLKCFG_PCS_SHIFT), PCC_CLKCFG_PCS_SHIFT, PCC_CLKCFG_PCS_WIDTH))
/*@}*/

/*!
 * @name Register PCC_CLKCFG, field INUSE[29] (RO)
 *
 * This read-only bit shows that this peripheral is already in use by another
 * core. That is, software on another core has already configured the clocking
 * options of this peripheral. For example, if CPU0 software has set this
 * peripheral's CGC bit first, it sees the INUSE bit as cleared. However, if software on
 * another core has set this peripheral's CGC bit first, CPU0 software sees the
 * INUSE bit as set.
 *
 * Values:
 * - 0b0 - Another core is not using this peripheral.
 * - 0b1 - Another core is using this peripheral. Software cannot modify the
 *     existing clocking configuration.
 */
/*@{*/
/*! @brief Read current value of the PCC_CLKCFG_INUSE field. */
#define PCC_RD_CLKCFG_INUSE(base, index) ((PCC_CLKCFG_REG(base, index) & PCC_CLKCFG_INUSE_MASK) >> PCC_CLKCFG_INUSE_SHIFT)
#define PCC_BRD_CLKCFG_INUSE(base, index) (BME_UBFX32(&PCC_CLKCFG_REG(base, index), PCC_CLKCFG_INUSE_SHIFT, PCC_CLKCFG_INUSE_WIDTH))
/*@}*/

/*!
 * @name Register PCC_CLKCFG, field CGC[30] (RW)
 *
 * This read/write bit enables the clock for the peripheral.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the PCC_CLKCFG_CGC field. */
#define PCC_RD_CLKCFG_CGC(base, index) ((PCC_CLKCFG_REG(base, index) & PCC_CLKCFG_CGC_MASK) >> PCC_CLKCFG_CGC_SHIFT)
#define PCC_BRD_CLKCFG_CGC(base, index) (BME_UBFX32(&PCC_CLKCFG_REG(base, index), PCC_CLKCFG_CGC_SHIFT, PCC_CLKCFG_CGC_WIDTH))

/*! @brief Set the CGC field to a new value. */
#define PCC_WR_CLKCFG_CGC(base, index, value) (PCC_RMW_CLKCFG(base, index, PCC_CLKCFG_CGC_MASK, PCC_CLKCFG_CGC(value)))
#define PCC_BWR_CLKCFG_CGC(base, index, value) (BME_BFI32(&PCC_CLKCFG_REG(base, index), ((uint32_t)(value) << PCC_CLKCFG_CGC_SHIFT), PCC_CLKCFG_CGC_SHIFT, PCC_CLKCFG_CGC_WIDTH))
/*@}*/

/*!
 * @name Register PCC_CLKCFG, field PR[31] (RO)
 *
 * This bit shows whether the peripheral is present on this device.
 *
 * Values:
 * - 0b0 - Peripheral is not present.
 * - 0b1 - Peripheral is present.
 */
/*@{*/
/*! @brief Read current value of the PCC_CLKCFG_PR field. */
#define PCC_RD_CLKCFG_PR(base, index) ((PCC_CLKCFG_REG(base, index) & PCC_CLKCFG_PR_MASK) >> PCC_CLKCFG_PR_SHIFT)
#define PCC_BRD_CLKCFG_PR(base, index) (BME_UBFX32(&PCC_CLKCFG_REG(base, index), PCC_CLKCFG_PR_SHIFT, PCC_CLKCFG_PR_WIDTH))
/*@}*/

/*
 * MKL28Z7 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - PMC_VERID - Version ID register
 * - PMC_PARAM - Parameter register
 * - PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - PMC_REGSC - Regulator Status And Control register
 * - PMC_HVDSC1 - High Voltage Detect Status And Control 1 register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_VERID - Version ID register
 ******************************************************************************/

/*!
 * @brief PMC_VERID - Version ID register (RO)
 *
 * Reset value: 0x04000000U
 */
/*!
 * @name Constants and macros for entire PMC_VERID register
 */
/*@{*/
#define PMC_RD_VERID(base)       (PMC_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual PMC_VERID bitfields
 */

/*!
 * @name Register PMC_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000000 - Standard features implemented
 */
/*@{*/
/*! @brief Read current value of the PMC_VERID_FEATURE field. */
#define PMC_RD_VERID_FEATURE(base) ((PMC_VERID_REG(base) & PMC_VERID_FEATURE_MASK) >> PMC_VERID_FEATURE_SHIFT)
#define PMC_BRD_VERID_FEATURE(base) (PMC_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register PMC_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the PMC_VERID_MINOR field. */
#define PMC_RD_VERID_MINOR(base) ((PMC_VERID_REG(base) & PMC_VERID_MINOR_MASK) >> PMC_VERID_MINOR_SHIFT)
#define PMC_BRD_VERID_MINOR(base) (BME_UBFX32(&PMC_VERID_REG(base), PMC_VERID_MINOR_SHIFT, PMC_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register PMC_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the PMC_VERID_MAJOR field. */
#define PMC_RD_VERID_MAJOR(base) ((PMC_VERID_REG(base) & PMC_VERID_MAJOR_MASK) >> PMC_VERID_MAJOR_SHIFT)
#define PMC_BRD_VERID_MAJOR(base) (BME_UBFX32(&PMC_VERID_REG(base), PMC_VERID_MAJOR_SHIFT, PMC_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_PARAM - Parameter register
 ******************************************************************************/

/*!
 * @brief PMC_PARAM - Parameter register (RO)
 *
 * Reset value: 0x00000003U
 */
/*!
 * @name Constants and macros for entire PMC_PARAM register
 */
/*@{*/
#define PMC_RD_PARAM(base)       (PMC_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual PMC_PARAM bitfields
 */

/*!
 * @name Register PMC_PARAM, field VLPOE[0] (RO)
 *
 * If set, indicates support for VLPO bit is enabled in the PMC_REGSC register.
 */
/*@{*/
/*! @brief Read current value of the PMC_PARAM_VLPOE field. */
#define PMC_RD_PARAM_VLPOE(base) ((PMC_PARAM_REG(base) & PMC_PARAM_VLPOE_MASK) >> PMC_PARAM_VLPOE_SHIFT)
#define PMC_BRD_PARAM_VLPOE(base) (BME_UBFX32(&PMC_PARAM_REG(base), PMC_PARAM_VLPOE_SHIFT, PMC_PARAM_VLPOE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_PARAM, field HVDE[1] (RO)
 *
 * If set, indicates support for High Voltage Detect is enabled.
 */
/*@{*/
/*! @brief Read current value of the PMC_PARAM_HVDE field. */
#define PMC_RD_PARAM_HVDE(base) ((PMC_PARAM_REG(base) & PMC_PARAM_HVDE_MASK) >> PMC_PARAM_HVDE_SHIFT)
#define PMC_BRD_PARAM_HVDE(base) (BME_UBFX32(&PMC_PARAM_REG(base), PMC_PARAM_HVDE_SHIFT, PMC_PARAM_HVDE_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x00000010U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (BME_OR32(&PMC_LVDSC1_REG(base), (uint32_t)(value)))
#define PMC_CLR_LVDSC1(base, value) (BME_AND32(&PMC_LVDSC1_REG(base), (uint32_t)(~(value))))
#define PMC_TOG_LVDSC1(base, value) (BME_XOR32(&PMC_LVDSC1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 0b00 - Low trip point selected (V LVD = V LVDL )
 * - 0b01 - High trip point selected (V LVD = V LVDH )
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define PMC_RD_LVDSC1_LVDV(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDV_MASK) >> PMC_LVDSC1_LVDV_SHIFT)
#define PMC_BRD_LVDSC1_LVDV(base) (BME_UBFX32(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))

/*! @brief Set the LVDV field to a new value. */
#define PMC_WR_LVDSC1_LVDV(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDV_MASK, PMC_LVDSC1_LVDV(value)))
#define PMC_BWR_LVDSC1_LVDV(base, value) (BME_BFI32(&PMC_LVDSC1_REG(base), ((uint32_t)(value) << PMC_LVDSC1_LVDV_SHIFT), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0b0 - LVDF does not generate hardware resets
 * - 0b1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BME_UBFX32(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BME_BFI32(&PMC_LVDSC1_REG(base), ((uint32_t)(value) << PMC_LVDSC1_LVDRE_SHIFT), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BME_UBFX32(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BME_BFI32(&PMC_LVDSC1_REG(base), ((uint32_t)(value) << PMC_LVDSC1_LVDIE_SHIFT), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (BME_BFI32(&PMC_LVDSC1_REG(base), ((uint32_t)(value) << PMC_LVDSC1_LVDACK_SHIFT), PMC_LVDSC1_LVDACK_SHIFT, PMC_LVDSC1_LVDACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0b0 - Low-voltage event not detected
 * - 0b1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BME_UBFX32(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT, PMC_LVDSC1_LVDF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (BME_OR32(&PMC_LVDSC2_REG(base), (uint32_t)(value)))
#define PMC_CLR_LVDSC2(base, value) (BME_AND32(&PMC_LVDSC2_REG(base), (uint32_t)(~(value))))
#define PMC_TOG_LVDSC2(base, value) (BME_XOR32(&PMC_LVDSC2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 0b00 - Low trip point selected (VLVW = VLVW1)
 * - 0b01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 0b10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 0b11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define PMC_RD_LVDSC2_LVWV(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWV_MASK) >> PMC_LVDSC2_LVWV_SHIFT)
#define PMC_BRD_LVDSC2_LVWV(base) (BME_UBFX32(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))

/*! @brief Set the LVWV field to a new value. */
#define PMC_WR_LVDSC2_LVWV(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWV_MASK, PMC_LVDSC2_LVWV(value)))
#define PMC_BWR_LVDSC2_LVWV(base, value) (BME_BFI32(&PMC_LVDSC2_REG(base), ((uint32_t)(value) << PMC_LVDSC2_LVWV_SHIFT), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BME_UBFX32(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BME_BFI32(&PMC_LVDSC2_REG(base), ((uint32_t)(value) << PMC_LVDSC2_LVWIE_SHIFT), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVWACK field to a new value. */
#define PMC_WR_LVDSC2_LVWACK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWACK_MASK, PMC_LVDSC2_LVWACK(value)))
#define PMC_BWR_LVDSC2_LVWACK(base, value) (BME_BFI32(&PMC_LVDSC2_REG(base), ((uint32_t)(value) << PMC_LVDSC2_LVWACK_SHIFT), PMC_LVDSC2_LVWACK_SHIFT, PMC_LVDSC2_LVWACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0b0 - Low-voltage warning event not detected
 * - 0b1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BME_UBFX32(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT, PMC_LVDSC2_LVWF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x00000024U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (BME_OR32(&PMC_REGSC_REG(base), (uint32_t)(value)))
#define PMC_CLR_REGSC(base, value) (BME_AND32(&PMC_REGSC_REG(base), (uint32_t)(~(value))))
#define PMC_TOG_REGSC(base, value) (BME_XOR32(&PMC_REGSC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0b0 - Bandgap buffer not enabled
 * - 0b1 - Bandgap buffer enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define PMC_RD_REGSC_BGBE(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGBE_MASK) >> PMC_REGSC_BGBE_SHIFT)
#define PMC_BRD_REGSC_BGBE(base) (BME_UBFX32(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))

/*! @brief Set the BGBE field to a new value. */
#define PMC_WR_REGSC_BGBE(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGBE_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGBE(value)))
#define PMC_BWR_REGSC_BGBE(base, value) (BME_BFI32(&PMC_REGSC_REG(base), ((uint32_t)(value) << PMC_REGSC_BGBE_SHIFT), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0b0 - Regulator is in stop regulation or in transition to/from it
 * - 0b1 - Regulator is in run regulation
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define PMC_RD_REGSC_REGONS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGONS_MASK) >> PMC_REGSC_REGONS_SHIFT)
#define PMC_BRD_REGSC_REGONS(base) (BME_UBFX32(&PMC_REGSC_REG(base), PMC_REGSC_REGONS_SHIFT, PMC_REGSC_REGONS_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration
 * for enabled LLWU wakeup pins should be restored to avoid any LLWU flag from
 * being falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0b0 - Peripherals and I/O pads are in normal run state.
 * - 0b1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define PMC_RD_REGSC_ACKISO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_ACKISO_MASK) >> PMC_REGSC_ACKISO_SHIFT)
#define PMC_BRD_REGSC_ACKISO(base) (BME_UBFX32(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))

/*! @brief Set the ACKISO field to a new value. */
#define PMC_WR_REGSC_ACKISO(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_ACKISO_MASK, PMC_REGSC_ACKISO(value)))
#define PMC_BWR_REGSC_ACKISO(base, value) (BME_BFI32(&PMC_REGSC_REG(base), ((uint32_t)(value) << PMC_REGSC_ACKISO_SHIFT), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field BGEN[4] (RW)
 *
 * BGEN controls whether the bandgap is enabled in lower power modes of
 * operation (VLPx, LLS, and VLLSx). When on-chip peripherals require the bandgap voltage
 * reference in low power modes of operation, set BGEN to continue to enable the
 * bandgap operation. When the bandgap voltage reference is not needed in low
 * power modes, clear BGEN to avoid excess power consumption.
 *
 * Values:
 * - 0b0 - Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes.
 * - 0b1 - Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGEN field. */
#define PMC_RD_REGSC_BGEN(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGEN_MASK) >> PMC_REGSC_BGEN_SHIFT)
#define PMC_BRD_REGSC_BGEN(base) (BME_UBFX32(&PMC_REGSC_REG(base), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))

/*! @brief Set the BGEN field to a new value. */
#define PMC_WR_REGSC_BGEN(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGEN_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGEN(value)))
#define PMC_BWR_REGSC_BGEN(base, value) (BME_BFI32(&PMC_REGSC_REG(base), ((uint32_t)(value) << PMC_REGSC_BGEN_SHIFT), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field VLPO[6] (RW)
 *
 * When used in conjunction with BGEN, this bit allows additional clock sources
 * and higher frequency operation (at the cost of higher power) to be selected
 * during VLPx modes.
 *
 * Values:
 * - 0b0 - Operating frequencies and SCG clocking modes are restricted during
 *     VLPx modes as listed in the Power Management chapter.
 * - 0b1 - If BGEN is also set, operating frequencies and SCG clocking modes are
 *     unrestricted during VLPx modes. Note that flash access frequency is still
 *     restricted however.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_VLPO field. */
#define PMC_RD_REGSC_VLPO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_VLPO_MASK) >> PMC_REGSC_VLPO_SHIFT)
#define PMC_BRD_REGSC_VLPO(base) (BME_UBFX32(&PMC_REGSC_REG(base), PMC_REGSC_VLPO_SHIFT, PMC_REGSC_VLPO_WIDTH))

/*! @brief Set the VLPO field to a new value. */
#define PMC_WR_REGSC_VLPO(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_VLPO_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_VLPO(value)))
#define PMC_BWR_REGSC_VLPO(base, value) (BME_BFI32(&PMC_REGSC_REG(base), ((uint32_t)(value) << PMC_REGSC_VLPO_SHIFT), PMC_REGSC_VLPO_SHIFT, PMC_REGSC_VLPO_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_HVDSC1 - High Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_HVDSC1 - High Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x00000001U
 *
 * This register contains status and control bits to support the high voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the HVD system is disabled regardless of HVDSC1 settings. To protect
 * systems that must have HVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power
 * or low leakage modes from being enabled. See the device's data sheet for the
 * exact HVD trip voltages. This register is reset solely on a POR Only event.For
 * more information about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_HVDSC1 register
 */
/*@{*/
#define PMC_RD_HVDSC1(base)      (PMC_HVDSC1_REG(base))
#define PMC_WR_HVDSC1(base, value) (PMC_HVDSC1_REG(base) = (value))
#define PMC_RMW_HVDSC1(base, mask, value) (PMC_WR_HVDSC1(base, (PMC_RD_HVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_HVDSC1(base, value) (BME_OR32(&PMC_HVDSC1_REG(base), (uint32_t)(value)))
#define PMC_CLR_HVDSC1(base, value) (BME_AND32(&PMC_HVDSC1_REG(base), (uint32_t)(~(value))))
#define PMC_TOG_HVDSC1(base, value) (BME_XOR32(&PMC_HVDSC1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_HVDSC1 bitfields
 */

/*!
 * @name Register PMC_HVDSC1, field HVDV[0] (RW)
 *
 * Selects the HVD trip point voltage (V HVD ).
 *
 * Values:
 * - 0b0 - Low trip point selected (V HVD = V HVDL )
 * - 0b1 - High trip point selected (V HVD = V HVDH )
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDV field. */
#define PMC_RD_HVDSC1_HVDV(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDV_MASK) >> PMC_HVDSC1_HVDV_SHIFT)
#define PMC_BRD_HVDSC1_HVDV(base) (BME_UBFX32(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDV_SHIFT, PMC_HVDSC1_HVDV_WIDTH))

/*! @brief Set the HVDV field to a new value. */
#define PMC_WR_HVDSC1_HVDV(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDV_MASK, PMC_HVDSC1_HVDV(value)))
#define PMC_BWR_HVDSC1_HVDV(base, value) (BME_BFI32(&PMC_HVDSC1_REG(base), ((uint32_t)(value) << PMC_HVDSC1_HVDV_SHIFT), PMC_HVDSC1_HVDV_SHIFT, PMC_HVDSC1_HVDV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDRE[4] (RW)
 *
 * This write-once bit enables HVDF events to generate a hardware reset.
 * Additional writes are ignored until the next chip reset.
 *
 * Values:
 * - 0b0 - HVDF does not generate hardware resets
 * - 0b1 - Force an MCU reset when HVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDRE field. */
#define PMC_RD_HVDSC1_HVDRE(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDRE_MASK) >> PMC_HVDSC1_HVDRE_SHIFT)
#define PMC_BRD_HVDSC1_HVDRE(base) (BME_UBFX32(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDRE_SHIFT, PMC_HVDSC1_HVDRE_WIDTH))

/*! @brief Set the HVDRE field to a new value. */
#define PMC_WR_HVDSC1_HVDRE(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDRE_MASK, PMC_HVDSC1_HVDRE(value)))
#define PMC_BWR_HVDSC1_HVDRE(base, value) (BME_BFI32(&PMC_HVDSC1_REG(base), ((uint32_t)(value) << PMC_HVDSC1_HVDRE_SHIFT), PMC_HVDSC1_HVDRE_SHIFT, PMC_HVDSC1_HVDRE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for HVDF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when HVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDIE field. */
#define PMC_RD_HVDSC1_HVDIE(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDIE_MASK) >> PMC_HVDSC1_HVDIE_SHIFT)
#define PMC_BRD_HVDSC1_HVDIE(base) (BME_UBFX32(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDIE_SHIFT, PMC_HVDSC1_HVDIE_WIDTH))

/*! @brief Set the HVDIE field to a new value. */
#define PMC_WR_HVDSC1_HVDIE(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDIE_MASK, PMC_HVDSC1_HVDIE(value)))
#define PMC_BWR_HVDSC1_HVDIE(base, value) (BME_BFI32(&PMC_HVDSC1_REG(base), ((uint32_t)(value) << PMC_HVDSC1_HVDIE_SHIFT), PMC_HVDSC1_HVDIE_SHIFT, PMC_HVDSC1_HVDIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge high voltage detection errors.
 * Write 1 to clear HVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the HVDACK field to a new value. */
#define PMC_WR_HVDSC1_HVDACK(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDACK_MASK, PMC_HVDSC1_HVDACK(value)))
#define PMC_BWR_HVDSC1_HVDACK(base, value) (BME_BFI32(&PMC_HVDSC1_REG(base), ((uint32_t)(value) << PMC_HVDSC1_HVDACK_SHIFT), PMC_HVDSC1_HVDACK_SHIFT, PMC_HVDSC1_HVDACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDF[7] (RO)
 *
 * This read-only status field indicates a high-voltage detect event.
 *
 * Values:
 * - 0b0 - High-voltage event not detected
 * - 0b1 - High-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDF field. */
#define PMC_RD_HVDSC1_HVDF(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDF_MASK) >> PMC_HVDSC1_HVDF_SHIFT)
#define PMC_BRD_HVDSC1_HVDF(base) (BME_UBFX32(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDF_SHIFT, PMC_HVDSC1_HVDF_WIDTH))
/*@}*/

/*
 * MKL28Z7 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_GICLR - Global Interrupt Control Low Register
 * - PORT_GICHR - Global Interrupt Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 */

#define PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */
#define PORTD_IDX (3U) /*!< Instance number for PORTD. */
#define PORTE_IDX (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000005U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (BME_OR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
#define PORT_CLR_PCR(base, index, value) (BME_AND32(&PORT_PCR_REG(base, index), (uint32_t)(~(value))))
#define PORT_TOG_PCR(base, index, value) (BME_XOR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * This bit is read only for pins that do not support a configurable pull
 * resistor direction. Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pulldown resistor is enabled on the corresponding pin, if
 *     the corresponding PE field is set.
 * - 0b1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PS_SHIFT), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * This field is read-only for pins that do not support a configurable pull
 * resistor. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support a configurable pull resistor. Pull configuration is
 * valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 0b1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PE_SHIFT), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * This field is read-only for pins that do not support a configurable slew
 * rate. Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 0b1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_SRE_SHIFT), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PFE[4] (RW)
 *
 * This field is read-only for pins that do not support a configurable passive
 * input filter. Passive filter configuration is valid in all digital pin muxing
 * modes.
 *
 * Values:
 * - 0b0 - Passive input filter is disabled on the corresponding pin.
 * - 0b1 - Passive input filter is enabled on the corresponding pin, if the pin
 *     is configured as a digital input. Refer to the device data sheet for
 *     filter characteristics.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PFE field. */
#define PORT_RD_PCR_PFE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PFE_MASK) >> PORT_PCR_PFE_SHIFT)
#define PORT_BRD_PCR_PFE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))

/*! @brief Set the PFE field to a new value. */
#define PORT_WR_PCR_PFE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PFE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PFE(value)))
#define PORT_BWR_PCR_PFE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PFE_SHIFT), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ODE[5] (RW)
 *
 * This field is read-only for pins that do not support a configurable open
 * drain output. Open drain configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Open drain output is disabled on the corresponding pin.
 * - 0b1 - Open drain output is enabled on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ODE field. */
#define PORT_RD_PCR_ODE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ODE_MASK) >> PORT_PCR_ODE_SHIFT)
#define PORT_BRD_PCR_ODE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT, PORT_PCR_ODE_WIDTH))

/*! @brief Set the ODE field to a new value. */
#define PORT_WR_PCR_ODE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_ODE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_ODE(value)))
#define PORT_BWR_PCR_ODE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ODE_SHIFT), PORT_PCR_ODE_SHIFT, PORT_PCR_ODE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field DSE[6] (RW)
 *
 * This field is read-only for pins that do not support a configurable drive
 * strength. Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 0b1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_DSE field. */
#define PORT_RD_PCR_DSE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_DSE_MASK) >> PORT_PCR_DSE_SHIFT)
#define PORT_BRD_PCR_DSE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))

/*! @brief Set the DSE field to a new value. */
#define PORT_WR_PCR_DSE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_DSE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_DSE(value)))
#define PORT_BWR_PCR_DSE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_DSE_SHIFT), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[10:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 0b000 - Pin disabled (analog).
 * - 0b001 - Alternative 1 (GPIO).
 * - 0b010 - Alternative 2 (chip-specific).
 * - 0b011 - Alternative 3 (chip-specific).
 * - 0b100 - Alternative 4 (chip-specific).
 * - 0b101 - Alternative 5 (chip-specific).
 * - 0b110 - Alternative 6 (chip-specific).
 * - 0b111 - Alternative 7 (chip-specific).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_MUX_SHIFT), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0b0000 - Interrupt Status Flag (ISF) is disabled.
 * - 0b0001 - ISF flag and DMA request on rising edge.
 * - 0b0010 - ISF flag and DMA request on falling edge.
 * - 0b0011 - ISF flag and DMA request on either edge.
 * - 0b0100 - Reserved.
 * - 0b0101 - Flag sets on rising edge.
 * - 0b0110 - Flag sets on falling edge.
 * - 0b0111 - Flag sets on either edge.
 * - 0b1000 - ISF flag and Interrupt when logic 0.
 * - 0b1001 - ISF flag and Interrupt on rising-edge.
 * - 0b1010 - ISF flag and Interrupt on falling-edge.
 * - 0b1011 - ISF flag and Interrupt on either edge.
 * - 0b1100 - ISF flag and Interrupt when logic 1.
 * - 0b1101 - Enable active high trigger output, flag is disabled. [The trigger
 *     output goes to the trigger mux, which allows pins to trigger other
 *     peripherals (configurable polarity; 1 pin per port; if multiple pins are
 *     configured, then they are ORed together to create the trigger)]
 * - 0b1110 - Enable active low trigger output, flag is disabled.
 * - 0b1111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_IRQC_SHIFT), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Configured interrupt is not detected.
 * - 0b1 - Configured interrupt is detected. If the pin is configured to
 *     generate a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured
 *     for a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ISF_SHIFT), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (PORT_WR_GPCLR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (PORT_WR_GPCLR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (PORT_WR_GPCHR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (PORT_WR_GPCHR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GICLR - Global Interrupt Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GICLR - Global Interrupt Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GICLR register
 */
/*@{*/
#define PORT_RD_GICLR(base)      (PORT_GICLR_REG(base))
#define PORT_WR_GICLR(base, value) (PORT_GICLR_REG(base) = (value))
#define PORT_RMW_GICLR(base, mask, value) (PORT_WR_GICLR(base, (PORT_RD_GICLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GICLR bitfields
 */

/*!
 * @name Register PORT_GICLR, field GIWE[15:0] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [31:16] update with
 * the value in GIWD.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GIWE field to a new value. */
#define PORT_WR_GICLR_GIWE(base, value) (PORT_RMW_GICLR(base, PORT_GICLR_GIWE_MASK, PORT_GICLR_GIWE(value)))
#define PORT_BWR_GICLR_GIWE(base, value) (PORT_WR_GICLR_GIWE(base, value))
/*@}*/

/*!
 * @name Register PORT_GICLR, field GIWD[31:16] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [31:16] that
 * are selected by GIWE.
 */
/*@{*/
/*! @brief Set the GIWD field to a new value. */
#define PORT_WR_GICLR_GIWD(base, value) (PORT_RMW_GICLR(base, PORT_GICLR_GIWD_MASK, PORT_GICLR_GIWD(value)))
#define PORT_BWR_GICLR_GIWD(base, value) (PORT_WR_GICLR_GIWD(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GICHR - Global Interrupt Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GICHR - Global Interrupt Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GICHR register
 */
/*@{*/
#define PORT_RD_GICHR(base)      (PORT_GICHR_REG(base))
#define PORT_WR_GICHR(base, value) (PORT_GICHR_REG(base) = (value))
#define PORT_RMW_GICHR(base, mask, value) (PORT_WR_GICHR(base, (PORT_RD_GICHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GICHR bitfields
 */

/*!
 * @name Register PORT_GICHR, field GIWE[15:0] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [31:16] update with
 * the value in GIWD.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GIWE field to a new value. */
#define PORT_WR_GICHR_GIWE(base, value) (PORT_RMW_GICHR(base, PORT_GICHR_GIWE_MASK, PORT_GICHR_GIWE(value)))
#define PORT_BWR_GICHR_GIWE(base, value) (PORT_WR_GICHR_GIWE(base, value))
/*@}*/

/*!
 * @name Register PORT_GICHR, field GIWD[31:16] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [31:16] that
 * are selected by GIWE.
 */
/*@{*/
/*! @brief Set the GIWD field to a new value. */
#define PORT_WR_GICHR_GIWD(base, value) (PORT_RMW_GICHR(base, PORT_GICHR_GIWD_MASK, PORT_GICHR_GIWD(value)))
#define PORT_BWR_GICHR_GIWD(base, value) (PORT_WR_GICHR_GIWD(base, value))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * Interrupt Status Flag for each pin is also visible in the corresponding Pin
 * Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (BME_OR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
#define PORT_CLR_ISFR(base, value) (BME_AND32(&PORT_ISFR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_ISFR(base, value) (BME_XOR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * MKL28Z7 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_VERID - Version ID Register
 * - RCM_PARAM - Parameter Register
 * - RCM_SRS - System Reset Status Register
 * - RCM_RPC - Reset Pin Control register
 * - RCM_MR - Mode Register
 * - RCM_FM - Force Mode Register
 * - RCM_SSRS - Sticky System Reset Status Register
 * - RCM_SRIE - System Reset Interrupt Enable Register
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief RCM_VERID - Version ID Register (RO)
 *
 * Reset value: 0x03000003U
 */
/*!
 * @name Constants and macros for entire RCM_VERID register
 */
/*@{*/
#define RCM_RD_VERID(base)       (RCM_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_VERID bitfields
 */

/*!
 * @name Register RCM_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000011 - Standard feature set.
 */
/*@{*/
/*! @brief Read current value of the RCM_VERID_FEATURE field. */
#define RCM_RD_VERID_FEATURE(base) ((RCM_VERID_REG(base) & RCM_VERID_FEATURE_MASK) >> RCM_VERID_FEATURE_SHIFT)
#define RCM_BRD_VERID_FEATURE(base) (RCM_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register RCM_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the RCM_VERID_MINOR field. */
#define RCM_RD_VERID_MINOR(base) ((RCM_VERID_REG(base) & RCM_VERID_MINOR_MASK) >> RCM_VERID_MINOR_SHIFT)
#define RCM_BRD_VERID_MINOR(base) (BME_UBFX32(&RCM_VERID_REG(base), RCM_VERID_MINOR_SHIFT, RCM_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register RCM_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the RCM_VERID_MAJOR field. */
#define RCM_RD_VERID_MAJOR(base) ((RCM_VERID_REG(base) & RCM_VERID_MAJOR_MASK) >> RCM_VERID_MAJOR_SHIFT)
#define RCM_BRD_VERID_MAJOR(base) (BME_UBFX32(&RCM_VERID_REG(base), RCM_VERID_MAJOR_SHIFT, RCM_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief RCM_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RCM_PARAM register
 */
/*@{*/
#define RCM_RD_PARAM(base)       (RCM_PARAM_REG(base))
/*@}*/

/*******************************************************************************
 * RCM_SRS - System Reset Status Register
 ******************************************************************************/

/*!
 * @brief RCM_SRS - System Reset Status Register (RO)
 *
 * Reset value: 0x00000082U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS register
 */
/*@{*/
#define RCM_RD_SRS(base)         (RCM_SRS_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS bitfields
 */

/*!
 * @name Register RCM_SRS, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by a wakeup from VLLS mode.
 *
 * Values:
 * - 0b0 - Reset not caused by wakeup from VLLS mode.
 * - 0b1 - Reset caused by wakeup from VLLS mode.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_WAKEUP field. */
#define RCM_RD_SRS_WAKEUP(base) ((RCM_SRS_REG(base) & RCM_SRS_WAKEUP_MASK) >> RCM_SRS_WAKEUP_SHIFT)
#define RCM_BRD_SRS_WAKEUP(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_WAKEUP_SHIFT, RCM_SRS_WAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. If PMC_HVDSC1[HVDRE] is set and the supply rises above
 * the HVD trip voltage, an HVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip, HVD trip or POR
 * - 0b1 - Reset caused by LVD trip, HVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LVD field. */
#define RCM_RD_SRS_LVD(base) ((RCM_SRS_REG(base) & RCM_SRS_LVD_MASK) >> RCM_SRS_LVD_SHIFT)
#define RCM_BRD_SRS_LVD(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_LVD_SHIFT, RCM_SRS_LVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The SCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed SCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LOC field. */
#define RCM_RD_SRS_LOC(base) ((RCM_SRS_REG(base) & RCM_SRS_LOC_MASK) >> RCM_SRS_LOC_SHIFT)
#define RCM_BRD_SRS_LOC(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_LOC_SHIFT, RCM_SRS_LOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field LOL[3] (RO)
 *
 * Indicates a reset has been caused by a loss of lock/clock in the SCG PLL.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LOL field. */
#define RCM_RD_SRS_LOL(base) ((RCM_SRS_REG(base) & RCM_SRS_LOL_MASK) >> RCM_SRS_LOL_SHIFT)
#define RCM_BRD_SRS_LOL(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_LOL_SHIFT, RCM_SRS_LOL_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_WDOG field. */
#define RCM_RD_SRS_WDOG(base) ((RCM_SRS_REG(base) & RCM_SRS_WDOG_MASK) >> RCM_SRS_WDOG_SHIFT)
#define RCM_BRD_SRS_WDOG(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_WDOG_SHIFT, RCM_SRS_WDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET (RESET_b) pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_PIN field. */
#define RCM_RD_SRS_PIN(base) ((RCM_SRS_REG(base) & RCM_SRS_PIN_MASK) >> RCM_SRS_PIN_SHIFT)
#define RCM_BRD_SRS_PIN(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_PIN_SHIFT, RCM_SRS_PIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_POR field. */
#define RCM_RD_SRS_POR(base) ((RCM_SRS_REG(base) & RCM_SRS_POR_MASK) >> RCM_SRS_POR_SHIFT)
#define RCM_BRD_SRS_POR(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_POR_SHIFT, RCM_SRS_POR_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field LOCKUP[9] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_LOCKUP field. */
#define RCM_RD_SRS_LOCKUP(base) ((RCM_SRS_REG(base) & RCM_SRS_LOCKUP_MASK) >> RCM_SRS_LOCKUP_SHIFT)
#define RCM_BRD_SRS_LOCKUP(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_LOCKUP_SHIFT, RCM_SRS_LOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field SW[10] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core. no
 * SYSRESETREQ bit in CM4 TRM ?
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_SW field. */
#define RCM_RD_SRS_SW(base)  ((RCM_SRS_REG(base) & RCM_SRS_SW_MASK) >> RCM_SRS_SW_SHIFT)
#define RCM_BRD_SRS_SW(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_SW_SHIFT, RCM_SRS_SW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field SACKERR[13] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_SACKERR field. */
#define RCM_RD_SRS_SACKERR(base) ((RCM_SRS_REG(base) & RCM_SRS_SACKERR_MASK) >> RCM_SRS_SACKERR_SHIFT)
#define RCM_BRD_SRS_SACKERR(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_SACKERR_SHIFT, RCM_SRS_SACKERR_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS, field CORE1[16] (RO)
 *
 * Comes from WDOG1 watchdog timeout.
 *
 * Values:
 * - 0b0 - Reset not caused by Core 1 Reset Source.
 * - 0b1 - Reset caused by Core 1 Reset Source.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS_CORE1 field. */
#define RCM_RD_SRS_CORE1(base) ((RCM_SRS_REG(base) & RCM_SRS_CORE1_MASK) >> RCM_SRS_CORE1_SHIFT)
#define RCM_BRD_SRS_CORE1(base) (BME_UBFX32(&RCM_SRS_REG(base), RCM_SRS_CORE1_SHIFT, RCM_SRS_CORE1_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPC - Reset Pin Control register
 ******************************************************************************/

/*!
 * @brief RCM_RPC - Reset Pin Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is reset on Chip POR only, it is unaffected by other reset
 * types. The bus clock filter is reset when disabled or when entering stop mode. The
 * LPO filter is reset when disabled.
 */
/*!
 * @name Constants and macros for entire RCM_RPC register
 */
/*@{*/
#define RCM_RD_RPC(base)         (RCM_RPC_REG(base))
#define RCM_WR_RPC(base, value)  (RCM_RPC_REG(base) = (value))
#define RCM_RMW_RPC(base, mask, value) (RCM_WR_RPC(base, (RCM_RD_RPC(base) & ~(mask)) | (value)))
#define RCM_SET_RPC(base, value) (BME_OR32(&RCM_RPC_REG(base), (uint32_t)(value)))
#define RCM_CLR_RPC(base, value) (BME_AND32(&RCM_RPC_REG(base), (uint32_t)(~(value))))
#define RCM_TOG_RPC(base, value) (BME_XOR32(&RCM_RPC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPC bitfields
 */

/*!
 * @name Register RCM_RPC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 0b00 - All filtering disabled
 * - 0b01 - Bus clock filter enabled for normal operation
 * - 0b10 - LPO clock filter enabled for normal operation
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the RCM_RPC_RSTFLTSRW field. */
#define RCM_RD_RPC_RSTFLTSRW(base) ((RCM_RPC_REG(base) & RCM_RPC_RSTFLTSRW_MASK) >> RCM_RPC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPC_RSTFLTSRW(base) (BME_UBFX32(&RCM_RPC_REG(base), RCM_RPC_RSTFLTSRW_SHIFT, RCM_RPC_RSTFLTSRW_WIDTH))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPC_RSTFLTSRW(base, value) (RCM_RMW_RPC(base, RCM_RPC_RSTFLTSRW_MASK, RCM_RPC_RSTFLTSRW(value)))
#define RCM_BWR_RPC_RSTFLTSRW(base, value) (BME_BFI32(&RCM_RPC_REG(base), ((uint32_t)(value) << RCM_RPC_RSTFLTSRW_SHIFT), RCM_RPC_RSTFLTSRW_SHIFT, RCM_RPC_RSTFLTSRW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_RPC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in any stop mode. On exit from
 * VLLS mode, this bit should be reconfigured before clearing PMC_REGSC[ACKISO].
 *
 * Values:
 * - 0b0 - All filtering disabled
 * - 0b1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPC_RSTFLTSS field. */
#define RCM_RD_RPC_RSTFLTSS(base) ((RCM_RPC_REG(base) & RCM_RPC_RSTFLTSS_MASK) >> RCM_RPC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPC_RSTFLTSS(base) (BME_UBFX32(&RCM_RPC_REG(base), RCM_RPC_RSTFLTSS_SHIFT, RCM_RPC_RSTFLTSS_WIDTH))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPC_RSTFLTSS(base, value) (RCM_RMW_RPC(base, RCM_RPC_RSTFLTSS_MASK, RCM_RPC_RSTFLTSS(value)))
#define RCM_BWR_RPC_RSTFLTSS(base, value) (BME_BFI32(&RCM_RPC_REG(base), ((uint32_t)(value) << RCM_RPC_RSTFLTSS_SHIFT), RCM_RPC_RSTFLTSS_SHIFT, RCM_RPC_RSTFLTSS_WIDTH))
/*@}*/

/*!
 * @name Register RCM_RPC, field RSTFLTSEL[12:8] (RW)
 *
 * Selects the reset pin bus clock filter width. Transitions for less than
 * (RSTFLTSEL+1) bus clock cycles are always filtered, transitions equal to
 * (RSTFLTSEL+1) bus clock cycles may be filtered.
 */
/*@{*/
/*! @brief Read current value of the RCM_RPC_RSTFLTSEL field. */
#define RCM_RD_RPC_RSTFLTSEL(base) ((RCM_RPC_REG(base) & RCM_RPC_RSTFLTSEL_MASK) >> RCM_RPC_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPC_RSTFLTSEL(base) (BME_UBFX32(&RCM_RPC_REG(base), RCM_RPC_RSTFLTSEL_SHIFT, RCM_RPC_RSTFLTSEL_WIDTH))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPC_RSTFLTSEL(base, value) (RCM_RMW_RPC(base, RCM_RPC_RSTFLTSEL_MASK, RCM_RPC_RSTFLTSEL(value)))
#define RCM_BWR_RPC_RSTFLTSEL(base, value) (BME_BFI32(&RCM_RPC_REG(base), ((uint32_t)(value) << RCM_RPC_RSTFLTSEL_SHIFT), RCM_RPC_RSTFLTSEL_SHIFT, RCM_RPC_RSTFLTSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_MR - Mode Register
 ******************************************************************************/

/*!
 * @brief RCM_MR - Mode Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register includes status flags to indicate the state of the mode pins
 * during the last Chip Reset.
 */
/*!
 * @name Constants and macros for entire RCM_MR register
 */
/*@{*/
#define RCM_RD_MR(base)          (RCM_MR_REG(base))
#define RCM_WR_MR(base, value)   (RCM_MR_REG(base) = (value))
#define RCM_RMW_MR(base, mask, value) (RCM_WR_MR(base, (RCM_RD_MR(base) & ~(mask)) | (value)))
#define RCM_SET_MR(base, value)  (BME_OR32(&RCM_MR_REG(base), (uint32_t)(value)))
#define RCM_CLR_MR(base, value)  (BME_AND32(&RCM_MR_REG(base), (uint32_t)(~(value))))
#define RCM_TOG_MR(base, value)  (BME_XOR32(&RCM_MR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_MR bitfields
 */

/*!
 * @name Register RCM_MR, field BOOTROM[2:1] (W1C)
 *
 * Indicates the boot source, the boot source remains set until the next System
 * Reset or software can write logic one to clear the corresponding mode bit.
 * While either bit is set, the NMI input is disabled and the vector table is
 * relocated to the ROM base address at $1C00_0000. These bits should be cleared by
 * writing logic one before executing any code from either Flash or SRAM.
 *
 * Values:
 * - 0b00 - Boot from Flash
 * - 0b01 - Boot from ROM due to BOOTCFG0 pin assertion
 * - 0b10 - Boot form ROM due to FOPT[7:6] configuration
 * - 0b11 - Boot from ROM due to both BOOTCFG0 pin assertion and FOPT[7:6]
 *     configuration
 */
/*@{*/
/*! @brief Read current value of the RCM_MR_BOOTROM field. */
#define RCM_RD_MR_BOOTROM(base) ((RCM_MR_REG(base) & RCM_MR_BOOTROM_MASK) >> RCM_MR_BOOTROM_SHIFT)
#define RCM_BRD_MR_BOOTROM(base) (BME_UBFX32(&RCM_MR_REG(base), RCM_MR_BOOTROM_SHIFT, RCM_MR_BOOTROM_WIDTH))

/*! @brief Set the BOOTROM field to a new value. */
#define RCM_WR_MR_BOOTROM(base, value) (RCM_RMW_MR(base, RCM_MR_BOOTROM_MASK, RCM_MR_BOOTROM(value)))
#define RCM_BWR_MR_BOOTROM(base, value) (BME_BFI32(&RCM_MR_REG(base), ((uint32_t)(value) << RCM_MR_BOOTROM_SHIFT), RCM_MR_BOOTROM_SHIFT, RCM_MR_BOOTROM_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_FM - Force Mode Register
 ******************************************************************************/

/*!
 * @brief RCM_FM - Force Mode Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The reset values of the bits in the FORCEROM field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_FM register
 */
/*@{*/
#define RCM_RD_FM(base)          (RCM_FM_REG(base))
#define RCM_WR_FM(base, value)   (RCM_FM_REG(base) = (value))
#define RCM_RMW_FM(base, mask, value) (RCM_WR_FM(base, (RCM_RD_FM(base) & ~(mask)) | (value)))
#define RCM_SET_FM(base, value)  (BME_OR32(&RCM_FM_REG(base), (uint32_t)(value)))
#define RCM_CLR_FM(base, value)  (BME_AND32(&RCM_FM_REG(base), (uint32_t)(~(value))))
#define RCM_TOG_FM(base, value)  (BME_XOR32(&RCM_FM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_FM bitfields
 */

/*!
 * @name Register RCM_FM, field FORCEROM[2:1] (RW)
 *
 * When either bit is set, will force boot from ROM during all subsequent system
 * resets.
 *
 * Values:
 * - 0b00 - No effect
 * - 0b01 - Force boot from ROM with RCM_MR[1] set.
 * - 0b10 - Force boot from ROM with RCM_MR[2] set.
 * - 0b11 - Force boot from ROM with RCM_MR[2:1] set.
 */
/*@{*/
/*! @brief Read current value of the RCM_FM_FORCEROM field. */
#define RCM_RD_FM_FORCEROM(base) ((RCM_FM_REG(base) & RCM_FM_FORCEROM_MASK) >> RCM_FM_FORCEROM_SHIFT)
#define RCM_BRD_FM_FORCEROM(base) (BME_UBFX32(&RCM_FM_REG(base), RCM_FM_FORCEROM_SHIFT, RCM_FM_FORCEROM_WIDTH))

/*! @brief Set the FORCEROM field to a new value. */
#define RCM_WR_FM_FORCEROM(base, value) (RCM_RMW_FM(base, RCM_FM_FORCEROM_MASK, RCM_FM_FORCEROM(value)))
#define RCM_BWR_FM_FORCEROM(base, value) (BME_BFI32(&RCM_FM_REG(base), ((uint32_t)(value) << RCM_FM_FORCEROM_SHIFT), RCM_FM_FORCEROM_SHIFT, RCM_FM_FORCEROM_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SSRS - Sticky System Reset Status Register
 ******************************************************************************/

/*!
 * @brief RCM_SSRS - Sticky System Reset Status Register (RW)
 *
 * Reset value: 0x00000082U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR or LVD, or VLLS Wakeup that have not been cleared by software.
 * Software can clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS register
 */
/*@{*/
#define RCM_RD_SSRS(base)        (RCM_SSRS_REG(base))
#define RCM_WR_SSRS(base, value) (RCM_SSRS_REG(base) = (value))
#define RCM_RMW_SSRS(base, mask, value) (RCM_WR_SSRS(base, (RCM_RD_SSRS(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS(base, value) (BME_OR32(&RCM_SSRS_REG(base), (uint32_t)(value)))
#define RCM_CLR_SSRS(base, value) (BME_AND32(&RCM_SSRS_REG(base), (uint32_t)(~(value))))
#define RCM_TOG_SSRS(base, value) (BME_XOR32(&RCM_SSRS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS bitfields
 */

/*!
 * @name Register RCM_SSRS, field SWAKEUP[0] (W1C)
 *
 * Indicates a reset has been caused by a wakeup from VLLS mode.
 *
 * Values:
 * - 0b0 - Reset not caused by wakeup from VLLS mode.
 * - 0b1 - Reset caused by wakeup from VLLS mode.
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SWAKEUP field. */
#define RCM_RD_SSRS_SWAKEUP(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SWAKEUP_MASK) >> RCM_SSRS_SWAKEUP_SHIFT)
#define RCM_BRD_SSRS_SWAKEUP(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SWAKEUP_SHIFT, RCM_SSRS_SWAKEUP_WIDTH))

/*! @brief Set the SWAKEUP field to a new value. */
#define RCM_WR_SSRS_SWAKEUP(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SWAKEUP(value)))
#define RCM_BWR_SSRS_SWAKEUP(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SWAKEUP_SHIFT), RCM_SSRS_SWAKEUP_SHIFT, RCM_SSRS_SWAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SLVD[1] (W1C)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip or POR
 * - 0b1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLVD field. */
#define RCM_RD_SSRS_SLVD(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLVD_MASK) >> RCM_SSRS_SLVD_SHIFT)
#define RCM_BRD_SSRS_SLVD(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SLVD_SHIFT, RCM_SSRS_SLVD_WIDTH))

/*! @brief Set the SLVD field to a new value. */
#define RCM_WR_SSRS_SLVD(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLVD_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SLVD(value)))
#define RCM_BWR_SSRS_SLVD(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SLVD_SHIFT), RCM_SSRS_SLVD_SHIFT, RCM_SSRS_SLVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SLOC[2] (W1C)
 *
 * Indicates a reset has been caused by a loss of external clock. The SCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed SCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLOC field. */
#define RCM_RD_SSRS_SLOC(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLOC_MASK) >> RCM_SSRS_SLOC_SHIFT)
#define RCM_BRD_SSRS_SLOC(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SLOC_SHIFT, RCM_SSRS_SLOC_WIDTH))

/*! @brief Set the SLOC field to a new value. */
#define RCM_WR_SSRS_SLOC(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLOC_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SLOC(value)))
#define RCM_BWR_SSRS_SLOC(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SLOC_SHIFT), RCM_SSRS_SLOC_SHIFT, RCM_SSRS_SLOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SLOL[3] (W1C)
 *
 * Indicates a reset has been caused by a loss of lock in the SCG PLL. See the
 * SCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLOL field. */
#define RCM_RD_SSRS_SLOL(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLOL_MASK) >> RCM_SSRS_SLOL_SHIFT)
#define RCM_BRD_SSRS_SLOL(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SLOL_SHIFT, RCM_SSRS_SLOL_WIDTH))

/*! @brief Set the SLOL field to a new value. */
#define RCM_WR_SSRS_SLOL(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLOL_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SLOL(value)))
#define RCM_BWR_SSRS_SLOL(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SLOL_SHIFT), RCM_SSRS_SLOL_SHIFT, RCM_SSRS_SLOL_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SWDOG[5] (W1C)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SWDOG field. */
#define RCM_RD_SSRS_SWDOG(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SWDOG_MASK) >> RCM_SSRS_SWDOG_SHIFT)
#define RCM_BRD_SSRS_SWDOG(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SWDOG_SHIFT, RCM_SSRS_SWDOG_WIDTH))

/*! @brief Set the SWDOG field to a new value. */
#define RCM_WR_SSRS_SWDOG(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SWDOG_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SWDOG(value)))
#define RCM_BWR_SSRS_SWDOG(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SWDOG_SHIFT), RCM_SSRS_SWDOG_SHIFT, RCM_SSRS_SWDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SPIN[6] (W1C)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET (RESET_b) pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SPIN field. */
#define RCM_RD_SSRS_SPIN(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SPIN_MASK) >> RCM_SSRS_SPIN_SHIFT)
#define RCM_BRD_SSRS_SPIN(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SPIN_SHIFT, RCM_SSRS_SPIN_WIDTH))

/*! @brief Set the SPIN field to a new value. */
#define RCM_WR_SSRS_SPIN(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SPIN_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SPIN(value)))
#define RCM_BWR_SSRS_SPIN(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SPIN_SHIFT), RCM_SSRS_SPIN_SHIFT, RCM_SSRS_SPIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SPOR[7] (W1C)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SPOR field. */
#define RCM_RD_SSRS_SPOR(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SPOR_MASK) >> RCM_SSRS_SPOR_SHIFT)
#define RCM_BRD_SSRS_SPOR(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SPOR_SHIFT, RCM_SSRS_SPOR_WIDTH))

/*! @brief Set the SPOR field to a new value. */
#define RCM_WR_SSRS_SPOR(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SPOR_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SPOR(value)))
#define RCM_BWR_SSRS_SPOR(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SPOR_SHIFT), RCM_SSRS_SPOR_SHIFT, RCM_SSRS_SPOR_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SLOCKUP[9] (W1C)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SLOCKUP field. */
#define RCM_RD_SSRS_SLOCKUP(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SLOCKUP_MASK) >> RCM_SSRS_SLOCKUP_SHIFT)
#define RCM_BRD_SSRS_SLOCKUP(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SLOCKUP_SHIFT, RCM_SSRS_SLOCKUP_WIDTH))

/*! @brief Set the SLOCKUP field to a new value. */
#define RCM_WR_SSRS_SLOCKUP(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SLOCKUP(value)))
#define RCM_BWR_SSRS_SLOCKUP(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SLOCKUP_SHIFT), RCM_SSRS_SLOCKUP_SHIFT, RCM_SSRS_SLOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SSW[10] (W1C)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core. no
 * SYSRESETREQ bit in CM4 TRM ?
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SSW field. */
#define RCM_RD_SSRS_SSW(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SSW_MASK) >> RCM_SSRS_SSW_SHIFT)
#define RCM_BRD_SSRS_SSW(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SSW_SHIFT, RCM_SSRS_SSW_WIDTH))

/*! @brief Set the SSW field to a new value. */
#define RCM_WR_SSRS_SSW(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SSW_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SSW(value)))
#define RCM_BWR_SSRS_SSW(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SSW_SHIFT), RCM_SSRS_SSW_SHIFT, RCM_SSRS_SSW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SSACKERR[13] (W1C)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SSACKERR field. */
#define RCM_RD_SSRS_SSACKERR(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SSACKERR_MASK) >> RCM_SSRS_SSACKERR_SHIFT)
#define RCM_BRD_SSRS_SSACKERR(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SSACKERR_SHIFT, RCM_SSRS_SSACKERR_WIDTH))

/*! @brief Set the SSACKERR field to a new value. */
#define RCM_WR_SSRS_SSACKERR(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SSACKERR_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SCORE1_MASK), RCM_SSRS_SSACKERR(value)))
#define RCM_BWR_SSRS_SSACKERR(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SSACKERR_SHIFT), RCM_SSRS_SSACKERR_SHIFT, RCM_SSRS_SSACKERR_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS, field SCORE1[16] (W1C)
 *
 * Values:
 * - 0b0 - Reset not caused by Core 1 Reset Source.
 * - 0b1 - Reset caused by Core 1 Reset Source.
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS_SCORE1 field. */
#define RCM_RD_SSRS_SCORE1(base) ((RCM_SSRS_REG(base) & RCM_SSRS_SCORE1_MASK) >> RCM_SSRS_SCORE1_SHIFT)
#define RCM_BRD_SSRS_SCORE1(base) (BME_UBFX32(&RCM_SSRS_REG(base), RCM_SSRS_SCORE1_SHIFT, RCM_SSRS_SCORE1_WIDTH))

/*! @brief Set the SCORE1 field to a new value. */
#define RCM_WR_SSRS_SCORE1(base, value) (RCM_RMW_SSRS(base, (RCM_SSRS_SCORE1_MASK | RCM_SSRS_SWAKEUP_MASK | RCM_SSRS_SLVD_MASK | RCM_SSRS_SLOC_MASK | RCM_SSRS_SLOL_MASK | RCM_SSRS_SWDOG_MASK | RCM_SSRS_SPIN_MASK | RCM_SSRS_SPOR_MASK | RCM_SSRS_SLOCKUP_MASK | RCM_SSRS_SSW_MASK | RCM_SSRS_SSACKERR_MASK), RCM_SSRS_SCORE1(value)))
#define RCM_BWR_SSRS_SCORE1(base, value) (BME_BFI32(&RCM_SSRS_REG(base), ((uint32_t)(value) << RCM_SSRS_SCORE1_SHIFT), RCM_SSRS_SCORE1_SHIFT, RCM_SSRS_SCORE1_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SRIE - System Reset Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RCM_SRIE - System Reset Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This registers delays the assertion of a system reset for a period of time
 * (DELAY field) while an interrupt is generated. This allows software to perform a
 * graceful shutdown. A Chip POR source cannot be delayed by this feature, and
 * entering Stop mode will terminate the delay. The SRS will only update after the
 * system reset occurs.
 */
/*!
 * @name Constants and macros for entire RCM_SRIE register
 */
/*@{*/
#define RCM_RD_SRIE(base)        (RCM_SRIE_REG(base))
#define RCM_WR_SRIE(base, value) (RCM_SRIE_REG(base) = (value))
#define RCM_RMW_SRIE(base, mask, value) (RCM_WR_SRIE(base, (RCM_RD_SRIE(base) & ~(mask)) | (value)))
#define RCM_SET_SRIE(base, value) (BME_OR32(&RCM_SRIE_REG(base), (uint32_t)(value)))
#define RCM_CLR_SRIE(base, value) (BME_AND32(&RCM_SRIE_REG(base), (uint32_t)(~(value))))
#define RCM_TOG_SRIE(base, value) (BME_XOR32(&RCM_SRIE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SRIE bitfields
 */

/*!
 * @name Register RCM_SRIE, field DELAY[1:0] (RW)
 *
 * Configures the maximum reset delay time from when the interrupt is asserted
 * and the system reset occurs.
 *
 * Values:
 * - 0b00 - 8 LPO cycles
 * - 0b01 - 32 LPO cycles
 * - 0b10 - 128 LPO cycles
 * - 0b11 - 512 LPO cycles
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_DELAY field. */
#define RCM_RD_SRIE_DELAY(base) ((RCM_SRIE_REG(base) & RCM_SRIE_DELAY_MASK) >> RCM_SRIE_DELAY_SHIFT)
#define RCM_BRD_SRIE_DELAY(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_DELAY_SHIFT, RCM_SRIE_DELAY_WIDTH))

/*! @brief Set the DELAY field to a new value. */
#define RCM_WR_SRIE_DELAY(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_DELAY_MASK, RCM_SRIE_DELAY(value)))
#define RCM_BWR_SRIE_DELAY(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_DELAY_SHIFT), RCM_SRIE_DELAY_SHIFT, RCM_SRIE_DELAY_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field LOC[2] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_LOC field. */
#define RCM_RD_SRIE_LOC(base) ((RCM_SRIE_REG(base) & RCM_SRIE_LOC_MASK) >> RCM_SRIE_LOC_SHIFT)
#define RCM_BRD_SRIE_LOC(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_LOC_SHIFT, RCM_SRIE_LOC_WIDTH))

/*! @brief Set the LOC field to a new value. */
#define RCM_WR_SRIE_LOC(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_LOC_MASK, RCM_SRIE_LOC(value)))
#define RCM_BWR_SRIE_LOC(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_LOC_SHIFT), RCM_SRIE_LOC_SHIFT, RCM_SRIE_LOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field LOL[3] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_LOL field. */
#define RCM_RD_SRIE_LOL(base) ((RCM_SRIE_REG(base) & RCM_SRIE_LOL_MASK) >> RCM_SRIE_LOL_SHIFT)
#define RCM_BRD_SRIE_LOL(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_LOL_SHIFT, RCM_SRIE_LOL_WIDTH))

/*! @brief Set the LOL field to a new value. */
#define RCM_WR_SRIE_LOL(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_LOL_MASK, RCM_SRIE_LOL(value)))
#define RCM_BWR_SRIE_LOL(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_LOL_SHIFT), RCM_SRIE_LOL_SHIFT, RCM_SRIE_LOL_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field WDOG[5] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_WDOG field. */
#define RCM_RD_SRIE_WDOG(base) ((RCM_SRIE_REG(base) & RCM_SRIE_WDOG_MASK) >> RCM_SRIE_WDOG_SHIFT)
#define RCM_BRD_SRIE_WDOG(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_WDOG_SHIFT, RCM_SRIE_WDOG_WIDTH))

/*! @brief Set the WDOG field to a new value. */
#define RCM_WR_SRIE_WDOG(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_WDOG_MASK, RCM_SRIE_WDOG(value)))
#define RCM_BWR_SRIE_WDOG(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_WDOG_SHIFT), RCM_SRIE_WDOG_SHIFT, RCM_SRIE_WDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field PIN[6] (RW)
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_PIN field. */
#define RCM_RD_SRIE_PIN(base) ((RCM_SRIE_REG(base) & RCM_SRIE_PIN_MASK) >> RCM_SRIE_PIN_SHIFT)
#define RCM_BRD_SRIE_PIN(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_PIN_SHIFT, RCM_SRIE_PIN_WIDTH))

/*! @brief Set the PIN field to a new value. */
#define RCM_WR_SRIE_PIN(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_PIN_MASK, RCM_SRIE_PIN(value)))
#define RCM_BWR_SRIE_PIN(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_PIN_SHIFT), RCM_SRIE_PIN_SHIFT, RCM_SRIE_PIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field GIE[7] (RW)
 *
 * Values:
 * - 0b0 - All interrupt sources disabled.
 * - 0b1 - All interrupt sources enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_GIE field. */
#define RCM_RD_SRIE_GIE(base) ((RCM_SRIE_REG(base) & RCM_SRIE_GIE_MASK) >> RCM_SRIE_GIE_SHIFT)
#define RCM_BRD_SRIE_GIE(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_GIE_SHIFT, RCM_SRIE_GIE_WIDTH))

/*! @brief Set the GIE field to a new value. */
#define RCM_WR_SRIE_GIE(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_GIE_MASK, RCM_SRIE_GIE(value)))
#define RCM_BWR_SRIE_GIE(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_GIE_SHIFT), RCM_SRIE_GIE_SHIFT, RCM_SRIE_GIE_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field LOCKUP[9] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_LOCKUP field. */
#define RCM_RD_SRIE_LOCKUP(base) ((RCM_SRIE_REG(base) & RCM_SRIE_LOCKUP_MASK) >> RCM_SRIE_LOCKUP_SHIFT)
#define RCM_BRD_SRIE_LOCKUP(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_LOCKUP_SHIFT, RCM_SRIE_LOCKUP_WIDTH))

/*! @brief Set the LOCKUP field to a new value. */
#define RCM_WR_SRIE_LOCKUP(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_LOCKUP_MASK, RCM_SRIE_LOCKUP(value)))
#define RCM_BWR_SRIE_LOCKUP(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_LOCKUP_SHIFT), RCM_SRIE_LOCKUP_SHIFT, RCM_SRIE_LOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field SW[10] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_SW field. */
#define RCM_RD_SRIE_SW(base) ((RCM_SRIE_REG(base) & RCM_SRIE_SW_MASK) >> RCM_SRIE_SW_SHIFT)
#define RCM_BRD_SRIE_SW(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_SW_SHIFT, RCM_SRIE_SW_WIDTH))

/*! @brief Set the SW field to a new value. */
#define RCM_WR_SRIE_SW(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_SW_MASK, RCM_SRIE_SW(value)))
#define RCM_BWR_SRIE_SW(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_SW_SHIFT), RCM_SRIE_SW_SHIFT, RCM_SRIE_SW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field SACKERR[13] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_SACKERR field. */
#define RCM_RD_SRIE_SACKERR(base) ((RCM_SRIE_REG(base) & RCM_SRIE_SACKERR_MASK) >> RCM_SRIE_SACKERR_SHIFT)
#define RCM_BRD_SRIE_SACKERR(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_SACKERR_SHIFT, RCM_SRIE_SACKERR_WIDTH))

/*! @brief Set the SACKERR field to a new value. */
#define RCM_WR_SRIE_SACKERR(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_SACKERR_MASK, RCM_SRIE_SACKERR(value)))
#define RCM_BWR_SRIE_SACKERR(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_SACKERR_SHIFT), RCM_SRIE_SACKERR_SHIFT, RCM_SRIE_SACKERR_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRIE, field CORE1[16] (RW)
 *
 * Values:
 * - 0b0 - Interrupt disabled.
 * - 0b1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRIE_CORE1 field. */
#define RCM_RD_SRIE_CORE1(base) ((RCM_SRIE_REG(base) & RCM_SRIE_CORE1_MASK) >> RCM_SRIE_CORE1_SHIFT)
#define RCM_BRD_SRIE_CORE1(base) (BME_UBFX32(&RCM_SRIE_REG(base), RCM_SRIE_CORE1_SHIFT, RCM_SRIE_CORE1_WIDTH))

/*! @brief Set the CORE1 field to a new value. */
#define RCM_WR_SRIE_CORE1(base, value) (RCM_RMW_SRIE(base, RCM_SRIE_CORE1_MASK, RCM_SRIE_CORE1(value)))
#define RCM_BWR_SRIE_CORE1(base, value) (BME_BFI32(&RCM_SRIE_REG(base), ((uint32_t)(value) << RCM_SRIE_CORE1_SHIFT), RCM_SRIE_CORE1_SHIFT, RCM_SRIE_CORE1_WIDTH))
/*@}*/

/*
 * MKL28Z7 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - RTC_TSR - RTC Time Seconds Register
 * - RTC_TPR - RTC Time Prescaler Register
 * - RTC_TAR - RTC Time Alarm Register
 * - RTC_TCR - RTC Time Compensation Register
 * - RTC_CR - RTC Control Register
 * - RTC_SR - RTC Status Register
 * - RTC_LR - RTC Lock Register
 * - RTC_IER - RTC Interrupt Enable Register
 */

#define RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define RTC_IDX (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * RTC_TSR - RTC Time Seconds Register
 ******************************************************************************/

/*!
 * @brief RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TSR register
 */
/*@{*/
#define RTC_RD_TSR(base)         (RTC_TSR_REG(base))
#define RTC_WR_TSR(base, value)  (RTC_TSR_REG(base) = (value))
#define RTC_RMW_TSR(base, mask, value) (RTC_WR_TSR(base, (RTC_RD_TSR(base) & ~(mask)) | (value)))
#define RTC_SET_TSR(base, value) (BME_OR32(&RTC_TSR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TSR(base, value) (BME_AND32(&RTC_TSR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TSR(base, value) (BME_XOR32(&RTC_TSR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * RTC_TPR - RTC Time Prescaler Register
 ******************************************************************************/

/*!
 * @brief RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TPR register
 */
/*@{*/
#define RTC_RD_TPR(base)         (RTC_TPR_REG(base))
#define RTC_WR_TPR(base, value)  (RTC_TPR_REG(base) = (value))
#define RTC_RMW_TPR(base, mask, value) (RTC_WR_TPR(base, (RTC_RD_TPR(base) & ~(mask)) | (value)))
#define RTC_SET_TPR(base, value) (BME_OR32(&RTC_TPR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TPR(base, value) (BME_AND32(&RTC_TPR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TPR(base, value) (BME_XOR32(&RTC_TPR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_TPR_TPR field. */
#define RTC_RD_TPR_TPR(base) ((RTC_TPR_REG(base) & RTC_TPR_TPR_MASK) >> RTC_TPR_TPR_SHIFT)
#define RTC_BRD_TPR_TPR(base) (RTC_RD_TPR_TPR(base))

/*! @brief Set the TPR field to a new value. */
#define RTC_WR_TPR_TPR(base, value) (RTC_RMW_TPR(base, RTC_TPR_TPR_MASK, RTC_TPR_TPR(value)))
#define RTC_BWR_TPR_TPR(base, value) (RTC_WR_TPR_TPR(base, value))
/*@}*/

/*******************************************************************************
 * RTC_TAR - RTC Time Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TAR register
 */
/*@{*/
#define RTC_RD_TAR(base)         (RTC_TAR_REG(base))
#define RTC_WR_TAR(base, value)  (RTC_TAR_REG(base) = (value))
#define RTC_RMW_TAR(base, mask, value) (RTC_WR_TAR(base, (RTC_RD_TAR(base) & ~(mask)) | (value)))
#define RTC_SET_TAR(base, value) (BME_OR32(&RTC_TAR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TAR(base, value) (BME_AND32(&RTC_TAR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TAR(base, value) (BME_XOR32(&RTC_TAR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * RTC_TCR - RTC Time Compensation Register
 ******************************************************************************/

/*!
 * @brief RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TCR register
 */
/*@{*/
#define RTC_RD_TCR(base)         (RTC_TCR_REG(base))
#define RTC_WR_TCR(base, value)  (RTC_TCR_REG(base) = (value))
#define RTC_RMW_TCR(base, mask, value) (RTC_WR_TCR(base, (RTC_RD_TCR(base) & ~(mask)) | (value)))
#define RTC_SET_TCR(base, value) (BME_OR32(&RTC_TCR_REG(base), (uint32_t)(value)))
#define RTC_CLR_TCR(base, value) (BME_AND32(&RTC_TCR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_TCR(base, value) (BME_XOR32(&RTC_TCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 0b10000000 - Time Prescaler Register overflows every 32896 clock cycles.
 * - 0b11111111 - Time Prescaler Register overflows every 32769 clock cycles.
 * - 0b00000000 - Time Prescaler Register overflows every 32768 clock cycles.
 * - 0b00000001 - Time Prescaler Register overflows every 32767 clock cycles.
 * - 0b01111111 - Time Prescaler Register overflows every 32641 clock cycles.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCR field. */
#define RTC_RD_TCR_TCR(base) ((RTC_TCR_REG(base) & RTC_TCR_TCR_MASK) >> RTC_TCR_TCR_SHIFT)
#define RTC_BRD_TCR_TCR(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_TCR_SHIFT, RTC_TCR_TCR_WIDTH))

/*! @brief Set the TCR field to a new value. */
#define RTC_WR_TCR_TCR(base, value) (RTC_RMW_TCR(base, RTC_TCR_TCR_MASK, RTC_TCR_TCR(value)))
#define RTC_BWR_TCR_TCR(base, value) (BME_BFI32(&RTC_TCR_REG(base), ((uint32_t)(value) << RTC_TCR_TCR_SHIFT), RTC_TCR_TCR_SHIFT, RTC_TCR_TCR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds. For
 * example, write zero to configure for a compensation interval of one second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIR field. */
#define RTC_RD_TCR_CIR(base) ((RTC_TCR_REG(base) & RTC_TCR_CIR_MASK) >> RTC_TCR_CIR_SHIFT)
#define RTC_BRD_TCR_CIR(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_CIR_SHIFT, RTC_TCR_CIR_WIDTH))

/*! @brief Set the CIR field to a new value. */
#define RTC_WR_TCR_CIR(base, value) (RTC_RMW_TCR(base, RTC_TCR_CIR_MASK, RTC_TCR_CIR(value)))
#define RTC_BWR_TCR_CIR(base, value) (BME_BFI32(&RTC_TCR_REG(base), ((uint32_t)(value) << RTC_TCR_CIR_SHIFT), RTC_TCR_CIR_SHIFT, RTC_TCR_CIR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCV field. */
#define RTC_RD_TCR_TCV(base) ((RTC_TCR_REG(base) & RTC_TCR_TCV_MASK) >> RTC_TCR_TCV_SHIFT)
#define RTC_BRD_TCR_TCV(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_TCV_SHIFT, RTC_TCR_TCV_WIDTH))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIC field. */
#define RTC_RD_TCR_CIC(base) ((RTC_TCR_REG(base) & RTC_TCR_CIC_MASK) >> RTC_TCR_CIC_SHIFT)
#define RTC_BRD_TCR_CIC(base) (BME_UBFX32(&RTC_TCR_REG(base), RTC_TCR_CIC_SHIFT, RTC_TCR_CIC_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_CR - RTC Control Register
 ******************************************************************************/

/*!
 * @brief RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_CR register
 */
/*@{*/
#define RTC_RD_CR(base)          (RTC_CR_REG(base))
#define RTC_WR_CR(base, value)   (RTC_CR_REG(base) = (value))
#define RTC_RMW_CR(base, mask, value) (RTC_WR_CR(base, (RTC_RD_CR(base) & ~(mask)) | (value)))
#define RTC_SET_CR(base, value)  (BME_OR32(&RTC_CR_REG(base), (uint32_t)(value)))
#define RTC_CLR_CR(base, value)  (BME_AND32(&RTC_CR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_CR(base, value)  (BME_XOR32(&RTC_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Resets all RTC registers except for the SWR bit . The SWR bit is
 *     cleared by POR and by software explicitly clearing it.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SWR field. */
#define RTC_RD_CR_SWR(base)  ((RTC_CR_REG(base) & RTC_CR_SWR_MASK) >> RTC_CR_SWR_SHIFT)
#define RTC_BRD_CR_SWR(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT, RTC_CR_SWR_WIDTH))

/*! @brief Set the SWR field to a new value. */
#define RTC_WR_CR_SWR(base, value) (RTC_RMW_CR(base, RTC_CR_SWR_MASK, RTC_CR_SWR(value)))
#define RTC_BWR_CR_SWR(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SWR_SHIFT), RTC_CR_SWR_SHIFT, RTC_CR_SWR_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0b0 - Wakeup pin is disabled.
 * - 0b1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPE field. */
#define RTC_RD_CR_WPE(base)  ((RTC_CR_REG(base) & RTC_CR_WPE_MASK) >> RTC_CR_WPE_SHIFT)
#define RTC_BRD_CR_WPE(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT, RTC_CR_WPE_WIDTH))

/*! @brief Set the WPE field to a new value. */
#define RTC_WR_CR_WPE(base, value) (RTC_RMW_CR(base, RTC_CR_WPE_MASK, RTC_CR_WPE(value)))
#define RTC_BWR_CR_WPE(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_WPE_SHIFT), RTC_CR_WPE_SHIFT, RTC_CR_WPE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0b0 - Non-supervisor mode write accesses are not supported and generate a
 *     bus error.
 * - 0b1 - Non-supervisor mode write accesses are supported.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SUP field. */
#define RTC_RD_CR_SUP(base)  ((RTC_CR_REG(base) & RTC_CR_SUP_MASK) >> RTC_CR_SUP_SHIFT)
#define RTC_BRD_CR_SUP(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT, RTC_CR_SUP_WIDTH))

/*! @brief Set the SUP field to a new value. */
#define RTC_WR_CR_SUP(base, value) (RTC_RMW_CR(base, RTC_CR_SUP_MASK, RTC_CR_SUP(value)))
#define RTC_BWR_CR_SUP(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SUP_SHIFT), RTC_CR_SUP_SHIFT, RTC_CR_SUP_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows SR[TCE] to be written even when the Status Register is locked. When
 * set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or if
 * the SR[TCE] is clear.
 *
 * Values:
 * - 0b0 - Registers cannot be written when locked.
 * - 0b1 - Registers can be written when locked under limited conditions.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_UM field. */
#define RTC_RD_CR_UM(base)   ((RTC_CR_REG(base) & RTC_CR_UM_MASK) >> RTC_CR_UM_SHIFT)
#define RTC_BRD_CR_UM(base)  (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT, RTC_CR_UM_WIDTH))

/*! @brief Set the UM field to a new value. */
#define RTC_WR_CR_UM(base, value) (RTC_RMW_CR(base, RTC_CR_UM_MASK, RTC_CR_UM(value)))
#define RTC_BWR_CR_UM(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_UM_SHIFT), RTC_CR_UM_SHIFT, RTC_CR_UM_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field WPS[4] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0b0 - Wakeup pin asserts (active low, open drain) if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 * - 0b1 - Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup
 *     pin is turned on and the 32kHz clock is output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPS field. */
#define RTC_RD_CR_WPS(base)  ((RTC_CR_REG(base) & RTC_CR_WPS_MASK) >> RTC_CR_WPS_SHIFT)
#define RTC_BRD_CR_WPS(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_WPS_SHIFT, RTC_CR_WPS_WIDTH))

/*! @brief Set the WPS field to a new value. */
#define RTC_WR_CR_WPS(base, value) (RTC_RMW_CR(base, RTC_CR_WPS_MASK, RTC_CR_WPS(value)))
#define RTC_BWR_CR_WPS(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_WPS_SHIFT), RTC_CR_WPS_SHIFT, RTC_CR_WPS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field CPS[5] (RW)
 *
 * Values:
 * - 0b0 - The prescaler output clock (as configured by TSIC) is output on
 *     RTC_CLKOUT.
 * - 0b1 - The RTC 32kHz crystal clock is output on RTC_CLKOUT.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CPS field. */
#define RTC_RD_CR_CPS(base)  ((RTC_CR_REG(base) & RTC_CR_CPS_MASK) >> RTC_CR_CPS_SHIFT)
#define RTC_BRD_CR_CPS(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_CPS_SHIFT, RTC_CR_CPS_WIDTH))

/*! @brief Set the CPS field to a new value. */
#define RTC_WR_CR_CPS(base, value) (RTC_RMW_CR(base, RTC_CR_CPS_MASK, RTC_CR_CPS(value)))
#define RTC_BWR_CR_CPS(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_CPS_SHIFT), RTC_CR_CPS_SHIFT, RTC_CR_CPS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field LPOS[7] (RW)
 *
 * When set, the RTC prescaler increments using the LPO 1kHz clock and not the
 * RTC 32kHz crystal clock. The LPO increments the prescaler from bit TPR[5]
 * (TPR[4:0] are ignored), supporting close to 1 second increment of the seconds
 * register. Although compensation is supported when clocked from the LPO, TCR[4:0] of
 * the compensation register are also ignored and only TCR[7:5] set the
 * compensation value (can overflow after 1020 to 1027 cycles).
 *
 * Values:
 * - 0b0 - RTC prescaler increments using 32kHz crystal.
 * - 0b1 - RTC prescaler increments using 1kHz LPO, bits [4:0] of the prescaler
 *     are bypassed.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_LPOS field. */
#define RTC_RD_CR_LPOS(base) ((RTC_CR_REG(base) & RTC_CR_LPOS_MASK) >> RTC_CR_LPOS_SHIFT)
#define RTC_BRD_CR_LPOS(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_LPOS_SHIFT, RTC_CR_LPOS_WIDTH))

/*! @brief Set the LPOS field to a new value. */
#define RTC_WR_CR_LPOS(base, value) (RTC_RMW_CR(base, RTC_CR_LPOS_MASK, RTC_CR_LPOS(value)))
#define RTC_BWR_CR_LPOS(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_LPOS_SHIFT), RTC_CR_LPOS_SHIFT, RTC_CR_LPOS_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0b0 - 32.768 kHz oscillator is disabled.
 * - 0b1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_OSCE field. */
#define RTC_RD_CR_OSCE(base) ((RTC_CR_REG(base) & RTC_CR_OSCE_MASK) >> RTC_CR_OSCE_SHIFT)
#define RTC_BRD_CR_OSCE(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT, RTC_CR_OSCE_WIDTH))

/*! @brief Set the OSCE field to a new value. */
#define RTC_WR_CR_OSCE(base, value) (RTC_RMW_CR(base, RTC_CR_OSCE_MASK, RTC_CR_OSCE(value)))
#define RTC_BWR_CR_OSCE(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_OSCE_SHIFT), RTC_CR_OSCE_SHIFT, RTC_CR_OSCE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0b0 - The 32 kHz clock is output to other peripherals.
 * - 0b1 - The 32 kHz clock is not output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CLKO field. */
#define RTC_RD_CR_CLKO(base) ((RTC_CR_REG(base) & RTC_CR_CLKO_MASK) >> RTC_CR_CLKO_SHIFT)
#define RTC_BRD_CR_CLKO(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT, RTC_CR_CLKO_WIDTH))

/*! @brief Set the CLKO field to a new value. */
#define RTC_WR_CR_CLKO(base, value) (RTC_RMW_CR(base, RTC_CR_CLKO_MASK, RTC_CR_CLKO(value)))
#define RTC_BWR_CR_CLKO(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_CLKO_SHIFT), RTC_CR_CLKO_SHIFT, RTC_CR_CLKO_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC16P field. */
#define RTC_RD_CR_SC16P(base) ((RTC_CR_REG(base) & RTC_CR_SC16P_MASK) >> RTC_CR_SC16P_SHIFT)
#define RTC_BRD_CR_SC16P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT, RTC_CR_SC16P_WIDTH))

/*! @brief Set the SC16P field to a new value. */
#define RTC_WR_CR_SC16P(base, value) (RTC_RMW_CR(base, RTC_CR_SC16P_MASK, RTC_CR_SC16P(value)))
#define RTC_BWR_CR_SC16P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC16P_SHIFT), RTC_CR_SC16P_SHIFT, RTC_CR_SC16P_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC8P field. */
#define RTC_RD_CR_SC8P(base) ((RTC_CR_REG(base) & RTC_CR_SC8P_MASK) >> RTC_CR_SC8P_SHIFT)
#define RTC_BRD_CR_SC8P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT, RTC_CR_SC8P_WIDTH))

/*! @brief Set the SC8P field to a new value. */
#define RTC_WR_CR_SC8P(base, value) (RTC_RMW_CR(base, RTC_CR_SC8P_MASK, RTC_CR_SC8P(value)))
#define RTC_BWR_CR_SC8P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC8P_SHIFT), RTC_CR_SC8P_SHIFT, RTC_CR_SC8P_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC4P field. */
#define RTC_RD_CR_SC4P(base) ((RTC_CR_REG(base) & RTC_CR_SC4P_MASK) >> RTC_CR_SC4P_SHIFT)
#define RTC_BRD_CR_SC4P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT, RTC_CR_SC4P_WIDTH))

/*! @brief Set the SC4P field to a new value. */
#define RTC_WR_CR_SC4P(base, value) (RTC_RMW_CR(base, RTC_CR_SC4P_MASK, RTC_CR_SC4P(value)))
#define RTC_BWR_CR_SC4P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC4P_SHIFT), RTC_CR_SC4P_SHIFT, RTC_CR_SC4P_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0b0 - Disable the load.
 * - 0b1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC2P field. */
#define RTC_RD_CR_SC2P(base) ((RTC_CR_REG(base) & RTC_CR_SC2P_MASK) >> RTC_CR_SC2P_SHIFT)
#define RTC_BRD_CR_SC2P(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT, RTC_CR_SC2P_WIDTH))

/*! @brief Set the SC2P field to a new value. */
#define RTC_WR_CR_SC2P(base, value) (RTC_RMW_CR(base, RTC_CR_SC2P_MASK, RTC_CR_SC2P(value)))
#define RTC_BWR_CR_SC2P(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_SC2P_SHIFT), RTC_CR_SC2P_SHIFT, RTC_CR_SC2P_WIDTH))
/*@}*/

/*!
 * @name Register RTC_CR, field CPE[25:24] (RW)
 *
 * Values:
 * - 0b00 - RTC_CLKOUT is disabled.
 * - 0b01 - RTC_CLKOUT is enabled on pin PTE0.
 * - 0b10 - RTC_CLKOUT is enabled on pin PTE26.
 * - 0b11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CPE field. */
#define RTC_RD_CR_CPE(base)  ((RTC_CR_REG(base) & RTC_CR_CPE_MASK) >> RTC_CR_CPE_SHIFT)
#define RTC_BRD_CR_CPE(base) (BME_UBFX32(&RTC_CR_REG(base), RTC_CR_CPE_SHIFT, RTC_CR_CPE_WIDTH))

/*! @brief Set the CPE field to a new value. */
#define RTC_WR_CR_CPE(base, value) (RTC_RMW_CR(base, RTC_CR_CPE_MASK, RTC_CR_CPE(value)))
#define RTC_BWR_CR_CPE(base, value) (BME_BFI32(&RTC_CR_REG(base), ((uint32_t)(value) << RTC_CR_CPE_SHIFT), RTC_CR_CPE_SHIFT, RTC_CR_CPE_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_SR - RTC Status Register
 ******************************************************************************/

/*!
 * @brief RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire RTC_SR register
 */
/*@{*/
#define RTC_RD_SR(base)          (RTC_SR_REG(base))
#define RTC_WR_SR(base, value)   (RTC_SR_REG(base) = (value))
#define RTC_RMW_SR(base, mask, value) (RTC_WR_SR(base, (RTC_RD_SR(base) & ~(mask)) | (value)))
#define RTC_SET_SR(base, value)  (BME_OR32(&RTC_SR_REG(base), (uint32_t)(value)))
#define RTC_CLR_SR(base, value)  (BME_AND32(&RTC_SR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_SR(base, value)  (BME_XOR32(&RTC_SR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on POR or software reset. The TSR and TPR do not
 * increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0b0 - Time is valid.
 * - 0b1 - Time is invalid and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TIF field. */
#define RTC_RD_SR_TIF(base)  ((RTC_SR_REG(base) & RTC_SR_TIF_MASK) >> RTC_SR_TIF_SHIFT)
#define RTC_BRD_SR_TIF(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TIF_SHIFT, RTC_SR_TIF_WIDTH))
/*@}*/

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0b0 - Time overflow has not occurred.
 * - 0b1 - Time overflow has occurred and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TOF field. */
#define RTC_RD_SR_TOF(base)  ((RTC_SR_REG(base) & RTC_SR_TOF_MASK) >> RTC_SR_TOF_SHIFT)
#define RTC_BRD_SR_TOF(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TOF_SHIFT, RTC_SR_TOF_WIDTH))
/*@}*/

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0b0 - Time alarm has not occurred.
 * - 0b1 - Time alarm has occurred.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TAF field. */
#define RTC_RD_SR_TAF(base)  ((RTC_SR_REG(base) & RTC_SR_TAF_MASK) >> RTC_SR_TAF_SHIFT)
#define RTC_BRD_SR_TAF(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TAF_SHIFT, RTC_SR_TAF_WIDTH))
/*@}*/

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0b0 - Time counter is disabled.
 * - 0b1 - Time counter is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TCE field. */
#define RTC_RD_SR_TCE(base)  ((RTC_SR_REG(base) & RTC_SR_TCE_MASK) >> RTC_SR_TCE_SHIFT)
#define RTC_BRD_SR_TCE(base) (BME_UBFX32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT, RTC_SR_TCE_WIDTH))

/*! @brief Set the TCE field to a new value. */
#define RTC_WR_SR_TCE(base, value) (RTC_RMW_SR(base, RTC_SR_TCE_MASK, RTC_SR_TCE(value)))
#define RTC_BWR_SR_TCE(base, value) (BME_BFI32(&RTC_SR_REG(base), ((uint32_t)(value) << RTC_SR_TCE_SHIFT), RTC_SR_TCE_SHIFT, RTC_SR_TCE_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_LR - RTC Lock Register
 ******************************************************************************/

/*!
 * @brief RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_LR register
 */
/*@{*/
#define RTC_RD_LR(base)          (RTC_LR_REG(base))
#define RTC_WR_LR(base, value)   (RTC_LR_REG(base) = (value))
#define RTC_RMW_LR(base, mask, value) (RTC_WR_LR(base, (RTC_RD_LR(base) & ~(mask)) | (value)))
#define RTC_SET_LR(base, value)  (BME_OR32(&RTC_LR_REG(base), (uint32_t)(value)))
#define RTC_CLR_LR(base, value)  (BME_AND32(&RTC_LR_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_LR(base, value)  (BME_XOR32(&RTC_LR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Time Compensation Register is locked and writes are ignored.
 * - 0b1 - Time Compensation Register is not locked and writes complete as
 *     normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_TCL field. */
#define RTC_RD_LR_TCL(base)  ((RTC_LR_REG(base) & RTC_LR_TCL_MASK) >> RTC_LR_TCL_SHIFT)
#define RTC_BRD_LR_TCL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT, RTC_LR_TCL_WIDTH))

/*! @brief Set the TCL field to a new value. */
#define RTC_WR_LR_TCL(base, value) (RTC_RMW_LR(base, RTC_LR_TCL_MASK, RTC_LR_TCL(value)))
#define RTC_BWR_LR_TCL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_TCL_SHIFT), RTC_LR_TCL_SHIFT, RTC_LR_TCL_WIDTH))
/*@}*/

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * After being cleared, this bit can only be set by POR.
 *
 * Values:
 * - 0b0 - Control Register is locked and writes are ignored.
 * - 0b1 - Control Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_CRL field. */
#define RTC_RD_LR_CRL(base)  ((RTC_LR_REG(base) & RTC_LR_CRL_MASK) >> RTC_LR_CRL_SHIFT)
#define RTC_BRD_LR_CRL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT, RTC_LR_CRL_WIDTH))

/*! @brief Set the CRL field to a new value. */
#define RTC_WR_LR_CRL(base, value) (RTC_RMW_LR(base, RTC_LR_CRL_MASK, RTC_LR_CRL(value)))
#define RTC_BWR_LR_CRL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_CRL_SHIFT), RTC_LR_CRL_SHIFT, RTC_LR_CRL_WIDTH))
/*@}*/

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Status Register is locked and writes are ignored.
 * - 0b1 - Status Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_SRL field. */
#define RTC_RD_LR_SRL(base)  ((RTC_LR_REG(base) & RTC_LR_SRL_MASK) >> RTC_LR_SRL_SHIFT)
#define RTC_BRD_LR_SRL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT, RTC_LR_SRL_WIDTH))

/*! @brief Set the SRL field to a new value. */
#define RTC_WR_LR_SRL(base, value) (RTC_RMW_LR(base, RTC_LR_SRL_MASK, RTC_LR_SRL(value)))
#define RTC_BWR_LR_SRL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_SRL_SHIFT), RTC_LR_SRL_SHIFT, RTC_LR_SRL_WIDTH))
/*@}*/

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * After being cleared, this bit can be set only by POR or software reset.
 *
 * Values:
 * - 0b0 - Lock Register is locked and writes are ignored.
 * - 0b1 - Lock Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_LRL field. */
#define RTC_RD_LR_LRL(base)  ((RTC_LR_REG(base) & RTC_LR_LRL_MASK) >> RTC_LR_LRL_SHIFT)
#define RTC_BRD_LR_LRL(base) (BME_UBFX32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT, RTC_LR_LRL_WIDTH))

/*! @brief Set the LRL field to a new value. */
#define RTC_WR_LR_LRL(base, value) (RTC_RMW_LR(base, RTC_LR_LRL_MASK, RTC_LR_LRL(value)))
#define RTC_BWR_LR_LRL(base, value) (BME_BFI32(&RTC_LR_REG(base), ((uint32_t)(value) << RTC_LR_LRL_SHIFT), RTC_LR_LRL_SHIFT, RTC_LR_LRL_WIDTH))
/*@}*/

/*******************************************************************************
 * RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define RTC_RD_IER(base)         (RTC_IER_REG(base))
#define RTC_WR_IER(base, value)  (RTC_IER_REG(base) = (value))
#define RTC_RMW_IER(base, mask, value) (RTC_WR_IER(base, (RTC_RD_IER(base) & ~(mask)) | (value)))
#define RTC_SET_IER(base, value) (BME_OR32(&RTC_IER_REG(base), (uint32_t)(value)))
#define RTC_CLR_IER(base, value) (BME_AND32(&RTC_IER_REG(base), (uint32_t)(~(value))))
#define RTC_TOG_IER(base, value) (BME_XOR32(&RTC_IER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0b0 - Time invalid flag does not generate an interrupt.
 * - 0b1 - Time invalid flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TIIE field. */
#define RTC_RD_IER_TIIE(base) ((RTC_IER_REG(base) & RTC_IER_TIIE_MASK) >> RTC_IER_TIIE_SHIFT)
#define RTC_BRD_IER_TIIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT, RTC_IER_TIIE_WIDTH))

/*! @brief Set the TIIE field to a new value. */
#define RTC_WR_IER_TIIE(base, value) (RTC_RMW_IER(base, RTC_IER_TIIE_MASK, RTC_IER_TIIE(value)))
#define RTC_BWR_IER_TIIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TIIE_SHIFT), RTC_IER_TIIE_SHIFT, RTC_IER_TIIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0b0 - Time overflow flag does not generate an interrupt.
 * - 0b1 - Time overflow flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TOIE field. */
#define RTC_RD_IER_TOIE(base) ((RTC_IER_REG(base) & RTC_IER_TOIE_MASK) >> RTC_IER_TOIE_SHIFT)
#define RTC_BRD_IER_TOIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT, RTC_IER_TOIE_WIDTH))

/*! @brief Set the TOIE field to a new value. */
#define RTC_WR_IER_TOIE(base, value) (RTC_RMW_IER(base, RTC_IER_TOIE_MASK, RTC_IER_TOIE(value)))
#define RTC_BWR_IER_TOIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TOIE_SHIFT), RTC_IER_TOIE_SHIFT, RTC_IER_TOIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0b0 - Time alarm flag does not generate an interrupt.
 * - 0b1 - Time alarm flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TAIE field. */
#define RTC_RD_IER_TAIE(base) ((RTC_IER_REG(base) & RTC_IER_TAIE_MASK) >> RTC_IER_TAIE_SHIFT)
#define RTC_BRD_IER_TAIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT, RTC_IER_TAIE_WIDTH))

/*! @brief Set the TAIE field to a new value. */
#define RTC_WR_IER_TAIE(base, value) (RTC_RMW_IER(base, RTC_IER_TAIE_MASK, RTC_IER_TAIE(value)))
#define RTC_BWR_IER_TAIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TAIE_SHIFT), RTC_IER_TAIE_SHIFT, RTC_IER_TAIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0b0 - Seconds interrupt is disabled.
 * - 0b1 - Seconds interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TSIE field. */
#define RTC_RD_IER_TSIE(base) ((RTC_IER_REG(base) & RTC_IER_TSIE_MASK) >> RTC_IER_TSIE_SHIFT)
#define RTC_BRD_IER_TSIE(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT, RTC_IER_TSIE_WIDTH))

/*! @brief Set the TSIE field to a new value. */
#define RTC_WR_IER_TSIE(base, value) (RTC_RMW_IER(base, RTC_IER_TSIE_MASK, RTC_IER_TSIE(value)))
#define RTC_BWR_IER_TSIE(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TSIE_SHIFT), RTC_IER_TSIE_SHIFT, RTC_IER_TSIE_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field WPON[7] (RW)
 *
 * The wakeup pin is optional and not available on all devices. Whenever the
 * wakeup pin is enabled and this bit is set, the wakeup pin will assert.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - If the wakeup pin is enabled, then the wakeup pin will assert.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_WPON field. */
#define RTC_RD_IER_WPON(base) ((RTC_IER_REG(base) & RTC_IER_WPON_MASK) >> RTC_IER_WPON_SHIFT)
#define RTC_BRD_IER_WPON(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_WPON_SHIFT, RTC_IER_WPON_WIDTH))

/*! @brief Set the WPON field to a new value. */
#define RTC_WR_IER_WPON(base, value) (RTC_RMW_IER(base, RTC_IER_WPON_MASK, RTC_IER_WPON(value)))
#define RTC_BWR_IER_WPON(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_WPON_SHIFT), RTC_IER_WPON_SHIFT, RTC_IER_WPON_WIDTH))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIC[18:16] (RW)
 *
 * Configures the frequency of the RTC Seconds interrupt and the RTC_CLKOUT
 * prescaler output. This field should only be altered when TSIE is clear.
 *
 * Values:
 * - 0b000 - 1 Hz.
 * - 0b001 - 2 Hz.
 * - 0b010 - 4 Hz.
 * - 0b011 - 8 Hz.
 * - 0b100 - 16 Hz.
 * - 0b101 - 32 Hz.
 * - 0b110 - 64 Hz.
 * - 0b111 - 128 Hz.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TSIC field. */
#define RTC_RD_IER_TSIC(base) ((RTC_IER_REG(base) & RTC_IER_TSIC_MASK) >> RTC_IER_TSIC_SHIFT)
#define RTC_BRD_IER_TSIC(base) (BME_UBFX32(&RTC_IER_REG(base), RTC_IER_TSIC_SHIFT, RTC_IER_TSIC_WIDTH))

/*! @brief Set the TSIC field to a new value. */
#define RTC_WR_IER_TSIC(base, value) (RTC_RMW_IER(base, RTC_IER_TSIC_MASK, RTC_IER_TSIC(value)))
#define RTC_BWR_IER_TSIC(base, value) (BME_BFI32(&RTC_IER_REG(base), ((uint32_t)(value) << RTC_IER_TSIC_SHIFT), RTC_IER_TSIC_SHIFT, RTC_IER_TSIC_WIDTH))
/*@}*/

/*
 * MKL28Z7 SCG
 *
 * System Clock Generator
 *
 * Registers defined in this header file:
 * - SCG_VERID - Version ID Register
 * - SCG_PARAM - Parameter Register
 * - SCG_CSR - Clock Status Register
 * - SCG_RCCR - Run Clock Control Register
 * - SCG_VCCR - VLPR Clock Control Register
 * - SCG_HCCR - HSRUN Clock Control Register
 * - SCG_CLKOUTCNFG - SCG CLKOUT Configuration Register
 * - SCG_SOSCCSR - System OSC Control Status Register
 * - SCG_SOSCDIV - System OSC Divide Register
 * - SCG_SOSCCFG - System Oscillator Configuration Register
 * - SCG_SIRCCSR - Slow IRC Control Status Register
 * - SCG_SIRCDIV - Slow IRC Divide Register
 * - SCG_SIRCCFG - Slow IRC Configuration Register
 * - SCG_FIRCCSR - Fast IRC Control Status Register
 * - SCG_FIRCDIV - Fast IRC Divide Register
 * - SCG_FIRCCFG - Fast IRC Configuration Register
 * - SCG_FIRCTCFG - Fast IRC Trim Configuration Register
 * - SCG_FIRCSTAT - Fast IRC Status Register
 * - SCG_SPLLCSR - System PLL Control Status Register
 * - SCG_SPLLDIV - System PLL Divide Register
 * - SCG_SPLLCFG - System PLL Configuration Register
 */

#define SCG_INSTANCE_COUNT (1U) /*!< Number of instances of the SCG module. */
#define SCG_IDX (0U) /*!< Instance number for SCG. */

/*******************************************************************************
 * SCG_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief SCG_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire SCG_VERID register
 */
/*@{*/
#define SCG_RD_VERID(base)       (SCG_VERID_REG(base))
/*@}*/

/*******************************************************************************
 * SCG_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief SCG_PARAM - Parameter Register (RO)
 *
 * Reset value: 0xF80000FEU
 */
/*!
 * @name Constants and macros for entire SCG_PARAM register
 */
/*@{*/
#define SCG_RD_PARAM(base)       (SCG_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual SCG_PARAM bitfields
 */

/*!
 * @name Register SCG_PARAM, field CLKPRES[7:0] (RO)
 *
 * Indicates which clock sources are present in this instance of SCG. Any bits
 * not defined in this bit field are Reserved and always has the value 0 when read.
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_CLKPRES field. */
#define SCG_RD_PARAM_CLKPRES(base) ((SCG_PARAM_REG(base) & SCG_PARAM_CLKPRES_MASK) >> SCG_PARAM_CLKPRES_SHIFT)
#define SCG_BRD_PARAM_CLKPRES(base) (BME_UBFX32(&SCG_PARAM_REG(base), SCG_PARAM_CLKPRES_SHIFT, SCG_PARAM_CLKPRES_WIDTH))
/*@}*/

/*!
 * @name Register SCG_PARAM, field UNDEFINED1[15:8] (ROZ)
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_UNDEFINED1 field. */
#define SCG_RD_PARAM_UNDEFINED1(base) ((SCG_PARAM_REG(base) & SCG_PARAM_UNDEFINED1_MASK) >> SCG_PARAM_UNDEFINED1_SHIFT)
#define SCG_BRD_PARAM_UNDEFINED1(base) (BME_UBFX32(&SCG_PARAM_REG(base), SCG_PARAM_UNDEFINED1_SHIFT, SCG_PARAM_UNDEFINED1_WIDTH))
/*@}*/

/*!
 * @name Register SCG_PARAM, field UNDEFINED2[26:16] (ROZ)
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_UNDEFINED2 field. */
#define SCG_RD_PARAM_UNDEFINED2(base) ((SCG_PARAM_REG(base) & SCG_PARAM_UNDEFINED2_MASK) >> SCG_PARAM_UNDEFINED2_SHIFT)
#define SCG_BRD_PARAM_UNDEFINED2(base) (SCG_RD_PARAM_UNDEFINED2(base))
/*@}*/

/*!
 * @name Register SCG_PARAM, field DIVPRES[31:27] (RO)
 *
 * Indicates which system clock dividers are present in this instance of SCG.
 */
/*@{*/
/*! @brief Read current value of the SCG_PARAM_DIVPRES field. */
#define SCG_RD_PARAM_DIVPRES(base) ((SCG_PARAM_REG(base) & SCG_PARAM_DIVPRES_MASK) >> SCG_PARAM_DIVPRES_SHIFT)
#define SCG_BRD_PARAM_DIVPRES(base) (BME_UBFX32(&SCG_PARAM_REG(base), SCG_PARAM_DIVPRES_SHIFT, SCG_PARAM_DIVPRES_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_CSR - Clock Status Register
 ******************************************************************************/

/*!
 * @brief SCG_CSR - Clock Status Register (RO)
 *
 * Reset value: 0x03000001U
 *
 * This register returns the currently configured system clock source and the
 * system clock dividers for the core (DIVCORE) and peripheral interface clock
 * (DIVSLOW). The SCG_CSR reflects the configuration set by one of three clock
 * control registers SCG_RCCR, SCG_VCCR, SCG_HCCR.
 */
/*!
 * @name Constants and macros for entire SCG_CSR register
 */
/*@{*/
#define SCG_RD_CSR(base)         (SCG_CSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual SCG_CSR bitfields
 */

/*!
 * @name Register SCG_CSR, field DIVSLOW[3:0] (RO)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_DIVSLOW field. */
#define SCG_RD_CSR_DIVSLOW(base) ((SCG_CSR_REG(base) & SCG_CSR_DIVSLOW_MASK) >> SCG_CSR_DIVSLOW_SHIFT)
#define SCG_BRD_CSR_DIVSLOW(base) (BME_UBFX32(&SCG_CSR_REG(base), SCG_CSR_DIVSLOW_SHIFT, SCG_CSR_DIVSLOW_WIDTH))
/*@}*/

/*!
 * @name Register SCG_CSR, field DIVCORE[19:16] (RO)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_DIVCORE field. */
#define SCG_RD_CSR_DIVCORE(base) ((SCG_CSR_REG(base) & SCG_CSR_DIVCORE_MASK) >> SCG_CSR_DIVCORE_SHIFT)
#define SCG_BRD_CSR_DIVCORE(base) (BME_UBFX32(&SCG_CSR_REG(base), SCG_CSR_DIVCORE_SHIFT, SCG_CSR_DIVCORE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_CSR, field SCS[27:24] (RO)
 *
 * Returns the currently configured clock source generating the system clock.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_CSR_SCS field. */
#define SCG_RD_CSR_SCS(base) ((SCG_CSR_REG(base) & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT)
#define SCG_BRD_CSR_SCS(base) (BME_UBFX32(&SCG_CSR_REG(base), SCG_CSR_SCS_SHIFT, SCG_CSR_SCS_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_RCCR - Run Clock Control Register
 ******************************************************************************/

/*!
 * @brief SCG_RCCR - Run Clock Control Register (RW)
 *
 * Reset value: 0x03000001U
 *
 * This register controls the system clock source and the system clock dividers
 * for the core, platform, external and bus clock domains when in Run mode only.
 * This register can only be written using a 32-bit write. Selecting a different
 * clock source when in RUN requires that clock source to be enabled first and be
 * valid before system clocks switch to that clock source. If system clock
 * divide ratios also change when selecting a different clock mode when in RUN, new
 * system clock divide ratios will not take affect until new clock source is valid.
 */
/*!
 * @name Constants and macros for entire SCG_RCCR register
 */
/*@{*/
#define SCG_RD_RCCR(base)        (SCG_RCCR_REG(base))
#define SCG_WR_RCCR(base, value) (SCG_RCCR_REG(base) = (value))
#define SCG_RMW_RCCR(base, mask, value) (SCG_WR_RCCR(base, (SCG_RD_RCCR(base) & ~(mask)) | (value)))
#define SCG_SET_RCCR(base, value) (BME_OR32(&SCG_RCCR_REG(base), (uint32_t)(value)))
#define SCG_CLR_RCCR(base, value) (BME_AND32(&SCG_RCCR_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_RCCR(base, value) (BME_XOR32(&SCG_RCCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_RCCR bitfields
 */

/*!
 * @name Register SCG_RCCR, field DIVSLOW[3:0] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_DIVSLOW field. */
#define SCG_RD_RCCR_DIVSLOW(base) ((SCG_RCCR_REG(base) & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT)
#define SCG_BRD_RCCR_DIVSLOW(base) (BME_UBFX32(&SCG_RCCR_REG(base), SCG_RCCR_DIVSLOW_SHIFT, SCG_RCCR_DIVSLOW_WIDTH))

/*! @brief Set the DIVSLOW field to a new value. */
#define SCG_WR_RCCR_DIVSLOW(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_DIVSLOW_MASK, SCG_RCCR_DIVSLOW(value)))
#define SCG_BWR_RCCR_DIVSLOW(base, value) (BME_BFI32(&SCG_RCCR_REG(base), ((uint32_t)(value) << SCG_RCCR_DIVSLOW_SHIFT), SCG_RCCR_DIVSLOW_SHIFT, SCG_RCCR_DIVSLOW_WIDTH))
/*@}*/

/*!
 * @name Register SCG_RCCR, field DIVCORE[19:16] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_DIVCORE field. */
#define SCG_RD_RCCR_DIVCORE(base) ((SCG_RCCR_REG(base) & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT)
#define SCG_BRD_RCCR_DIVCORE(base) (BME_UBFX32(&SCG_RCCR_REG(base), SCG_RCCR_DIVCORE_SHIFT, SCG_RCCR_DIVCORE_WIDTH))

/*! @brief Set the DIVCORE field to a new value. */
#define SCG_WR_RCCR_DIVCORE(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_DIVCORE_MASK, SCG_RCCR_DIVCORE(value)))
#define SCG_BWR_RCCR_DIVCORE(base, value) (BME_BFI32(&SCG_RCCR_REG(base), ((uint32_t)(value) << SCG_RCCR_DIVCORE_SHIFT), SCG_RCCR_DIVCORE_SHIFT, SCG_RCCR_DIVCORE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_RCCR, field SCS[27:24] (RW)
 *
 * Selects the clock source generating the system clock in Run mode. Attempting
 * to select a clock that is not valid will be ignored. Selecting a different
 * clock source when in Run mode requires that clock source to be enabled first and
 * be valid before system clocks are allowed to switch to that clock source.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_RCCR_SCS field. */
#define SCG_RD_RCCR_SCS(base) ((SCG_RCCR_REG(base) & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT)
#define SCG_BRD_RCCR_SCS(base) (BME_UBFX32(&SCG_RCCR_REG(base), SCG_RCCR_SCS_SHIFT, SCG_RCCR_SCS_WIDTH))

/*! @brief Set the SCS field to a new value. */
#define SCG_WR_RCCR_SCS(base, value) (SCG_RMW_RCCR(base, SCG_RCCR_SCS_MASK, SCG_RCCR_SCS(value)))
#define SCG_BWR_RCCR_SCS(base, value) (BME_BFI32(&SCG_RCCR_REG(base), ((uint32_t)(value) << SCG_RCCR_SCS_SHIFT), SCG_RCCR_SCS_SHIFT, SCG_RCCR_SCS_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_VCCR - VLPR Clock Control Register
 ******************************************************************************/

/*!
 * @brief SCG_VCCR - VLPR Clock Control Register (RW)
 *
 * Reset value: 0x02000001U
 *
 * This register controls the system clock source and the system clock dividers
 * for the core, platform, external and bus clock domains when in VLPR mode only.
 * This register can only be written using a 32-bit write. Selecting a different
 * clock source when in VLPR requires that clock source to be enabled first and
 * be valid before system clocks switch to that clock source. If system clock
 * divide ratios also change when selecting a different clock mode when in VLPR, new
 * system clock divide ratios will not take affect until new clock source is
 * valid.
 */
/*!
 * @name Constants and macros for entire SCG_VCCR register
 */
/*@{*/
#define SCG_RD_VCCR(base)        (SCG_VCCR_REG(base))
#define SCG_WR_VCCR(base, value) (SCG_VCCR_REG(base) = (value))
#define SCG_RMW_VCCR(base, mask, value) (SCG_WR_VCCR(base, (SCG_RD_VCCR(base) & ~(mask)) | (value)))
#define SCG_SET_VCCR(base, value) (BME_OR32(&SCG_VCCR_REG(base), (uint32_t)(value)))
#define SCG_CLR_VCCR(base, value) (BME_AND32(&SCG_VCCR_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_VCCR(base, value) (BME_XOR32(&SCG_VCCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_VCCR bitfields
 */

/*!
 * @name Register SCG_VCCR, field DIVSLOW[3:0] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_DIVSLOW field. */
#define SCG_RD_VCCR_DIVSLOW(base) ((SCG_VCCR_REG(base) & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT)
#define SCG_BRD_VCCR_DIVSLOW(base) (BME_UBFX32(&SCG_VCCR_REG(base), SCG_VCCR_DIVSLOW_SHIFT, SCG_VCCR_DIVSLOW_WIDTH))

/*! @brief Set the DIVSLOW field to a new value. */
#define SCG_WR_VCCR_DIVSLOW(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_DIVSLOW_MASK, SCG_VCCR_DIVSLOW(value)))
#define SCG_BWR_VCCR_DIVSLOW(base, value) (BME_BFI32(&SCG_VCCR_REG(base), ((uint32_t)(value) << SCG_VCCR_DIVSLOW_SHIFT), SCG_VCCR_DIVSLOW_SHIFT, SCG_VCCR_DIVSLOW_WIDTH))
/*@}*/

/*!
 * @name Register SCG_VCCR, field DIVCORE[19:16] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_DIVCORE field. */
#define SCG_RD_VCCR_DIVCORE(base) ((SCG_VCCR_REG(base) & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT)
#define SCG_BRD_VCCR_DIVCORE(base) (BME_UBFX32(&SCG_VCCR_REG(base), SCG_VCCR_DIVCORE_SHIFT, SCG_VCCR_DIVCORE_WIDTH))

/*! @brief Set the DIVCORE field to a new value. */
#define SCG_WR_VCCR_DIVCORE(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_DIVCORE_MASK, SCG_VCCR_DIVCORE(value)))
#define SCG_BWR_VCCR_DIVCORE(base, value) (BME_BFI32(&SCG_VCCR_REG(base), ((uint32_t)(value) << SCG_VCCR_DIVCORE_SHIFT), SCG_VCCR_DIVCORE_SHIFT, SCG_VCCR_DIVCORE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_VCCR, field SCS[27:24] (RW)
 *
 * Selects the clock source generating the system clock in VLPR mode. Attempting
 * to select a clock that is not valid will be ignored. Selects the clock source
 * generating the system clock. Selecting a different clock source when in VLPR
 * mode requires that clock source to be enabled first and be valid before system
 * clocks switch to that clock source.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_VCCR_SCS field. */
#define SCG_RD_VCCR_SCS(base) ((SCG_VCCR_REG(base) & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT)
#define SCG_BRD_VCCR_SCS(base) (BME_UBFX32(&SCG_VCCR_REG(base), SCG_VCCR_SCS_SHIFT, SCG_VCCR_SCS_WIDTH))

/*! @brief Set the SCS field to a new value. */
#define SCG_WR_VCCR_SCS(base, value) (SCG_RMW_VCCR(base, SCG_VCCR_SCS_MASK, SCG_VCCR_SCS(value)))
#define SCG_BWR_VCCR_SCS(base, value) (BME_BFI32(&SCG_VCCR_REG(base), ((uint32_t)(value) << SCG_VCCR_SCS_SHIFT), SCG_VCCR_SCS_SHIFT, SCG_VCCR_SCS_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_HCCR - HSRUN Clock Control Register
 ******************************************************************************/

/*!
 * @brief SCG_HCCR - HSRUN Clock Control Register (RW)
 *
 * Reset value: 0x03000001U
 *
 * This register controls the system clock source and the system clock dividers
 * for the core, platform, external and bus clock domains when in HSRUN mode
 * only. This register can only be written using a 32-bit write. Selecting a
 * different clock source when in HSRUN requires that clock source to be enabled first
 * and be valid before system clocks switch to that clock source. If system clock
 * divide ratios also change when selecting a different clock mode when in HSRUN,
 * new system clock divide ratios will not take affect until new clock source is
 * valid.
 */
/*!
 * @name Constants and macros for entire SCG_HCCR register
 */
/*@{*/
#define SCG_RD_HCCR(base)        (SCG_HCCR_REG(base))
#define SCG_WR_HCCR(base, value) (SCG_HCCR_REG(base) = (value))
#define SCG_RMW_HCCR(base, mask, value) (SCG_WR_HCCR(base, (SCG_RD_HCCR(base) & ~(mask)) | (value)))
#define SCG_SET_HCCR(base, value) (BME_OR32(&SCG_HCCR_REG(base), (uint32_t)(value)))
#define SCG_CLR_HCCR(base, value) (BME_AND32(&SCG_HCCR_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_HCCR(base, value) (BME_XOR32(&SCG_HCCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_HCCR bitfields
 */

/*!
 * @name Register SCG_HCCR, field DIVSLOW[3:0] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_DIVSLOW field. */
#define SCG_RD_HCCR_DIVSLOW(base) ((SCG_HCCR_REG(base) & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT)
#define SCG_BRD_HCCR_DIVSLOW(base) (BME_UBFX32(&SCG_HCCR_REG(base), SCG_HCCR_DIVSLOW_SHIFT, SCG_HCCR_DIVSLOW_WIDTH))

/*! @brief Set the DIVSLOW field to a new value. */
#define SCG_WR_HCCR_DIVSLOW(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_DIVSLOW_MASK, SCG_HCCR_DIVSLOW(value)))
#define SCG_BWR_HCCR_DIVSLOW(base, value) (BME_BFI32(&SCG_HCCR_REG(base), ((uint32_t)(value) << SCG_HCCR_DIVSLOW_SHIFT), SCG_HCCR_DIVSLOW_SHIFT, SCG_HCCR_DIVSLOW_WIDTH))
/*@}*/

/*!
 * @name Register SCG_HCCR, field DIVCORE[19:16] (RW)
 *
 * Values:
 * - 0b0000 - Divide-by-1
 * - 0b0001 - Divide-by-2
 * - 0b0010 - Divide-by-3
 * - 0b0011 - Divide-by-4
 * - 0b0100 - Divide-by-5
 * - 0b0101 - Divide-by-6
 * - 0b0110 - Divide-by-7
 * - 0b0111 - Divide-by-8
 * - 0b1000 - Divide-by-9
 * - 0b1001 - Divide-by-10
 * - 0b1010 - Divide-by-11
 * - 0b1011 - Divide-by-12
 * - 0b1100 - Divide-by-13
 * - 0b1101 - Divide-by-14
 * - 0b1110 - Divide-by-15
 * - 0b1111 - Divide-by-16
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_DIVCORE field. */
#define SCG_RD_HCCR_DIVCORE(base) ((SCG_HCCR_REG(base) & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT)
#define SCG_BRD_HCCR_DIVCORE(base) (BME_UBFX32(&SCG_HCCR_REG(base), SCG_HCCR_DIVCORE_SHIFT, SCG_HCCR_DIVCORE_WIDTH))

/*! @brief Set the DIVCORE field to a new value. */
#define SCG_WR_HCCR_DIVCORE(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_DIVCORE_MASK, SCG_HCCR_DIVCORE(value)))
#define SCG_BWR_HCCR_DIVCORE(base, value) (BME_BFI32(&SCG_HCCR_REG(base), ((uint32_t)(value) << SCG_HCCR_DIVCORE_SHIFT), SCG_HCCR_DIVCORE_SHIFT, SCG_HCCR_DIVCORE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_HCCR, field SCS[27:24] (RW)
 *
 * Selects the clock source generating the system clock in HSRUN mode.
 * Attempting to select a clock that is not valid will be ignored. Selecting a different
 * clock source when in HSRUN mode will enable that clock source and switch to
 * that clock mode when it is valid.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_HCCR_SCS field. */
#define SCG_RD_HCCR_SCS(base) ((SCG_HCCR_REG(base) & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT)
#define SCG_BRD_HCCR_SCS(base) (BME_UBFX32(&SCG_HCCR_REG(base), SCG_HCCR_SCS_SHIFT, SCG_HCCR_SCS_WIDTH))

/*! @brief Set the SCS field to a new value. */
#define SCG_WR_HCCR_SCS(base, value) (SCG_RMW_HCCR(base, SCG_HCCR_SCS_MASK, SCG_HCCR_SCS(value)))
#define SCG_BWR_HCCR_SCS(base, value) (BME_BFI32(&SCG_HCCR_REG(base), ((uint32_t)(value) << SCG_HCCR_SCS_SHIFT), SCG_HCCR_SCS_SHIFT, SCG_HCCR_SCS_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_CLKOUTCNFG - SCG CLKOUT Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_CLKOUTCNFG - SCG CLKOUT Configuration Register (RW)
 *
 * Reset value: 0x03000000U
 *
 * This register controls which SCG clock source is selected to be ported out to
 * the CLKOUT pin.
 */
/*!
 * @name Constants and macros for entire SCG_CLKOUTCNFG register
 */
/*@{*/
#define SCG_RD_CLKOUTCNFG(base)  (SCG_CLKOUTCNFG_REG(base))
#define SCG_WR_CLKOUTCNFG(base, value) (SCG_CLKOUTCNFG_REG(base) = (value))
#define SCG_RMW_CLKOUTCNFG(base, mask, value) (SCG_WR_CLKOUTCNFG(base, (SCG_RD_CLKOUTCNFG(base) & ~(mask)) | (value)))
#define SCG_SET_CLKOUTCNFG(base, value) (BME_OR32(&SCG_CLKOUTCNFG_REG(base), (uint32_t)(value)))
#define SCG_CLR_CLKOUTCNFG(base, value) (BME_AND32(&SCG_CLKOUTCNFG_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_CLKOUTCNFG(base, value) (BME_XOR32(&SCG_CLKOUTCNFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_CLKOUTCNFG bitfields
 */

/*!
 * @name Register SCG_CLKOUTCNFG, field CLKOUTSEL[27:24] (RW)
 *
 * Selects the SCG system clock.
 *
 * Values:
 * - 0b0000 - SCG SLOW Clock
 * - 0b0001 - System OSC
 * - 0b0010 - Slow IRC
 * - 0b0011 - Fast IRC
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - System PLL
 * - 0b0111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SCG_CLKOUTCNFG_CLKOUTSEL field. */
#define SCG_RD_CLKOUTCNFG_CLKOUTSEL(base) ((SCG_CLKOUTCNFG_REG(base) & SCG_CLKOUTCNFG_CLKOUTSEL_MASK) >> SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT)
#define SCG_BRD_CLKOUTCNFG_CLKOUTSEL(base) (BME_UBFX32(&SCG_CLKOUTCNFG_REG(base), SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT, SCG_CLKOUTCNFG_CLKOUTSEL_WIDTH))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SCG_WR_CLKOUTCNFG_CLKOUTSEL(base, value) (SCG_RMW_CLKOUTCNFG(base, SCG_CLKOUTCNFG_CLKOUTSEL_MASK, SCG_CLKOUTCNFG_CLKOUTSEL(value)))
#define SCG_BWR_CLKOUTCNFG_CLKOUTSEL(base, value) (BME_BFI32(&SCG_CLKOUTCNFG_REG(base), ((uint32_t)(value) << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT), SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT, SCG_CLKOUTCNFG_CLKOUTSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SOSCCSR - System OSC Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_SOSCCSR - System OSC Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SCG_SOSCCSR register
 */
/*@{*/
#define SCG_RD_SOSCCSR(base)     (SCG_SOSCCSR_REG(base))
#define SCG_WR_SOSCCSR(base, value) (SCG_SOSCCSR_REG(base) = (value))
#define SCG_RMW_SOSCCSR(base, mask, value) (SCG_WR_SOSCCSR(base, (SCG_RD_SOSCCSR(base) & ~(mask)) | (value)))
#define SCG_SET_SOSCCSR(base, value) (BME_OR32(&SCG_SOSCCSR_REG(base), (uint32_t)(value)))
#define SCG_CLR_SOSCCSR(base, value) (BME_AND32(&SCG_SOSCCSR_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SOSCCSR(base, value) (BME_XOR32(&SCG_SOSCCSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SOSCCSR bitfields
 */

/*!
 * @name Register SCG_SOSCCSR, field SOSCEN[0] (RW)
 *
 * Values:
 * - 0b0 - System OSC is disabled
 * - 0b1 - System OSC is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCEN field. */
#define SCG_RD_SOSCCSR_SOSCEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCEN(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCEN_SHIFT, SCG_SOSCCSR_SOSCEN_WIDTH))

/*! @brief Set the SOSCEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCEN(value)))
#define SCG_BWR_SOSCCSR_SOSCEN(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_SOSCEN_SHIFT), SCG_SOSCCSR_SOSCEN_SHIFT, SCG_SOSCCSR_SOSCEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - System OSC is disabled in Stop modes
 * - 0b1 - System OSC is enabled in Stop modes if SOSCEN=1. In VLLS0, system
 *     oscillator is disabled even if SOSCSTEN=1 and SOSCEN=1.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCSTEN field. */
#define SCG_RD_SOSCCSR_SOSCSTEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCSTEN_MASK) >> SCG_SOSCCSR_SOSCSTEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCSTEN(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCSTEN_SHIFT, SCG_SOSCCSR_SOSCSTEN_WIDTH))

/*! @brief Set the SOSCSTEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCSTEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCSTEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCSTEN(value)))
#define SCG_BWR_SOSCCSR_SOSCSTEN(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_SOSCSTEN_SHIFT), SCG_SOSCCSR_SOSCSTEN_SHIFT, SCG_SOSCCSR_SOSCSTEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCLPEN[2] (RW)
 *
 * SOSCLPEN is required for low power modes. In VLPS mode (low power stop mode),
 * if you want the clock to remain ON, then both SOSCLPEN and SOSCSTEN bits must
 * be enabled.
 *
 * Values:
 * - 0b0 - System OSC is disabled in VLP modes
 * - 0b1 - System OSC is enabled in VLP modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCLPEN field. */
#define SCG_RD_SOSCCSR_SOSCLPEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCLPEN_MASK) >> SCG_SOSCCSR_SOSCLPEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCLPEN(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCLPEN_SHIFT, SCG_SOSCCSR_SOSCLPEN_WIDTH))

/*! @brief Set the SOSCLPEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCLPEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCLPEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCLPEN(value)))
#define SCG_BWR_SOSCCSR_SOSCLPEN(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_SOSCLPEN_SHIFT), SCG_SOSCCSR_SOSCLPEN_SHIFT, SCG_SOSCCSR_SOSCLPEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCERCLKEN[3] (RW)
 *
 * SOSCERCLKEN is required for stop modes.
 *
 * Values:
 * - 0b0 - System OSC 3V ERCLK output clock is disabled.
 * - 0b1 - System OSC 3V ERCLK output clock is enabled when SYSOSC is enabled.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCERCLKEN field. */
#define SCG_RD_SOSCCSR_SOSCERCLKEN(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCERCLKEN_MASK) >> SCG_SOSCCSR_SOSCERCLKEN_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCERCLKEN(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCERCLKEN_SHIFT, SCG_SOSCCSR_SOSCERCLKEN_WIDTH))

/*! @brief Set the SOSCERCLKEN field to a new value. */
#define SCG_WR_SOSCCSR_SOSCERCLKEN(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCERCLKEN_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCERCLKEN(value)))
#define SCG_BWR_SOSCCSR_SOSCERCLKEN(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_SOSCERCLKEN_SHIFT), SCG_SOSCCSR_SOSCERCLKEN_SHIFT, SCG_SOSCCSR_SOSCERCLKEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCCM[16] (RW)
 *
 * Enables the clock monitor when SOSCVLD is set. If the clock source is
 * disabled in a low power mode then the clock monitor is also disabled in the low power
 * mode. The clock monitor is always disabled in LLS/VLLS modes. When the clock
 * monitor is disabled in a low power mode, it remains disabled until the clock
 * valid flag is set following exit from the low power mode.
 *
 * Values:
 * - 0b0 - System OSC Clock Monitor is disabled
 * - 0b1 - System OSC Clock Monitor is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCCM field. */
#define SCG_RD_SOSCCSR_SOSCCM(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCCM_MASK) >> SCG_SOSCCSR_SOSCCM_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCCM(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCCM_SHIFT, SCG_SOSCCSR_SOSCCM_WIDTH))

/*! @brief Set the SOSCCM field to a new value. */
#define SCG_WR_SOSCCSR_SOSCCM(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCCM_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCCM(value)))
#define SCG_BWR_SOSCCSR_SOSCCM(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_SOSCCM_SHIFT), SCG_SOSCCSR_SOSCCM_SHIFT, SCG_SOSCCSR_SOSCCM_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCCMRE[17] (RW)
 *
 * Values:
 * - 0b0 - Clock Monitor generates interrupt when error detected
 * - 0b1 - Clock Monitor generates reset when error detected
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCCMRE field. */
#define SCG_RD_SOSCCSR_SOSCCMRE(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCCMRE_MASK) >> SCG_SOSCCSR_SOSCCMRE_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCCMRE(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCCMRE_SHIFT, SCG_SOSCCSR_SOSCCMRE_WIDTH))

/*! @brief Set the SOSCCMRE field to a new value. */
#define SCG_WR_SOSCCSR_SOSCCMRE(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_SOSCCMRE_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_SOSCCMRE(value)))
#define SCG_BWR_SOSCCSR_SOSCCMRE(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_SOSCCMRE_SHIFT), SCG_SOSCCSR_SOSCCMRE_SHIFT, SCG_SOSCCSR_SOSCCMRE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - This Control Status Register can be written.
 * - 0b1 - This Control Status Register cannot be written until the next System
 *     Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_LK field. */
#define SCG_RD_SOSCCSR_LK(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_LK_MASK) >> SCG_SOSCCSR_LK_SHIFT)
#define SCG_BRD_SOSCCSR_LK(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_LK_SHIFT, SCG_SOSCCSR_LK_WIDTH))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_SOSCCSR_LK(base, value) (SCG_RMW_SOSCCSR(base, (SCG_SOSCCSR_LK_MASK | SCG_SOSCCSR_SOSCERR_MASK), SCG_SOSCCSR_LK(value)))
#define SCG_BWR_SOSCCSR_LK(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_LK_SHIFT), SCG_SOSCCSR_LK_SHIFT, SCG_SOSCCSR_LK_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCVLD[24] (RO)
 *
 * Values:
 * - 0b0 - System OSC is not enabled or clock is not valid
 * - 0b1 - System OSC is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCVLD field. */
#define SCG_RD_SOSCCSR_SOSCVLD(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCVLD(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCVLD_SHIFT, SCG_SOSCCSR_SOSCVLD_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCSEL[25] (RO)
 *
 * Values:
 * - 0b0 - System OSC is not the system clock source
 * - 0b1 - System OSC is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCSEL field. */
#define SCG_RD_SOSCCSR_SOSCSEL(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCSEL_MASK) >> SCG_SOSCCSR_SOSCSEL_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCSEL(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCSEL_SHIFT, SCG_SOSCCSR_SOSCSEL_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCSR, field SOSCERR[26] (W1C)
 *
 * This flag is reset on Chip POR only, software can also clear this flag by
 * writing a logic one.
 *
 * Values:
 * - 0b0 - System OSC Clock Monitor is disabled or has not detected an error
 * - 0b1 - System OSC Clock Monitor is enabled and detected an error
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCSR_SOSCERR field. */
#define SCG_RD_SOSCCSR_SOSCERR(base) ((SCG_SOSCCSR_REG(base) & SCG_SOSCCSR_SOSCERR_MASK) >> SCG_SOSCCSR_SOSCERR_SHIFT)
#define SCG_BRD_SOSCCSR_SOSCERR(base) (BME_UBFX32(&SCG_SOSCCSR_REG(base), SCG_SOSCCSR_SOSCERR_SHIFT, SCG_SOSCCSR_SOSCERR_WIDTH))

/*! @brief Set the SOSCERR field to a new value. */
#define SCG_WR_SOSCCSR_SOSCERR(base, value) (SCG_RMW_SOSCCSR(base, SCG_SOSCCSR_SOSCERR_MASK, SCG_SOSCCSR_SOSCERR(value)))
#define SCG_BWR_SOSCCSR_SOSCERR(base, value) (BME_BFI32(&SCG_SOSCCSR_REG(base), ((uint32_t)(value) << SCG_SOSCCSR_SOSCERR_SHIFT), SCG_SOSCCSR_SOSCERR_SHIFT, SCG_SOSCCSR_SOSCERR_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SOSCDIV - System OSC Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_SOSCDIV - System OSC Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SCG_SOSCDIV register provides the control of 3 clock trees which can be
 * used to provide optional peripheral functional clocks, or alternative module
 * clocks. Each clock tree has optional dividers of the input SOSC clock. Changes
 * to SOSCDIV should be done when System OSC is disabled to prevent glitches to
 * output divided clock.
 */
/*!
 * @name Constants and macros for entire SCG_SOSCDIV register
 */
/*@{*/
#define SCG_RD_SOSCDIV(base)     (SCG_SOSCDIV_REG(base))
#define SCG_WR_SOSCDIV(base, value) (SCG_SOSCDIV_REG(base) = (value))
#define SCG_RMW_SOSCDIV(base, mask, value) (SCG_WR_SOSCDIV(base, (SCG_RD_SOSCDIV(base) & ~(mask)) | (value)))
#define SCG_SET_SOSCDIV(base, value) (BME_OR32(&SCG_SOSCDIV_REG(base), (uint32_t)(value)))
#define SCG_CLR_SOSCDIV(base, value) (BME_AND32(&SCG_SOSCDIV_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SOSCDIV(base, value) (BME_XOR32(&SCG_SOSCDIV_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SOSCDIV bitfields
 */

/*!
 * @name Register SCG_SOSCDIV, field SOSCDIV1[2:0] (RW)
 *
 * Clock divider 1 for System OSC. Used to generate the system clock source and
 * by platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCDIV_SOSCDIV1 field. */
#define SCG_RD_SOSCDIV_SOSCDIV1(base) ((SCG_SOSCDIV_REG(base) & SCG_SOSCDIV_SOSCDIV1_MASK) >> SCG_SOSCDIV_SOSCDIV1_SHIFT)
#define SCG_BRD_SOSCDIV_SOSCDIV1(base) (BME_UBFX32(&SCG_SOSCDIV_REG(base), SCG_SOSCDIV_SOSCDIV1_SHIFT, SCG_SOSCDIV_SOSCDIV1_WIDTH))

/*! @brief Set the SOSCDIV1 field to a new value. */
#define SCG_WR_SOSCDIV_SOSCDIV1(base, value) (SCG_RMW_SOSCDIV(base, SCG_SOSCDIV_SOSCDIV1_MASK, SCG_SOSCDIV_SOSCDIV1(value)))
#define SCG_BWR_SOSCDIV_SOSCDIV1(base, value) (BME_BFI32(&SCG_SOSCDIV_REG(base), ((uint32_t)(value) << SCG_SOSCDIV_SOSCDIV1_SHIFT), SCG_SOSCDIV_SOSCDIV1_SHIFT, SCG_SOSCDIV_SOSCDIV1_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCDIV, field SOSCDIV2[10:8] (RW)
 *
 * Clock divider 2 for System OSC.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCDIV_SOSCDIV2 field. */
#define SCG_RD_SOSCDIV_SOSCDIV2(base) ((SCG_SOSCDIV_REG(base) & SCG_SOSCDIV_SOSCDIV2_MASK) >> SCG_SOSCDIV_SOSCDIV2_SHIFT)
#define SCG_BRD_SOSCDIV_SOSCDIV2(base) (BME_UBFX32(&SCG_SOSCDIV_REG(base), SCG_SOSCDIV_SOSCDIV2_SHIFT, SCG_SOSCDIV_SOSCDIV2_WIDTH))

/*! @brief Set the SOSCDIV2 field to a new value. */
#define SCG_WR_SOSCDIV_SOSCDIV2(base, value) (SCG_RMW_SOSCDIV(base, SCG_SOSCDIV_SOSCDIV2_MASK, SCG_SOSCDIV_SOSCDIV2(value)))
#define SCG_BWR_SOSCDIV_SOSCDIV2(base, value) (BME_BFI32(&SCG_SOSCDIV_REG(base), ((uint32_t)(value) << SCG_SOSCDIV_SOSCDIV2_SHIFT), SCG_SOSCDIV_SOSCDIV2_SHIFT, SCG_SOSCDIV_SOSCDIV2_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCDIV, field SOSCDIV3[18:16] (RW)
 *
 * Clock divider 3 for System OSC.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCDIV_SOSCDIV3 field. */
#define SCG_RD_SOSCDIV_SOSCDIV3(base) ((SCG_SOSCDIV_REG(base) & SCG_SOSCDIV_SOSCDIV3_MASK) >> SCG_SOSCDIV_SOSCDIV3_SHIFT)
#define SCG_BRD_SOSCDIV_SOSCDIV3(base) (BME_UBFX32(&SCG_SOSCDIV_REG(base), SCG_SOSCDIV_SOSCDIV3_SHIFT, SCG_SOSCDIV_SOSCDIV3_WIDTH))

/*! @brief Set the SOSCDIV3 field to a new value. */
#define SCG_WR_SOSCDIV_SOSCDIV3(base, value) (SCG_RMW_SOSCDIV(base, SCG_SOSCDIV_SOSCDIV3_MASK, SCG_SOSCDIV_SOSCDIV3(value)))
#define SCG_BWR_SOSCDIV_SOSCDIV3(base, value) (BME_BFI32(&SCG_SOSCDIV_REG(base), ((uint32_t)(value) << SCG_SOSCDIV_SOSCDIV3_SHIFT), SCG_SOSCDIV_SOSCDIV3_SHIFT, SCG_SOSCDIV_SOSCDIV3_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SOSCCFG - System Oscillator Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_SOSCCFG - System Oscillator Configuration Register (RW)
 *
 * Reset value: 0x00000010U
 *
 * The SOSCCFG register cannot be changed when the System OSC is enabled. When
 * the System OSC is enabled, writes to this register are ignored, and there is no
 * transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_SOSCCFG register
 */
/*@{*/
#define SCG_RD_SOSCCFG(base)     (SCG_SOSCCFG_REG(base))
#define SCG_WR_SOSCCFG(base, value) (SCG_SOSCCFG_REG(base) = (value))
#define SCG_RMW_SOSCCFG(base, mask, value) (SCG_WR_SOSCCFG(base, (SCG_RD_SOSCCFG(base) & ~(mask)) | (value)))
#define SCG_SET_SOSCCFG(base, value) (BME_OR32(&SCG_SOSCCFG_REG(base), (uint32_t)(value)))
#define SCG_CLR_SOSCCFG(base, value) (BME_AND32(&SCG_SOSCCFG_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SOSCCFG(base, value) (BME_XOR32(&SCG_SOSCCFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SOSCCFG bitfields
 */

/*!
 * @name Register SCG_SOSCCFG, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock. This bit selects which
 * clock is output from the System OSC (SOSC) into the SCG, thus either the
 * crystal oscillator or from an external clock input
 *
 * Values:
 * - 0b0 - External reference clock selected
 * - 0b1 - Internal oscillator of OSC requested. In VLLS0, the internal
 *     oscillator of OSC is disabled even if SOSCEN=1 and SOSCSTEN=1.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_EREFS field. */
#define SCG_RD_SOSCCFG_EREFS(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_EREFS_MASK) >> SCG_SOSCCFG_EREFS_SHIFT)
#define SCG_BRD_SOSCCFG_EREFS(base) (BME_UBFX32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_EREFS_SHIFT, SCG_SOSCCFG_EREFS_WIDTH))

/*! @brief Set the EREFS field to a new value. */
#define SCG_WR_SOSCCFG_EREFS(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_EREFS_MASK, SCG_SOSCCFG_EREFS(value)))
#define SCG_BWR_SOSCCFG_EREFS(base, value) (BME_BFI32(&SCG_SOSCCFG_REG(base), ((uint32_t)(value) << SCG_SOSCCFG_EREFS_SHIFT), SCG_SOSCCFG_EREFS_SHIFT, SCG_SOSCCFG_EREFS_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field HGO[3] (RW)
 *
 * Controls the crystal oscillator power mode of operations.
 *
 * Values:
 * - 0b0 - Configure crystal oscillaor for low-power operation
 * - 0b1 - Configure crystal oscillator for high-gain operation
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_HGO field. */
#define SCG_RD_SOSCCFG_HGO(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_HGO_MASK) >> SCG_SOSCCFG_HGO_SHIFT)
#define SCG_BRD_SOSCCFG_HGO(base) (BME_UBFX32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_HGO_SHIFT, SCG_SOSCCFG_HGO_WIDTH))

/*! @brief Set the HGO field to a new value. */
#define SCG_WR_SOSCCFG_HGO(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_HGO_MASK, SCG_SOSCCFG_HGO(value)))
#define SCG_BWR_SOSCCFG_HGO(base, value) (BME_BFI32(&SCG_SOSCCFG_REG(base), ((uint32_t)(value) << SCG_SOSCCFG_HGO_SHIFT), SCG_SOSCCFG_HGO_SHIFT, SCG_SOSCCFG_HGO_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the system crystal oscillator (OSC)
 *
 * Values:
 * - 0b00 - Reserved
 * - 0b01 - Low frequency range selected for the crystal oscillator of 32 kHz to
 *     40 kHz.
 * - 0b10 - Medium frequency range selected for the crytstal oscillator of 1 Mhz
 *     to 8 Mhz.
 * - 0b11 - High frequency range selected for the crystal oscillator of 8 Mhz to
 *     32 Mhz.
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_RANGE field. */
#define SCG_RD_SOSCCFG_RANGE(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_RANGE_MASK) >> SCG_SOSCCFG_RANGE_SHIFT)
#define SCG_BRD_SOSCCFG_RANGE(base) (BME_UBFX32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_RANGE_SHIFT, SCG_SOSCCFG_RANGE_WIDTH))

/*! @brief Set the RANGE field to a new value. */
#define SCG_WR_SOSCCFG_RANGE(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_RANGE_MASK, SCG_SOSCCFG_RANGE(value)))
#define SCG_BWR_SOSCCFG_RANGE(base, value) (BME_BFI32(&SCG_SOSCCFG_REG(base), ((uint32_t)(value) << SCG_SOSCCFG_RANGE_SHIFT), SCG_SOSCCFG_RANGE_SHIFT, SCG_SOSCCFG_RANGE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC16P[8] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC16P field. */
#define SCG_RD_SOSCCFG_SC16P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC16P_MASK) >> SCG_SOSCCFG_SC16P_SHIFT)
#define SCG_BRD_SOSCCFG_SC16P(base) (BME_UBFX32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC16P_SHIFT, SCG_SOSCCFG_SC16P_WIDTH))

/*! @brief Set the SC16P field to a new value. */
#define SCG_WR_SOSCCFG_SC16P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC16P_MASK, SCG_SOSCCFG_SC16P(value)))
#define SCG_BWR_SOSCCFG_SC16P(base, value) (BME_BFI32(&SCG_SOSCCFG_REG(base), ((uint32_t)(value) << SCG_SOSCCFG_SC16P_SHIFT), SCG_SOSCCFG_SC16P_SHIFT, SCG_SOSCCFG_SC16P_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC8P[9] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC8P field. */
#define SCG_RD_SOSCCFG_SC8P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC8P_MASK) >> SCG_SOSCCFG_SC8P_SHIFT)
#define SCG_BRD_SOSCCFG_SC8P(base) (BME_UBFX32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC8P_SHIFT, SCG_SOSCCFG_SC8P_WIDTH))

/*! @brief Set the SC8P field to a new value. */
#define SCG_WR_SOSCCFG_SC8P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC8P_MASK, SCG_SOSCCFG_SC8P(value)))
#define SCG_BWR_SOSCCFG_SC8P(base, value) (BME_BFI32(&SCG_SOSCCFG_REG(base), ((uint32_t)(value) << SCG_SOSCCFG_SC8P_SHIFT), SCG_SOSCCFG_SC8P_SHIFT, SCG_SOSCCFG_SC8P_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC4P[10] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC4P field. */
#define SCG_RD_SOSCCFG_SC4P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC4P_MASK) >> SCG_SOSCCFG_SC4P_SHIFT)
#define SCG_BRD_SOSCCFG_SC4P(base) (BME_UBFX32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC4P_SHIFT, SCG_SOSCCFG_SC4P_WIDTH))

/*! @brief Set the SC4P field to a new value. */
#define SCG_WR_SOSCCFG_SC4P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC4P_MASK, SCG_SOSCCFG_SC4P(value)))
#define SCG_BWR_SOSCCFG_SC4P(base, value) (BME_BFI32(&SCG_SOSCCFG_REG(base), ((uint32_t)(value) << SCG_SOSCCFG_SC4P_SHIFT), SCG_SOSCCFG_SC4P_SHIFT, SCG_SOSCCFG_SC4P_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SOSCCFG, field SC2P[11] (RW)
 */
/*@{*/
/*! @brief Read current value of the SCG_SOSCCFG_SC2P field. */
#define SCG_RD_SOSCCFG_SC2P(base) ((SCG_SOSCCFG_REG(base) & SCG_SOSCCFG_SC2P_MASK) >> SCG_SOSCCFG_SC2P_SHIFT)
#define SCG_BRD_SOSCCFG_SC2P(base) (BME_UBFX32(&SCG_SOSCCFG_REG(base), SCG_SOSCCFG_SC2P_SHIFT, SCG_SOSCCFG_SC2P_WIDTH))

/*! @brief Set the SC2P field to a new value. */
#define SCG_WR_SOSCCFG_SC2P(base, value) (SCG_RMW_SOSCCFG(base, SCG_SOSCCFG_SC2P_MASK, SCG_SOSCCFG_SC2P(value)))
#define SCG_BWR_SOSCCFG_SC2P(base, value) (BME_BFI32(&SCG_SOSCCFG_REG(base), ((uint32_t)(value) << SCG_SOSCCFG_SC2P_SHIFT), SCG_SOSCCFG_SC2P_SHIFT, SCG_SOSCCFG_SC2P_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SIRCCSR - Slow IRC Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_SIRCCSR - Slow IRC Control Status Register (RW)
 *
 * Reset value: 0x03000005U
 */
/*!
 * @name Constants and macros for entire SCG_SIRCCSR register
 */
/*@{*/
#define SCG_RD_SIRCCSR(base)     (SCG_SIRCCSR_REG(base))
#define SCG_WR_SIRCCSR(base, value) (SCG_SIRCCSR_REG(base) = (value))
#define SCG_RMW_SIRCCSR(base, mask, value) (SCG_WR_SIRCCSR(base, (SCG_RD_SIRCCSR(base) & ~(mask)) | (value)))
#define SCG_SET_SIRCCSR(base, value) (BME_OR32(&SCG_SIRCCSR_REG(base), (uint32_t)(value)))
#define SCG_CLR_SIRCCSR(base, value) (BME_AND32(&SCG_SIRCCSR_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SIRCCSR(base, value) (BME_XOR32(&SCG_SIRCCSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SIRCCSR bitfields
 */

/*!
 * @name Register SCG_SIRCCSR, field SIRCEN[0] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC is disabled
 * - 0b1 - Slow IRC is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCEN field. */
#define SCG_RD_SIRCCSR_SIRCEN(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCEN_MASK) >> SCG_SIRCCSR_SIRCEN_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCEN(base) (BME_UBFX32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCEN_SHIFT, SCG_SIRCCSR_SIRCEN_WIDTH))

/*! @brief Set the SIRCEN field to a new value. */
#define SCG_WR_SIRCCSR_SIRCEN(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_SIRCEN_MASK, SCG_SIRCCSR_SIRCEN(value)))
#define SCG_BWR_SIRCCSR_SIRCEN(base, value) (BME_BFI32(&SCG_SIRCCSR_REG(base), ((uint32_t)(value) << SCG_SIRCCSR_SIRCEN_SHIFT), SCG_SIRCCSR_SIRCEN_SHIFT, SCG_SIRCCSR_SIRCEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC is disabled in Stop modes
 * - 0b1 - Slow IRC is enabled in Stop modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCSTEN field. */
#define SCG_RD_SIRCCSR_SIRCSTEN(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCSTEN_MASK) >> SCG_SIRCCSR_SIRCSTEN_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCSTEN(base) (BME_UBFX32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCSTEN_SHIFT, SCG_SIRCCSR_SIRCSTEN_WIDTH))

/*! @brief Set the SIRCSTEN field to a new value. */
#define SCG_WR_SIRCCSR_SIRCSTEN(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_SIRCSTEN_MASK, SCG_SIRCCSR_SIRCSTEN(value)))
#define SCG_BWR_SIRCCSR_SIRCSTEN(base, value) (BME_BFI32(&SCG_SIRCCSR_REG(base), ((uint32_t)(value) << SCG_SIRCCSR_SIRCSTEN_SHIFT), SCG_SIRCCSR_SIRCSTEN_SHIFT, SCG_SIRCCSR_SIRCSTEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCLPEN[2] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC is disabled in VLP modes
 * - 0b1 - Slow IRC is enabled in VLP modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCLPEN field. */
#define SCG_RD_SIRCCSR_SIRCLPEN(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCLPEN_MASK) >> SCG_SIRCCSR_SIRCLPEN_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCLPEN(base) (BME_UBFX32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCLPEN_SHIFT, SCG_SIRCCSR_SIRCLPEN_WIDTH))

/*! @brief Set the SIRCLPEN field to a new value. */
#define SCG_WR_SIRCCSR_SIRCLPEN(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_SIRCLPEN_MASK, SCG_SIRCCSR_SIRCLPEN(value)))
#define SCG_BWR_SIRCCSR_SIRCLPEN(base, value) (BME_BFI32(&SCG_SIRCCSR_REG(base), ((uint32_t)(value) << SCG_SIRCCSR_SIRCLPEN_SHIFT), SCG_SIRCCSR_SIRCLPEN_SHIFT, SCG_SIRCCSR_SIRCLPEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_LK field. */
#define SCG_RD_SIRCCSR_LK(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_LK_MASK) >> SCG_SIRCCSR_LK_SHIFT)
#define SCG_BRD_SIRCCSR_LK(base) (BME_UBFX32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_LK_SHIFT, SCG_SIRCCSR_LK_WIDTH))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_SIRCCSR_LK(base, value) (SCG_RMW_SIRCCSR(base, SCG_SIRCCSR_LK_MASK, SCG_SIRCCSR_LK(value)))
#define SCG_BWR_SIRCCSR_LK(base, value) (BME_BFI32(&SCG_SIRCCSR_REG(base), ((uint32_t)(value) << SCG_SIRCCSR_LK_SHIFT), SCG_SIRCCSR_LK_SHIFT, SCG_SIRCCSR_LK_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCVLD[24] (RO)
 *
 * Values:
 * - 0b0 - Slow IRC is not enabled or clock is not valid
 * - 0b1 - Slow IRC is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCVLD field. */
#define SCG_RD_SIRCCSR_SIRCVLD(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCVLD(base) (BME_UBFX32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCVLD_SHIFT, SCG_SIRCCSR_SIRCVLD_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SIRCCSR, field SIRCSEL[25] (RO)
 *
 * Values:
 * - 0b0 - Slow IRC is not the system clock source
 * - 0b1 - Slow IRC is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCSR_SIRCSEL field. */
#define SCG_RD_SIRCCSR_SIRCSEL(base) ((SCG_SIRCCSR_REG(base) & SCG_SIRCCSR_SIRCSEL_MASK) >> SCG_SIRCCSR_SIRCSEL_SHIFT)
#define SCG_BRD_SIRCCSR_SIRCSEL(base) (BME_UBFX32(&SCG_SIRCCSR_REG(base), SCG_SIRCCSR_SIRCSEL_SHIFT, SCG_SIRCCSR_SIRCSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SIRCDIV - Slow IRC Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_SIRCDIV - Slow IRC Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Changes to SIRCDIV should be done when Slow IRC is disabled to prevent
 * glitches to output divided clock.
 */
/*!
 * @name Constants and macros for entire SCG_SIRCDIV register
 */
/*@{*/
#define SCG_RD_SIRCDIV(base)     (SCG_SIRCDIV_REG(base))
#define SCG_WR_SIRCDIV(base, value) (SCG_SIRCDIV_REG(base) = (value))
#define SCG_RMW_SIRCDIV(base, mask, value) (SCG_WR_SIRCDIV(base, (SCG_RD_SIRCDIV(base) & ~(mask)) | (value)))
#define SCG_SET_SIRCDIV(base, value) (BME_OR32(&SCG_SIRCDIV_REG(base), (uint32_t)(value)))
#define SCG_CLR_SIRCDIV(base, value) (BME_AND32(&SCG_SIRCDIV_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SIRCDIV(base, value) (BME_XOR32(&SCG_SIRCDIV_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SIRCDIV bitfields
 */

/*!
 * @name Register SCG_SIRCDIV, field SIRCDIV1[2:0] (RW)
 *
 * Clock divider 1 for Slow IRC. Used to generate the system clock source and by
 * platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCDIV_SIRCDIV1 field. */
#define SCG_RD_SIRCDIV_SIRCDIV1(base) ((SCG_SIRCDIV_REG(base) & SCG_SIRCDIV_SIRCDIV1_MASK) >> SCG_SIRCDIV_SIRCDIV1_SHIFT)
#define SCG_BRD_SIRCDIV_SIRCDIV1(base) (BME_UBFX32(&SCG_SIRCDIV_REG(base), SCG_SIRCDIV_SIRCDIV1_SHIFT, SCG_SIRCDIV_SIRCDIV1_WIDTH))

/*! @brief Set the SIRCDIV1 field to a new value. */
#define SCG_WR_SIRCDIV_SIRCDIV1(base, value) (SCG_RMW_SIRCDIV(base, SCG_SIRCDIV_SIRCDIV1_MASK, SCG_SIRCDIV_SIRCDIV1(value)))
#define SCG_BWR_SIRCDIV_SIRCDIV1(base, value) (BME_BFI32(&SCG_SIRCDIV_REG(base), ((uint32_t)(value) << SCG_SIRCDIV_SIRCDIV1_SHIFT), SCG_SIRCDIV_SIRCDIV1_SHIFT, SCG_SIRCDIV_SIRCDIV1_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SIRCDIV, field SIRCDIV2[10:8] (RW)
 *
 * Clock divider 2 for Slow IRC.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCDIV_SIRCDIV2 field. */
#define SCG_RD_SIRCDIV_SIRCDIV2(base) ((SCG_SIRCDIV_REG(base) & SCG_SIRCDIV_SIRCDIV2_MASK) >> SCG_SIRCDIV_SIRCDIV2_SHIFT)
#define SCG_BRD_SIRCDIV_SIRCDIV2(base) (BME_UBFX32(&SCG_SIRCDIV_REG(base), SCG_SIRCDIV_SIRCDIV2_SHIFT, SCG_SIRCDIV_SIRCDIV2_WIDTH))

/*! @brief Set the SIRCDIV2 field to a new value. */
#define SCG_WR_SIRCDIV_SIRCDIV2(base, value) (SCG_RMW_SIRCDIV(base, SCG_SIRCDIV_SIRCDIV2_MASK, SCG_SIRCDIV_SIRCDIV2(value)))
#define SCG_BWR_SIRCDIV_SIRCDIV2(base, value) (BME_BFI32(&SCG_SIRCDIV_REG(base), ((uint32_t)(value) << SCG_SIRCDIV_SIRCDIV2_SHIFT), SCG_SIRCDIV_SIRCDIV2_SHIFT, SCG_SIRCDIV_SIRCDIV2_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SIRCDIV, field SIRCDIV3[18:16] (RW)
 *
 * Clock divider 3 for Slow IRC.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCDIV_SIRCDIV3 field. */
#define SCG_RD_SIRCDIV_SIRCDIV3(base) ((SCG_SIRCDIV_REG(base) & SCG_SIRCDIV_SIRCDIV3_MASK) >> SCG_SIRCDIV_SIRCDIV3_SHIFT)
#define SCG_BRD_SIRCDIV_SIRCDIV3(base) (BME_UBFX32(&SCG_SIRCDIV_REG(base), SCG_SIRCDIV_SIRCDIV3_SHIFT, SCG_SIRCDIV_SIRCDIV3_WIDTH))

/*! @brief Set the SIRCDIV3 field to a new value. */
#define SCG_WR_SIRCDIV_SIRCDIV3(base, value) (SCG_RMW_SIRCDIV(base, SCG_SIRCDIV_SIRCDIV3_MASK, SCG_SIRCDIV_SIRCDIV3(value)))
#define SCG_BWR_SIRCDIV_SIRCDIV3(base, value) (BME_BFI32(&SCG_SIRCDIV_REG(base), ((uint32_t)(value) << SCG_SIRCDIV_SIRCDIV3_SHIFT), SCG_SIRCDIV_SIRCDIV3_SHIFT, SCG_SIRCDIV_SIRCDIV3_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SIRCCFG - Slow IRC Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_SIRCCFG - Slow IRC Configuration Register (RW)
 *
 * Reset value: 0x00000001U
 *
 * The SIRCCFG register cannot be changed when the slow IRC clock is enabled.
 * When the slow IRC clock is enabled, writes to this register are ignored, and
 * there is no transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_SIRCCFG register
 */
/*@{*/
#define SCG_RD_SIRCCFG(base)     (SCG_SIRCCFG_REG(base))
#define SCG_WR_SIRCCFG(base, value) (SCG_SIRCCFG_REG(base) = (value))
#define SCG_RMW_SIRCCFG(base, mask, value) (SCG_WR_SIRCCFG(base, (SCG_RD_SIRCCFG(base) & ~(mask)) | (value)))
#define SCG_SET_SIRCCFG(base, value) (BME_OR32(&SCG_SIRCCFG_REG(base), (uint32_t)(value)))
#define SCG_CLR_SIRCCFG(base, value) (BME_AND32(&SCG_SIRCCFG_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SIRCCFG(base, value) (BME_XOR32(&SCG_SIRCCFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SIRCCFG bitfields
 */

/*!
 * @name Register SCG_SIRCCFG, field RANGE[0] (RW)
 *
 * Values:
 * - 0b0 - Slow IRC low range clock (2 MHz)
 * - 0b1 - Slow IRC high range clock (8 MHz)
 */
/*@{*/
/*! @brief Read current value of the SCG_SIRCCFG_RANGE field. */
#define SCG_RD_SIRCCFG_RANGE(base) ((SCG_SIRCCFG_REG(base) & SCG_SIRCCFG_RANGE_MASK) >> SCG_SIRCCFG_RANGE_SHIFT)
#define SCG_BRD_SIRCCFG_RANGE(base) (BME_UBFX32(&SCG_SIRCCFG_REG(base), SCG_SIRCCFG_RANGE_SHIFT, SCG_SIRCCFG_RANGE_WIDTH))

/*! @brief Set the RANGE field to a new value. */
#define SCG_WR_SIRCCFG_RANGE(base, value) (SCG_RMW_SIRCCFG(base, SCG_SIRCCFG_RANGE_MASK, SCG_SIRCCFG_RANGE(value)))
#define SCG_BWR_SIRCCFG_RANGE(base, value) (BME_BFI32(&SCG_SIRCCFG_REG(base), ((uint32_t)(value) << SCG_SIRCCFG_RANGE_SHIFT), SCG_SIRCCFG_RANGE_SHIFT, SCG_SIRCCFG_RANGE_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_FIRCCSR - Fast IRC Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCCSR - Fast IRC Control Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire SCG_FIRCCSR register
 */
/*@{*/
#define SCG_RD_FIRCCSR(base)     (SCG_FIRCCSR_REG(base))
#define SCG_WR_FIRCCSR(base, value) (SCG_FIRCCSR_REG(base) = (value))
#define SCG_RMW_FIRCCSR(base, mask, value) (SCG_WR_FIRCCSR(base, (SCG_RD_FIRCCSR(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCCSR(base, value) (BME_OR32(&SCG_FIRCCSR_REG(base), (uint32_t)(value)))
#define SCG_CLR_FIRCCSR(base, value) (BME_AND32(&SCG_FIRCCSR_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_FIRCCSR(base, value) (BME_XOR32(&SCG_FIRCCSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCCSR bitfields
 */

/*!
 * @name Register SCG_FIRCCSR, field FIRCEN[0] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC is disabled
 * - 0b1 - Fast IRC is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCEN field. */
#define SCG_RD_FIRCCSR_FIRCEN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCEN(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCEN_SHIFT, SCG_FIRCCSR_FIRCEN_WIDTH))

/*! @brief Set the FIRCEN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCEN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCEN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCEN(value)))
#define SCG_BWR_FIRCCSR_FIRCEN(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_FIRCEN_SHIFT), SCG_FIRCCSR_FIRCEN_SHIFT, SCG_FIRCCSR_FIRCEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC is disabled in Stop modes. When selected as the reference
 *     clock to the System PLL and if the System PLL is enabled in STOP mode, the
 *     Fast IRC will stay enabled even if FIRCSTEN=0.
 * - 0b1 - Fast IRC is enabled in Stop modes
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCSTEN field. */
#define SCG_RD_FIRCCSR_FIRCSTEN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCSTEN_MASK) >> SCG_FIRCCSR_FIRCSTEN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCSTEN(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCSTEN_SHIFT, SCG_FIRCCSR_FIRCSTEN_WIDTH))

/*! @brief Set the FIRCSTEN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCSTEN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCSTEN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCSTEN(value)))
#define SCG_BWR_FIRCCSR_FIRCSTEN(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_FIRCSTEN_SHIFT), SCG_FIRCCSR_FIRCSTEN_SHIFT, SCG_FIRCCSR_FIRCSTEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCREGOFF[2] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC Regulator is enabled.
 * - 0b1 - Fast IRC Regulator is disabled.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCREGOFF field. */
#define SCG_RD_FIRCCSR_FIRCREGOFF(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCREGOFF(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCREGOFF_SHIFT, SCG_FIRCCSR_FIRCREGOFF_WIDTH))

/*! @brief Set the FIRCREGOFF field to a new value. */
#define SCG_WR_FIRCCSR_FIRCREGOFF(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCREGOFF_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCREGOFF(value)))
#define SCG_BWR_FIRCCSR_FIRCREGOFF(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_FIRCREGOFF_SHIFT), SCG_FIRCCSR_FIRCREGOFF_SHIFT, SCG_FIRCCSR_FIRCREGOFF_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCLPEN[3] (RW)
 *
 * Values:
 * - 0b0 - Fast IRC is disabled in VLP modes
 * - 0b1 - Fast IRC is enabled in VLP modes
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCLPEN field. */
#define SCG_RD_FIRCCSR_FIRCLPEN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCLPEN_MASK) >> SCG_FIRCCSR_FIRCLPEN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCLPEN(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCLPEN_SHIFT, SCG_FIRCCSR_FIRCLPEN_WIDTH))

/*! @brief Set the FIRCLPEN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCLPEN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCLPEN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCLPEN(value)))
#define SCG_BWR_FIRCCSR_FIRCLPEN(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_FIRCLPEN_SHIFT), SCG_FIRCCSR_FIRCLPEN_SHIFT, SCG_FIRCCSR_FIRCLPEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCTREN[8] (RW)
 *
 * Values:
 * - 0b0 - Disable trimming Fast IRC to an external clock source
 * - 0b1 - Enable trimming Fast IRC to an external clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCTREN field. */
#define SCG_RD_FIRCCSR_FIRCTREN(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCTREN_MASK) >> SCG_FIRCCSR_FIRCTREN_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCTREN(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCTREN_SHIFT, SCG_FIRCCSR_FIRCTREN_WIDTH))

/*! @brief Set the FIRCTREN field to a new value. */
#define SCG_WR_FIRCCSR_FIRCTREN(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCTREN_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCTREN(value)))
#define SCG_BWR_FIRCCSR_FIRCTREN(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_FIRCTREN_SHIFT), SCG_FIRCCSR_FIRCTREN_SHIFT, SCG_FIRCCSR_FIRCTREN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCTRUP[9] (RW)
 *
 * Values:
 * - 0b0 - Disable Fast IRC trimming updates
 * - 0b1 - Enable Fast IRC trimming updates
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCTRUP field. */
#define SCG_RD_FIRCCSR_FIRCTRUP(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCTRUP_MASK) >> SCG_FIRCCSR_FIRCTRUP_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCTRUP(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCTRUP_SHIFT, SCG_FIRCCSR_FIRCTRUP_WIDTH))

/*! @brief Set the FIRCTRUP field to a new value. */
#define SCG_WR_FIRCCSR_FIRCTRUP(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_FIRCTRUP_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_FIRCTRUP(value)))
#define SCG_BWR_FIRCCSR_FIRCTRUP(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_FIRCTRUP_SHIFT), SCG_FIRCCSR_FIRCTRUP_SHIFT, SCG_FIRCCSR_FIRCTRUP_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until the next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_LK field. */
#define SCG_RD_FIRCCSR_LK(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_LK_MASK) >> SCG_FIRCCSR_LK_SHIFT)
#define SCG_BRD_FIRCCSR_LK(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_LK_SHIFT, SCG_FIRCCSR_LK_WIDTH))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_FIRCCSR_LK(base, value) (SCG_RMW_FIRCCSR(base, (SCG_FIRCCSR_LK_MASK | SCG_FIRCCSR_FIRCERR_MASK), SCG_FIRCCSR_LK(value)))
#define SCG_BWR_FIRCCSR_LK(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_LK_SHIFT), SCG_FIRCCSR_LK_SHIFT, SCG_FIRCCSR_LK_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCVLD[24] (RO)
 *
 * Values:
 * - 0b0 - Fast IRC is not enabled or clock is not valid
 * - 0b1 - Fast IRC is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCVLD field. */
#define SCG_RD_FIRCCSR_FIRCVLD(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCVLD(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCVLD_SHIFT, SCG_FIRCCSR_FIRCVLD_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCSEL[25] (RO)
 *
 * Values:
 * - 0b0 - Fast IRC is not the system clock source
 * - 0b1 - Fast IRC is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCSEL field. */
#define SCG_RD_FIRCCSR_FIRCSEL(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCSEL_MASK) >> SCG_FIRCCSR_FIRCSEL_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCSEL(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCSEL_SHIFT, SCG_FIRCCSR_FIRCSEL_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCCSR, field FIRCERR[26] (W1C)
 *
 * This flag is reset on Chip POR only, software can also clear this flag by
 * writing a logic one
 *
 * Values:
 * - 0b0 - Error not detected with the Fast IRC trimming.
 * - 0b1 - Error detected with the Fast IRC trimming.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCSR_FIRCERR field. */
#define SCG_RD_FIRCCSR_FIRCERR(base) ((SCG_FIRCCSR_REG(base) & SCG_FIRCCSR_FIRCERR_MASK) >> SCG_FIRCCSR_FIRCERR_SHIFT)
#define SCG_BRD_FIRCCSR_FIRCERR(base) (BME_UBFX32(&SCG_FIRCCSR_REG(base), SCG_FIRCCSR_FIRCERR_SHIFT, SCG_FIRCCSR_FIRCERR_WIDTH))

/*! @brief Set the FIRCERR field to a new value. */
#define SCG_WR_FIRCCSR_FIRCERR(base, value) (SCG_RMW_FIRCCSR(base, SCG_FIRCCSR_FIRCERR_MASK, SCG_FIRCCSR_FIRCERR(value)))
#define SCG_BWR_FIRCCSR_FIRCERR(base, value) (BME_BFI32(&SCG_FIRCCSR_REG(base), ((uint32_t)(value) << SCG_FIRCCSR_FIRCERR_SHIFT), SCG_FIRCCSR_FIRCERR_SHIFT, SCG_FIRCCSR_FIRCERR_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_FIRCDIV - Fast IRC Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCDIV - Fast IRC Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Changes to FIRCDIV should be done when FAST IRC is disabled to prevent
 * glitches to output divided clock.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCDIV register
 */
/*@{*/
#define SCG_RD_FIRCDIV(base)     (SCG_FIRCDIV_REG(base))
#define SCG_WR_FIRCDIV(base, value) (SCG_FIRCDIV_REG(base) = (value))
#define SCG_RMW_FIRCDIV(base, mask, value) (SCG_WR_FIRCDIV(base, (SCG_RD_FIRCDIV(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCDIV(base, value) (BME_OR32(&SCG_FIRCDIV_REG(base), (uint32_t)(value)))
#define SCG_CLR_FIRCDIV(base, value) (BME_AND32(&SCG_FIRCDIV_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_FIRCDIV(base, value) (BME_XOR32(&SCG_FIRCDIV_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCDIV bitfields
 */

/*!
 * @name Register SCG_FIRCDIV, field FIRCDIV1[2:0] (RW)
 *
 * Clock divider 1 for Fast IRC. Used to generate the system clock source and by
 * platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCDIV_FIRCDIV1 field. */
#define SCG_RD_FIRCDIV_FIRCDIV1(base) ((SCG_FIRCDIV_REG(base) & SCG_FIRCDIV_FIRCDIV1_MASK) >> SCG_FIRCDIV_FIRCDIV1_SHIFT)
#define SCG_BRD_FIRCDIV_FIRCDIV1(base) (BME_UBFX32(&SCG_FIRCDIV_REG(base), SCG_FIRCDIV_FIRCDIV1_SHIFT, SCG_FIRCDIV_FIRCDIV1_WIDTH))

/*! @brief Set the FIRCDIV1 field to a new value. */
#define SCG_WR_FIRCDIV_FIRCDIV1(base, value) (SCG_RMW_FIRCDIV(base, SCG_FIRCDIV_FIRCDIV1_MASK, SCG_FIRCDIV_FIRCDIV1(value)))
#define SCG_BWR_FIRCDIV_FIRCDIV1(base, value) (BME_BFI32(&SCG_FIRCDIV_REG(base), ((uint32_t)(value) << SCG_FIRCDIV_FIRCDIV1_SHIFT), SCG_FIRCDIV_FIRCDIV1_SHIFT, SCG_FIRCDIV_FIRCDIV1_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCDIV, field FIRCDIV2[10:8] (RW)
 *
 * Clock divider 2 for the Fast IRC.
 *
 * Values:
 * - 0b000 - Output disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCDIV_FIRCDIV2 field. */
#define SCG_RD_FIRCDIV_FIRCDIV2(base) ((SCG_FIRCDIV_REG(base) & SCG_FIRCDIV_FIRCDIV2_MASK) >> SCG_FIRCDIV_FIRCDIV2_SHIFT)
#define SCG_BRD_FIRCDIV_FIRCDIV2(base) (BME_UBFX32(&SCG_FIRCDIV_REG(base), SCG_FIRCDIV_FIRCDIV2_SHIFT, SCG_FIRCDIV_FIRCDIV2_WIDTH))

/*! @brief Set the FIRCDIV2 field to a new value. */
#define SCG_WR_FIRCDIV_FIRCDIV2(base, value) (SCG_RMW_FIRCDIV(base, SCG_FIRCDIV_FIRCDIV2_MASK, SCG_FIRCDIV_FIRCDIV2(value)))
#define SCG_BWR_FIRCDIV_FIRCDIV2(base, value) (BME_BFI32(&SCG_FIRCDIV_REG(base), ((uint32_t)(value) << SCG_FIRCDIV_FIRCDIV2_SHIFT), SCG_FIRCDIV_FIRCDIV2_SHIFT, SCG_FIRCDIV_FIRCDIV2_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCDIV, field FIRCDIV3[18:16] (RW)
 *
 * Clock divider 2 for the Fast IRC.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCDIV_FIRCDIV3 field. */
#define SCG_RD_FIRCDIV_FIRCDIV3(base) ((SCG_FIRCDIV_REG(base) & SCG_FIRCDIV_FIRCDIV3_MASK) >> SCG_FIRCDIV_FIRCDIV3_SHIFT)
#define SCG_BRD_FIRCDIV_FIRCDIV3(base) (BME_UBFX32(&SCG_FIRCDIV_REG(base), SCG_FIRCDIV_FIRCDIV3_SHIFT, SCG_FIRCDIV_FIRCDIV3_WIDTH))

/*! @brief Set the FIRCDIV3 field to a new value. */
#define SCG_WR_FIRCDIV_FIRCDIV3(base, value) (SCG_RMW_FIRCDIV(base, SCG_FIRCDIV_FIRCDIV3_MASK, SCG_FIRCDIV_FIRCDIV3(value)))
#define SCG_BWR_FIRCDIV_FIRCDIV3(base, value) (BME_BFI32(&SCG_FIRCDIV_REG(base), ((uint32_t)(value) << SCG_FIRCDIV_FIRCDIV3_SHIFT), SCG_FIRCDIV_FIRCDIV3_SHIFT, SCG_FIRCDIV_FIRCDIV3_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_FIRCCFG - Fast IRC Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCCFG - Fast IRC Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The FIRCCFG register cannot be changed when the Fast IRC is enabled. When the
 * Fast IRC is enabled, writes to this register are ignored, and there is no
 * transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCCFG register
 */
/*@{*/
#define SCG_RD_FIRCCFG(base)     (SCG_FIRCCFG_REG(base))
#define SCG_WR_FIRCCFG(base, value) (SCG_FIRCCFG_REG(base) = (value))
#define SCG_RMW_FIRCCFG(base, mask, value) (SCG_WR_FIRCCFG(base, (SCG_RD_FIRCCFG(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCCFG(base, value) (BME_OR32(&SCG_FIRCCFG_REG(base), (uint32_t)(value)))
#define SCG_CLR_FIRCCFG(base, value) (BME_AND32(&SCG_FIRCCFG_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_FIRCCFG(base, value) (BME_XOR32(&SCG_FIRCCFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCCFG bitfields
 */

/*!
 * @name Register SCG_FIRCCFG, field RANGE[1:0] (RW)
 *
 * Values:
 * - 0b00 - Fast IRC is trimmed to 48 MHz
 * - 0b01 - Fast IRC is trimmed to 52 MHz
 * - 0b10 - Fast IRC is trimmed to 56 MHz
 * - 0b11 - Fast IRC is trimmed to 60 MHz
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCCFG_RANGE field. */
#define SCG_RD_FIRCCFG_RANGE(base) ((SCG_FIRCCFG_REG(base) & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)
#define SCG_BRD_FIRCCFG_RANGE(base) (BME_UBFX32(&SCG_FIRCCFG_REG(base), SCG_FIRCCFG_RANGE_SHIFT, SCG_FIRCCFG_RANGE_WIDTH))

/*! @brief Set the RANGE field to a new value. */
#define SCG_WR_FIRCCFG_RANGE(base, value) (SCG_RMW_FIRCCFG(base, SCG_FIRCCFG_RANGE_MASK, SCG_FIRCCFG_RANGE(value)))
#define SCG_BWR_FIRCCFG_RANGE(base, value) (BME_BFI32(&SCG_FIRCCFG_REG(base), ((uint32_t)(value) << SCG_FIRCCFG_RANGE_SHIFT), SCG_FIRCCFG_RANGE_SHIFT, SCG_FIRCCFG_RANGE_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_FIRCTCFG - Fast IRC Trim Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCTCFG - Fast IRC Trim Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The FIRCTCFG register cannot be changed when Fast IRC tuning is enabled. When
 * the Fast IRC tuning is enabled, writes to this register are ignored, and
 * there is no transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCTCFG register
 */
/*@{*/
#define SCG_RD_FIRCTCFG(base)    (SCG_FIRCTCFG_REG(base))
#define SCG_WR_FIRCTCFG(base, value) (SCG_FIRCTCFG_REG(base) = (value))
#define SCG_RMW_FIRCTCFG(base, mask, value) (SCG_WR_FIRCTCFG(base, (SCG_RD_FIRCTCFG(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCTCFG(base, value) (BME_OR32(&SCG_FIRCTCFG_REG(base), (uint32_t)(value)))
#define SCG_CLR_FIRCTCFG(base, value) (BME_AND32(&SCG_FIRCTCFG_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_FIRCTCFG(base, value) (BME_XOR32(&SCG_FIRCTCFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCTCFG bitfields
 */

/*!
 * @name Register SCG_FIRCTCFG, field TRIMSRC[1:0] (RW)
 *
 * Configures the external clock source to tune the Fast IRC.
 *
 * Values:
 * - 0b00 - USB0 Start of Frame (1 kHz)
 * - 0b01 - USB1 Start of Frame (1 kHz)
 * - 0b10 - System OSC
 * - 0b11 - RTC OSC (32.768 kHz)
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTCFG_TRIMSRC field. */
#define SCG_RD_FIRCTCFG_TRIMSRC(base) ((SCG_FIRCTCFG_REG(base) & SCG_FIRCTCFG_TRIMSRC_MASK) >> SCG_FIRCTCFG_TRIMSRC_SHIFT)
#define SCG_BRD_FIRCTCFG_TRIMSRC(base) (BME_UBFX32(&SCG_FIRCTCFG_REG(base), SCG_FIRCTCFG_TRIMSRC_SHIFT, SCG_FIRCTCFG_TRIMSRC_WIDTH))

/*! @brief Set the TRIMSRC field to a new value. */
#define SCG_WR_FIRCTCFG_TRIMSRC(base, value) (SCG_RMW_FIRCTCFG(base, SCG_FIRCTCFG_TRIMSRC_MASK, SCG_FIRCTCFG_TRIMSRC(value)))
#define SCG_BWR_FIRCTCFG_TRIMSRC(base, value) (BME_BFI32(&SCG_FIRCTCFG_REG(base), ((uint32_t)(value) << SCG_FIRCTCFG_TRIMSRC_SHIFT), SCG_FIRCTCFG_TRIMSRC_SHIFT, SCG_FIRCTCFG_TRIMSRC_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCTCFG, field TRIMDIV[10:8] (RW)
 *
 * Divide the System OSC down for Fast IRC trimming.
 *
 * Values:
 * - 0b000 - Divide by 1
 * - 0b001 - Divide by 128
 * - 0b010 - Divide by 256
 * - 0b011 - Divide by 512
 * - 0b100 - Divide by 1024
 * - 0b101 - Divide by 2048
 * - 0b110 - Reserved. Writing this value will result in Divide by 1.
 * - 0b111 - Reserved. Writing this value will result in a Divide by 1.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCTCFG_TRIMDIV field. */
#define SCG_RD_FIRCTCFG_TRIMDIV(base) ((SCG_FIRCTCFG_REG(base) & SCG_FIRCTCFG_TRIMDIV_MASK) >> SCG_FIRCTCFG_TRIMDIV_SHIFT)
#define SCG_BRD_FIRCTCFG_TRIMDIV(base) (BME_UBFX32(&SCG_FIRCTCFG_REG(base), SCG_FIRCTCFG_TRIMDIV_SHIFT, SCG_FIRCTCFG_TRIMDIV_WIDTH))

/*! @brief Set the TRIMDIV field to a new value. */
#define SCG_WR_FIRCTCFG_TRIMDIV(base, value) (SCG_RMW_FIRCTCFG(base, SCG_FIRCTCFG_TRIMDIV_MASK, SCG_FIRCTCFG_TRIMDIV(value)))
#define SCG_BWR_FIRCTCFG_TRIMDIV(base, value) (BME_BFI32(&SCG_FIRCTCFG_REG(base), ((uint32_t)(value) << SCG_FIRCTCFG_TRIMDIV_SHIFT), SCG_FIRCTCFG_TRIMDIV_SHIFT, SCG_FIRCTCFG_TRIMDIV_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_FIRCSTAT - Fast IRC Status Register
 ******************************************************************************/

/*!
 * @brief SCG_FIRCSTAT - Fast IRC Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is loaded from IFR during reset. These register gets uploaded
 * with the trim values generated by FIRC auto trimming which is enabled when FIRC
 * is enabled and FIRCTREN=1 and FRICTRUP=1. When FIRC auto trimming is enabled
 * and FIRCTRUP is off, writes to this register is allowed and values written to
 * this register are used to trim FIRC clock.
 */
/*!
 * @name Constants and macros for entire SCG_FIRCSTAT register
 */
/*@{*/
#define SCG_RD_FIRCSTAT(base)    (SCG_FIRCSTAT_REG(base))
#define SCG_WR_FIRCSTAT(base, value) (SCG_FIRCSTAT_REG(base) = (value))
#define SCG_RMW_FIRCSTAT(base, mask, value) (SCG_WR_FIRCSTAT(base, (SCG_RD_FIRCSTAT(base) & ~(mask)) | (value)))
#define SCG_SET_FIRCSTAT(base, value) (BME_OR32(&SCG_FIRCSTAT_REG(base), (uint32_t)(value)))
#define SCG_CLR_FIRCSTAT(base, value) (BME_AND32(&SCG_FIRCSTAT_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_FIRCSTAT(base, value) (BME_XOR32(&SCG_FIRCSTAT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_FIRCSTAT bitfields
 */

/*!
 * @name Register SCG_FIRCSTAT, field TRIMFINE[6:0] (RW)
 *
 * When FIRC is enabled and auto trimming is enabled (FIRCTREN=1 and FIRCTRUP=1)
 * these register gets uploaded with the trimmed coarse value. When FIRCTRUP=0,
 * these register is writeable to allow user programming of fine trim values.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCSTAT_TRIMFINE field. */
#define SCG_RD_FIRCSTAT_TRIMFINE(base) ((SCG_FIRCSTAT_REG(base) & SCG_FIRCSTAT_TRIMFINE_MASK) >> SCG_FIRCSTAT_TRIMFINE_SHIFT)
#define SCG_BRD_FIRCSTAT_TRIMFINE(base) (BME_UBFX32(&SCG_FIRCSTAT_REG(base), SCG_FIRCSTAT_TRIMFINE_SHIFT, SCG_FIRCSTAT_TRIMFINE_WIDTH))

/*! @brief Set the TRIMFINE field to a new value. */
#define SCG_WR_FIRCSTAT_TRIMFINE(base, value) (SCG_RMW_FIRCSTAT(base, SCG_FIRCSTAT_TRIMFINE_MASK, SCG_FIRCSTAT_TRIMFINE(value)))
#define SCG_BWR_FIRCSTAT_TRIMFINE(base, value) (BME_BFI32(&SCG_FIRCSTAT_REG(base), ((uint32_t)(value) << SCG_FIRCSTAT_TRIMFINE_SHIFT), SCG_FIRCSTAT_TRIMFINE_SHIFT, SCG_FIRCSTAT_TRIMFINE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_FIRCSTAT, field TRIMCOAR[15:8] (RW)
 *
 * When FIRC is enabled and auto trimming is enabled (FIRCTREN=1 and FIRCTRUP=1)
 * these register gets uploaded with the trimmed coarse value. When FIRCTRUP=0,
 * these register is writable to allow user programming of coarse trim values.
 */
/*@{*/
/*! @brief Read current value of the SCG_FIRCSTAT_TRIMCOAR field. */
#define SCG_RD_FIRCSTAT_TRIMCOAR(base) ((SCG_FIRCSTAT_REG(base) & SCG_FIRCSTAT_TRIMCOAR_MASK) >> SCG_FIRCSTAT_TRIMCOAR_SHIFT)
#define SCG_BRD_FIRCSTAT_TRIMCOAR(base) (BME_UBFX32(&SCG_FIRCSTAT_REG(base), SCG_FIRCSTAT_TRIMCOAR_SHIFT, SCG_FIRCSTAT_TRIMCOAR_WIDTH))

/*! @brief Set the TRIMCOAR field to a new value. */
#define SCG_WR_FIRCSTAT_TRIMCOAR(base, value) (SCG_RMW_FIRCSTAT(base, SCG_FIRCSTAT_TRIMCOAR_MASK, SCG_FIRCSTAT_TRIMCOAR(value)))
#define SCG_BWR_FIRCSTAT_TRIMCOAR(base, value) (BME_BFI32(&SCG_FIRCSTAT_REG(base), ((uint32_t)(value) << SCG_FIRCSTAT_TRIMCOAR_SHIFT), SCG_FIRCSTAT_TRIMCOAR_SHIFT, SCG_FIRCSTAT_TRIMCOAR_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SPLLCSR - System PLL Control Status Register
 ******************************************************************************/

/*!
 * @brief SCG_SPLLCSR - System PLL Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SCG_SPLLCSR register
 */
/*@{*/
#define SCG_RD_SPLLCSR(base)     (SCG_SPLLCSR_REG(base))
#define SCG_WR_SPLLCSR(base, value) (SCG_SPLLCSR_REG(base) = (value))
#define SCG_RMW_SPLLCSR(base, mask, value) (SCG_WR_SPLLCSR(base, (SCG_RD_SPLLCSR(base) & ~(mask)) | (value)))
#define SCG_SET_SPLLCSR(base, value) (BME_OR32(&SCG_SPLLCSR_REG(base), (uint32_t)(value)))
#define SCG_CLR_SPLLCSR(base, value) (BME_AND32(&SCG_SPLLCSR_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SPLLCSR(base, value) (BME_XOR32(&SCG_SPLLCSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SPLLCSR bitfields
 */

/*!
 * @name Register SCG_SPLLCSR, field SPLLEN[0] (RW)
 *
 * Values:
 * - 0b0 - System PLL is disabled
 * - 0b1 - System PLL is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLEN field. */
#define SCG_RD_SPLLCSR_SPLLEN(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLEN(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLEN_SHIFT, SCG_SPLLCSR_SPLLEN_WIDTH))

/*! @brief Set the SPLLEN field to a new value. */
#define SCG_WR_SPLLCSR_SPLLEN(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLEN_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLEN(value)))
#define SCG_BWR_SPLLCSR_SPLLEN(base, value) (BME_BFI32(&SCG_SPLLCSR_REG(base), ((uint32_t)(value) << SCG_SPLLCSR_SPLLEN_SHIFT), SCG_SPLLCSR_SPLLEN_SHIFT, SCG_SPLLCSR_SPLLEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLSTEN[1] (RW)
 *
 * Values:
 * - 0b0 - System PLL is disabled in Stop modes
 * - 0b1 - System PLL is enabled in Stop modes
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLSTEN field. */
#define SCG_RD_SPLLCSR_SPLLSTEN(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLSTEN_MASK) >> SCG_SPLLCSR_SPLLSTEN_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLSTEN(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLSTEN_SHIFT, SCG_SPLLCSR_SPLLSTEN_WIDTH))

/*! @brief Set the SPLLSTEN field to a new value. */
#define SCG_WR_SPLLCSR_SPLLSTEN(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLSTEN_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLSTEN(value)))
#define SCG_BWR_SPLLCSR_SPLLSTEN(base, value) (BME_BFI32(&SCG_SPLLCSR_REG(base), ((uint32_t)(value) << SCG_SPLLCSR_SPLLSTEN_SHIFT), SCG_SPLLCSR_SPLLSTEN_SHIFT, SCG_SPLLCSR_SPLLSTEN_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLCM[16] (RW)
 *
 * Enables the clock monitor, if the clock source is disabled in a low power
 * mode then the clock monitor is also disabled in the low power mode. The clock
 * monitor is always disabled in LLS/VLLS modes. When the clock monitor is disabled
 * in a low power mode, it remains disabled until the clock valid flag is set
 * following exit from the low power mode.
 *
 * Values:
 * - 0b0 - System PLL Clock Monitor is disabled
 * - 0b1 - System PLL Clock Monitor is enabled
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLCM field. */
#define SCG_RD_SPLLCSR_SPLLCM(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLCM_MASK) >> SCG_SPLLCSR_SPLLCM_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLCM(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLCM_SHIFT, SCG_SPLLCSR_SPLLCM_WIDTH))

/*! @brief Set the SPLLCM field to a new value. */
#define SCG_WR_SPLLCSR_SPLLCM(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLCM_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLCM(value)))
#define SCG_BWR_SPLLCSR_SPLLCM(base, value) (BME_BFI32(&SCG_SPLLCSR_REG(base), ((uint32_t)(value) << SCG_SPLLCSR_SPLLCM_SHIFT), SCG_SPLLCSR_SPLLCM_SHIFT, SCG_SPLLCSR_SPLLCM_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLCMRE[17] (RW)
 *
 * Values:
 * - 0b0 - Clock Monitor generates interrupt when error detected
 * - 0b1 - Clock Monitor generates reset when error detected
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLCMRE field. */
#define SCG_RD_SPLLCSR_SPLLCMRE(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLCMRE_MASK) >> SCG_SPLLCSR_SPLLCMRE_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLCMRE(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLCMRE_SHIFT, SCG_SPLLCSR_SPLLCMRE_WIDTH))

/*! @brief Set the SPLLCMRE field to a new value. */
#define SCG_WR_SPLLCSR_SPLLCMRE(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_SPLLCMRE_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_SPLLCMRE(value)))
#define SCG_BWR_SPLLCSR_SPLLCMRE(base, value) (BME_BFI32(&SCG_SPLLCSR_REG(base), ((uint32_t)(value) << SCG_SPLLCSR_SPLLCMRE_SHIFT), SCG_SPLLCSR_SPLLCMRE_SHIFT, SCG_SPLLCSR_SPLLCMRE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field LK[23] (RW)
 *
 * Values:
 * - 0b0 - Control Status Register can be written.
 * - 0b1 - Control Status Register cannot be written until the next System Reset.
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_LK field. */
#define SCG_RD_SPLLCSR_LK(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_LK_MASK) >> SCG_SPLLCSR_LK_SHIFT)
#define SCG_BRD_SPLLCSR_LK(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_LK_SHIFT, SCG_SPLLCSR_LK_WIDTH))

/*! @brief Set the LK field to a new value. */
#define SCG_WR_SPLLCSR_LK(base, value) (SCG_RMW_SPLLCSR(base, (SCG_SPLLCSR_LK_MASK | SCG_SPLLCSR_SPLLERR_MASK), SCG_SPLLCSR_LK(value)))
#define SCG_BWR_SPLLCSR_LK(base, value) (BME_BFI32(&SCG_SPLLCSR_REG(base), ((uint32_t)(value) << SCG_SPLLCSR_LK_SHIFT), SCG_SPLLCSR_LK_SHIFT, SCG_SPLLCSR_LK_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLVLD[24] (RO)
 *
 * Indicates when the SPLL clock is valid. Disabling the SPLL or a SOSC error
 * when selected as the reference clock to the SPLL will cause the SPLLVLD to clear
 * without setting SPLLERROR.
 *
 * Values:
 * - 0b0 - System PLL is not enabled or clock is not valid
 * - 0b1 - System PLL is enabled and output clock is valid
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLVLD field. */
#define SCG_RD_SPLLCSR_SPLLVLD(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLVLD(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLVLD_SHIFT, SCG_SPLLCSR_SPLLVLD_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLSEL[25] (RO)
 *
 * Values:
 * - 0b0 - System PLL is not the system clock source
 * - 0b1 - System PLL is the system clock source
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLSEL field. */
#define SCG_RD_SPLLCSR_SPLLSEL(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLSEL_MASK) >> SCG_SPLLCSR_SPLLSEL_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLSEL(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLSEL_SHIFT, SCG_SPLLCSR_SPLLSEL_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCSR, field SPLLERR[26] (W1C)
 *
 * This flag is reset on Chip POR only, software can also clear this flag by
 * writing a logic one
 *
 * Values:
 * - 0b0 - System PLL Clock Monitor is disabled or has not detected an error
 * - 0b1 - System PLL Clock Monitor is enabled and detected an error. System PLL
 *     Clock Error flag will not set when System OSC is selected as its source
 *     and SOSCERR has set.
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCSR_SPLLERR field. */
#define SCG_RD_SPLLCSR_SPLLERR(base) ((SCG_SPLLCSR_REG(base) & SCG_SPLLCSR_SPLLERR_MASK) >> SCG_SPLLCSR_SPLLERR_SHIFT)
#define SCG_BRD_SPLLCSR_SPLLERR(base) (BME_UBFX32(&SCG_SPLLCSR_REG(base), SCG_SPLLCSR_SPLLERR_SHIFT, SCG_SPLLCSR_SPLLERR_WIDTH))

/*! @brief Set the SPLLERR field to a new value. */
#define SCG_WR_SPLLCSR_SPLLERR(base, value) (SCG_RMW_SPLLCSR(base, SCG_SPLLCSR_SPLLERR_MASK, SCG_SPLLCSR_SPLLERR(value)))
#define SCG_BWR_SPLLCSR_SPLLERR(base, value) (BME_BFI32(&SCG_SPLLCSR_REG(base), ((uint32_t)(value) << SCG_SPLLCSR_SPLLERR_SHIFT), SCG_SPLLCSR_SPLLERR_SHIFT, SCG_SPLLCSR_SPLLERR_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SPLLDIV - System PLL Divide Register
 ******************************************************************************/

/*!
 * @brief SCG_SPLLDIV - System PLL Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Changes to SPLLDIV should be done when System PLL is disabled to prevent
 * glitches to output divided clock.
 */
/*!
 * @name Constants and macros for entire SCG_SPLLDIV register
 */
/*@{*/
#define SCG_RD_SPLLDIV(base)     (SCG_SPLLDIV_REG(base))
#define SCG_WR_SPLLDIV(base, value) (SCG_SPLLDIV_REG(base) = (value))
#define SCG_RMW_SPLLDIV(base, mask, value) (SCG_WR_SPLLDIV(base, (SCG_RD_SPLLDIV(base) & ~(mask)) | (value)))
#define SCG_SET_SPLLDIV(base, value) (BME_OR32(&SCG_SPLLDIV_REG(base), (uint32_t)(value)))
#define SCG_CLR_SPLLDIV(base, value) (BME_AND32(&SCG_SPLLDIV_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SPLLDIV(base, value) (BME_XOR32(&SCG_SPLLDIV_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SPLLDIV bitfields
 */

/*!
 * @name Register SCG_SPLLDIV, field SPLLDIV1[2:0] (RW)
 *
 * Clock divider 1 for System PLL. Used to generate the system clock source used
 * by platform clock modules that need an asynchronous clock source.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLDIV_SPLLDIV1 field. */
#define SCG_RD_SPLLDIV_SPLLDIV1(base) ((SCG_SPLLDIV_REG(base) & SCG_SPLLDIV_SPLLDIV1_MASK) >> SCG_SPLLDIV_SPLLDIV1_SHIFT)
#define SCG_BRD_SPLLDIV_SPLLDIV1(base) (BME_UBFX32(&SCG_SPLLDIV_REG(base), SCG_SPLLDIV_SPLLDIV1_SHIFT, SCG_SPLLDIV_SPLLDIV1_WIDTH))

/*! @brief Set the SPLLDIV1 field to a new value. */
#define SCG_WR_SPLLDIV_SPLLDIV1(base, value) (SCG_RMW_SPLLDIV(base, SCG_SPLLDIV_SPLLDIV1_MASK, SCG_SPLLDIV_SPLLDIV1(value)))
#define SCG_BWR_SPLLDIV_SPLLDIV1(base, value) (BME_BFI32(&SCG_SPLLDIV_REG(base), ((uint32_t)(value) << SCG_SPLLDIV_SPLLDIV1_SHIFT), SCG_SPLLDIV_SPLLDIV1_SHIFT, SCG_SPLLDIV_SPLLDIV1_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLDIV, field SPLLDIV2[10:8] (RW)
 *
 * Clock divider 2 for System PLL.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLDIV_SPLLDIV2 field. */
#define SCG_RD_SPLLDIV_SPLLDIV2(base) ((SCG_SPLLDIV_REG(base) & SCG_SPLLDIV_SPLLDIV2_MASK) >> SCG_SPLLDIV_SPLLDIV2_SHIFT)
#define SCG_BRD_SPLLDIV_SPLLDIV2(base) (BME_UBFX32(&SCG_SPLLDIV_REG(base), SCG_SPLLDIV_SPLLDIV2_SHIFT, SCG_SPLLDIV_SPLLDIV2_WIDTH))

/*! @brief Set the SPLLDIV2 field to a new value. */
#define SCG_WR_SPLLDIV_SPLLDIV2(base, value) (SCG_RMW_SPLLDIV(base, SCG_SPLLDIV_SPLLDIV2_MASK, SCG_SPLLDIV_SPLLDIV2(value)))
#define SCG_BWR_SPLLDIV_SPLLDIV2(base, value) (BME_BFI32(&SCG_SPLLDIV_REG(base), ((uint32_t)(value) << SCG_SPLLDIV_SPLLDIV2_SHIFT), SCG_SPLLDIV_SPLLDIV2_SHIFT, SCG_SPLLDIV_SPLLDIV2_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLDIV, field SPLLDIV3[18:16] (RW)
 *
 * Clock divider 3 for System PLL.
 *
 * Values:
 * - 0b000 - Clock disabled
 * - 0b001 - Divide by 1
 * - 0b010 - Divide by 2
 * - 0b011 - Divide by 4
 * - 0b100 - Divide by 8
 * - 0b101 - Divide by 16
 * - 0b110 - Divide by 32
 * - 0b111 - Divide by 64
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLDIV_SPLLDIV3 field. */
#define SCG_RD_SPLLDIV_SPLLDIV3(base) ((SCG_SPLLDIV_REG(base) & SCG_SPLLDIV_SPLLDIV3_MASK) >> SCG_SPLLDIV_SPLLDIV3_SHIFT)
#define SCG_BRD_SPLLDIV_SPLLDIV3(base) (BME_UBFX32(&SCG_SPLLDIV_REG(base), SCG_SPLLDIV_SPLLDIV3_SHIFT, SCG_SPLLDIV_SPLLDIV3_WIDTH))

/*! @brief Set the SPLLDIV3 field to a new value. */
#define SCG_WR_SPLLDIV_SPLLDIV3(base, value) (SCG_RMW_SPLLDIV(base, SCG_SPLLDIV_SPLLDIV3_MASK, SCG_SPLLDIV_SPLLDIV3(value)))
#define SCG_BWR_SPLLDIV_SPLLDIV3(base, value) (BME_BFI32(&SCG_SPLLDIV_REG(base), ((uint32_t)(value) << SCG_SPLLDIV_SPLLDIV3_SHIFT), SCG_SPLLDIV_SPLLDIV3_SHIFT, SCG_SPLLDIV_SPLLDIV3_WIDTH))
/*@}*/

/*******************************************************************************
 * SCG_SPLLCFG - System PLL Configuration Register
 ******************************************************************************/

/*!
 * @brief SCG_SPLLCFG - System PLL Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SPLLCFG register cannot be changed when the System PLL is enabled. When
 * the System PLL is enabled, writes to this register are ignored, and there is no
 * transfer error.
 */
/*!
 * @name Constants and macros for entire SCG_SPLLCFG register
 */
/*@{*/
#define SCG_RD_SPLLCFG(base)     (SCG_SPLLCFG_REG(base))
#define SCG_WR_SPLLCFG(base, value) (SCG_SPLLCFG_REG(base) = (value))
#define SCG_RMW_SPLLCFG(base, mask, value) (SCG_WR_SPLLCFG(base, (SCG_RD_SPLLCFG(base) & ~(mask)) | (value)))
#define SCG_SET_SPLLCFG(base, value) (BME_OR32(&SCG_SPLLCFG_REG(base), (uint32_t)(value)))
#define SCG_CLR_SPLLCFG(base, value) (BME_AND32(&SCG_SPLLCFG_REG(base), (uint32_t)(~(value))))
#define SCG_TOG_SPLLCFG(base, value) (BME_XOR32(&SCG_SPLLCFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SCG_SPLLCFG bitfields
 */

/*!
 * @name Register SCG_SPLLCFG, field SOURCE[0] (RW)
 *
 * Configures the input clock source for the System PLL.
 *
 * Values:
 * - 0b0 - System OSC
 * - 0b1 - Fast IRC
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCFG_SOURCE field. */
#define SCG_RD_SPLLCFG_SOURCE(base) ((SCG_SPLLCFG_REG(base) & SCG_SPLLCFG_SOURCE_MASK) >> SCG_SPLLCFG_SOURCE_SHIFT)
#define SCG_BRD_SPLLCFG_SOURCE(base) (BME_UBFX32(&SCG_SPLLCFG_REG(base), SCG_SPLLCFG_SOURCE_SHIFT, SCG_SPLLCFG_SOURCE_WIDTH))

/*! @brief Set the SOURCE field to a new value. */
#define SCG_WR_SPLLCFG_SOURCE(base, value) (SCG_RMW_SPLLCFG(base, SCG_SPLLCFG_SOURCE_MASK, SCG_SPLLCFG_SOURCE(value)))
#define SCG_BWR_SPLLCFG_SOURCE(base, value) (BME_BFI32(&SCG_SPLLCFG_REG(base), ((uint32_t)(value) << SCG_SPLLCFG_SOURCE_SHIFT), SCG_SPLLCFG_SOURCE_SHIFT, SCG_SPLLCFG_SOURCE_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCFG, field PREDIV[10:8] (RW)
 *
 * Selects the amount to divide down the reference clock for the System PLL. The
 * resulting frequency must be in the range of 8 MHz to 32 MHz. System PLL
 * Reference Divide Factor PERDIV Divide Factor 000 1 001 2 010 3 011 4 100 5 101 6
 * 110 7 111 8
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCFG_PREDIV field. */
#define SCG_RD_SPLLCFG_PREDIV(base) ((SCG_SPLLCFG_REG(base) & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT)
#define SCG_BRD_SPLLCFG_PREDIV(base) (BME_UBFX32(&SCG_SPLLCFG_REG(base), SCG_SPLLCFG_PREDIV_SHIFT, SCG_SPLLCFG_PREDIV_WIDTH))

/*! @brief Set the PREDIV field to a new value. */
#define SCG_WR_SPLLCFG_PREDIV(base, value) (SCG_RMW_SPLLCFG(base, SCG_SPLLCFG_PREDIV_MASK, SCG_SPLLCFG_PREDIV(value)))
#define SCG_BWR_SPLLCFG_PREDIV(base, value) (BME_BFI32(&SCG_SPLLCFG_REG(base), ((uint32_t)(value) << SCG_SPLLCFG_PREDIV_SHIFT), SCG_SPLLCFG_PREDIV_SHIFT, SCG_SPLLCFG_PREDIV_WIDTH))
/*@}*/

/*!
 * @name Register SCG_SPLLCFG, field MULT[20:16] (RW)
 *
 * Multiplier for the System PLL. The MULT bits establish the multiplication
 * factor applied to the PLL reference clock frequency. PLL VCO Multiply Factor MULT
 * Multiply Factor MULT Multiply Factor MULT Multiply Factor MULT Multiply
 * Factor 00000 16 01000 24 10000 32 11000 40 00001 17 01001 25 10001 33 11001 41
 * 00010 18 01010 26 10010 34 11010 42 00011 19 01011 27 10011 35 11011 43 00100 20
 * 01100 28 10100 36 11100 44 00101 21 01101 29 10101 37 11101 45 00110 22 01110
 * 30 10110 38 11110 46 00111 23 01111 31 10111 39 11111 47
 */
/*@{*/
/*! @brief Read current value of the SCG_SPLLCFG_MULT field. */
#define SCG_RD_SPLLCFG_MULT(base) ((SCG_SPLLCFG_REG(base) & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT)
#define SCG_BRD_SPLLCFG_MULT(base) (BME_UBFX32(&SCG_SPLLCFG_REG(base), SCG_SPLLCFG_MULT_SHIFT, SCG_SPLLCFG_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define SCG_WR_SPLLCFG_MULT(base, value) (SCG_RMW_SPLLCFG(base, SCG_SPLLCFG_MULT_MASK, SCG_SPLLCFG_MULT(value)))
#define SCG_BWR_SPLLCFG_MULT(base, value) (BME_BFI32(&SCG_SPLLCFG_REG(base), ((uint32_t)(value) << SCG_SPLLCFG_MULT_SHIFT), SCG_SPLLCFG_MULT_SHIFT, SCG_SPLLCFG_MULT_WIDTH))
/*@}*/

/*
 * MKL28Z7 SEMA42
 *
 * SEMA42
 *
 * Registers defined in this header file:
 * - SEMA42_GATE3 - Gate Register
 * - SEMA42_GATE2 - Gate Register
 * - SEMA42_GATE1 - Gate Register
 * - SEMA42_GATE0 - Gate Register
 * - SEMA42_GATE7 - Gate Register
 * - SEMA42_GATE6 - Gate Register
 * - SEMA42_GATE5 - Gate Register
 * - SEMA42_GATE4 - Gate Register
 * - SEMA42_GATE11 - Gate Register
 * - SEMA42_GATE10 - Gate Register
 * - SEMA42_GATE9 - Gate Register
 * - SEMA42_GATE8 - Gate Register
 * - SEMA42_GATE15 - Gate Register
 * - SEMA42_GATE14 - Gate Register
 * - SEMA42_GATE13 - Gate Register
 * - SEMA42_GATE12 - Gate Register
 * - SEMA42_RSTGT_R - Reset Gate Read
 * - SEMA42_RSTGT_W - Reset Gate Write
 */

#define SEMA42_INSTANCE_COUNT (2U) /*!< Number of instances of the SEMA42 module. */
#define SEMA420_IDX (0U) /*!< Instance number for SEMA420. */
#define SEMA421_IDX (1U) /*!< Instance number for SEMA421. */

/*******************************************************************************
 * SEMA42_GATE3 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE3 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE3 register
 */
/*@{*/
#define SEMA42_RD_GATE3(base)    (SEMA42_GATE3_REG(base))
#define SEMA42_WR_GATE3(base, value) (SEMA42_GATE3_REG(base) = (value))
#define SEMA42_RMW_GATE3(base, mask, value) (SEMA42_WR_GATE3(base, (SEMA42_RD_GATE3(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE3(base, value) (BME_OR8(&SEMA42_GATE3_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE3(base, value) (BME_AND8(&SEMA42_GATE3_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE3(base, value) (BME_XOR8(&SEMA42_GATE3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE3 bitfields
 */

/*!
 * @name Register SEMA42_GATE3, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE3_GTFSM field. */
#define SEMA42_RD_GATE3_GTFSM(base) ((SEMA42_GATE3_REG(base) & SEMA42_GATE3_GTFSM_MASK) >> SEMA42_GATE3_GTFSM_SHIFT)
#define SEMA42_BRD_GATE3_GTFSM(base) (BME_UBFX8(&SEMA42_GATE3_REG(base), SEMA42_GATE3_GTFSM_SHIFT, SEMA42_GATE3_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE3_GTFSM(base, value) (SEMA42_RMW_GATE3(base, SEMA42_GATE3_GTFSM_MASK, SEMA42_GATE3_GTFSM(value)))
#define SEMA42_BWR_GATE3_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE3_REG(base), ((uint8_t)(value) << SEMA42_GATE3_GTFSM_SHIFT), SEMA42_GATE3_GTFSM_SHIFT, SEMA42_GATE3_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE2 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE2 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE2 register
 */
/*@{*/
#define SEMA42_RD_GATE2(base)    (SEMA42_GATE2_REG(base))
#define SEMA42_WR_GATE2(base, value) (SEMA42_GATE2_REG(base) = (value))
#define SEMA42_RMW_GATE2(base, mask, value) (SEMA42_WR_GATE2(base, (SEMA42_RD_GATE2(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE2(base, value) (BME_OR8(&SEMA42_GATE2_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE2(base, value) (BME_AND8(&SEMA42_GATE2_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE2(base, value) (BME_XOR8(&SEMA42_GATE2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE2 bitfields
 */

/*!
 * @name Register SEMA42_GATE2, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE2_GTFSM field. */
#define SEMA42_RD_GATE2_GTFSM(base) ((SEMA42_GATE2_REG(base) & SEMA42_GATE2_GTFSM_MASK) >> SEMA42_GATE2_GTFSM_SHIFT)
#define SEMA42_BRD_GATE2_GTFSM(base) (BME_UBFX8(&SEMA42_GATE2_REG(base), SEMA42_GATE2_GTFSM_SHIFT, SEMA42_GATE2_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE2_GTFSM(base, value) (SEMA42_RMW_GATE2(base, SEMA42_GATE2_GTFSM_MASK, SEMA42_GATE2_GTFSM(value)))
#define SEMA42_BWR_GATE2_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE2_REG(base), ((uint8_t)(value) << SEMA42_GATE2_GTFSM_SHIFT), SEMA42_GATE2_GTFSM_SHIFT, SEMA42_GATE2_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE1 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE1 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE1 register
 */
/*@{*/
#define SEMA42_RD_GATE1(base)    (SEMA42_GATE1_REG(base))
#define SEMA42_WR_GATE1(base, value) (SEMA42_GATE1_REG(base) = (value))
#define SEMA42_RMW_GATE1(base, mask, value) (SEMA42_WR_GATE1(base, (SEMA42_RD_GATE1(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE1(base, value) (BME_OR8(&SEMA42_GATE1_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE1(base, value) (BME_AND8(&SEMA42_GATE1_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE1(base, value) (BME_XOR8(&SEMA42_GATE1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE1 bitfields
 */

/*!
 * @name Register SEMA42_GATE1, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE1_GTFSM field. */
#define SEMA42_RD_GATE1_GTFSM(base) ((SEMA42_GATE1_REG(base) & SEMA42_GATE1_GTFSM_MASK) >> SEMA42_GATE1_GTFSM_SHIFT)
#define SEMA42_BRD_GATE1_GTFSM(base) (BME_UBFX8(&SEMA42_GATE1_REG(base), SEMA42_GATE1_GTFSM_SHIFT, SEMA42_GATE1_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE1_GTFSM(base, value) (SEMA42_RMW_GATE1(base, SEMA42_GATE1_GTFSM_MASK, SEMA42_GATE1_GTFSM(value)))
#define SEMA42_BWR_GATE1_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE1_REG(base), ((uint8_t)(value) << SEMA42_GATE1_GTFSM_SHIFT), SEMA42_GATE1_GTFSM_SHIFT, SEMA42_GATE1_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE0 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE0 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE0 register
 */
/*@{*/
#define SEMA42_RD_GATE0(base)    (SEMA42_GATE0_REG(base))
#define SEMA42_WR_GATE0(base, value) (SEMA42_GATE0_REG(base) = (value))
#define SEMA42_RMW_GATE0(base, mask, value) (SEMA42_WR_GATE0(base, (SEMA42_RD_GATE0(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE0(base, value) (BME_OR8(&SEMA42_GATE0_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE0(base, value) (BME_AND8(&SEMA42_GATE0_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE0(base, value) (BME_XOR8(&SEMA42_GATE0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE0 bitfields
 */

/*!
 * @name Register SEMA42_GATE0, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE0_GTFSM field. */
#define SEMA42_RD_GATE0_GTFSM(base) ((SEMA42_GATE0_REG(base) & SEMA42_GATE0_GTFSM_MASK) >> SEMA42_GATE0_GTFSM_SHIFT)
#define SEMA42_BRD_GATE0_GTFSM(base) (BME_UBFX8(&SEMA42_GATE0_REG(base), SEMA42_GATE0_GTFSM_SHIFT, SEMA42_GATE0_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE0_GTFSM(base, value) (SEMA42_RMW_GATE0(base, SEMA42_GATE0_GTFSM_MASK, SEMA42_GATE0_GTFSM(value)))
#define SEMA42_BWR_GATE0_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE0_REG(base), ((uint8_t)(value) << SEMA42_GATE0_GTFSM_SHIFT), SEMA42_GATE0_GTFSM_SHIFT, SEMA42_GATE0_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE7 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE7 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE7 register
 */
/*@{*/
#define SEMA42_RD_GATE7(base)    (SEMA42_GATE7_REG(base))
#define SEMA42_WR_GATE7(base, value) (SEMA42_GATE7_REG(base) = (value))
#define SEMA42_RMW_GATE7(base, mask, value) (SEMA42_WR_GATE7(base, (SEMA42_RD_GATE7(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE7(base, value) (BME_OR8(&SEMA42_GATE7_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE7(base, value) (BME_AND8(&SEMA42_GATE7_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE7(base, value) (BME_XOR8(&SEMA42_GATE7_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE7 bitfields
 */

/*!
 * @name Register SEMA42_GATE7, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE7_GTFSM field. */
#define SEMA42_RD_GATE7_GTFSM(base) ((SEMA42_GATE7_REG(base) & SEMA42_GATE7_GTFSM_MASK) >> SEMA42_GATE7_GTFSM_SHIFT)
#define SEMA42_BRD_GATE7_GTFSM(base) (BME_UBFX8(&SEMA42_GATE7_REG(base), SEMA42_GATE7_GTFSM_SHIFT, SEMA42_GATE7_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE7_GTFSM(base, value) (SEMA42_RMW_GATE7(base, SEMA42_GATE7_GTFSM_MASK, SEMA42_GATE7_GTFSM(value)))
#define SEMA42_BWR_GATE7_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE7_REG(base), ((uint8_t)(value) << SEMA42_GATE7_GTFSM_SHIFT), SEMA42_GATE7_GTFSM_SHIFT, SEMA42_GATE7_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE6 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE6 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE6 register
 */
/*@{*/
#define SEMA42_RD_GATE6(base)    (SEMA42_GATE6_REG(base))
#define SEMA42_WR_GATE6(base, value) (SEMA42_GATE6_REG(base) = (value))
#define SEMA42_RMW_GATE6(base, mask, value) (SEMA42_WR_GATE6(base, (SEMA42_RD_GATE6(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE6(base, value) (BME_OR8(&SEMA42_GATE6_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE6(base, value) (BME_AND8(&SEMA42_GATE6_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE6(base, value) (BME_XOR8(&SEMA42_GATE6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE6 bitfields
 */

/*!
 * @name Register SEMA42_GATE6, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE6_GTFSM field. */
#define SEMA42_RD_GATE6_GTFSM(base) ((SEMA42_GATE6_REG(base) & SEMA42_GATE6_GTFSM_MASK) >> SEMA42_GATE6_GTFSM_SHIFT)
#define SEMA42_BRD_GATE6_GTFSM(base) (BME_UBFX8(&SEMA42_GATE6_REG(base), SEMA42_GATE6_GTFSM_SHIFT, SEMA42_GATE6_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE6_GTFSM(base, value) (SEMA42_RMW_GATE6(base, SEMA42_GATE6_GTFSM_MASK, SEMA42_GATE6_GTFSM(value)))
#define SEMA42_BWR_GATE6_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE6_REG(base), ((uint8_t)(value) << SEMA42_GATE6_GTFSM_SHIFT), SEMA42_GATE6_GTFSM_SHIFT, SEMA42_GATE6_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE5 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE5 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE5 register
 */
/*@{*/
#define SEMA42_RD_GATE5(base)    (SEMA42_GATE5_REG(base))
#define SEMA42_WR_GATE5(base, value) (SEMA42_GATE5_REG(base) = (value))
#define SEMA42_RMW_GATE5(base, mask, value) (SEMA42_WR_GATE5(base, (SEMA42_RD_GATE5(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE5(base, value) (BME_OR8(&SEMA42_GATE5_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE5(base, value) (BME_AND8(&SEMA42_GATE5_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE5(base, value) (BME_XOR8(&SEMA42_GATE5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE5 bitfields
 */

/*!
 * @name Register SEMA42_GATE5, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE5_GTFSM field. */
#define SEMA42_RD_GATE5_GTFSM(base) ((SEMA42_GATE5_REG(base) & SEMA42_GATE5_GTFSM_MASK) >> SEMA42_GATE5_GTFSM_SHIFT)
#define SEMA42_BRD_GATE5_GTFSM(base) (BME_UBFX8(&SEMA42_GATE5_REG(base), SEMA42_GATE5_GTFSM_SHIFT, SEMA42_GATE5_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE5_GTFSM(base, value) (SEMA42_RMW_GATE5(base, SEMA42_GATE5_GTFSM_MASK, SEMA42_GATE5_GTFSM(value)))
#define SEMA42_BWR_GATE5_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE5_REG(base), ((uint8_t)(value) << SEMA42_GATE5_GTFSM_SHIFT), SEMA42_GATE5_GTFSM_SHIFT, SEMA42_GATE5_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE4 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE4 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE4 register
 */
/*@{*/
#define SEMA42_RD_GATE4(base)    (SEMA42_GATE4_REG(base))
#define SEMA42_WR_GATE4(base, value) (SEMA42_GATE4_REG(base) = (value))
#define SEMA42_RMW_GATE4(base, mask, value) (SEMA42_WR_GATE4(base, (SEMA42_RD_GATE4(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE4(base, value) (BME_OR8(&SEMA42_GATE4_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE4(base, value) (BME_AND8(&SEMA42_GATE4_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE4(base, value) (BME_XOR8(&SEMA42_GATE4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE4 bitfields
 */

/*!
 * @name Register SEMA42_GATE4, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE4_GTFSM field. */
#define SEMA42_RD_GATE4_GTFSM(base) ((SEMA42_GATE4_REG(base) & SEMA42_GATE4_GTFSM_MASK) >> SEMA42_GATE4_GTFSM_SHIFT)
#define SEMA42_BRD_GATE4_GTFSM(base) (BME_UBFX8(&SEMA42_GATE4_REG(base), SEMA42_GATE4_GTFSM_SHIFT, SEMA42_GATE4_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE4_GTFSM(base, value) (SEMA42_RMW_GATE4(base, SEMA42_GATE4_GTFSM_MASK, SEMA42_GATE4_GTFSM(value)))
#define SEMA42_BWR_GATE4_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE4_REG(base), ((uint8_t)(value) << SEMA42_GATE4_GTFSM_SHIFT), SEMA42_GATE4_GTFSM_SHIFT, SEMA42_GATE4_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE11 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE11 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE11 register
 */
/*@{*/
#define SEMA42_RD_GATE11(base)   (SEMA42_GATE11_REG(base))
#define SEMA42_WR_GATE11(base, value) (SEMA42_GATE11_REG(base) = (value))
#define SEMA42_RMW_GATE11(base, mask, value) (SEMA42_WR_GATE11(base, (SEMA42_RD_GATE11(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE11(base, value) (BME_OR8(&SEMA42_GATE11_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE11(base, value) (BME_AND8(&SEMA42_GATE11_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE11(base, value) (BME_XOR8(&SEMA42_GATE11_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE11 bitfields
 */

/*!
 * @name Register SEMA42_GATE11, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE11_GTFSM field. */
#define SEMA42_RD_GATE11_GTFSM(base) ((SEMA42_GATE11_REG(base) & SEMA42_GATE11_GTFSM_MASK) >> SEMA42_GATE11_GTFSM_SHIFT)
#define SEMA42_BRD_GATE11_GTFSM(base) (BME_UBFX8(&SEMA42_GATE11_REG(base), SEMA42_GATE11_GTFSM_SHIFT, SEMA42_GATE11_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE11_GTFSM(base, value) (SEMA42_RMW_GATE11(base, SEMA42_GATE11_GTFSM_MASK, SEMA42_GATE11_GTFSM(value)))
#define SEMA42_BWR_GATE11_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE11_REG(base), ((uint8_t)(value) << SEMA42_GATE11_GTFSM_SHIFT), SEMA42_GATE11_GTFSM_SHIFT, SEMA42_GATE11_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE10 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE10 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE10 register
 */
/*@{*/
#define SEMA42_RD_GATE10(base)   (SEMA42_GATE10_REG(base))
#define SEMA42_WR_GATE10(base, value) (SEMA42_GATE10_REG(base) = (value))
#define SEMA42_RMW_GATE10(base, mask, value) (SEMA42_WR_GATE10(base, (SEMA42_RD_GATE10(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE10(base, value) (BME_OR8(&SEMA42_GATE10_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE10(base, value) (BME_AND8(&SEMA42_GATE10_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE10(base, value) (BME_XOR8(&SEMA42_GATE10_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE10 bitfields
 */

/*!
 * @name Register SEMA42_GATE10, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE10_GTFSM field. */
#define SEMA42_RD_GATE10_GTFSM(base) ((SEMA42_GATE10_REG(base) & SEMA42_GATE10_GTFSM_MASK) >> SEMA42_GATE10_GTFSM_SHIFT)
#define SEMA42_BRD_GATE10_GTFSM(base) (BME_UBFX8(&SEMA42_GATE10_REG(base), SEMA42_GATE10_GTFSM_SHIFT, SEMA42_GATE10_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE10_GTFSM(base, value) (SEMA42_RMW_GATE10(base, SEMA42_GATE10_GTFSM_MASK, SEMA42_GATE10_GTFSM(value)))
#define SEMA42_BWR_GATE10_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE10_REG(base), ((uint8_t)(value) << SEMA42_GATE10_GTFSM_SHIFT), SEMA42_GATE10_GTFSM_SHIFT, SEMA42_GATE10_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE9 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE9 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE9 register
 */
/*@{*/
#define SEMA42_RD_GATE9(base)    (SEMA42_GATE9_REG(base))
#define SEMA42_WR_GATE9(base, value) (SEMA42_GATE9_REG(base) = (value))
#define SEMA42_RMW_GATE9(base, mask, value) (SEMA42_WR_GATE9(base, (SEMA42_RD_GATE9(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE9(base, value) (BME_OR8(&SEMA42_GATE9_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE9(base, value) (BME_AND8(&SEMA42_GATE9_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE9(base, value) (BME_XOR8(&SEMA42_GATE9_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE9 bitfields
 */

/*!
 * @name Register SEMA42_GATE9, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE9_GTFSM field. */
#define SEMA42_RD_GATE9_GTFSM(base) ((SEMA42_GATE9_REG(base) & SEMA42_GATE9_GTFSM_MASK) >> SEMA42_GATE9_GTFSM_SHIFT)
#define SEMA42_BRD_GATE9_GTFSM(base) (BME_UBFX8(&SEMA42_GATE9_REG(base), SEMA42_GATE9_GTFSM_SHIFT, SEMA42_GATE9_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE9_GTFSM(base, value) (SEMA42_RMW_GATE9(base, SEMA42_GATE9_GTFSM_MASK, SEMA42_GATE9_GTFSM(value)))
#define SEMA42_BWR_GATE9_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE9_REG(base), ((uint8_t)(value) << SEMA42_GATE9_GTFSM_SHIFT), SEMA42_GATE9_GTFSM_SHIFT, SEMA42_GATE9_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE8 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE8 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE8 register
 */
/*@{*/
#define SEMA42_RD_GATE8(base)    (SEMA42_GATE8_REG(base))
#define SEMA42_WR_GATE8(base, value) (SEMA42_GATE8_REG(base) = (value))
#define SEMA42_RMW_GATE8(base, mask, value) (SEMA42_WR_GATE8(base, (SEMA42_RD_GATE8(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE8(base, value) (BME_OR8(&SEMA42_GATE8_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE8(base, value) (BME_AND8(&SEMA42_GATE8_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE8(base, value) (BME_XOR8(&SEMA42_GATE8_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE8 bitfields
 */

/*!
 * @name Register SEMA42_GATE8, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE8_GTFSM field. */
#define SEMA42_RD_GATE8_GTFSM(base) ((SEMA42_GATE8_REG(base) & SEMA42_GATE8_GTFSM_MASK) >> SEMA42_GATE8_GTFSM_SHIFT)
#define SEMA42_BRD_GATE8_GTFSM(base) (BME_UBFX8(&SEMA42_GATE8_REG(base), SEMA42_GATE8_GTFSM_SHIFT, SEMA42_GATE8_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE8_GTFSM(base, value) (SEMA42_RMW_GATE8(base, SEMA42_GATE8_GTFSM_MASK, SEMA42_GATE8_GTFSM(value)))
#define SEMA42_BWR_GATE8_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE8_REG(base), ((uint8_t)(value) << SEMA42_GATE8_GTFSM_SHIFT), SEMA42_GATE8_GTFSM_SHIFT, SEMA42_GATE8_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE15 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE15 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE15 register
 */
/*@{*/
#define SEMA42_RD_GATE15(base)   (SEMA42_GATE15_REG(base))
#define SEMA42_WR_GATE15(base, value) (SEMA42_GATE15_REG(base) = (value))
#define SEMA42_RMW_GATE15(base, mask, value) (SEMA42_WR_GATE15(base, (SEMA42_RD_GATE15(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE15(base, value) (BME_OR8(&SEMA42_GATE15_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE15(base, value) (BME_AND8(&SEMA42_GATE15_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE15(base, value) (BME_XOR8(&SEMA42_GATE15_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE15 bitfields
 */

/*!
 * @name Register SEMA42_GATE15, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE15_GTFSM field. */
#define SEMA42_RD_GATE15_GTFSM(base) ((SEMA42_GATE15_REG(base) & SEMA42_GATE15_GTFSM_MASK) >> SEMA42_GATE15_GTFSM_SHIFT)
#define SEMA42_BRD_GATE15_GTFSM(base) (BME_UBFX8(&SEMA42_GATE15_REG(base), SEMA42_GATE15_GTFSM_SHIFT, SEMA42_GATE15_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE15_GTFSM(base, value) (SEMA42_RMW_GATE15(base, SEMA42_GATE15_GTFSM_MASK, SEMA42_GATE15_GTFSM(value)))
#define SEMA42_BWR_GATE15_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE15_REG(base), ((uint8_t)(value) << SEMA42_GATE15_GTFSM_SHIFT), SEMA42_GATE15_GTFSM_SHIFT, SEMA42_GATE15_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE14 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE14 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE14 register
 */
/*@{*/
#define SEMA42_RD_GATE14(base)   (SEMA42_GATE14_REG(base))
#define SEMA42_WR_GATE14(base, value) (SEMA42_GATE14_REG(base) = (value))
#define SEMA42_RMW_GATE14(base, mask, value) (SEMA42_WR_GATE14(base, (SEMA42_RD_GATE14(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE14(base, value) (BME_OR8(&SEMA42_GATE14_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE14(base, value) (BME_AND8(&SEMA42_GATE14_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE14(base, value) (BME_XOR8(&SEMA42_GATE14_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE14 bitfields
 */

/*!
 * @name Register SEMA42_GATE14, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE14_GTFSM field. */
#define SEMA42_RD_GATE14_GTFSM(base) ((SEMA42_GATE14_REG(base) & SEMA42_GATE14_GTFSM_MASK) >> SEMA42_GATE14_GTFSM_SHIFT)
#define SEMA42_BRD_GATE14_GTFSM(base) (BME_UBFX8(&SEMA42_GATE14_REG(base), SEMA42_GATE14_GTFSM_SHIFT, SEMA42_GATE14_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE14_GTFSM(base, value) (SEMA42_RMW_GATE14(base, SEMA42_GATE14_GTFSM_MASK, SEMA42_GATE14_GTFSM(value)))
#define SEMA42_BWR_GATE14_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE14_REG(base), ((uint8_t)(value) << SEMA42_GATE14_GTFSM_SHIFT), SEMA42_GATE14_GTFSM_SHIFT, SEMA42_GATE14_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE13 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE13 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE13 register
 */
/*@{*/
#define SEMA42_RD_GATE13(base)   (SEMA42_GATE13_REG(base))
#define SEMA42_WR_GATE13(base, value) (SEMA42_GATE13_REG(base) = (value))
#define SEMA42_RMW_GATE13(base, mask, value) (SEMA42_WR_GATE13(base, (SEMA42_RD_GATE13(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE13(base, value) (BME_OR8(&SEMA42_GATE13_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE13(base, value) (BME_AND8(&SEMA42_GATE13_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE13(base, value) (BME_XOR8(&SEMA42_GATE13_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE13 bitfields
 */

/*!
 * @name Register SEMA42_GATE13, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE13_GTFSM field. */
#define SEMA42_RD_GATE13_GTFSM(base) ((SEMA42_GATE13_REG(base) & SEMA42_GATE13_GTFSM_MASK) >> SEMA42_GATE13_GTFSM_SHIFT)
#define SEMA42_BRD_GATE13_GTFSM(base) (BME_UBFX8(&SEMA42_GATE13_REG(base), SEMA42_GATE13_GTFSM_SHIFT, SEMA42_GATE13_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE13_GTFSM(base, value) (SEMA42_RMW_GATE13(base, SEMA42_GATE13_GTFSM_MASK, SEMA42_GATE13_GTFSM(value)))
#define SEMA42_BWR_GATE13_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE13_REG(base), ((uint8_t)(value) << SEMA42_GATE13_GTFSM_SHIFT), SEMA42_GATE13_GTFSM_SHIFT, SEMA42_GATE13_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_GATE12 - Gate Register
 ******************************************************************************/

/*!
 * @brief SEMA42_GATE12 - Gate Register (RW)
 *
 * Reset value: 0x00U
 *
 * Each semaphore gate is implemented in a 4-bit finite state machine,
 * right-justified in a byte data structure. The hardware uses the logical bus master
 * number in conjunction with the data patterns to validate all attempted write
 * operations. Only processor bus masters can modify the gate registers. Once locked,
 * a gate can (and must) be opened (unlocked) by the locking processor core.
 * Multiple gate values can be read in a single access, but only a single gate can be
 * updated via a write operation at a time. Attempted writes with a data value
 * that is neither the unlock value (0x00) nor the appropriate lock value
 * (processor_number + 1) are simply treated as "no operation" and do not affect any gate
 * state. Attempts to write multiple gates in a single aligned access with a
 * size larger than an 8-bit (byte) reference generate an error termination and do
 * not allow any gate state changes.
 */
/*!
 * @name Constants and macros for entire SEMA42_GATE12 register
 */
/*@{*/
#define SEMA42_RD_GATE12(base)   (SEMA42_GATE12_REG(base))
#define SEMA42_WR_GATE12(base, value) (SEMA42_GATE12_REG(base) = (value))
#define SEMA42_RMW_GATE12(base, mask, value) (SEMA42_WR_GATE12(base, (SEMA42_RD_GATE12(base) & ~(mask)) | (value)))
#define SEMA42_SET_GATE12(base, value) (BME_OR8(&SEMA42_GATE12_REG(base), (uint8_t)(value)))
#define SEMA42_CLR_GATE12(base, value) (BME_AND8(&SEMA42_GATE12_REG(base), (uint8_t)(~(value))))
#define SEMA42_TOG_GATE12(base, value) (BME_XOR8(&SEMA42_GATE12_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_GATE12 bitfields
 */

/*!
 * @name Register SEMA42_GATE12, field GTFSM[3:0] (RW)
 *
 * The state of the gate reflects the last processor that locked it, which can
 * be useful during system debug. The hardware gate is maintained in a 16-state
 * implementation, defined as:
 *
 * Values:
 * - 0b0000 - The gate is unlocked (free).
 * - 0b0001 - The gate has been locked by processor 0.
 * - 0b0010 - The gate has been locked by processor 1.
 * - 0b0011 - The gate has been locked by processor 2.
 * - 0b0100 - The gate has been locked by processor 3.
 * - 0b0101 - The gate has been locked by processor 4.
 * - 0b0110 - The gate has been locked by processor 5.
 * - 0b0111 - The gate has been locked by processor 6.
 * - 0b1000 - The gate has been locked by processor 7.
 * - 0b1001 - The gate has been locked by processor 8.
 * - 0b1010 - The gate has been locked by processor 9.
 * - 0b1011 - The gate has been locked by processor 10.
 * - 0b1100 - The gate has been locked by processor 11.
 * - 0b1101 - The gate has been locked by processor 12.
 * - 0b1110 - The gate has been locked by processor 13.
 * - 0b1111 - The gate has been locked by processor 14.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_GATE12_GTFSM field. */
#define SEMA42_RD_GATE12_GTFSM(base) ((SEMA42_GATE12_REG(base) & SEMA42_GATE12_GTFSM_MASK) >> SEMA42_GATE12_GTFSM_SHIFT)
#define SEMA42_BRD_GATE12_GTFSM(base) (BME_UBFX8(&SEMA42_GATE12_REG(base), SEMA42_GATE12_GTFSM_SHIFT, SEMA42_GATE12_GTFSM_WIDTH))

/*! @brief Set the GTFSM field to a new value. */
#define SEMA42_WR_GATE12_GTFSM(base, value) (SEMA42_RMW_GATE12(base, SEMA42_GATE12_GTFSM_MASK, SEMA42_GATE12_GTFSM(value)))
#define SEMA42_BWR_GATE12_GTFSM(base, value) (BME_BFI8(&SEMA42_GATE12_REG(base), ((uint8_t)(value) << SEMA42_GATE12_GTFSM_SHIFT), SEMA42_GATE12_GTFSM_SHIFT, SEMA42_GATE12_GTFSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_RSTGT_R - Reset Gate Read
 ******************************************************************************/

/*!
 * @brief SEMA42_RSTGT_R - Reset Gate Read (RW)
 *
 * Reset value: 0x0000U
 *
 * See description for RSTGT_WReset Gate Write .
 */
/*!
 * @name Constants and macros for entire SEMA42_RSTGT_R register
 */
/*@{*/
#define SEMA42_RD_RSTGT_R(base)  (SEMA42_RSTGT_R_REG(base))
#define SEMA42_WR_RSTGT_R(base, value) (SEMA42_RSTGT_R_REG(base) = (value))
#define SEMA42_RMW_RSTGT_R(base, mask, value) (SEMA42_WR_RSTGT_R(base, (SEMA42_RD_RSTGT_R(base) & ~(mask)) | (value)))
#define SEMA42_SET_RSTGT_R(base, value) (BME_OR16(&SEMA42_RSTGT_R_REG(base), (uint16_t)(value)))
#define SEMA42_CLR_RSTGT_R(base, value) (BME_AND16(&SEMA42_RSTGT_R_REG(base), (uint16_t)(~(value))))
#define SEMA42_TOG_RSTGT_R(base, value) (BME_XOR16(&SEMA42_RSTGT_R_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_RSTGT_R bitfields
 */

/*!
 * @name Register SEMA42_RSTGT_R, field RSTGTN[7:0] (RW)
 *
 * Reset Gate Number. This 8-bit field specifies the specific hardware gate to
 * be reset. This field is updated by the second write. If RSTGTN < 64, then reset
 * the single gate defined by RSTGTN, else reset all the gates.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_RSTGT_R_RSTGTN field. */
#define SEMA42_RD_RSTGT_R_RSTGTN(base) ((SEMA42_RSTGT_R_REG(base) & SEMA42_RSTGT_R_RSTGTN_MASK) >> SEMA42_RSTGT_R_RSTGTN_SHIFT)
#define SEMA42_BRD_RSTGT_R_RSTGTN(base) (BME_UBFX16(&SEMA42_RSTGT_R_REG(base), SEMA42_RSTGT_R_RSTGTN_SHIFT, SEMA42_RSTGT_R_RSTGTN_WIDTH))

/*! @brief Set the RSTGTN field to a new value. */
#define SEMA42_WR_RSTGT_R_RSTGTN(base, value) (SEMA42_RMW_RSTGT_R(base, SEMA42_RSTGT_R_RSTGTN_MASK, SEMA42_RSTGT_R_RSTGTN(value)))
#define SEMA42_BWR_RSTGT_R_RSTGTN(base, value) (BME_BFI16(&SEMA42_RSTGT_R_REG(base), ((uint16_t)(value) << SEMA42_RSTGT_R_RSTGTN_SHIFT), SEMA42_RSTGT_R_RSTGTN_SHIFT, SEMA42_RSTGT_R_RSTGTN_WIDTH))
/*@}*/

/*!
 * @name Register SEMA42_RSTGT_R, field RSTGMS[11:8] (RO)
 *
 * Reset Gate Bus Master. This 4-bit read-only field records the logical number
 * of the bus master performing the gate reset function. The logical number is
 * the domain number. This domain number is determined by the Extended Resource
 * Domain Controller's Master Domain Assignment Controller (XRDA_MDAC). The reset
 * function requires that the two consecutive writes to this register must be
 * initiated by the same bus master to succeed. This field is updated each time a
 * write to this register occurs. The association between system bus master port
 * numbers, the associated bus master device, and the logical processor number is
 * SoC-specific. Consult the device reference manual for this information.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_RSTGT_R_RSTGMS field. */
#define SEMA42_RD_RSTGT_R_RSTGMS(base) ((SEMA42_RSTGT_R_REG(base) & SEMA42_RSTGT_R_RSTGMS_MASK) >> SEMA42_RSTGT_R_RSTGMS_SHIFT)
#define SEMA42_BRD_RSTGT_R_RSTGMS(base) (BME_UBFX16(&SEMA42_RSTGT_R_REG(base), SEMA42_RSTGT_R_RSTGMS_SHIFT, SEMA42_RSTGT_R_RSTGMS_WIDTH))
/*@}*/

/*!
 * @name Register SEMA42_RSTGT_R, field RSTGSM[13:12] (RO)
 *
 * Reset Gate Finite State Machine. Reads of the SEMA42_RSTGT register return
 * the encoded state machine value. Note the RSTGSM = 10 state is valid for only a
 * single machine cycle, so it is impossible for a read to return this value. The
 * reset state machine is maintained in a 2-bit, 3-state implementation, defined
 * as:
 *
 * Values:
 * - 0b00 - Idle, waiting for the first data pattern write.
 * - 0b01 - Waiting for the second data pattern write.
 * - 0b10 - The 2-write sequence has completed. Generate the specified gate
 *     reset(s). After the reset is performed, this machine returns to the idle
 *     (waiting for first data pattern write) state. The "01" state persists for only
 *     one clock cycle. Software cannot observe this state.
 * - 0b11 - This state encoding is never used and therefore reserved.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_RSTGT_R_RSTGSM field. */
#define SEMA42_RD_RSTGT_R_RSTGSM(base) ((SEMA42_RSTGT_R_REG(base) & SEMA42_RSTGT_R_RSTGSM_MASK) >> SEMA42_RSTGT_R_RSTGSM_SHIFT)
#define SEMA42_BRD_RSTGT_R_RSTGSM(base) (BME_UBFX16(&SEMA42_RSTGT_R_REG(base), SEMA42_RSTGT_R_RSTGSM_SHIFT, SEMA42_RSTGT_R_RSTGSM_WIDTH))
/*@}*/

/*******************************************************************************
 * SEMA42_RSTGT_W - Reset Gate Write
 ******************************************************************************/

/*!
 * @brief SEMA42_RSTGT_W - Reset Gate Write (RW)
 *
 * Reset value: 0x0000U
 *
 * Although the intent of the hardware gate implementation specifies a protocol
 * where the locking processor must unlock the gate, it is recognized that system
 * operation may require a reset function to re-initialize the state of any
 * gate(s) without requiring a system-level reset. To support this special gate reset
 * requirement, the Semaphores module implements a "secure" reset mechanism that
 * allows a hardware gate (or all the gates) to be initialized by following a
 * specific dual-write access pattern. Using a technique similar to that required
 * for the servicing of a software watchdog timer, the secure gate reset requires
 * two consecutive writes with predefined data patterns from the same processor
 * to force the clearing of the specified gate(s). The required access pattern is:
 * A processor performs a 16-bit write to the SEMA42_RSTGT memory location. The
 * most significant byte (SEMA42_RSTGT[RSTGDP]) must be 0xE2; the least
 * significant byte is a "don't_care" for this reference. The same processor then performs
 * a second 16-bit write to the SEMA42_RSTGT location. For this write, the upper
 * byte (SEMA42_RSTGT[RSTGDP]) is the logical complement of the first data
 * pattern (0x1D) and the lower byte (SEMA42_RSTGT[RSTGTN]) specifies the gate(s) to
 * be reset. This gate field can specify a single gate be cleared, or in the case
 * where SEMA42_RSTGT[RSTGTN] = 64 or greater, all gates are to be cleared. If
 * the same processor writes incorrect data on the second access or another
 * processor performs the second write access, the special gate reset sequence is
 * aborted and no error signal is asserted. Reads of the SEMA42_RSTGT location return
 * information on the 2-bit state machine (SEMA42_RSTGT[RSTGSM]) that implements
 * this function, the bus master performing the reset (SEMA42_RSTGT[RSTGMS], and
 * the gate number(s) last cleared (SEMA42_RSTGT[RSTGTN]). Reads of the
 * SEMA42_RSTGT register do not affect the secure reset finite state machine in any manner.
 */
/*!
 * @name Constants and macros for entire SEMA42_RSTGT_W register
 */
/*@{*/
#define SEMA42_RD_RSTGT_W(base)  (SEMA42_RSTGT_W_REG(base))
#define SEMA42_WR_RSTGT_W(base, value) (SEMA42_RSTGT_W_REG(base) = (value))
#define SEMA42_RMW_RSTGT_W(base, mask, value) (SEMA42_WR_RSTGT_W(base, (SEMA42_RD_RSTGT_W(base) & ~(mask)) | (value)))
#define SEMA42_SET_RSTGT_W(base, value) (BME_OR16(&SEMA42_RSTGT_W_REG(base), (uint16_t)(value)))
#define SEMA42_CLR_RSTGT_W(base, value) (BME_AND16(&SEMA42_RSTGT_W_REG(base), (uint16_t)(~(value))))
#define SEMA42_TOG_RSTGT_W(base, value) (BME_XOR16(&SEMA42_RSTGT_W_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SEMA42_RSTGT_W bitfields
 */

/*!
 * @name Register SEMA42_RSTGT_W, field RSTGTN[7:0] (RW)
 *
 * Reset Gate Number. This 8-bit field specifies the specific hardware gate to
 * be reset. This field is updated by the second write. If RSTGTN < 64, then reset
 * the single gate defined by RSTGTN, else reset all the gates.
 */
/*@{*/
/*! @brief Read current value of the SEMA42_RSTGT_W_RSTGTN field. */
#define SEMA42_RD_RSTGT_W_RSTGTN(base) ((SEMA42_RSTGT_W_REG(base) & SEMA42_RSTGT_W_RSTGTN_MASK) >> SEMA42_RSTGT_W_RSTGTN_SHIFT)
#define SEMA42_BRD_RSTGT_W_RSTGTN(base) (BME_UBFX16(&SEMA42_RSTGT_W_REG(base), SEMA42_RSTGT_W_RSTGTN_SHIFT, SEMA42_RSTGT_W_RSTGTN_WIDTH))

/*! @brief Set the RSTGTN field to a new value. */
#define SEMA42_WR_RSTGT_W_RSTGTN(base, value) (SEMA42_RMW_RSTGT_W(base, SEMA42_RSTGT_W_RSTGTN_MASK, SEMA42_RSTGT_W_RSTGTN(value)))
#define SEMA42_BWR_RSTGT_W_RSTGTN(base, value) (BME_BFI16(&SEMA42_RSTGT_W_REG(base), ((uint16_t)(value) << SEMA42_RSTGT_W_RSTGTN_SHIFT), SEMA42_RSTGT_W_RSTGTN_SHIFT, SEMA42_RSTGT_W_RSTGTN_WIDTH))
/*@}*/

/*!
 * @name Register SEMA42_RSTGT_W, field RSTGDP[15:8] (WORZ)
 *
 * Reset Gate Data Pattern. This write-only field is accessed with the specified
 * data patterns on the two consecutive writes by the same processor to enable
 * the gate reset mechanism. For the first write, RSTGDP = 0xE2 while the second
 * write requires RSTGDP = 0x1D.
 */
/*@{*/
/*! @brief Set the RSTGDP field to a new value. */
#define SEMA42_WR_RSTGT_W_RSTGDP(base, value) (SEMA42_RMW_RSTGT_W(base, SEMA42_RSTGT_W_RSTGDP_MASK, SEMA42_RSTGT_W_RSTGDP(value)))
#define SEMA42_BWR_RSTGT_W_RSTGDP(base, value) (BME_BFI16(&SEMA42_RSTGT_W_REG(base), ((uint16_t)(value) << SEMA42_RSTGT_W_RSTGDP_SHIFT), SEMA42_RSTGT_W_RSTGDP_SHIFT, SEMA42_RSTGT_W_RSTGDP_WIDTH))
/*@}*/

/*
 * MKL28Z7 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_SOPT1 - System Options Register 1
 * - SIM_SOPT1CFG - SOPT1 Configuration Register
 * - SIM_SDID - System Device Identification Register
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid Low
 * - SIM_UIDL - Unique Identification Register Low
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x80000000U
 *
 * The SOPT1 register is only reset on POR or LVD.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define SIM_RD_SOPT1(base)       (SIM_SOPT1_REG(base))
#define SIM_WR_SOPT1(base, value) (SIM_SOPT1_REG(base) = (value))
#define SIM_RMW_SOPT1(base, mask, value) (SIM_WR_SOPT1(base, (SIM_RD_SOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1(base, value) (BME_OR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT1(base, value) (BME_AND32(&SIM_SOPT1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT1(base, value) (BME_XOR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field USBVSTBY[29] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * VLPR and VLPW modes.
 *
 * Values:
 * - 0b0 - USB voltage regulator not in standby during VLPR and VLPW modes.
 * - 0b1 - USB voltage regulator in standby during VLPR and VLPW modes.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_USBVSTBY field. */
#define SIM_RD_SOPT1_USBVSTBY(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_USBVSTBY_MASK) >> SIM_SOPT1_USBVSTBY_SHIFT)
#define SIM_BRD_SOPT1_USBVSTBY(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBVSTBY_SHIFT, SIM_SOPT1_USBVSTBY_WIDTH))

/*! @brief Set the USBVSTBY field to a new value. */
#define SIM_WR_SOPT1_USBVSTBY(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_USBVSTBY_MASK, SIM_SOPT1_USBVSTBY(value)))
#define SIM_BWR_SOPT1_USBVSTBY(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_USBVSTBY_SHIFT), SIM_SOPT1_USBVSTBY_SHIFT, SIM_SOPT1_USBVSTBY_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBSSTBY[30] (RW)
 *
 * Controls whether the USB voltage regulator is placed in standby mode during
 * Stop, VLPS, LLS and VLLS modes.
 *
 * Values:
 * - 0b0 - USB voltage regulator not in standby during Stop, VLPS, LLS and VLLS
 *     modes.
 * - 0b1 - USB voltage regulator in standby during Stop, VLPS, LLS and VLLS
 *     modes.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_USBSSTBY field. */
#define SIM_RD_SOPT1_USBSSTBY(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_USBSSTBY_MASK) >> SIM_SOPT1_USBSSTBY_SHIFT)
#define SIM_BRD_SOPT1_USBSSTBY(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBSSTBY_SHIFT, SIM_SOPT1_USBSSTBY_WIDTH))

/*! @brief Set the USBSSTBY field to a new value. */
#define SIM_WR_SOPT1_USBSSTBY(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_USBSSTBY_MASK, SIM_SOPT1_USBSSTBY(value)))
#define SIM_BWR_SOPT1_USBSSTBY(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_USBSSTBY_SHIFT), SIM_SOPT1_USBSSTBY_SHIFT, SIM_SOPT1_USBSSTBY_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field USBREGEN[31] (RW)
 *
 * Controls whether the USB voltage regulator is enabled.
 *
 * Values:
 * - 0b0 - USB voltage regulator is disabled.
 * - 0b1 - USB voltage regulator is enabled.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_USBREGEN field. */
#define SIM_RD_SOPT1_USBREGEN(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_USBREGEN_MASK) >> SIM_SOPT1_USBREGEN_SHIFT)
#define SIM_BRD_SOPT1_USBREGEN(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_USBREGEN_SHIFT, SIM_SOPT1_USBREGEN_WIDTH))

/*! @brief Set the USBREGEN field to a new value. */
#define SIM_WR_SOPT1_USBREGEN(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_USBREGEN_MASK, SIM_SOPT1_USBREGEN(value)))
#define SIM_BWR_SOPT1_USBREGEN(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_USBREGEN_SHIFT), SIM_SOPT1_USBREGEN_SHIFT, SIM_SOPT1_USBREGEN_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT1CFG - SOPT1 Configuration Register
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1CFG - SOPT1 Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1CFG register is reset on System Reset not VLLS.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1CFG register
 */
/*@{*/
#define SIM_RD_SOPT1CFG(base)    (SIM_SOPT1CFG_REG(base))
#define SIM_WR_SOPT1CFG(base, value) (SIM_SOPT1CFG_REG(base) = (value))
#define SIM_RMW_SOPT1CFG(base, mask, value) (SIM_WR_SOPT1CFG(base, (SIM_RD_SOPT1CFG(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1CFG(base, value) (BME_OR32(&SIM_SOPT1CFG_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT1CFG(base, value) (BME_AND32(&SIM_SOPT1CFG_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT1CFG(base, value) (BME_XOR32(&SIM_SOPT1CFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1CFG bitfields
 */

/*!
 * @name Register SIM_SOPT1CFG, field URWE[24] (RW)
 *
 * Writing one to the URWE bit allows the SOPT1 USBREGEN bit to be written. This
 * register bit clears after a write to USBREGEN.
 *
 * Values:
 * - 0b0 - SOPT1 USBREGEN cannot be written.
 * - 0b1 - SOPT1 USBREGEN can be written.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1CFG_URWE field. */
#define SIM_RD_SOPT1CFG_URWE(base) ((SIM_SOPT1CFG_REG(base) & SIM_SOPT1CFG_URWE_MASK) >> SIM_SOPT1CFG_URWE_SHIFT)
#define SIM_BRD_SOPT1CFG_URWE(base) (BME_UBFX32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_URWE_SHIFT, SIM_SOPT1CFG_URWE_WIDTH))

/*! @brief Set the URWE field to a new value. */
#define SIM_WR_SOPT1CFG_URWE(base, value) (SIM_RMW_SOPT1CFG(base, SIM_SOPT1CFG_URWE_MASK, SIM_SOPT1CFG_URWE(value)))
#define SIM_BWR_SOPT1CFG_URWE(base, value) (BME_BFI32(&SIM_SOPT1CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1CFG_URWE_SHIFT), SIM_SOPT1CFG_URWE_SHIFT, SIM_SOPT1CFG_URWE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field UVSWE[25] (RW)
 *
 * Writing one to the UVSWE bit allows the SOPT1 USBVSTBY bit to be written.
 * This register bit clears after a write to USBVSTBY.
 *
 * Values:
 * - 0b0 - SOPT1 USBVSTB cannot be written.
 * - 0b1 - SOPT1 USBVSTB can be written.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1CFG_UVSWE field. */
#define SIM_RD_SOPT1CFG_UVSWE(base) ((SIM_SOPT1CFG_REG(base) & SIM_SOPT1CFG_UVSWE_MASK) >> SIM_SOPT1CFG_UVSWE_SHIFT)
#define SIM_BRD_SOPT1CFG_UVSWE(base) (BME_UBFX32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_UVSWE_SHIFT, SIM_SOPT1CFG_UVSWE_WIDTH))

/*! @brief Set the UVSWE field to a new value. */
#define SIM_WR_SOPT1CFG_UVSWE(base, value) (SIM_RMW_SOPT1CFG(base, SIM_SOPT1CFG_UVSWE_MASK, SIM_SOPT1CFG_UVSWE(value)))
#define SIM_BWR_SOPT1CFG_UVSWE(base, value) (BME_BFI32(&SIM_SOPT1CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1CFG_UVSWE_SHIFT), SIM_SOPT1CFG_UVSWE_SHIFT, SIM_SOPT1CFG_UVSWE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1CFG, field USSWE[26] (RW)
 *
 * Writing one to the USSWE bit allows the SOPT1 USBSSTBY bit to be written.
 * This register bit clears after a write to USBSSTBY.
 *
 * Values:
 * - 0b0 - SOPT1 USBSSTB cannot be written.
 * - 0b1 - SOPT1 USBSSTB can be written.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1CFG_USSWE field. */
#define SIM_RD_SOPT1CFG_USSWE(base) ((SIM_SOPT1CFG_REG(base) & SIM_SOPT1CFG_USSWE_MASK) >> SIM_SOPT1CFG_USSWE_SHIFT)
#define SIM_BRD_SOPT1CFG_USSWE(base) (BME_UBFX32(&SIM_SOPT1CFG_REG(base), SIM_SOPT1CFG_USSWE_SHIFT, SIM_SOPT1CFG_USSWE_WIDTH))

/*! @brief Set the USSWE field to a new value. */
#define SIM_WR_SOPT1CFG_USSWE(base, value) (SIM_RMW_SOPT1CFG(base, SIM_SOPT1CFG_USSWE_MASK, SIM_SOPT1CFG_USSWE(value)))
#define SIM_BWR_SOPT1CFG_USSWE(base, value) (BME_BFI32(&SIM_SOPT1CFG_REG(base), ((uint32_t)(value) << SIM_SOPT1CFG_USSWE_SHIFT), SIM_SOPT1CFG_USSWE_SHIFT, SIM_SOPT1CFG_USSWE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00100E00U
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pin count of the device.
 *
 * Values:
 * - 0b0000 - 16-pin
 * - 0b0001 - 24-pin
 * - 0b0010 - 32-pin
 * - 0b0011 - 36-pin
 * - 0b0100 - 48-pin
 * - 0b0101 - 64-pin
 * - 0b0110 - 80-pin
 * - 0b0111 - Reserved
 * - 0b1000 - 100-pin
 * - 0b1001 - 121-pin
 * - 0b1010 - Reserved
 * - 0b1011 - Custom pin-out(WLCSP)
 * - 0b1100 - Reserved
 * - 0b1101 - Reserved
 * - 0b1110 - Reserved
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_PINID_SHIFT, SIM_SDID_PINID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field KEYATT[6:4] (RO)
 *
 * Specifies the core configuration of the device.
 *
 * Values:
 * - 0b000 - Cortex CM0+ core
 * - 0b001 - Cortex CM0+ core with RPM
 * - 0b010 - Reserved
 * - 0b011 - Reserved
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_KEYATT field. */
#define SIM_RD_SDID_KEYATT(base) ((SIM_SDID_REG(base) & SIM_SDID_KEYATT_MASK) >> SIM_SDID_KEYATT_SHIFT)
#define SIM_BRD_SDID_KEYATT(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_KEYATT_SHIFT, SIM_SDID_KEYATT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field DIEID[11:7] (RO)
 *
 * Specifies the silicon implementation number for the device. This field always
 * reads as 11100.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_DIEID field. */
#define SIM_RD_SDID_DIEID(base) ((SIM_SDID_REG(base) & SIM_SDID_DIEID_MASK) >> SIM_SDID_DIEID_SHIFT)
#define SIM_BRD_SDID_DIEID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_DIEID_SHIFT, SIM_SDID_DIEID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_REVID_SHIFT, SIM_SDID_REVID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SRAMSIZE[19:16] (RO)
 *
 * Specifies the size of the System SRAM
 *
 * Values:
 * - 0b1000 - 96 KB
 * - 0b1001 - 128 KB
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SRAMSIZE field. */
#define SIM_RD_SDID_SRAMSIZE(base) ((SIM_SDID_REG(base) & SIM_SDID_SRAMSIZE_MASK) >> SIM_SDID_SRAMSIZE_SHIFT)
#define SIM_BRD_SDID_SRAMSIZE(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SRAMSIZE_SHIFT, SIM_SDID_SRAMSIZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 0b0001 - KL family
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define SIM_RD_SDID_SERIESID(base) ((SIM_SDID_REG(base) & SIM_SDID_SERIESID_MASK) >> SIM_SDID_SERIESID_SHIFT)
#define SIM_BRD_SDID_SERIESID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SERIESID_SHIFT, SIM_SDID_SERIESID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the Kinetis sub-family of the device.
 *
 * Values:
 * - 0b0010 - KLx2 Subfamily
 * - 0b0011 - KLx3 Subfamily
 * - 0b0100 - KLx4 Subfamily
 * - 0b0101 - KLx5 Subfamily
 * - 0b0110 - KLx6 Subfamily
 * - 0b0111 - KLx7 Subfamily
 * - 0b1000 - KLx8 Subfamily
 * - 0b1001 - KLx9 Subfamily
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define SIM_RD_SDID_SUBFAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_SUBFAMID_MASK) >> SIM_SDID_SUBFAMID_SHIFT)
#define SIM_BRD_SDID_SUBFAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SUBFAMID_SHIFT, SIM_SDID_SUBFAMID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[31:28] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 0b0010 - KL2x Family (USB)
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define SIM_RD_SDID_FAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMID_MASK) >> SIM_SDID_FAMID_SHIFT)
#define SIM_BRD_SDID_FAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_FAMID_SHIFT, SIM_SDID_FAMID_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0x0F000000U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (BME_OR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
#define SIM_CLR_FCFG1(base, value) (BME_AND32(&SIM_FCFG1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_FCFG1(base, value) (BME_XOR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the flash memory
 * is placed in a low-power state. This field should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0b0 - Flash is enabled.
 * - 0b1 - Flash is disabled.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDIS_SHIFT), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, flash memory is disabled for the duration of Doze mode. This field
 * must be clear during VLP modes. The flash will be automatically enabled again
 * at the end of Doze mode so interrupt vectors do not need to be relocated out
 * of flash memory. The wake-up time from Doze mode is extended when this field is
 * set. An attempt by the DMA or other bus master to access the flash memory
 * when the flash is disabled will result in a bus error.
 *
 * Values:
 * - 0b0 - Flash remains enabled during Doze mode.
 * - 0b1 - Flash is disabled for the duration of Doze mode.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDOZE_SHIFT), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * Specifies the amount of program flash memory available on the device .
 * Undefined values are reserved.
 *
 * Values:
 * - 0b0101 - 64 KB of program flash memory, 2 KB protection region
 * - 0b0111 - 128 KB of program flash memory, 4 KB protection region
 * - 0b1001 - 256 KB of program flash memory, 8 KB protection region
 * - 0b1010 - 512 KB of program flash memory, 16 KB protection region
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_PFSIZE_SHIFT, SIM_FCFG1_PFSIZE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x7FFF0000U
 *
 * This is read only register, any write to this register will cause transfer
 * error.
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR1[22:16] (RO)
 *
 * This field concatenated with leading zeros plus the value of the MAXADDR1
 * field indicates the first invalid address of the second program flash block
 * (flash block 1). For example, if MAXADDR0 = MAXADDR1 = 0x10 the first invalid
 * address of flash block 1 is 0x2_0000 + 0x2_0000. This would be the MAXADDR1 value
 * for a device with 256 KB program flash memory across two flash blocks.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR1 field. */
#define SIM_RD_FCFG2_MAXADDR1(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR1_MASK) >> SIM_FCFG2_MAXADDR1_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR1(base) (BME_UBFX32(&SIM_FCFG2_REG(base), SIM_FCFG2_MAXADDR1_SHIFT, SIM_FCFG2_MAXADDR1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with 13 trailing zeros indicates the first invalid
 * address of program flash (block 0). For example, if MAXADDR0 = 0x10, the first
 * invalid address of program flash (block 0) is 0x0002_0000. This would be the
 * MAXADDR0 value for a device with 128 KB program flash in flash block 0.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define SIM_RD_FCFG2_MAXADDR0(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR0_MASK) >> SIM_FCFG2_MAXADDR0_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR0(base) (BME_UBFX32(&SIM_FCFG2_REG(base), SIM_FCFG2_MAXADDR0_SHIFT, SIM_FCFG2_MAXADDR0_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_UIDMH bitfields
 */

/*!
 * @name Register SIM_UIDMH, field UID[15:0] (RO)
 *
 * Unique identification for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_UIDMH_UID field. */
#define SIM_RD_UIDMH_UID(base) ((SIM_UIDMH_REG(base) & SIM_UIDMH_UID_MASK) >> SIM_UIDMH_UID_SHIFT)
#define SIM_BRD_UIDMH_UID(base) (SIM_RD_UIDMH_UID(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*
 * MKL28Z7 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_VERID - SMC Version ID Register
 * - SMC_PARAM - SMC Parameter Register
 * - SMC_PMPROT - Power Mode Protection register
 * - SMC_PMCTRL - Power Mode Control register
 * - SMC_STOPCTRL - Stop Control Register
 * - SMC_PMSTAT - Power Mode Status register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_VERID - SMC Version ID Register
 ******************************************************************************/

/*!
 * @brief SMC_VERID - SMC Version ID Register (RO)
 *
 * Reset value: 0x01000000U
 */
/*!
 * @name Constants and macros for entire SMC_VERID register
 */
/*@{*/
#define SMC_RD_VERID(base)       (SMC_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SMC_VERID bitfields
 */

/*!
 * @name Register SMC_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0b0000000000000000 - Standard features implemented
 */
/*@{*/
/*! @brief Read current value of the SMC_VERID_FEATURE field. */
#define SMC_RD_VERID_FEATURE(base) ((SMC_VERID_REG(base) & SMC_VERID_FEATURE_MASK) >> SMC_VERID_FEATURE_SHIFT)
#define SMC_BRD_VERID_FEATURE(base) (SMC_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register SMC_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the SMC_VERID_MINOR field. */
#define SMC_RD_VERID_MINOR(base) ((SMC_VERID_REG(base) & SMC_VERID_MINOR_MASK) >> SMC_VERID_MINOR_SHIFT)
#define SMC_BRD_VERID_MINOR(base) (BME_UBFX32(&SMC_VERID_REG(base), SMC_VERID_MINOR_SHIFT, SMC_VERID_MINOR_WIDTH))
/*@}*/

/*!
 * @name Register SMC_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the SMC_VERID_MAJOR field. */
#define SMC_RD_VERID_MAJOR(base) ((SMC_VERID_REG(base) & SMC_VERID_MAJOR_MASK) >> SMC_VERID_MAJOR_SHIFT)
#define SMC_BRD_VERID_MAJOR(base) (BME_UBFX32(&SMC_VERID_REG(base), SMC_VERID_MAJOR_SHIFT, SMC_VERID_MAJOR_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PARAM - SMC Parameter Register
 ******************************************************************************/

/*!
 * @brief SMC_PARAM - SMC Parameter Register (RO)
 *
 * Reset value: 0x00000069U
 */
/*!
 * @name Constants and macros for entire SMC_PARAM register
 */
/*@{*/
#define SMC_RD_PARAM(base)       (SMC_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual SMC_PARAM bitfields
 */

/*!
 * @name Register SMC_PARAM, field EHSRUN[0] (RO)
 *
 * HSRUN mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_EHSRUN field. */
#define SMC_RD_PARAM_EHSRUN(base) ((SMC_PARAM_REG(base) & SMC_PARAM_EHSRUN_MASK) >> SMC_PARAM_EHSRUN_SHIFT)
#define SMC_BRD_PARAM_EHSRUN(base) (BME_UBFX32(&SMC_PARAM_REG(base), SMC_PARAM_EHSRUN_SHIFT, SMC_PARAM_EHSRUN_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PARAM, field ELLS[3] (RO)
 *
 * LLS mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_ELLS field. */
#define SMC_RD_PARAM_ELLS(base) ((SMC_PARAM_REG(base) & SMC_PARAM_ELLS_MASK) >> SMC_PARAM_ELLS_SHIFT)
#define SMC_BRD_PARAM_ELLS(base) (BME_UBFX32(&SMC_PARAM_REG(base), SMC_PARAM_ELLS_SHIFT, SMC_PARAM_ELLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PARAM, field ELLS2[5] (RO)
 *
 * LLS2 mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_ELLS2 field. */
#define SMC_RD_PARAM_ELLS2(base) ((SMC_PARAM_REG(base) & SMC_PARAM_ELLS2_MASK) >> SMC_PARAM_ELLS2_SHIFT)
#define SMC_BRD_PARAM_ELLS2(base) (BME_UBFX32(&SMC_PARAM_REG(base), SMC_PARAM_ELLS2_SHIFT, SMC_PARAM_ELLS2_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PARAM, field EVLLS0[6] (RO)
 *
 * VLLS0 mode enabled
 */
/*@{*/
/*! @brief Read current value of the SMC_PARAM_EVLLS0 field. */
#define SMC_RD_PARAM_EVLLS0(base) ((SMC_PARAM_REG(base) & SMC_PARAM_EVLLS0_MASK) >> SMC_PARAM_EVLLS0_SHIFT)
#define SMC_BRD_PARAM_EVLLS0(base) (BME_UBFX32(&SMC_PARAM_REG(base), SMC_PARAM_EVLLS0_SHIFT, SMC_PARAM_EVLLS0_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x00000020U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (BME_OR32(&SMC_PMPROT_REG(base), (uint32_t)(value)))
#define SMC_CLR_PMPROT(base, value) (BME_AND32(&SMC_PMPROT_REG(base), (uint32_t)(~(value))))
#define SMC_TOG_PMPROT(base, value) (BME_XOR32(&SMC_PMPROT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0b0 - Any VLLSx mode is not allowed
 * - 0b1 - Any VLLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define SMC_RD_PMPROT_AVLLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLLS_MASK) >> SMC_PMPROT_AVLLS_SHIFT)
#define SMC_BRD_PMPROT_AVLLS(base) (BME_UBFX32(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))

/*! @brief Set the AVLLS field to a new value. */
#define SMC_WR_PMPROT_AVLLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLLS_MASK, SMC_PMPROT_AVLLS(value)))
#define SMC_BWR_PMPROT_AVLLS(base, value) (BME_BFI32(&SMC_PMPROT_REG(base), ((uint32_t)(value) << SMC_PMPROT_AVLLS_SHIFT), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field ALLS[3] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any low-leakage stop mode (LLS).
 *
 * Values:
 * - 0b0 - Any LLSx mode is not allowed
 * - 0b1 - Any LLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_ALLS field. */
#define SMC_RD_PMPROT_ALLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_ALLS_MASK) >> SMC_PMPROT_ALLS_SHIFT)
#define SMC_BRD_PMPROT_ALLS(base) (BME_UBFX32(&SMC_PMPROT_REG(base), SMC_PMPROT_ALLS_SHIFT, SMC_PMPROT_ALLS_WIDTH))

/*! @brief Set the ALLS field to a new value. */
#define SMC_WR_PMPROT_ALLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_ALLS_MASK, SMC_PMPROT_ALLS(value)))
#define SMC_BWR_PMPROT_ALLS(base, value) (BME_BFI32(&SMC_PMPROT_REG(base), ((uint32_t)(value) << SMC_PMPROT_ALLS_SHIFT), SMC_PMPROT_ALLS_SHIFT, SMC_PMPROT_ALLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0b0 - VLPR, VLPW, and VLPS are not allowed.
 * - 0b1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BME_UBFX32(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BME_BFI32(&SMC_PMPROT_REG(base), ((uint32_t)(value) << SMC_PMPROT_AVLP_SHIFT), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AHSRUN[7] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter High Speed Run mode (HSRUN).
 *
 * Values:
 * - 0b0 - HSRUN is not allowed
 * - 0b1 - HSRUN is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AHSRUN field. */
#define SMC_RD_PMPROT_AHSRUN(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AHSRUN_MASK) >> SMC_PMPROT_AHSRUN_SHIFT)
#define SMC_BRD_PMPROT_AHSRUN(base) (BME_UBFX32(&SMC_PMPROT_REG(base), SMC_PMPROT_AHSRUN_SHIFT, SMC_PMPROT_AHSRUN_WIDTH))

/*! @brief Set the AHSRUN field to a new value. */
#define SMC_WR_PMPROT_AHSRUN(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AHSRUN_MASK, SMC_PMPROT_AHSRUN(value)))
#define SMC_BWR_PMPROT_AHSRUN(base, value) (BME_BFI32(&SMC_PMPROT_REG(base), ((uint32_t)(value) << SMC_PMPROT_AHSRUN_SHIFT), SMC_PMPROT_AHSRUN_SHIFT, SMC_PMPROT_AHSRUN_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x00000040U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (BME_OR32(&SMC_PMCTRL_REG(base), (uint32_t)(value)))
#define SMC_CLR_PMCTRL(base, value) (BME_AND32(&SMC_PMCTRL_REG(base), (uint32_t)(~(value))))
#define SMC_TOG_PMCTRL(base, value) (BME_XOR32(&SMC_PMCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSxor LLSx, the LLSM in the STOPCTRL
 * register is used to further select the particular VLLSor LLS submode which will
 * be entered. When set to STOP, the PSTOPO bits in the STOPCTRL register can be
 * used to select a Partial Stop mode if desired.
 *
 * Values:
 * - 0b000 - Normal Stop (STOP)
 * - 0b001 - Reserved
 * - 0b010 - Very-Low-Power Stop (VLPS)
 * - 0b011 - Low-Leakage Stop (LLSx)
 * - 0b100 - Very-Low-Leakage Stop (VLLSx)
 * - 0b101 - Reserved
 * - 0b110 - Reseved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (BME_UBFX32(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (BME_BFI32(&SMC_PMCTRL_REG(base), ((uint32_t)(value) << SMC_PMCTRL_STOPM_SHIFT), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt occured during the
 * previous stop mode entry sequence, preventing the system from entering that
 * mode. This field is cleared by reset or by hardware at the beginning of any
 * stop mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0b0 - The previous stop mode entry was successsful.
 * - 0b1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BME_UBFX32(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT, SMC_PMCTRL_STOPA_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. RUNM may be set to HSRUN
 * only when PMSTAT=RUN. Also, stop mode entry should not be attempted while
 * RUNM=HSRUN or PMSTAT=HSRUN.
 *
 * Values:
 * - 0b00 - Normal Run mode (RUN)
 * - 0b01 - Reserved
 * - 0b10 - Very-Low-Power Run mode (VLPR)
 * - 0b11 - High Speed Run mode (HSRUN)
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (BME_UBFX32(&SMC_PMCTRL_REG(base), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (BME_BFI32(&SMC_PMCTRL_REG(base), ((uint32_t)(value) << SMC_PMCTRL_RUNM_SHIFT), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x00000003U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define SMC_RD_STOPCTRL(base)    (SMC_STOPCTRL_REG(base))
#define SMC_WR_STOPCTRL(base, value) (SMC_STOPCTRL_REG(base) = (value))
#define SMC_RMW_STOPCTRL(base, mask, value) (SMC_WR_STOPCTRL(base, (SMC_RD_STOPCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_STOPCTRL(base, value) (BME_OR32(&SMC_STOPCTRL_REG(base), (uint32_t)(value)))
#define SMC_CLR_STOPCTRL(base, value) (BME_AND32(&SMC_STOPCTRL_REG(base), (uint32_t)(~(value))))
#define SMC_TOG_STOPCTRL(base, value) (BME_XOR32(&SMC_STOPCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field LLSM[2:0] (RW)
 *
 * This field controls whichLLS or VLLS sub-mode to enter if STOPM=LLSx orVLLSx.
 *
 * Values:
 * - 0b000 - VLLS0 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
 * - 0b001 - VLLS1 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
 * - 0b010 - VLLS2 if PMCTRL[STOPM]=VLLSx, LLS2 if PMCTRL[STOPM]=LLSx
 * - 0b011 - VLLS3 if PMCTRL[STOPM]=VLLSx, LLS3 if PMCTRL[STOPM]=LLSx
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_LLSM field. */
#define SMC_RD_STOPCTRL_LLSM(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_LLSM_MASK) >> SMC_STOPCTRL_LLSM_SHIFT)
#define SMC_BRD_STOPCTRL_LLSM(base) (BME_UBFX32(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_LLSM_SHIFT, SMC_STOPCTRL_LLSM_WIDTH))

/*! @brief Set the LLSM field to a new value. */
#define SMC_WR_STOPCTRL_LLSM(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_LLSM_MASK, SMC_STOPCTRL_LLSM(value)))
#define SMC_BWR_STOPCTRL_LLSM(base, value) (BME_BFI32(&SMC_STOPCTRL_REG(base), ((uint32_t)(value) << SMC_STOPCTRL_LLSM_SHIFT), SMC_STOPCTRL_LLSM_SHIFT, SMC_STOPCTRL_LLSM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field LPOPO[3] (RW)
 *
 * Controls whether the 1 kHz LPO clock is enabled in LLS/VLLSx modes. During
 * VLLS0 mode, the LPO clock is disabled by hardware and this bit has no effect.
 *
 * Values:
 * - 0b0 - LPO clock is enabled in LLS/VLLSx
 * - 0b1 - LPO clock is disabled in LLS/VLLSx
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_LPOPO field. */
#define SMC_RD_STOPCTRL_LPOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_LPOPO_MASK) >> SMC_STOPCTRL_LPOPO_SHIFT)
#define SMC_BRD_STOPCTRL_LPOPO(base) (BME_UBFX32(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_LPOPO_SHIFT, SMC_STOPCTRL_LPOPO_WIDTH))

/*! @brief Set the LPOPO field to a new value. */
#define SMC_WR_STOPCTRL_LPOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_LPOPO_MASK, SMC_STOPCTRL_LPOPO(value)))
#define SMC_BWR_STOPCTRL_LPOPO(base, value) (BME_BFI32(&SMC_STOPCTRL_REG(base), ((uint32_t)(value) << SMC_STOPCTRL_LPOPO_SHIFT), SMC_STOPCTRL_LPOPO_SHIFT, SMC_STOPCTRL_LPOPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0b0 - POR detect circuit is enabled in VLLS0
 * - 0b1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PORPO field. */
#define SMC_RD_STOPCTRL_PORPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PORPO_MASK) >> SMC_STOPCTRL_PORPO_SHIFT)
#define SMC_BRD_STOPCTRL_PORPO(base) (BME_UBFX32(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))

/*! @brief Set the PORPO field to a new value. */
#define SMC_WR_STOPCTRL_PORPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PORPO_MASK, SMC_STOPCTRL_PORPO(value)))
#define SMC_BWR_STOPCTRL_PORPO(base, value) (BME_BFI32(&SMC_STOPCTRL_REG(base), ((uint32_t)(value) << SMC_STOPCTRL_PORPO_SHIFT), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN mode, the PMC, SCG and flash remain
 * fully powered, allowing the device to wakeup almost instantaneously at the
 * expense of higher power consumption. In PSTOP2, only system clocks are gated
 * allowing peripherals running on bus clock to remain fully functional. In PSTOP1,
 * both system and bus clocks are gated.
 *
 * Values:
 * - 0b00 - STOP - Normal Stop mode
 * - 0b01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 0b10 - PSTOP2 - Partial Stop with system clock disabled and bus clock
 *     enabled
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define SMC_RD_STOPCTRL_PSTOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PSTOPO_MASK) >> SMC_STOPCTRL_PSTOPO_SHIFT)
#define SMC_BRD_STOPCTRL_PSTOPO(base) (BME_UBFX32(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))

/*! @brief Set the PSTOPO field to a new value. */
#define SMC_WR_STOPCTRL_PSTOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PSTOPO_MASK, SMC_STOPCTRL_PSTOPO(value)))
#define SMC_BWR_STOPCTRL_PSTOPO(base, value) (BME_BFI32(&SMC_STOPCTRL_REG(base), ((uint32_t)(value) << SMC_STOPCTRL_PSTOPO_SHIFT), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x00000004U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual SMC_PMSTAT bitfields
 */

/*!
 * @name Register SMC_PMSTAT, field PMSTAT[7:0] (RO)
 *
 * When debug is enabled, the PMSTAT will not update to STOP or VLPS When a
 * PSTOP mode is enabled, the PMSTAT will not update to STOP or VLPS Since the RUNM
 * bits in the PMCTRL register are reset to VLPR on any Chip Reset not VLLS, the
 * PMSTAT will update to VLPR shortly after the reset sequence is complete.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMSTAT_PMSTAT field. */
#define SMC_RD_PMSTAT_PMSTAT(base) ((SMC_PMSTAT_REG(base) & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT)
#define SMC_BRD_PMSTAT_PMSTAT(base) (BME_UBFX32(&SMC_PMSTAT_REG(base), SMC_PMSTAT_PMSTAT_SHIFT, SMC_PMSTAT_PMSTAT_WIDTH))
/*@}*/

/*
 * MKL28Z7 TPM
 *
 * Timer/PWM Module
 *
 * Registers defined in this header file:
 * - TPM_SC - Status and Control
 * - TPM_CNT - Counter
 * - TPM_MOD - Modulo
 * - TPM_STATUS - Capture and Compare Status
 * - TPM_CnSC - Channel (n) Status and Control
 * - TPM_CnV - Channel (n) Value
 * - TPM_COMBINE - Combine Channel Register
 * - TPM_POL - Channel Polarity
 * - TPM_FILTER - Filter Control
 * - TPM_QDCTRL - Quadrature Decoder Control and Status
 * - TPM_CONF - Configuration
 */

#define TPM_INSTANCE_COUNT (3U) /*!< Number of instances of the TPM module. */
#define TPM2_IDX (0U) /*!< Instance number for TPM2. */
#define TPM0_IDX (1U) /*!< Instance number for TPM0. */
#define TPM1_IDX (2U) /*!< Instance number for TPM1. */

/*******************************************************************************
 * TPM_SC - Status and Control
 ******************************************************************************/

/*!
 * @brief TPM_SC - Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, module configuration and prescaler factor. These controls
 * relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire TPM_SC register
 */
/*@{*/
#define TPM_RD_SC(base)          (TPM_SC_REG(base))
#define TPM_WR_SC(base, value)   (TPM_SC_REG(base) = (value))
#define TPM_RMW_SC(base, mask, value) (TPM_WR_SC(base, (TPM_RD_SC(base) & ~(mask)) | (value)))
#define TPM_SET_SC(base, value)  (BME_OR32(&TPM_SC_REG(base), (uint32_t)(value)))
#define TPM_CLR_SC(base, value)  (BME_AND32(&TPM_SC_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_SC(base, value)  (BME_XOR32(&TPM_SC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_SC bitfields
 */

/*!
 * @name Register TPM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock mode selected by CMOD. This
 * field is write protected. It can be written only when the counter is disabled.
 *
 * Values:
 * - 0b000 - Divide by 1
 * - 0b001 - Divide by 2
 * - 0b010 - Divide by 4
 * - 0b011 - Divide by 8
 * - 0b100 - Divide by 16
 * - 0b101 - Divide by 32
 * - 0b110 - Divide by 64
 * - 0b111 - Divide by 128
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_PS field. */
#define TPM_RD_SC_PS(base)   ((TPM_SC_REG(base) & TPM_SC_PS_MASK) >> TPM_SC_PS_SHIFT)
#define TPM_BRD_SC_PS(base)  (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_PS_SHIFT, TPM_SC_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define TPM_WR_SC_PS(base, value) (TPM_RMW_SC(base, (TPM_SC_PS_MASK | TPM_SC_TOF_MASK), TPM_SC_PS(value)))
#define TPM_BWR_SC_PS(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_PS_SHIFT), TPM_SC_PS_SHIFT, TPM_SC_PS_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field CMOD[4:3] (RW)
 *
 * Selects the TPM counter clock modes. When disabling the counter, this field
 * remain set until acknolwedged in the TPM clock domain.
 *
 * Values:
 * - 0b00 - TPM counter is disabled
 * - 0b01 - TPM counter increments on every TPM counter clock
 * - 0b10 - TPM counter increments on rising edge of TPM_EXTCLK synchronized to
 *     the TPM counter clock
 * - 0b11 - TPM counter increments on rising edge of the selected external input
 *     trigger.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_CMOD field. */
#define TPM_RD_SC_CMOD(base) ((TPM_SC_REG(base) & TPM_SC_CMOD_MASK) >> TPM_SC_CMOD_SHIFT)
#define TPM_BRD_SC_CMOD(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_CMOD_SHIFT, TPM_SC_CMOD_WIDTH))

/*! @brief Set the CMOD field to a new value. */
#define TPM_WR_SC_CMOD(base, value) (TPM_RMW_SC(base, (TPM_SC_CMOD_MASK | TPM_SC_TOF_MASK), TPM_SC_CMOD(value)))
#define TPM_BWR_SC_CMOD(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_CMOD_SHIFT), TPM_SC_CMOD_SHIFT, TPM_SC_CMOD_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the TPM to operate in up-down
 * counting mode. This field is write protected. It can be written only when the counter
 * is disabled.
 *
 * Values:
 * - 0b0 - TPM counter operates in up counting mode.
 * - 0b1 - TPM counter operates in up-down counting mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_CPWMS field. */
#define TPM_RD_SC_CPWMS(base) ((TPM_SC_REG(base) & TPM_SC_CPWMS_MASK) >> TPM_SC_CPWMS_SHIFT)
#define TPM_BRD_SC_CPWMS(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_CPWMS_SHIFT, TPM_SC_CPWMS_WIDTH))

/*! @brief Set the CPWMS field to a new value. */
#define TPM_WR_SC_CPWMS(base, value) (TPM_RMW_SC(base, (TPM_SC_CPWMS_MASK | TPM_SC_TOF_MASK), TPM_SC_CPWMS(value)))
#define TPM_BWR_SC_CPWMS(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_CPWMS_SHIFT), TPM_SC_CPWMS_SHIFT, TPM_SC_CPWMS_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field TOIE[6] (RW)
 *
 * Enables TPM overflow interrupts.
 *
 * Values:
 * - 0b0 - Disable TOF interrupts. Use software polling or DMA request.
 * - 0b1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_TOIE field. */
#define TPM_RD_SC_TOIE(base) ((TPM_SC_REG(base) & TPM_SC_TOIE_MASK) >> TPM_SC_TOIE_SHIFT)
#define TPM_BRD_SC_TOIE(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_TOIE_SHIFT, TPM_SC_TOIE_WIDTH))

/*! @brief Set the TOIE field to a new value. */
#define TPM_WR_SC_TOIE(base, value) (TPM_RMW_SC(base, (TPM_SC_TOIE_MASK | TPM_SC_TOF_MASK), TPM_SC_TOIE(value)))
#define TPM_BWR_SC_TOIE(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_TOIE_SHIFT), TPM_SC_TOIE_SHIFT, TPM_SC_TOIE_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field TOF[7] (W1C)
 *
 * Set by hardware when the TPM counter equals the value in the MOD register and
 * increments. Writing a 1 to TOF clears it. Writing a 0 to TOF has no effect.
 * If another TPM overflow occurs between the flag setting and the flag clearing,
 * the write operation has no effect; therefore, TOF remains set indicating
 * another overflow has occurred. In this case a TOF interrupt request is not lost due
 * to a delay in clearing the previous TOF.
 *
 * Values:
 * - 0b0 - TPM counter has not overflowed.
 * - 0b1 - TPM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_TOF field. */
#define TPM_RD_SC_TOF(base)  ((TPM_SC_REG(base) & TPM_SC_TOF_MASK) >> TPM_SC_TOF_SHIFT)
#define TPM_BRD_SC_TOF(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_TOF_SHIFT, TPM_SC_TOF_WIDTH))

/*! @brief Set the TOF field to a new value. */
#define TPM_WR_SC_TOF(base, value) (TPM_RMW_SC(base, TPM_SC_TOF_MASK, TPM_SC_TOF(value)))
#define TPM_BWR_SC_TOF(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_TOF_SHIFT), TPM_SC_TOF_SHIFT, TPM_SC_TOF_WIDTH))
/*@}*/

/*!
 * @name Register TPM_SC, field DMA[8] (RW)
 *
 * Enables DMA transfers for the overflow flag.
 *
 * Values:
 * - 0b0 - Disables DMA transfers.
 * - 0b1 - Enables DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_DMA field. */
#define TPM_RD_SC_DMA(base)  ((TPM_SC_REG(base) & TPM_SC_DMA_MASK) >> TPM_SC_DMA_SHIFT)
#define TPM_BRD_SC_DMA(base) (BME_UBFX32(&TPM_SC_REG(base), TPM_SC_DMA_SHIFT, TPM_SC_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define TPM_WR_SC_DMA(base, value) (TPM_RMW_SC(base, (TPM_SC_DMA_MASK | TPM_SC_TOF_MASK), TPM_SC_DMA(value)))
#define TPM_BWR_SC_DMA(base, value) (BME_BFI32(&TPM_SC_REG(base), ((uint32_t)(value) << TPM_SC_DMA_SHIFT), TPM_SC_DMA_SHIFT, TPM_SC_DMA_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief TPM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the TPM counter value. Reset clears the CNT
 * register. Writing any value to COUNT also clears the counter. When debug is active,
 * the TPM counter does not increment unless configured otherwise. Reading the CNT
 * register adds two wait states to the register access due to synchronization
 * delays.
 */
/*!
 * @name Constants and macros for entire TPM_CNT register
 */
/*@{*/
#define TPM_RD_CNT(base)         (TPM_CNT_REG(base))
#define TPM_WR_CNT(base, value)  (TPM_CNT_REG(base) = (value))
#define TPM_RMW_CNT(base, mask, value) (TPM_WR_CNT(base, (TPM_RD_CNT(base) & ~(mask)) | (value)))
#define TPM_SET_CNT(base, value) (BME_OR32(&TPM_CNT_REG(base), (uint32_t)(value)))
#define TPM_CLR_CNT(base, value) (BME_AND32(&TPM_CNT_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_CNT(base, value) (BME_XOR32(&TPM_CNT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CNT bitfields
 */

/*!
 * @name Register TPM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the TPM_CNT_COUNT field. */
#define TPM_RD_CNT_COUNT(base) ((TPM_CNT_REG(base) & TPM_CNT_COUNT_MASK) >> TPM_CNT_COUNT_SHIFT)
#define TPM_BRD_CNT_COUNT(base) (TPM_RD_CNT_COUNT(base))

/*! @brief Set the COUNT field to a new value. */
#define TPM_WR_CNT_COUNT(base, value) (TPM_RMW_CNT(base, TPM_CNT_COUNT_MASK, TPM_CNT_COUNT(value)))
#define TPM_BWR_CNT_COUNT(base, value) (TPM_WR_CNT_COUNT(base, value))
/*@}*/

/*******************************************************************************
 * TPM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief TPM_MOD - Modulo (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * The Modulo register contains the modulo value for the TPM counter. When the
 * TPM counter reaches the modulo value and increments, the overflow flag (TOF) is
 * set and the next value of TPM counter depends on the selected counting method
 * (see CounterThe TPM has a 16-bit counter that is used by the channels either
 * for input or output modes. ). Writing to the MOD register latches the value
 * into a buffer. The MOD register is updated with the value of its write buffer
 * according to MOD Register Update . Additional writes to the MOD write buffer are
 * ignored until the register has been updated. It is recommended to initialize
 * the TPM counter (write to CNT) before writing to the MOD register to avoid
 * confusion about when the first counter overflow will occur.
 */
/*!
 * @name Constants and macros for entire TPM_MOD register
 */
/*@{*/
#define TPM_RD_MOD(base)         (TPM_MOD_REG(base))
#define TPM_WR_MOD(base, value)  (TPM_MOD_REG(base) = (value))
#define TPM_RMW_MOD(base, mask, value) (TPM_WR_MOD(base, (TPM_RD_MOD(base) & ~(mask)) | (value)))
#define TPM_SET_MOD(base, value) (BME_OR32(&TPM_MOD_REG(base), (uint32_t)(value)))
#define TPM_CLR_MOD(base, value) (BME_AND32(&TPM_MOD_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_MOD(base, value) (BME_XOR32(&TPM_MOD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_MOD bitfields
 */

/*!
 * @name Register TPM_MOD, field MOD[15:0] (RW)
 *
 * This field must be written with single 16-bit or 32-bit access.
 */
/*@{*/
/*! @brief Read current value of the TPM_MOD_MOD field. */
#define TPM_RD_MOD_MOD(base) ((TPM_MOD_REG(base) & TPM_MOD_MOD_MASK) >> TPM_MOD_MOD_SHIFT)
#define TPM_BRD_MOD_MOD(base) (TPM_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define TPM_WR_MOD_MOD(base, value) (TPM_RMW_MOD(base, TPM_MOD_MOD_MASK, TPM_MOD_MOD(value)))
#define TPM_BWR_MOD_MOD(base, value) (TPM_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * TPM_STATUS - Capture and Compare Status
 ******************************************************************************/

/*!
 * @brief TPM_STATUS - Capture and Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag, CnSC[CHnF] for each
 * TPM channel, as well as SC[TOF], for software convenience. Each CHnF bit in
 * STATUS is a mirror of CHnF bit in CnSC. All CHnF bits can be checked using only
 * one read of STATUS. All CHnF bits can be cleared by writing all ones to STATUS.
 * Hardware sets the individual channel flags when an event occurs on the
 * channel. Writing a 1 to CHF clears it. Writing a 0 to CHF has no effect. If another
 * event occurs between the flag setting and the write operation, the write
 * operation has no effect; therefore, CHF remains set indicating another event has
 * occurred. In this case a CHF interrupt request is not lost due to the clearing
 * sequence for a previous CHF.
 */
/*!
 * @name Constants and macros for entire TPM_STATUS register
 */
/*@{*/
#define TPM_RD_STATUS(base)      (TPM_STATUS_REG(base))
#define TPM_WR_STATUS(base, value) (TPM_STATUS_REG(base) = (value))
#define TPM_RMW_STATUS(base, mask, value) (TPM_WR_STATUS(base, (TPM_RD_STATUS(base) & ~(mask)) | (value)))
#define TPM_SET_STATUS(base, value) (BME_OR32(&TPM_STATUS_REG(base), (uint32_t)(value)))
#define TPM_CLR_STATUS(base, value) (BME_AND32(&TPM_STATUS_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_STATUS(base, value) (BME_XOR32(&TPM_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_STATUS bitfields
 */

/*!
 * @name Register TPM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH0F field. */
#define TPM_RD_STATUS_CH0F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH0F_MASK) >> TPM_STATUS_CH0F_SHIFT)
#define TPM_BRD_STATUS_CH0F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH0F_SHIFT, TPM_STATUS_CH0F_WIDTH))

/*! @brief Set the CH0F field to a new value. */
#define TPM_WR_STATUS_CH0F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH0F(value)))
#define TPM_BWR_STATUS_CH0F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH0F_SHIFT), TPM_STATUS_CH0F_SHIFT, TPM_STATUS_CH0F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH1F field. */
#define TPM_RD_STATUS_CH1F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH1F_MASK) >> TPM_STATUS_CH1F_SHIFT)
#define TPM_BRD_STATUS_CH1F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH1F_SHIFT, TPM_STATUS_CH1F_WIDTH))

/*! @brief Set the CH1F field to a new value. */
#define TPM_WR_STATUS_CH1F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH1F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH1F(value)))
#define TPM_BWR_STATUS_CH1F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH1F_SHIFT), TPM_STATUS_CH1F_SHIFT, TPM_STATUS_CH1F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH2F field. */
#define TPM_RD_STATUS_CH2F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH2F_MASK) >> TPM_STATUS_CH2F_SHIFT)
#define TPM_BRD_STATUS_CH2F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH2F_SHIFT, TPM_STATUS_CH2F_WIDTH))

/*! @brief Set the CH2F field to a new value. */
#define TPM_WR_STATUS_CH2F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH2F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH2F(value)))
#define TPM_BWR_STATUS_CH2F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH2F_SHIFT), TPM_STATUS_CH2F_SHIFT, TPM_STATUS_CH2F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH3F field. */
#define TPM_RD_STATUS_CH3F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH3F_MASK) >> TPM_STATUS_CH3F_SHIFT)
#define TPM_BRD_STATUS_CH3F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH3F_SHIFT, TPM_STATUS_CH3F_WIDTH))

/*! @brief Set the CH3F field to a new value. */
#define TPM_WR_STATUS_CH3F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH3F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH3F(value)))
#define TPM_BWR_STATUS_CH3F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH3F_SHIFT), TPM_STATUS_CH3F_SHIFT, TPM_STATUS_CH3F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH4F field. */
#define TPM_RD_STATUS_CH4F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH4F_MASK) >> TPM_STATUS_CH4F_SHIFT)
#define TPM_BRD_STATUS_CH4F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH4F_SHIFT, TPM_STATUS_CH4F_WIDTH))

/*! @brief Set the CH4F field to a new value. */
#define TPM_WR_STATUS_CH4F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH4F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH4F(value)))
#define TPM_BWR_STATUS_CH4F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH4F_SHIFT), TPM_STATUS_CH4F_SHIFT, TPM_STATUS_CH4F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH5F field. */
#define TPM_RD_STATUS_CH5F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH5F_MASK) >> TPM_STATUS_CH5F_SHIFT)
#define TPM_BRD_STATUS_CH5F(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_CH5F_SHIFT, TPM_STATUS_CH5F_WIDTH))

/*! @brief Set the CH5F field to a new value. */
#define TPM_WR_STATUS_CH5F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH5F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH5F(value)))
#define TPM_BWR_STATUS_CH5F(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_CH5F_SHIFT), TPM_STATUS_CH5F_SHIFT, TPM_STATUS_CH5F_WIDTH))
/*@}*/

/*!
 * @name Register TPM_STATUS, field TOF[8] (W1C)
 *
 * See register description
 *
 * Values:
 * - 0b0 - TPM counter has not overflowed.
 * - 0b1 - TPM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_TOF field. */
#define TPM_RD_STATUS_TOF(base) ((TPM_STATUS_REG(base) & TPM_STATUS_TOF_MASK) >> TPM_STATUS_TOF_SHIFT)
#define TPM_BRD_STATUS_TOF(base) (BME_UBFX32(&TPM_STATUS_REG(base), TPM_STATUS_TOF_SHIFT, TPM_STATUS_TOF_WIDTH))

/*! @brief Set the TOF field to a new value. */
#define TPM_WR_STATUS_TOF(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_TOF_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK), TPM_STATUS_TOF(value)))
#define TPM_BWR_STATUS_TOF(base, value) (BME_BFI32(&TPM_STATUS_REG(base), ((uint32_t)(value) << TPM_STATUS_TOF_SHIFT), TPM_STATUS_TOF_SHIFT, TPM_STATUS_TOF_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CnSC - Channel (n) Status and Control
 ******************************************************************************/

/*!
 * @brief TPM_CnSC - Channel (n) Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. When
 * switching from one channel mode to a different channel mode, the channel must
 * first be disabled and this must be acknowledged in the TPM counter clock domain.
 * Mode, Edge, and Level Selection CPWMS MSnB:MSnA ELSnB:ELSnA Mode Configuration
 * X 00 00 None Channel disabled X 01 00 Software compare Pin not used for TPM 0
 * 00 01 Input capture Capture on Rising Edge Only 10 Capture on Falling Edge
 * Only 11 Capture on Rising or Falling Edge 01 01 Output compare Toggle Output on
 * match 10 Clear Output on match 11 Set Output on match 10 10 Edge-aligned PWM
 * High-true pulses (clear Output on match, set Output on reload) X1 Low-true
 * pulses (set Output on match, clear Output on reload) 11 10 Output compare Pulse
 * Output low on match 01 Pulse Output high on match 1 10 10 Center-aligned PWM
 * High-true pulses (clear Output on match-up, set Output on match-down) 01 Low-true
 * pulses (set Output on match-up, clear Output on match-down)
 */
/*!
 * @name Constants and macros for entire TPM_CnSC register
 */
/*@{*/
#define TPM_RD_CnSC(base, index) (TPM_CnSC_REG(base, index))
#define TPM_WR_CnSC(base, index, value) (TPM_CnSC_REG(base, index) = (value))
#define TPM_RMW_CnSC(base, index, mask, value) (TPM_WR_CnSC(base, index, (TPM_RD_CnSC(base, index) & ~(mask)) | (value)))
#define TPM_SET_CnSC(base, index, value) (BME_OR32(&TPM_CnSC_REG(base, index), (uint32_t)(value)))
#define TPM_CLR_CnSC(base, index, value) (BME_AND32(&TPM_CnSC_REG(base, index), (uint32_t)(~(value))))
#define TPM_TOG_CnSC(base, index, value) (BME_XOR32(&TPM_CnSC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnSC bitfields
 */

/*!
 * @name Register TPM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_DMA field. */
#define TPM_RD_CnSC_DMA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_DMA_MASK) >> TPM_CnSC_DMA_SHIFT)
#define TPM_BRD_CnSC_DMA(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_DMA_SHIFT, TPM_CnSC_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define TPM_WR_CnSC_DMA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_DMA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_DMA(value)))
#define TPM_BWR_CnSC_DMA(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_DMA_SHIFT), TPM_CnSC_DMA_SHIFT, TPM_CnSC_DMA_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_ELSA field. */
#define TPM_RD_CnSC_ELSA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_ELSA_MASK) >> TPM_CnSC_ELSA_SHIFT)
#define TPM_BRD_CnSC_ELSA(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSA_SHIFT, TPM_CnSC_ELSA_WIDTH))

/*! @brief Set the ELSA field to a new value. */
#define TPM_WR_CnSC_ELSA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_ELSA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_ELSA(value)))
#define TPM_BWR_CnSC_ELSA(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_ELSA_SHIFT), TPM_CnSC_ELSA_SHIFT, TPM_CnSC_ELSA_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_ELSB field. */
#define TPM_RD_CnSC_ELSB(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_ELSB_MASK) >> TPM_CnSC_ELSB_SHIFT)
#define TPM_BRD_CnSC_ELSB(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSB_SHIFT, TPM_CnSC_ELSB_WIDTH))

/*! @brief Set the ELSB field to a new value. */
#define TPM_WR_CnSC_ELSB(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_ELSB_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_ELSB(value)))
#define TPM_BWR_CnSC_ELSB(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_ELSB_SHIFT), TPM_CnSC_ELSB_SHIFT, TPM_CnSC_ELSB_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_MSA field. */
#define TPM_RD_CnSC_MSA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_MSA_MASK) >> TPM_CnSC_MSA_SHIFT)
#define TPM_BRD_CnSC_MSA(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSA_SHIFT, TPM_CnSC_MSA_WIDTH))

/*! @brief Set the MSA field to a new value. */
#define TPM_WR_CnSC_MSA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_MSA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_MSA(value)))
#define TPM_BWR_CnSC_MSA(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_MSA_SHIFT), TPM_CnSC_MSA_SHIFT, TPM_CnSC_MSA_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_MSB field. */
#define TPM_RD_CnSC_MSB(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_MSB_MASK) >> TPM_CnSC_MSB_SHIFT)
#define TPM_BRD_CnSC_MSB(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSB_SHIFT, TPM_CnSC_MSB_WIDTH))

/*! @brief Set the MSB field to a new value. */
#define TPM_WR_CnSC_MSB(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_MSB_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_MSB(value)))
#define TPM_BWR_CnSC_MSB(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_MSB_SHIFT), TPM_CnSC_MSB_SHIFT, TPM_CnSC_MSB_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_CHIE field. */
#define TPM_RD_CnSC_CHIE(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_CHIE_MASK) >> TPM_CnSC_CHIE_SHIFT)
#define TPM_BRD_CnSC_CHIE(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHIE_SHIFT, TPM_CnSC_CHIE_WIDTH))

/*! @brief Set the CHIE field to a new value. */
#define TPM_WR_CnSC_CHIE(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_CHIE_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_CHIE(value)))
#define TPM_BWR_CnSC_CHIE(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_CHIE_SHIFT), TPM_CnSC_CHIE_SHIFT, TPM_CnSC_CHIE_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHF[7] (W1C)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * writing a 1 to the CHF bit. Writing a 0 to CHF has no effect. If another event
 * occurs between the CHF sets and the write operation, the write operation has no
 * effect; therefore, CHF remains set indicating another event has occurred. In this
 * case a CHF interrupt request is not lost due to the delay in clearing the
 * previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_CHF field. */
#define TPM_RD_CnSC_CHF(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_CHF_MASK) >> TPM_CnSC_CHF_SHIFT)
#define TPM_BRD_CnSC_CHF(base, index) (BME_UBFX32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHF_SHIFT, TPM_CnSC_CHF_WIDTH))

/*! @brief Set the CHF field to a new value. */
#define TPM_WR_CnSC_CHF(base, index, value) (TPM_RMW_CnSC(base, index, TPM_CnSC_CHF_MASK, TPM_CnSC_CHF(value)))
#define TPM_BWR_CnSC_CHF(base, index, value) (BME_BFI32(&TPM_CnSC_REG(base, index), ((uint32_t)(value) << TPM_CnSC_CHF_SHIFT), TPM_CnSC_CHF_SHIFT, TPM_CnSC_CHF_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief TPM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured TPM counter value for the input modes or
 * the match value for the output modes. In input capture mode, any write to a
 * CnV register is ignored. In compare modes, writing to a CnV register latches
 * the value into a buffer. A CnV register is updated with the value of its write
 * buffer according to CnV Register Update . Additional writes to the CnV write
 * buffer are ignored until the register has been updated.
 */
/*!
 * @name Constants and macros for entire TPM_CnV register
 */
/*@{*/
#define TPM_RD_CnV(base, index)  (TPM_CnV_REG(base, index))
#define TPM_WR_CnV(base, index, value) (TPM_CnV_REG(base, index) = (value))
#define TPM_RMW_CnV(base, index, mask, value) (TPM_WR_CnV(base, index, (TPM_RD_CnV(base, index) & ~(mask)) | (value)))
#define TPM_SET_CnV(base, index, value) (BME_OR32(&TPM_CnV_REG(base, index), (uint32_t)(value)))
#define TPM_CLR_CnV(base, index, value) (BME_AND32(&TPM_CnV_REG(base, index), (uint32_t)(~(value))))
#define TPM_TOG_CnV(base, index, value) (BME_XOR32(&TPM_CnV_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnV bitfields
 */

/*!
 * @name Register TPM_CnV, field VAL[15:0] (RW)
 *
 * Captured TPM counter value of the input modes or the match value for the
 * output modes. This field must be written with single 16-bit or 32-bit access.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnV_VAL field. */
#define TPM_RD_CnV_VAL(base, index) ((TPM_CnV_REG(base, index) & TPM_CnV_VAL_MASK) >> TPM_CnV_VAL_SHIFT)
#define TPM_BRD_CnV_VAL(base, index) (TPM_RD_CnV_VAL(base, index))

/*! @brief Set the VAL field to a new value. */
#define TPM_WR_CnV_VAL(base, index, value) (TPM_RMW_CnV(base, index, TPM_CnV_VAL_MASK, TPM_CnV_VAL(value)))
#define TPM_BWR_CnV_VAL(base, index, value) (TPM_WR_CnV_VAL(base, index, value))
/*@}*/

/*******************************************************************************
 * TPM_COMBINE - Combine Channel Register
 ******************************************************************************/

/*!
 * @brief TPM_COMBINE - Combine Channel Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the combine channel
 * modes for each pair of channels (n) and (n+1), where n is all the even
 * numbered channels.
 */
/*!
 * @name Constants and macros for entire TPM_COMBINE register
 */
/*@{*/
#define TPM_RD_COMBINE(base)     (TPM_COMBINE_REG(base))
#define TPM_WR_COMBINE(base, value) (TPM_COMBINE_REG(base) = (value))
#define TPM_RMW_COMBINE(base, mask, value) (TPM_WR_COMBINE(base, (TPM_RD_COMBINE(base) & ~(mask)) | (value)))
#define TPM_SET_COMBINE(base, value) (BME_OR32(&TPM_COMBINE_REG(base), (uint32_t)(value)))
#define TPM_CLR_COMBINE(base, value) (BME_AND32(&TPM_COMBINE_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_COMBINE(base, value) (BME_XOR32(&TPM_COMBINE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_COMBINE bitfields
 */

/*!
 * @name Register TPM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels 0 and 1. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0b0 - Channels 0 and 1 are independent.
 * - 0b1 - Channels 0 and 1 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE0 field. */
#define TPM_RD_COMBINE_COMBINE0(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE0_MASK) >> TPM_COMBINE_COMBINE0_SHIFT)
#define TPM_BRD_COMBINE_COMBINE0(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE0_SHIFT, TPM_COMBINE_COMBINE0_WIDTH))

/*! @brief Set the COMBINE0 field to a new value. */
#define TPM_WR_COMBINE_COMBINE0(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE0_MASK, TPM_COMBINE_COMBINE0(value)))
#define TPM_BWR_COMBINE_COMBINE0(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMBINE0_SHIFT), TPM_COMBINE_COMBINE0_SHIFT, TPM_COMBINE_COMBINE0_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP0[1] (RW)
 *
 * When set in combine mode, the even channel is used for the input capture and
 * 1st compare, the odd channel is used for the 2nd compare.
 *
 * Values:
 * - 0b0 - Even channel is used for input capture and 1st compare.
 * - 0b1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP0 field. */
#define TPM_RD_COMBINE_COMSWAP0(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP0_MASK) >> TPM_COMBINE_COMSWAP0_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP0(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP0_SHIFT, TPM_COMBINE_COMSWAP0_WIDTH))

/*! @brief Set the COMSWAP0 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP0(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP0_MASK, TPM_COMBINE_COMSWAP0(value)))
#define TPM_BWR_COMBINE_COMSWAP0(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMSWAP0_SHIFT), TPM_COMBINE_COMSWAP0_SHIFT, TPM_COMBINE_COMSWAP0_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels 2 and 3. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0b0 - Channels 2 and 3 are independent.
 * - 0b1 - Channels 2 and 3 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE1 field. */
#define TPM_RD_COMBINE_COMBINE1(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE1_MASK) >> TPM_COMBINE_COMBINE1_SHIFT)
#define TPM_BRD_COMBINE_COMBINE1(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE1_SHIFT, TPM_COMBINE_COMBINE1_WIDTH))

/*! @brief Set the COMBINE1 field to a new value. */
#define TPM_WR_COMBINE_COMBINE1(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE1_MASK, TPM_COMBINE_COMBINE1(value)))
#define TPM_BWR_COMBINE_COMBINE1(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMBINE1_SHIFT), TPM_COMBINE_COMBINE1_SHIFT, TPM_COMBINE_COMBINE1_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP1[9] (RW)
 *
 * When set in combine mode, the odd channel is used for the input capture and
 * 1st compare, the even channel is used for the 2nd compare.
 *
 * Values:
 * - 0b0 - Even channel is used for input capture and 1st compare.
 * - 0b1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP1 field. */
#define TPM_RD_COMBINE_COMSWAP1(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP1_MASK) >> TPM_COMBINE_COMSWAP1_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP1(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP1_SHIFT, TPM_COMBINE_COMSWAP1_WIDTH))

/*! @brief Set the COMSWAP1 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP1(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP1_MASK, TPM_COMBINE_COMSWAP1(value)))
#define TPM_BWR_COMBINE_COMSWAP1(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMSWAP1_SHIFT), TPM_COMBINE_COMSWAP1_SHIFT, TPM_COMBINE_COMSWAP1_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMBINE2[16] (RW)
 *
 * Enables the combine feature for channels 2 and 3. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0b0 - Channels 4 and 5 are independent.
 * - 0b1 - Channels 4 and 5 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE2 field. */
#define TPM_RD_COMBINE_COMBINE2(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE2_MASK) >> TPM_COMBINE_COMBINE2_SHIFT)
#define TPM_BRD_COMBINE_COMBINE2(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE2_SHIFT, TPM_COMBINE_COMBINE2_WIDTH))

/*! @brief Set the COMBINE2 field to a new value. */
#define TPM_WR_COMBINE_COMBINE2(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE2_MASK, TPM_COMBINE_COMBINE2(value)))
#define TPM_BWR_COMBINE_COMBINE2(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMBINE2_SHIFT), TPM_COMBINE_COMBINE2_SHIFT, TPM_COMBINE_COMBINE2_WIDTH))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP2[17] (RW)
 *
 * When set in combine mode, the even channel is used for the input capture and
 * 1st compare, the odd channel is used for the 2nd compare.
 *
 * Values:
 * - 0b0 - Even channel is used for input capture and 1st compare.
 * - 0b1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP2 field. */
#define TPM_RD_COMBINE_COMSWAP2(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP2_MASK) >> TPM_COMBINE_COMSWAP2_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP2(base) (BME_UBFX32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP2_SHIFT, TPM_COMBINE_COMSWAP2_WIDTH))

/*! @brief Set the COMSWAP2 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP2(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP2_MASK, TPM_COMBINE_COMSWAP2(value)))
#define TPM_BWR_COMBINE_COMSWAP2(base, value) (BME_BFI32(&TPM_COMBINE_REG(base), ((uint32_t)(value) << TPM_COMBINE_COMSWAP2_SHIFT), TPM_COMBINE_COMSWAP2_SHIFT, TPM_COMBINE_COMSWAP2_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_POL - Channel Polarity
 ******************************************************************************/

/*!
 * @brief TPM_POL - Channel Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the input and output polarity of each of the channels.
 */
/*!
 * @name Constants and macros for entire TPM_POL register
 */
/*@{*/
#define TPM_RD_POL(base)         (TPM_POL_REG(base))
#define TPM_WR_POL(base, value)  (TPM_POL_REG(base) = (value))
#define TPM_RMW_POL(base, mask, value) (TPM_WR_POL(base, (TPM_RD_POL(base) & ~(mask)) | (value)))
#define TPM_SET_POL(base, value) (BME_OR32(&TPM_POL_REG(base), (uint32_t)(value)))
#define TPM_CLR_POL(base, value) (BME_AND32(&TPM_POL_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_POL(base, value) (BME_XOR32(&TPM_POL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_POL bitfields
 */

/*!
 * @name Register TPM_POL, field POL0[0] (RW)
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL0 field. */
#define TPM_RD_POL_POL0(base) ((TPM_POL_REG(base) & TPM_POL_POL0_MASK) >> TPM_POL_POL0_SHIFT)
#define TPM_BRD_POL_POL0(base) (BME_UBFX32(&TPM_POL_REG(base), TPM_POL_POL0_SHIFT, TPM_POL_POL0_WIDTH))

/*! @brief Set the POL0 field to a new value. */
#define TPM_WR_POL_POL0(base, value) (TPM_RMW_POL(base, TPM_POL_POL0_MASK, TPM_POL_POL0(value)))
#define TPM_BWR_POL_POL0(base, value) (BME_BFI32(&TPM_POL_REG(base), ((uint32_t)(value) << TPM_POL_POL0_SHIFT), TPM_POL_POL0_SHIFT, TPM_POL_POL0_WIDTH))
/*@}*/

/*!
 * @name Register TPM_POL, field POL1[1] (RW)
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL1 field. */
#define TPM_RD_POL_POL1(base) ((TPM_POL_REG(base) & TPM_POL_POL1_MASK) >> TPM_POL_POL1_SHIFT)
#define TPM_BRD_POL_POL1(base) (BME_UBFX32(&TPM_POL_REG(base), TPM_POL_POL1_SHIFT, TPM_POL_POL1_WIDTH))

/*! @brief Set the POL1 field to a new value. */
#define TPM_WR_POL_POL1(base, value) (TPM_RMW_POL(base, TPM_POL_POL1_MASK, TPM_POL_POL1(value)))
#define TPM_BWR_POL_POL1(base, value) (BME_BFI32(&TPM_POL_REG(base), ((uint32_t)(value) << TPM_POL_POL1_SHIFT), TPM_POL_POL1_SHIFT, TPM_POL_POL1_WIDTH))
/*@}*/

/*!
 * @name Register TPM_POL, field POL2[2] (RW)
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL2 field. */
#define TPM_RD_POL_POL2(base) ((TPM_POL_REG(base) & TPM_POL_POL2_MASK) >> TPM_POL_POL2_SHIFT)
#define TPM_BRD_POL_POL2(base) (BME_UBFX32(&TPM_POL_REG(base), TPM_POL_POL2_SHIFT, TPM_POL_POL2_WIDTH))

/*! @brief Set the POL2 field to a new value. */
#define TPM_WR_POL_POL2(base, value) (TPM_RMW_POL(base, TPM_POL_POL2_MASK, TPM_POL_POL2(value)))
#define TPM_BWR_POL_POL2(base, value) (BME_BFI32(&TPM_POL_REG(base), ((uint32_t)(value) << TPM_POL_POL2_SHIFT), TPM_POL_POL2_SHIFT, TPM_POL_POL2_WIDTH))
/*@}*/

/*!
 * @name Register TPM_POL, field POL3[3] (RW)
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL3 field. */
#define TPM_RD_POL_POL3(base) ((TPM_POL_REG(base) & TPM_POL_POL3_MASK) >> TPM_POL_POL3_SHIFT)
#define TPM_BRD_POL_POL3(base) (BME_UBFX32(&TPM_POL_REG(base), TPM_POL_POL3_SHIFT, TPM_POL_POL3_WIDTH))

/*! @brief Set the POL3 field to a new value. */
#define TPM_WR_POL_POL3(base, value) (TPM_RMW_POL(base, TPM_POL_POL3_MASK, TPM_POL_POL3(value)))
#define TPM_BWR_POL_POL3(base, value) (BME_BFI32(&TPM_POL_REG(base), ((uint32_t)(value) << TPM_POL_POL3_SHIFT), TPM_POL_POL3_SHIFT, TPM_POL_POL3_WIDTH))
/*@}*/

/*!
 * @name Register TPM_POL, field POL4[4] (RW)
 *
 * Values:
 * - 0b0 - The channel polarity is active high
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL4 field. */
#define TPM_RD_POL_POL4(base) ((TPM_POL_REG(base) & TPM_POL_POL4_MASK) >> TPM_POL_POL4_SHIFT)
#define TPM_BRD_POL_POL4(base) (BME_UBFX32(&TPM_POL_REG(base), TPM_POL_POL4_SHIFT, TPM_POL_POL4_WIDTH))

/*! @brief Set the POL4 field to a new value. */
#define TPM_WR_POL_POL4(base, value) (TPM_RMW_POL(base, TPM_POL_POL4_MASK, TPM_POL_POL4(value)))
#define TPM_BWR_POL_POL4(base, value) (BME_BFI32(&TPM_POL_REG(base), ((uint32_t)(value) << TPM_POL_POL4_SHIFT), TPM_POL_POL4_SHIFT, TPM_POL_POL4_WIDTH))
/*@}*/

/*!
 * @name Register TPM_POL, field POL5[5] (RW)
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL5 field. */
#define TPM_RD_POL_POL5(base) ((TPM_POL_REG(base) & TPM_POL_POL5_MASK) >> TPM_POL_POL5_SHIFT)
#define TPM_BRD_POL_POL5(base) (BME_UBFX32(&TPM_POL_REG(base), TPM_POL_POL5_SHIFT, TPM_POL_POL5_WIDTH))

/*! @brief Set the POL5 field to a new value. */
#define TPM_WR_POL_POL5(base, value) (TPM_RMW_POL(base, TPM_POL_POL5_MASK, TPM_POL_POL5(value)))
#define TPM_BWR_POL_POL5(base, value) (BME_BFI32(&TPM_POL_REG(base), ((uint32_t)(value) << TPM_POL_POL5_SHIFT), TPM_POL_POL5_SHIFT, TPM_POL_POL5_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_FILTER - Filter Control
 ******************************************************************************/

/*!
 * @brief TPM_FILTER - Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value of the channel inputs, and an
 * additional output delay value for the channel outputs. In PWM combine modes, the
 * filter can effectively implements deadtime insertion.
 */
/*!
 * @name Constants and macros for entire TPM_FILTER register
 */
/*@{*/
#define TPM_RD_FILTER(base)      (TPM_FILTER_REG(base))
#define TPM_WR_FILTER(base, value) (TPM_FILTER_REG(base) = (value))
#define TPM_RMW_FILTER(base, mask, value) (TPM_WR_FILTER(base, (TPM_RD_FILTER(base) & ~(mask)) | (value)))
#define TPM_SET_FILTER(base, value) (BME_OR32(&TPM_FILTER_REG(base), (uint32_t)(value)))
#define TPM_CLR_FILTER(base, value) (BME_AND32(&TPM_FILTER_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_FILTER(base, value) (BME_XOR32(&TPM_FILTER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_FILTER bitfields
 */

/*!
 * @name Register TPM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH0FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH0FVAL field. */
#define TPM_RD_FILTER_CH0FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH0FVAL_MASK) >> TPM_FILTER_CH0FVAL_SHIFT)
#define TPM_BRD_FILTER_CH0FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH0FVAL_SHIFT, TPM_FILTER_CH0FVAL_WIDTH))

/*! @brief Set the CH0FVAL field to a new value. */
#define TPM_WR_FILTER_CH0FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH0FVAL_MASK, TPM_FILTER_CH0FVAL(value)))
#define TPM_BWR_FILTER_CH0FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH0FVAL_SHIFT), TPM_FILTER_CH0FVAL_SHIFT, TPM_FILTER_CH0FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH1FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH1FVAL field. */
#define TPM_RD_FILTER_CH1FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH1FVAL_MASK) >> TPM_FILTER_CH1FVAL_SHIFT)
#define TPM_BRD_FILTER_CH1FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH1FVAL_SHIFT, TPM_FILTER_CH1FVAL_WIDTH))

/*! @brief Set the CH1FVAL field to a new value. */
#define TPM_WR_FILTER_CH1FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH1FVAL_MASK, TPM_FILTER_CH1FVAL(value)))
#define TPM_BWR_FILTER_CH1FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH1FVAL_SHIFT), TPM_FILTER_CH1FVAL_SHIFT, TPM_FILTER_CH1FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH2FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH2FVAL field. */
#define TPM_RD_FILTER_CH2FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH2FVAL_MASK) >> TPM_FILTER_CH2FVAL_SHIFT)
#define TPM_BRD_FILTER_CH2FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH2FVAL_SHIFT, TPM_FILTER_CH2FVAL_WIDTH))

/*! @brief Set the CH2FVAL field to a new value. */
#define TPM_WR_FILTER_CH2FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH2FVAL_MASK, TPM_FILTER_CH2FVAL(value)))
#define TPM_BWR_FILTER_CH2FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH2FVAL_SHIFT), TPM_FILTER_CH2FVAL_SHIFT, TPM_FILTER_CH2FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH3FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH3FVAL field. */
#define TPM_RD_FILTER_CH3FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH3FVAL_MASK) >> TPM_FILTER_CH3FVAL_SHIFT)
#define TPM_BRD_FILTER_CH3FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH3FVAL_SHIFT, TPM_FILTER_CH3FVAL_WIDTH))

/*! @brief Set the CH3FVAL field to a new value. */
#define TPM_WR_FILTER_CH3FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH3FVAL_MASK, TPM_FILTER_CH3FVAL(value)))
#define TPM_BWR_FILTER_CH3FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH3FVAL_SHIFT), TPM_FILTER_CH3FVAL_SHIFT, TPM_FILTER_CH3FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH4FVAL[19:16] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH4FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH4FVAL field. */
#define TPM_RD_FILTER_CH4FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH4FVAL_MASK) >> TPM_FILTER_CH4FVAL_SHIFT)
#define TPM_BRD_FILTER_CH4FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH4FVAL_SHIFT, TPM_FILTER_CH4FVAL_WIDTH))

/*! @brief Set the CH4FVAL field to a new value. */
#define TPM_WR_FILTER_CH4FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH4FVAL_MASK, TPM_FILTER_CH4FVAL(value)))
#define TPM_BWR_FILTER_CH4FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH4FVAL_SHIFT), TPM_FILTER_CH4FVAL_SHIFT, TPM_FILTER_CH4FVAL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH5FVAL[23:20] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH5FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH5FVAL field. */
#define TPM_RD_FILTER_CH5FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH5FVAL_MASK) >> TPM_FILTER_CH5FVAL_SHIFT)
#define TPM_BRD_FILTER_CH5FVAL(base) (BME_UBFX32(&TPM_FILTER_REG(base), TPM_FILTER_CH5FVAL_SHIFT, TPM_FILTER_CH5FVAL_WIDTH))

/*! @brief Set the CH5FVAL field to a new value. */
#define TPM_WR_FILTER_CH5FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH5FVAL_MASK, TPM_FILTER_CH5FVAL(value)))
#define TPM_BWR_FILTER_CH5FVAL(base, value) (BME_BFI32(&TPM_FILTER_REG(base), ((uint32_t)(value) << TPM_FILTER_CH5FVAL_SHIFT), TPM_FILTER_CH5FVAL_SHIFT, TPM_FILTER_CH5FVAL_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_QDCTRL - Quadrature Decoder Control and Status
 ******************************************************************************/

/*!
 * @brief TPM_QDCTRL - Quadrature Decoder Control and Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the quadrature decoder mode.
 */
/*!
 * @name Constants and macros for entire TPM_QDCTRL register
 */
/*@{*/
#define TPM_RD_QDCTRL(base)      (TPM_QDCTRL_REG(base))
#define TPM_WR_QDCTRL(base, value) (TPM_QDCTRL_REG(base) = (value))
#define TPM_RMW_QDCTRL(base, mask, value) (TPM_WR_QDCTRL(base, (TPM_RD_QDCTRL(base) & ~(mask)) | (value)))
#define TPM_SET_QDCTRL(base, value) (BME_OR32(&TPM_QDCTRL_REG(base), (uint32_t)(value)))
#define TPM_CLR_QDCTRL(base, value) (BME_AND32(&TPM_QDCTRL_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_QDCTRL(base, value) (BME_XOR32(&TPM_QDCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_QDCTRL bitfields
 */

/*!
 * @name Register TPM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the quadrature decoder mode. In this mode, the channel 0 and channel
 * 1 inputs control the TPM counter direction and can only be used for software
 * compare. The quadrature decoder mode has precedence over the other modes.
 *
 * Values:
 * - 0b0 - Quadrature decoder mode is disabled.
 * - 0b1 - Quadrature decoder mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADEN field. */
#define TPM_RD_QDCTRL_QUADEN(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADEN_MASK) >> TPM_QDCTRL_QUADEN_SHIFT)
#define TPM_BRD_QDCTRL_QUADEN(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADEN_SHIFT, TPM_QDCTRL_QUADEN_WIDTH))

/*! @brief Set the QUADEN field to a new value. */
#define TPM_WR_QDCTRL_QUADEN(base, value) (TPM_RMW_QDCTRL(base, TPM_QDCTRL_QUADEN_MASK, TPM_QDCTRL_QUADEN(value)))
#define TPM_BWR_QDCTRL_QUADEN(base, value) (BME_BFI32(&TPM_QDCTRL_REG(base), ((uint32_t)(value) << TPM_QDCTRL_QUADEN_SHIFT), TPM_QDCTRL_QUADEN_SHIFT, TPM_QDCTRL_QUADEN_WIDTH))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0b0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (zero) to its
 *     maximum value (MOD register).
 * - 0b1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (zero).
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_TOFDIR field. */
#define TPM_RD_QDCTRL_TOFDIR(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_TOFDIR_MASK) >> TPM_QDCTRL_TOFDIR_SHIFT)
#define TPM_BRD_QDCTRL_TOFDIR(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_TOFDIR_SHIFT, TPM_QDCTRL_TOFDIR_WIDTH))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0b0 - Counter direction is decreasing (counter decrement).
 * - 0b1 - Counter direction is increasing (counter increment).
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADIR field. */
#define TPM_RD_QDCTRL_QUADIR(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADIR_MASK) >> TPM_QDCTRL_QUADIR_SHIFT)
#define TPM_BRD_QDCTRL_QUADIR(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADIR_SHIFT, TPM_QDCTRL_QUADIR_WIDTH))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the quadrature decoder mode.
 *
 * Values:
 * - 0b0 - Phase encoding mode.
 * - 0b1 - Count and direction encoding mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADMODE field. */
#define TPM_RD_QDCTRL_QUADMODE(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADMODE_MASK) >> TPM_QDCTRL_QUADMODE_SHIFT)
#define TPM_BRD_QDCTRL_QUADMODE(base) (BME_UBFX32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADMODE_SHIFT, TPM_QDCTRL_QUADMODE_WIDTH))

/*! @brief Set the QUADMODE field to a new value. */
#define TPM_WR_QDCTRL_QUADMODE(base, value) (TPM_RMW_QDCTRL(base, TPM_QDCTRL_QUADMODE_MASK, TPM_QDCTRL_QUADMODE(value)))
#define TPM_BWR_QDCTRL_QUADMODE(base, value) (BME_BFI32(&TPM_QDCTRL_REG(base), ((uint32_t)(value) << TPM_QDCTRL_QUADMODE_SHIFT), TPM_QDCTRL_QUADMODE_SHIFT, TPM_QDCTRL_QUADMODE_WIDTH))
/*@}*/

/*******************************************************************************
 * TPM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief TPM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the behavior in debug and wait modes and the use of an
 * external global time base.
 */
/*!
 * @name Constants and macros for entire TPM_CONF register
 */
/*@{*/
#define TPM_RD_CONF(base)        (TPM_CONF_REG(base))
#define TPM_WR_CONF(base, value) (TPM_CONF_REG(base) = (value))
#define TPM_RMW_CONF(base, mask, value) (TPM_WR_CONF(base, (TPM_RD_CONF(base) & ~(mask)) | (value)))
#define TPM_SET_CONF(base, value) (BME_OR32(&TPM_CONF_REG(base), (uint32_t)(value)))
#define TPM_CLR_CONF(base, value) (BME_AND32(&TPM_CONF_REG(base), (uint32_t)(~(value))))
#define TPM_TOG_CONF(base, value) (BME_XOR32(&TPM_CONF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CONF bitfields
 */

/*!
 * @name Register TPM_CONF, field DOZEEN[5] (RW)
 *
 * Configures the TPM behavior in wait mode.
 *
 * Values:
 * - 0b0 - Internal TPM counter continues in Doze mode.
 * - 0b1 - Internal TPM counter is paused and does not increment during Doze
 *     mode. Trigger inputs and input capture events are also ignored.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_DOZEEN field. */
#define TPM_RD_CONF_DOZEEN(base) ((TPM_CONF_REG(base) & TPM_CONF_DOZEEN_MASK) >> TPM_CONF_DOZEEN_SHIFT)
#define TPM_BRD_CONF_DOZEEN(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_DOZEEN_SHIFT, TPM_CONF_DOZEEN_WIDTH))

/*! @brief Set the DOZEEN field to a new value. */
#define TPM_WR_CONF_DOZEEN(base, value) (TPM_RMW_CONF(base, TPM_CONF_DOZEEN_MASK, TPM_CONF_DOZEEN(value)))
#define TPM_BWR_CONF_DOZEEN(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_DOZEEN_SHIFT), TPM_CONF_DOZEEN_SHIFT, TPM_CONF_DOZEEN_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field DBGMODE[7:6] (RW)
 *
 * Configures the TPM behavior in debug mode. All other configurations are
 * reserved.
 *
 * Values:
 * - 0b00 - TPM counter is paused and does not increment during debug mode.
 *     Trigger inputs and input capture events are also ignored.
 * - 0b11 - TPM counter continues in debug mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_DBGMODE field. */
#define TPM_RD_CONF_DBGMODE(base) ((TPM_CONF_REG(base) & TPM_CONF_DBGMODE_MASK) >> TPM_CONF_DBGMODE_SHIFT)
#define TPM_BRD_CONF_DBGMODE(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_DBGMODE_SHIFT, TPM_CONF_DBGMODE_WIDTH))

/*! @brief Set the DBGMODE field to a new value. */
#define TPM_WR_CONF_DBGMODE(base, value) (TPM_RMW_CONF(base, TPM_CONF_DBGMODE_MASK, TPM_CONF_DBGMODE(value)))
#define TPM_BWR_CONF_DBGMODE(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_DBGMODE_SHIFT), TPM_CONF_DBGMODE_SHIFT, TPM_CONF_DBGMODE_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBSYNC[8] (RW)
 *
 * When enabled, the TPM counter is synchronized to the global time base. It
 * uses the global timebase enable, trigger and overflow to ensure the TPM counter
 * starts incrementing at the same time as the global timebase, stops incrementing
 * at the same time as the global timebase and is reset at the same time as the
 * global timebase. This field should only be changed when the TPM counter is
 * disabled.
 *
 * Values:
 * - 0b0 - Global timebase synchronization disabled.
 * - 0b1 - Global timebase synchronization enabled.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_GTBSYNC field. */
#define TPM_RD_CONF_GTBSYNC(base) ((TPM_CONF_REG(base) & TPM_CONF_GTBSYNC_MASK) >> TPM_CONF_GTBSYNC_SHIFT)
#define TPM_BRD_CONF_GTBSYNC(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_GTBSYNC_SHIFT, TPM_CONF_GTBSYNC_WIDTH))

/*! @brief Set the GTBSYNC field to a new value. */
#define TPM_WR_CONF_GTBSYNC(base, value) (TPM_RMW_CONF(base, TPM_CONF_GTBSYNC_MASK, TPM_CONF_GTBSYNC(value)))
#define TPM_BWR_CONF_GTBSYNC(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_GTBSYNC_SHIFT), TPM_CONF_GTBSYNC_SHIFT, TPM_CONF_GTBSYNC_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the TPM to use an externally generated global time base counter.
 * When an externally generated timebase is used, the internal TPM counter is not
 * used by the channels but can be used to generate a periodic interruptor DMA
 * request using the Modulo register and timer overflow flag.
 *
 * Values:
 * - 0b0 - All channels use the internally generated TPM counter as their
 *     timebase
 * - 0b1 - All channels use an externally generated global timebase as their
 *     timebase
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_GTBEEN field. */
#define TPM_RD_CONF_GTBEEN(base) ((TPM_CONF_REG(base) & TPM_CONF_GTBEEN_MASK) >> TPM_CONF_GTBEEN_SHIFT)
#define TPM_BRD_CONF_GTBEEN(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_GTBEEN_SHIFT, TPM_CONF_GTBEEN_WIDTH))

/*! @brief Set the GTBEEN field to a new value. */
#define TPM_WR_CONF_GTBEEN(base, value) (TPM_RMW_CONF(base, TPM_CONF_GTBEEN_MASK, TPM_CONF_GTBEEN(value)))
#define TPM_BWR_CONF_GTBEEN(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_GTBEEN_SHIFT), TPM_CONF_GTBEEN_SHIFT, TPM_CONF_GTBEEN_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOT[16] (RW)
 *
 * When set, the TPM counter will not start incrementing after it is enabled
 * until a rising edge on the selected trigger input is detected. If the TPM counter
 * is stopped due to an overflow, a rising edge on the selected trigger input
 * will also cause the TPM counter to start incrementing again. The trigger input
 * is ignored if the TPM counter is paused during debug mode or doze mode. This
 * field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0b0 - TPM counter starts to increment immediately, once it is enabled.
 * - 0b1 - TPM counter only starts to increment when it a rising edge on the
 *     selected input trigger is detected, after it has been enabled or after it has
 *     stopped due to overflow.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CSOT field. */
#define TPM_RD_CONF_CSOT(base) ((TPM_CONF_REG(base) & TPM_CONF_CSOT_MASK) >> TPM_CONF_CSOT_SHIFT)
#define TPM_BRD_CONF_CSOT(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_CSOT_SHIFT, TPM_CONF_CSOT_WIDTH))

/*! @brief Set the CSOT field to a new value. */
#define TPM_WR_CONF_CSOT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CSOT_MASK, TPM_CONF_CSOT(value)))
#define TPM_BWR_CONF_CSOT(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_CSOT_SHIFT), TPM_CONF_CSOT_SHIFT, TPM_CONF_CSOT_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOO[17] (RW)
 *
 * When set, the TPM counter will stop incrementing once the counter equals the
 * MOD value and incremented (this also sets the TOF). Reloading the counter with
 * 0 due to writing to the counter register or due to a trigger input does not
 * cause the counter to stop incrementing. Once the counter has stopped
 * incrementing, the counter will not start incrementing unless it is disabled and then
 * enabled again, or a rising edge on the selected trigger input is detected when
 * CSOT set. This field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0b0 - TPM counter continues incrementing or decrementing after overflow
 * - 0b1 - TPM counter stops incrementing or decrementing after overflow.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CSOO field. */
#define TPM_RD_CONF_CSOO(base) ((TPM_CONF_REG(base) & TPM_CONF_CSOO_MASK) >> TPM_CONF_CSOO_SHIFT)
#define TPM_BRD_CONF_CSOO(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_CSOO_SHIFT, TPM_CONF_CSOO_WIDTH))

/*! @brief Set the CSOO field to a new value. */
#define TPM_WR_CONF_CSOO(base, value) (TPM_RMW_CONF(base, TPM_CONF_CSOO_MASK, TPM_CONF_CSOO(value)))
#define TPM_BWR_CONF_CSOO(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_CSOO_SHIFT), TPM_CONF_CSOO_SHIFT, TPM_CONF_CSOO_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field CROT[18] (RW)
 *
 * When set, the TPM counter will reload with 0 (and initialize PWM outputs to
 * their default value) when a rising edge is detected on the selected trigger
 * input. The trigger input is ignored if the TPM counter is paused during debug
 * mode or doze mode. This field should only be changed when the TPM counter is
 * disabled.
 *
 * Values:
 * - 0b0 - Counter is not reloaded due to a rising edge on the selected input
 *     trigger
 * - 0b1 - Counter is reloaded when a rising edge is detected on the selected
 *     input trigger
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CROT field. */
#define TPM_RD_CONF_CROT(base) ((TPM_CONF_REG(base) & TPM_CONF_CROT_MASK) >> TPM_CONF_CROT_SHIFT)
#define TPM_BRD_CONF_CROT(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_CROT_SHIFT, TPM_CONF_CROT_WIDTH))

/*! @brief Set the CROT field to a new value. */
#define TPM_WR_CONF_CROT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CROT_MASK, TPM_CONF_CROT(value)))
#define TPM_BWR_CONF_CROT(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_CROT_SHIFT), TPM_CONF_CROT_SHIFT, TPM_CONF_CROT_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field CPOT[19] (RW)
 *
 * When enabled, the counter will pause incrementing while the trigger remains
 * asserted (level sensitive). This field should only be changed when the TPM
 * counter is disabled.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CPOT field. */
#define TPM_RD_CONF_CPOT(base) ((TPM_CONF_REG(base) & TPM_CONF_CPOT_MASK) >> TPM_CONF_CPOT_SHIFT)
#define TPM_BRD_CONF_CPOT(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_CPOT_SHIFT, TPM_CONF_CPOT_WIDTH))

/*! @brief Set the CPOT field to a new value. */
#define TPM_WR_CONF_CPOT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CPOT_MASK, TPM_CONF_CPOT(value)))
#define TPM_BWR_CONF_CPOT(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_CPOT_SHIFT), TPM_CONF_CPOT_SHIFT, TPM_CONF_CPOT_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGPOL[22] (RW)
 *
 * Selects the polarity of the external trigger source. This field should only
 * be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0b0 - Trigger is active high.
 * - 0b1 - Trigger is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_TRGPOL field. */
#define TPM_RD_CONF_TRGPOL(base) ((TPM_CONF_REG(base) & TPM_CONF_TRGPOL_MASK) >> TPM_CONF_TRGPOL_SHIFT)
#define TPM_BRD_CONF_TRGPOL(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_TRGPOL_SHIFT, TPM_CONF_TRGPOL_WIDTH))

/*! @brief Set the TRGPOL field to a new value. */
#define TPM_WR_CONF_TRGPOL(base, value) (TPM_RMW_CONF(base, TPM_CONF_TRGPOL_MASK, TPM_CONF_TRGPOL(value)))
#define TPM_BWR_CONF_TRGPOL(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_TRGPOL_SHIFT), TPM_CONF_TRGPOL_SHIFT, TPM_CONF_TRGPOL_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSRC[23] (RW)
 *
 * Selects between internal (channel pin input capture) or external trigger
 * sources. When selecting an internal trigger, the channel selected should be
 * configured for input capture. Only a rising edge input capture can be used to
 * initially start the counter using the CSOT configuration; either rising edge or
 * falling edge input capture can be used to reload the counter using the CROT
 * configuration; and the state of the channel input pin is used to pause the counter
 * using the CPOT configuration. The channel polarity register can be used to
 * invert the polarity of the channel input pins. This field should only be changed
 * when the TPM counter is disabled.
 *
 * Values:
 * - 0b0 - Trigger source selected by TRGSEL is external.
 * - 0b1 - Trigger source selected by TRGSEL is internal (channel pin input
 *     capture).
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_TRGSRC field. */
#define TPM_RD_CONF_TRGSRC(base) ((TPM_CONF_REG(base) & TPM_CONF_TRGSRC_MASK) >> TPM_CONF_TRGSRC_SHIFT)
#define TPM_BRD_CONF_TRGSRC(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_TRGSRC_SHIFT, TPM_CONF_TRGSRC_WIDTH))

/*! @brief Set the TRGSRC field to a new value. */
#define TPM_WR_CONF_TRGSRC(base, value) (TPM_RMW_CONF(base, TPM_CONF_TRGSRC_MASK, TPM_CONF_TRGSRC(value)))
#define TPM_BWR_CONF_TRGSRC(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_TRGSRC_SHIFT), TPM_CONF_TRGSRC_SHIFT, TPM_CONF_TRGSRC_WIDTH))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSEL[27:24] (RW)
 *
 * Selects the input trigger to use for starting, reloading and/or pausing the
 * counter. The source of the trigger (external or internal to the TPM) is
 * configured by the TRGSRC field. This field should only be changed when the TPM
 * counter is disabled. Refer to the chip configuration section for available external
 * trigger options. The available internal trigger sources are listed below.
 *
 * Values:
 * - 0b0001 - Channel 0 pin input capture
 * - 0b0010 - Channel 1 pin input capture
 * - 0b0011 - Channel 0 or Channel 1 pin input capture
 * - 0b0100 - Channel 2 pin input capture
 * - 0b0101 - Channel 0 or Channel 2 pin input capture
 * - 0b0110 - Channel 1 or Channel 2 pin input capture
 * - 0b0111 - Channel 0 or Channel 1 or Channel 2 pin input capture
 * - 0b1000 - Channel 3 pin input capture
 * - 0b1001 - Channel 0 or Channel 3 pin input capture
 * - 0b1010 - Channel 1 or Channel 3 pin input capture
 * - 0b1011 - Channel 0 or Channel 1 or Channel 3 pin input capture
 * - 0b1100 - Channel 2 or Channel 3 pin input capture
 * - 0b1101 - Channel 0 or Channel 2 or Channel 3 pin input capture
 * - 0b1110 - Channel 1 or Channel 2 or Channel 3 pin input capture
 * - 0b1111 - Channel 0 or Channel 1 or Channel 2 or Channel 3 pin input capture
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_TRGSEL field. */
#define TPM_RD_CONF_TRGSEL(base) ((TPM_CONF_REG(base) & TPM_CONF_TRGSEL_MASK) >> TPM_CONF_TRGSEL_SHIFT)
#define TPM_BRD_CONF_TRGSEL(base) (BME_UBFX32(&TPM_CONF_REG(base), TPM_CONF_TRGSEL_SHIFT, TPM_CONF_TRGSEL_WIDTH))

/*! @brief Set the TRGSEL field to a new value. */
#define TPM_WR_CONF_TRGSEL(base, value) (TPM_RMW_CONF(base, TPM_CONF_TRGSEL_MASK, TPM_CONF_TRGSEL(value)))
#define TPM_BWR_CONF_TRGSEL(base, value) (BME_BFI32(&TPM_CONF_REG(base), ((uint32_t)(value) << TPM_CONF_TRGSEL_SHIFT), TPM_CONF_TRGSEL_SHIFT, TPM_CONF_TRGSEL_WIDTH))
/*@}*/

/*
 * MKL28Z7 TRGMUX
 *
 *
 *
 * Registers defined in this header file:
 * - TRGMUX_TRGCFG - TRGMUX TRGCFG Register
 */

#define TRGMUX_INSTANCE_COUNT (2U) /*!< Number of instances of the TRGMUX module. */
#define TRGMUX0_IDX (0U) /*!< Instance number for TRGMUX0. */
#define TRGMUX1_IDX (1U) /*!< Instance number for TRGMUX1. */

/*******************************************************************************
 * TRGMUX_TRGCFG - TRGMUX TRGCFG Register
 ******************************************************************************/

/*!
 * @brief TRGMUX_TRGCFG - TRGMUX TRGCFG Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TRGMUX_TRGCFG register
 */
/*@{*/
#define TRGMUX_RD_TRGCFG(base, index) (TRGMUX_TRGCFG_REG(base, index))
#define TRGMUX_WR_TRGCFG(base, index, value) (TRGMUX_TRGCFG_REG(base, index) = (value))
#define TRGMUX_RMW_TRGCFG(base, index, mask, value) (TRGMUX_WR_TRGCFG(base, index, (TRGMUX_RD_TRGCFG(base, index) & ~(mask)) | (value)))
#define TRGMUX_SET_TRGCFG(base, index, value) (BME_OR32(&TRGMUX_TRGCFG_REG(base, index), (uint32_t)(value)))
#define TRGMUX_CLR_TRGCFG(base, index, value) (BME_AND32(&TRGMUX_TRGCFG_REG(base, index), (uint32_t)(~(value))))
#define TRGMUX_TOG_TRGCFG(base, index, value) (BME_XOR32(&TRGMUX_TRGCFG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRGMUX_TRGCFG bitfields
 */

/*!
 * @name Register TRGMUX_TRGCFG, field SEL0[5:0] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 0. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_TRGCFG_SEL0 field. */
#define TRGMUX_RD_TRGCFG_SEL0(base, index) ((TRGMUX_TRGCFG_REG(base, index) & TRGMUX_TRGCFG_SEL0_MASK) >> TRGMUX_TRGCFG_SEL0_SHIFT)
#define TRGMUX_BRD_TRGCFG_SEL0(base, index) (BME_UBFX32(&TRGMUX_TRGCFG_REG(base, index), TRGMUX_TRGCFG_SEL0_SHIFT, TRGMUX_TRGCFG_SEL0_WIDTH))

/*! @brief Set the SEL0 field to a new value. */
#define TRGMUX_WR_TRGCFG_SEL0(base, index, value) (TRGMUX_RMW_TRGCFG(base, index, TRGMUX_TRGCFG_SEL0_MASK, TRGMUX_TRGCFG_SEL0(value)))
#define TRGMUX_BWR_TRGCFG_SEL0(base, index, value) (BME_BFI32(&TRGMUX_TRGCFG_REG(base, index), ((uint32_t)(value) << TRGMUX_TRGCFG_SEL0_SHIFT), TRGMUX_TRGCFG_SEL0_SHIFT, TRGMUX_TRGCFG_SEL0_WIDTH))
/*@}*/

/*!
 * @name Register TRGMUX_TRGCFG, field SEL1[13:8] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 1. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_TRGCFG_SEL1 field. */
#define TRGMUX_RD_TRGCFG_SEL1(base, index) ((TRGMUX_TRGCFG_REG(base, index) & TRGMUX_TRGCFG_SEL1_MASK) >> TRGMUX_TRGCFG_SEL1_SHIFT)
#define TRGMUX_BRD_TRGCFG_SEL1(base, index) (BME_UBFX32(&TRGMUX_TRGCFG_REG(base, index), TRGMUX_TRGCFG_SEL1_SHIFT, TRGMUX_TRGCFG_SEL1_WIDTH))

/*! @brief Set the SEL1 field to a new value. */
#define TRGMUX_WR_TRGCFG_SEL1(base, index, value) (TRGMUX_RMW_TRGCFG(base, index, TRGMUX_TRGCFG_SEL1_MASK, TRGMUX_TRGCFG_SEL1(value)))
#define TRGMUX_BWR_TRGCFG_SEL1(base, index, value) (BME_BFI32(&TRGMUX_TRGCFG_REG(base, index), ((uint32_t)(value) << TRGMUX_TRGCFG_SEL1_SHIFT), TRGMUX_TRGCFG_SEL1_SHIFT, TRGMUX_TRGCFG_SEL1_WIDTH))
/*@}*/

/*!
 * @name Register TRGMUX_TRGCFG, field SEL2[21:16] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 2. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_TRGCFG_SEL2 field. */
#define TRGMUX_RD_TRGCFG_SEL2(base, index) ((TRGMUX_TRGCFG_REG(base, index) & TRGMUX_TRGCFG_SEL2_MASK) >> TRGMUX_TRGCFG_SEL2_SHIFT)
#define TRGMUX_BRD_TRGCFG_SEL2(base, index) (BME_UBFX32(&TRGMUX_TRGCFG_REG(base, index), TRGMUX_TRGCFG_SEL2_SHIFT, TRGMUX_TRGCFG_SEL2_WIDTH))

/*! @brief Set the SEL2 field to a new value. */
#define TRGMUX_WR_TRGCFG_SEL2(base, index, value) (TRGMUX_RMW_TRGCFG(base, index, TRGMUX_TRGCFG_SEL2_MASK, TRGMUX_TRGCFG_SEL2(value)))
#define TRGMUX_BWR_TRGCFG_SEL2(base, index, value) (BME_BFI32(&TRGMUX_TRGCFG_REG(base, index), ((uint32_t)(value) << TRGMUX_TRGCFG_SEL2_SHIFT), TRGMUX_TRGCFG_SEL2_SHIFT, TRGMUX_TRGCFG_SEL2_WIDTH))
/*@}*/

/*!
 * @name Register TRGMUX_TRGCFG, field SEL3[29:24] (RW)
 *
 * This read/write bit field is used to configure the MUX select for peripheral
 * trigger input 3. Refer to the Select Bit Fields table in the Features section
 * for bit field information.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_TRGCFG_SEL3 field. */
#define TRGMUX_RD_TRGCFG_SEL3(base, index) ((TRGMUX_TRGCFG_REG(base, index) & TRGMUX_TRGCFG_SEL3_MASK) >> TRGMUX_TRGCFG_SEL3_SHIFT)
#define TRGMUX_BRD_TRGCFG_SEL3(base, index) (BME_UBFX32(&TRGMUX_TRGCFG_REG(base, index), TRGMUX_TRGCFG_SEL3_SHIFT, TRGMUX_TRGCFG_SEL3_WIDTH))

/*! @brief Set the SEL3 field to a new value. */
#define TRGMUX_WR_TRGCFG_SEL3(base, index, value) (TRGMUX_RMW_TRGCFG(base, index, TRGMUX_TRGCFG_SEL3_MASK, TRGMUX_TRGCFG_SEL3(value)))
#define TRGMUX_BWR_TRGCFG_SEL3(base, index, value) (BME_BFI32(&TRGMUX_TRGCFG_REG(base, index), ((uint32_t)(value) << TRGMUX_TRGCFG_SEL3_SHIFT), TRGMUX_TRGCFG_SEL3_SHIFT, TRGMUX_TRGCFG_SEL3_WIDTH))
/*@}*/

/*!
 * @name Register TRGMUX_TRGCFG, field LK[31] (RO)
 *
 * This bit shows whether the register can be written or not.
 *
 * Values:
 * - 0b0 - Register can be written.
 * - 0b1 - Register cannot be written until the next system Reset.
 */
/*@{*/
/*! @brief Read current value of the TRGMUX_TRGCFG_LK field. */
#define TRGMUX_RD_TRGCFG_LK(base, index) ((TRGMUX_TRGCFG_REG(base, index) & TRGMUX_TRGCFG_LK_MASK) >> TRGMUX_TRGCFG_LK_SHIFT)
#define TRGMUX_BRD_TRGCFG_LK(base, index) (BME_UBFX32(&TRGMUX_TRGCFG_REG(base, index), TRGMUX_TRGCFG_LK_SHIFT, TRGMUX_TRGCFG_LK_WIDTH))
/*@}*/

/*
 * MKL28Z7 TRNG
 *
 * RNG
 *
 * Registers defined in this header file:
 * - TRNG_RTMCTL - RNG Miscellaneous Control Register
 * - TRNG_RTSCMISC - RNG Statistical Check Miscellaneous Register
 * - TRNG_RTPKRRNG - RNG Poker Range Register
 * - TRNG_RTPKRMAX - RNG Poker Maximum Limit Register
 * - TRNG_RTPKRSQ - RNG Poker Square Calculation Result Register
 * - TRNG_RTSDCTL - RNG Seed Control Register
 * - TRNG_RTSBLIM - RNG Sparse Bit Limit Register
 * - TRNG_RTTOTSAM - RNG Total Samples Register
 * - TRNG_RTFRQMIN - RNG Frequency Count Minimum Limit Register
 * - TRNG_RTFRQCNT - RNG Frequency Count Register
 * - TRNG_RTFRQMAX - RNG Frequency Count Maximum Limit Register
 * - TRNG_RTSCMC - RNG Statistical Check Monobit Count Register
 * - TRNG_RTSCML - RNG Statistical Check Monobit Limit Register
 * - TRNG_RTSCR1C - RNG Statistical Check Run Length 1 Count Register
 * - TRNG_RTSCR1L - RNG Statistical Check Run Length 1 Limit Register
 * - TRNG_RTSCR2C - RNG Statistical Check Run Length 2 Count Register
 * - TRNG_RTSCR2L - RNG Statistical Check Run Length 2 Limit Register
 * - TRNG_RTSCR3C - RNG Statistical Check Run Length 3 Count Register
 * - TRNG_RTSCR3L - RNG Statistical Check Run Length 3 Limit Register
 * - TRNG_RTSCR4C - RNG Statistical Check Run Length 4 Count Register
 * - TRNG_RTSCR4L - RNG Statistical Check Run Length 4 Limit Register
 * - TRNG_RTSCR5C - RNG Statistical Check Run Length 5 Count Register
 * - TRNG_RTSCR5L - RNG Statistical Check Run Length 5 Limit Register
 * - TRNG_RTSCR6PC - RNG Statistical Check Run Length 6+ Count Register
 * - TRNG_RTSCR6PL - RNG Statistical Check Run Length 6+ Limit Register
 * - TRNG_RTSTATUS - RNG Status Register
 * - TRNG_RTENT0 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT1 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT2 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT3 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT4 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT5 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT6 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT7 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT8 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT9 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT10 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT11 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT12 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT13 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT14 - RNG TRNG Entropy Read Register
 * - TRNG_RTENT15 - RNG TRNG Entropy Read Register
 * - TRNG_RTPKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register
 * - TRNG_RTPKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register
 * - TRNG_RTPKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register
 * - TRNG_RTPKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register
 * - TRNG_RTPKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register
 * - TRNG_RTPKRCNTBA - RNG Statistical Check Poker Count B and A Register
 * - TRNG_RTPKRCNTDC - RNG Statistical Check Poker Count D and C Register
 * - TRNG_RTPKRCNTFE - RNG Statistical Check Poker Count F and E Register
 * - TRNG_SA_TRNG_SEC_CFG - RNG Security Configuration Register
 * - TRNG_SA_TRNG_INT_CTRL - RNG Interrupt Control Register
 * - TRNG_SA_TRNG_INT_MASK - RNG Mask Register
 * - TRNG_SA_TRNG_INT_STATUS - RNG Interrupt Status Register
 * - TRNG_SA_TRNG_VID1 - RNG Version ID Register (MS)
 * - TRNG_SA_TRNG_VID2 - RNG Version ID Register (LS)
 */

#define TRNG_INSTANCE_COUNT (1U) /*!< Number of instances of the TRNG module. */
#define TRNG_IDX (0U) /*!< Instance number for TRNG. */

/*******************************************************************************
 * TRNG_RTMCTL - RNG Miscellaneous Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTMCTL - RNG Miscellaneous Control Register (RW)
 *
 * Reset value: 0x00012001U
 *
 * This register is intended to be used for programming, configuring and testing
 * the RNG. It is the main register to read/write, in order to enable Entropy
 * generation, to stop entropy generation and to block access to entropy registers.
 * This is done via the special TRNG_ACC and PRGM bits below. The RNG
 * Miscellaneous Control Register is a read/write register used to control the RNG's True
 * Random Number Generator (TRNG) access, operation and test. Note that in many
 * cases two RNG registers share the same address, and a particular register at the
 * shared address is selected based upon the value in the PRGM field of the true
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTMCTL register
 */
/*@{*/
#define TRNG_RD_RTMCTL(base)     (TRNG_RTMCTL_REG(base))
#define TRNG_WR_RTMCTL(base, value) (TRNG_RTMCTL_REG(base) = (value))
#define TRNG_RMW_RTMCTL(base, mask, value) (TRNG_WR_RTMCTL(base, (TRNG_RD_RTMCTL(base) & ~(mask)) | (value)))
#define TRNG_SET_RTMCTL(base, value) (BME_OR32(&TRNG_RTMCTL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTMCTL(base, value) (BME_AND32(&TRNG_RTMCTL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTMCTL(base, value) (BME_XOR32(&TRNG_RTMCTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTMCTL bitfields
 */

/*!
 * @name Register TRNG_RTMCTL, field SAMP_MODE[1:0] (RW)
 *
 * Sample Mode. Determines the method of sampling the ring oscillator while
 * generating the Entropy value:This field is writable only if PRGM bit is 1, or PRGM
 * bit is being written to 1 simultaneously with writing this field. This field
 * is cleared to 00 by writing the RST_DEF bit to 1.
 *
 * Values:
 * - 0b00 - use Von Neumann data into both Entropy shifter and Statistical
 *     Checker
 * - 0b01 - use raw data into both Entropy shifter and Statistical Checker
 * - 0b10 - use Von Neumann data into Entropy shifter. Use raw data into
 *     Statistical Checker
 * - 0b11 - reserved.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_SAMP_MODE field. */
#define TRNG_RD_RTMCTL_SAMP_MODE(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_SAMP_MODE_MASK) >> TRNG_RTMCTL_SAMP_MODE_SHIFT)
#define TRNG_BRD_RTMCTL_SAMP_MODE(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_SAMP_MODE_SHIFT, TRNG_RTMCTL_SAMP_MODE_WIDTH))

/*! @brief Set the SAMP_MODE field to a new value. */
#define TRNG_WR_RTMCTL_SAMP_MODE(base, value) (TRNG_RMW_RTMCTL(base, (TRNG_RTMCTL_SAMP_MODE_MASK | TRNG_RTMCTL_ERR_MASK), TRNG_RTMCTL_SAMP_MODE(value)))
#define TRNG_BWR_RTMCTL_SAMP_MODE(base, value) (BME_BFI32(&TRNG_RTMCTL_REG(base), ((uint32_t)(value) << TRNG_RTMCTL_SAMP_MODE_SHIFT), TRNG_RTMCTL_SAMP_MODE_SHIFT, TRNG_RTMCTL_SAMP_MODE_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field OSC_DIV[3:2] (RW)
 *
 * Oscillator Divide. Determines the amount of dividing done to the ring
 * oscillator before it is used by the TRNG.This field is writable only if PRGM bit is
 * 1, or PRGM bit is being written to 1 simultaneously to writing this field. This
 * field is cleared to 00 by writing the RST_DEF bit to 1.
 *
 * Values:
 * - 0b00 - use ring oscillator with no divide
 * - 0b01 - use ring oscillator divided-by-2
 * - 0b10 - use ring oscillator divided-by-4
 * - 0b11 - use ring oscillator divided-by-8
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_OSC_DIV field. */
#define TRNG_RD_RTMCTL_OSC_DIV(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_OSC_DIV_MASK) >> TRNG_RTMCTL_OSC_DIV_SHIFT)
#define TRNG_BRD_RTMCTL_OSC_DIV(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_OSC_DIV_SHIFT, TRNG_RTMCTL_OSC_DIV_WIDTH))

/*! @brief Set the OSC_DIV field to a new value. */
#define TRNG_WR_RTMCTL_OSC_DIV(base, value) (TRNG_RMW_RTMCTL(base, (TRNG_RTMCTL_OSC_DIV_MASK | TRNG_RTMCTL_ERR_MASK), TRNG_RTMCTL_OSC_DIV(value)))
#define TRNG_BWR_RTMCTL_OSC_DIV(base, value) (BME_BFI32(&TRNG_RTMCTL_REG(base), ((uint32_t)(value) << TRNG_RTMCTL_OSC_DIV_SHIFT), TRNG_RTMCTL_OSC_DIV_SHIFT, TRNG_RTMCTL_OSC_DIV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field UNUSED[4] (RW)
 *
 * This bit is unused but write-able. Must be left as zero.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_UNUSED field. */
#define TRNG_RD_RTMCTL_UNUSED(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_UNUSED_MASK) >> TRNG_RTMCTL_UNUSED_SHIFT)
#define TRNG_BRD_RTMCTL_UNUSED(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_UNUSED_SHIFT, TRNG_RTMCTL_UNUSED_WIDTH))

/*! @brief Set the UNUSED field to a new value. */
#define TRNG_WR_RTMCTL_UNUSED(base, value) (TRNG_RMW_RTMCTL(base, (TRNG_RTMCTL_UNUSED_MASK | TRNG_RTMCTL_ERR_MASK), TRNG_RTMCTL_UNUSED(value)))
#define TRNG_BWR_RTMCTL_UNUSED(base, value) (BME_BFI32(&TRNG_RTMCTL_REG(base), ((uint32_t)(value) << TRNG_RTMCTL_UNUSED_SHIFT), TRNG_RTMCTL_UNUSED_SHIFT, TRNG_RTMCTL_UNUSED_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field TRNG_ACC[5] (RW)
 *
 * TRNG Access Mode. If this bit is set to 1, the TRNG will generate an Entropy
 * value that can be read via the true0-true15 registers. The Entropy value may
 * be read once the ENT VAL bit is asserted. Also see truea register descriptions
 * (For a = 0 to 15).
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_TRNG_ACC field. */
#define TRNG_RD_RTMCTL_TRNG_ACC(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_TRNG_ACC_MASK) >> TRNG_RTMCTL_TRNG_ACC_SHIFT)
#define TRNG_BRD_RTMCTL_TRNG_ACC(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_TRNG_ACC_SHIFT, TRNG_RTMCTL_TRNG_ACC_WIDTH))

/*! @brief Set the TRNG_ACC field to a new value. */
#define TRNG_WR_RTMCTL_TRNG_ACC(base, value) (TRNG_RMW_RTMCTL(base, (TRNG_RTMCTL_TRNG_ACC_MASK | TRNG_RTMCTL_ERR_MASK), TRNG_RTMCTL_TRNG_ACC(value)))
#define TRNG_BWR_RTMCTL_TRNG_ACC(base, value) (BME_BFI32(&TRNG_RTMCTL_REG(base), ((uint32_t)(value) << TRNG_RTMCTL_TRNG_ACC_SHIFT), TRNG_RTMCTL_TRNG_ACC_SHIFT, TRNG_RTMCTL_TRNG_ACC_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field RST_DEF[6] (WO)
 *
 * Reset Defaults. Writing a 1 to this bit clears various TRNG registers, and
 * bits within registers, to their default state. This bit is writable only if PRGM
 * bit is 1, or PRGM bit is being written to 1 simultaneously to writing this
 * bit. Reading this bit always produces a 0.
 */
/*@{*/
/*! @brief Set the RST_DEF field to a new value. */
#define TRNG_WR_RTMCTL_RST_DEF(base, value) (TRNG_RMW_RTMCTL(base, (TRNG_RTMCTL_RST_DEF_MASK | TRNG_RTMCTL_ERR_MASK), TRNG_RTMCTL_RST_DEF(value)))
#define TRNG_BWR_RTMCTL_RST_DEF(base, value) (TRNG_WR_RTMCTL_RST_DEF(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field FOR_SCLK[7] (RW)
 *
 * Force System Clock. If set, the system clock is used to operate the TRNG,
 * instead of the ring oscillator. This is for test use only, and indeterminate
 * results may occur. This bit is writable only if PRGM bit is 1, or PRGM bit is
 * being written to 1 simultaneously to writing this bit. This bit is cleared by
 * writing the RST_DEF bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_FOR_SCLK field. */
#define TRNG_RD_RTMCTL_FOR_SCLK(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_FOR_SCLK_MASK) >> TRNG_RTMCTL_FOR_SCLK_SHIFT)
#define TRNG_BRD_RTMCTL_FOR_SCLK(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_FOR_SCLK_SHIFT, TRNG_RTMCTL_FOR_SCLK_WIDTH))

/*! @brief Set the FOR_SCLK field to a new value. */
#define TRNG_WR_RTMCTL_FOR_SCLK(base, value) (TRNG_RMW_RTMCTL(base, (TRNG_RTMCTL_FOR_SCLK_MASK | TRNG_RTMCTL_ERR_MASK), TRNG_RTMCTL_FOR_SCLK(value)))
#define TRNG_BWR_RTMCTL_FOR_SCLK(base, value) (BME_BFI32(&TRNG_RTMCTL_REG(base), ((uint32_t)(value) << TRNG_RTMCTL_FOR_SCLK_SHIFT), TRNG_RTMCTL_FOR_SCLK_SHIFT, TRNG_RTMCTL_FOR_SCLK_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field FCT_FAIL[8] (RO)
 *
 * Read only: Frequency Count Fail. The frequency counter has detected a
 * failure. This may be due to improper programming of the true and/or true registers,
 * or a hardware failure in the ring oscillator. This error may be cleared by
 * writing a 1 to the ERR bit.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_FCT_FAIL field. */
#define TRNG_RD_RTMCTL_FCT_FAIL(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_FCT_FAIL_MASK) >> TRNG_RTMCTL_FCT_FAIL_SHIFT)
#define TRNG_BRD_RTMCTL_FCT_FAIL(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_FCT_FAIL_SHIFT, TRNG_RTMCTL_FCT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field FCT_VAL[9] (RO)
 *
 * Read only: Frequency Count Valid. Indicates that a valid frequency count may
 * be read from true.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_FCT_VAL field. */
#define TRNG_RD_RTMCTL_FCT_VAL(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_FCT_VAL_MASK) >> TRNG_RTMCTL_FCT_VAL_SHIFT)
#define TRNG_BRD_RTMCTL_FCT_VAL(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_FCT_VAL_SHIFT, TRNG_RTMCTL_FCT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field ENT_VAL[10] (RO)
 *
 * Read only: Entropy Valid. Will assert only if TRNG ACC bit is set, and then
 * after an entropy value is generated. Will be cleared when true15 is read.
 * (true0 through true14 should be read before reading true15).
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_ENT_VAL field. */
#define TRNG_RD_RTMCTL_ENT_VAL(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_ENT_VAL_MASK) >> TRNG_RTMCTL_ENT_VAL_SHIFT)
#define TRNG_BRD_RTMCTL_ENT_VAL(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_ENT_VAL_SHIFT, TRNG_RTMCTL_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field TST_OUT[11] (RO)
 *
 * Read only: Test point inside ring oscillator.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_TST_OUT field. */
#define TRNG_RD_RTMCTL_TST_OUT(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_TST_OUT_MASK) >> TRNG_RTMCTL_TST_OUT_SHIFT)
#define TRNG_BRD_RTMCTL_TST_OUT(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_TST_OUT_SHIFT, TRNG_RTMCTL_TST_OUT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field ERR[12] (W1C)
 *
 * Read: Error status. 1 = error detected. 0 = no error.Write: Write 1 to clear
 * errors. Writing 0 has no effect.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_ERR field. */
#define TRNG_RD_RTMCTL_ERR(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_ERR_MASK) >> TRNG_RTMCTL_ERR_SHIFT)
#define TRNG_BRD_RTMCTL_ERR(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_ERR_SHIFT, TRNG_RTMCTL_ERR_WIDTH))

/*! @brief Set the ERR field to a new value. */
#define TRNG_WR_RTMCTL_ERR(base, value) (TRNG_RMW_RTMCTL(base, TRNG_RTMCTL_ERR_MASK, TRNG_RTMCTL_ERR(value)))
#define TRNG_BWR_RTMCTL_ERR(base, value) (BME_BFI32(&TRNG_RTMCTL_REG(base), ((uint32_t)(value) << TRNG_RTMCTL_ERR_SHIFT), TRNG_RTMCTL_ERR_SHIFT, TRNG_RTMCTL_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field TSTOP_OK[13] (RO)
 *
 * TRNG_OK_TO_STOP. Software should check that this bit is a 1 before
 * transitioning RNG to low power mode (RNG clock stopped). RNG turns on the TRNG
 * free-running ring oscillator whenever new entropy is being generated and turns off the
 * ring oscillator when entropy generation is complete. If the RNG clock is
 * stopped while the TRNG ring oscillator is running, the oscillator will continue
 * running even though the RNG clock is stopped. TSTOP_OK is asserted when the TRNG
 * ring oscillator is not running. and therefore it is ok to stop the RNG clock.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_TSTOP_OK field. */
#define TRNG_RD_RTMCTL_TSTOP_OK(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_TSTOP_OK_MASK) >> TRNG_RTMCTL_TSTOP_OK_SHIFT)
#define TRNG_BRD_RTMCTL_TSTOP_OK(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_TSTOP_OK_SHIFT, TRNG_RTMCTL_TSTOP_OK_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTMCTL, field PRGM[16] (RW)
 *
 * Programming Mode Select. When this bit is 1, the TRNG is in Program Mode,
 * otherwise it is in Run Mode. No Entropy value will be generated while the TRNG is
 * in Program Mode. Note that different RNG registers are accessible at the same
 * address depending on whether PRGM is set to 1 or 0. This is noted in the RNG
 * register descriptions.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTMCTL_PRGM field. */
#define TRNG_RD_RTMCTL_PRGM(base) ((TRNG_RTMCTL_REG(base) & TRNG_RTMCTL_PRGM_MASK) >> TRNG_RTMCTL_PRGM_SHIFT)
#define TRNG_BRD_RTMCTL_PRGM(base) (BME_UBFX32(&TRNG_RTMCTL_REG(base), TRNG_RTMCTL_PRGM_SHIFT, TRNG_RTMCTL_PRGM_WIDTH))

/*! @brief Set the PRGM field to a new value. */
#define TRNG_WR_RTMCTL_PRGM(base, value) (TRNG_RMW_RTMCTL(base, (TRNG_RTMCTL_PRGM_MASK | TRNG_RTMCTL_ERR_MASK), TRNG_RTMCTL_PRGM(value)))
#define TRNG_BWR_RTMCTL_PRGM(base, value) (BME_BFI32(&TRNG_RTMCTL_REG(base), ((uint32_t)(value) << TRNG_RTMCTL_PRGM_SHIFT), TRNG_RTMCTL_PRGM_SHIFT, TRNG_RTMCTL_PRGM_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCMISC - RNG Statistical Check Miscellaneous Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCMISC - RNG Statistical Check Miscellaneous Register (RW)
 *
 * Reset value: 0x0001001FU
 *
 * The RNG Statistical Check Miscellaneous Register contains the Long Run
 * Maximum Limit value and the Retry Count value. This register is accessible only when
 * the true[PRGM] bit is 1, otherwise this register will read zeroes, and cannot
 * be written.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCMISC register
 */
/*@{*/
#define TRNG_RD_RTSCMISC(base)   (TRNG_RTSCMISC_REG(base))
#define TRNG_WR_RTSCMISC(base, value) (TRNG_RTSCMISC_REG(base) = (value))
#define TRNG_RMW_RTSCMISC(base, mask, value) (TRNG_WR_RTSCMISC(base, (TRNG_RD_RTSCMISC(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCMISC(base, value) (BME_OR32(&TRNG_RTSCMISC_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCMISC(base, value) (BME_AND32(&TRNG_RTSCMISC_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCMISC(base, value) (BME_XOR32(&TRNG_RTSCMISC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCMISC bitfields
 */

/*!
 * @name Register TRNG_RTSCMISC, field LRUN_MAX[7:0] (RW)
 *
 * LONG RUN MAX LIMIT. This value is the largest allowable number of consecutive
 * samples of all 1, or all 0, that is allowed during the Entropy generation.
 * This field is writable only if true[PRGM] bit is 1. This field will read zeroes
 * if true[PRGM] = 0. This field is cleared to 22h by writing the true[RST_DEF]
 * bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCMISC_LRUN_MAX field. */
#define TRNG_RD_RTSCMISC_LRUN_MAX(base) ((TRNG_RTSCMISC_REG(base) & TRNG_RTSCMISC_LRUN_MAX_MASK) >> TRNG_RTSCMISC_LRUN_MAX_SHIFT)
#define TRNG_BRD_RTSCMISC_LRUN_MAX(base) (BME_UBFX32(&TRNG_RTSCMISC_REG(base), TRNG_RTSCMISC_LRUN_MAX_SHIFT, TRNG_RTSCMISC_LRUN_MAX_WIDTH))

/*! @brief Set the LRUN_MAX field to a new value. */
#define TRNG_WR_RTSCMISC_LRUN_MAX(base, value) (TRNG_RMW_RTSCMISC(base, TRNG_RTSCMISC_LRUN_MAX_MASK, TRNG_RTSCMISC_LRUN_MAX(value)))
#define TRNG_BWR_RTSCMISC_LRUN_MAX(base, value) (BME_BFI32(&TRNG_RTSCMISC_REG(base), ((uint32_t)(value) << TRNG_RTSCMISC_LRUN_MAX_SHIFT), TRNG_RTSCMISC_LRUN_MAX_SHIFT, TRNG_RTSCMISC_LRUN_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSCMISC, field RTY_CT[19:16] (RW)
 *
 * RETRY COUNT. If a statistical check fails during the TRNG Entropy Generation,
 * the RTY_CT value indicates the number of times a retry should occur before
 * generating an error. This field is writable only if true[PRGM] bit is 1. This
 * field will read zeroes if true[PRGM] = 0. This field is cleared to 1h by writing
 * the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCMISC_RTY_CT field. */
#define TRNG_RD_RTSCMISC_RTY_CT(base) ((TRNG_RTSCMISC_REG(base) & TRNG_RTSCMISC_RTY_CT_MASK) >> TRNG_RTSCMISC_RTY_CT_SHIFT)
#define TRNG_BRD_RTSCMISC_RTY_CT(base) (BME_UBFX32(&TRNG_RTSCMISC_REG(base), TRNG_RTSCMISC_RTY_CT_SHIFT, TRNG_RTSCMISC_RTY_CT_WIDTH))

/*! @brief Set the RTY_CT field to a new value. */
#define TRNG_WR_RTSCMISC_RTY_CT(base, value) (TRNG_RMW_RTSCMISC(base, TRNG_RTSCMISC_RTY_CT_MASK, TRNG_RTSCMISC_RTY_CT(value)))
#define TRNG_BWR_RTSCMISC_RTY_CT(base, value) (BME_BFI32(&TRNG_RTSCMISC_REG(base), ((uint32_t)(value) << TRNG_RTSCMISC_RTY_CT_SHIFT), TRNG_RTSCMISC_RTY_CT_SHIFT, TRNG_RTSCMISC_RTY_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRRNG - RNG Poker Range Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRRNG - RNG Poker Range Register (RW)
 *
 * Reset value: 0x000009A3U
 *
 * The RNG Poker Range Register defines the difference between the TRNG Poker
 * Maximum Limit and the minimum limit. These limits are used during the TRNG
 * Statistical Check Poker Test.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRRNG register
 */
/*@{*/
#define TRNG_RD_RTPKRRNG(base)   (TRNG_RTPKRRNG_REG(base))
#define TRNG_WR_RTPKRRNG(base, value) (TRNG_RTPKRRNG_REG(base) = (value))
#define TRNG_RMW_RTPKRRNG(base, mask, value) (TRNG_WR_RTPKRRNG(base, (TRNG_RD_RTPKRRNG(base) & ~(mask)) | (value)))
#define TRNG_SET_RTPKRRNG(base, value) (BME_OR32(&TRNG_RTPKRRNG_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTPKRRNG(base, value) (BME_AND32(&TRNG_RTPKRRNG_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTPKRRNG(base, value) (BME_XOR32(&TRNG_RTPKRRNG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRRNG bitfields
 */

/*!
 * @name Register TRNG_RTPKRRNG, field PKR_RNG[15:0] (RW)
 *
 * Poker Range. During the TRNG Statistical Checks, a "Poker Test" is run which
 * requires a maximum and minimum limit. The maximum is programmed in the
 * RTPKRMAX[PKR_MAX] register, and the minimum is derived by subtracting the PKR_RNG
 * value from the programmed maximum value. This field is writable only if
 * true[PRGM] bit is 1. This field will read zeroes if true[PRGM] = 0. This field is
 * cleared to 09A3h (decimal 2467) by writing the true[RST_DEF] bit to 1. Note that
 * the minimum allowable Poker result is PKR_MAX - PKR_RNG + 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRRNG_PKR_RNG field. */
#define TRNG_RD_RTPKRRNG_PKR_RNG(base) ((TRNG_RTPKRRNG_REG(base) & TRNG_RTPKRRNG_PKR_RNG_MASK) >> TRNG_RTPKRRNG_PKR_RNG_SHIFT)
#define TRNG_BRD_RTPKRRNG_PKR_RNG(base) (TRNG_RD_RTPKRRNG_PKR_RNG(base))

/*! @brief Set the PKR_RNG field to a new value. */
#define TRNG_WR_RTPKRRNG_PKR_RNG(base, value) (TRNG_RMW_RTPKRRNG(base, TRNG_RTPKRRNG_PKR_RNG_MASK, TRNG_RTPKRRNG_PKR_RNG(value)))
#define TRNG_BWR_RTPKRRNG_PKR_RNG(base, value) (TRNG_WR_RTPKRRNG_PKR_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRSQ - RNG Poker Square Calculation Result Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRSQ - RNG Poker Square Calculation Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Poker Square Calculation Result Register is a read-only register used
 * to read the result of the TRNG Statistical Check Poker Test's Square
 * Calculation. This test starts with the true value and decreases towards a final
 * result, which is read here. For the Poker Test to pass, this final result must be
 * less than the programmed true value. Note that this offset (0xBASE_060C) is used
 * as true if true[PRGM] is 1. If true[PRGM] is 0, this offset is used as true
 * readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRSQ register
 */
/*@{*/
#define TRNG_RD_RTPKRSQ(base)    (TRNG_RTPKRSQ_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRSQ bitfields
 */

/*!
 * @name Register TRNG_RTPKRSQ, field PKR_SQ[23:0] (RO)
 *
 * Poker Square Calculation Result. During the TRNG Statistical Checks, a "Poker
 * Test" is run which starts with the value true[PKR_MAX]. This value decreases
 * according to a "sum of squares" algorithm, and must remain greater than zero,
 * but less than the true[PKR_RNG] limit. The resulting value may be read through
 * this register, if true[PRGM] bit is 0. Note that if true[PRGM] bit is 1, this
 * register address is used to access the Poker Test Maximum Limit in register
 * true, as defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRSQ_PKR_SQ field. */
#define TRNG_RD_RTPKRSQ_PKR_SQ(base) ((TRNG_RTPKRSQ_REG(base) & TRNG_RTPKRSQ_PKR_SQ_MASK) >> TRNG_RTPKRSQ_PKR_SQ_SHIFT)
#define TRNG_BRD_RTPKRSQ_PKR_SQ(base) (TRNG_RD_RTPKRSQ_PKR_SQ(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRMAX - RNG Poker Maximum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRMAX - RNG Poker Maximum Limit Register (RW)
 *
 * Reset value: 0x00006920U
 *
 * The RNG Poker Maximum Limit Register defines Maximum Limit allowable during
 * the TRNG Statistical Check Poker Test. Note that this offset (0xBASE_060C) is
 * used as true only if true[PRGM] is 1. If true[PRGM] is 0, this offset is used
 * as the true readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRMAX register
 */
/*@{*/
#define TRNG_RD_RTPKRMAX(base)   (TRNG_RTPKRMAX_REG(base))
#define TRNG_WR_RTPKRMAX(base, value) (TRNG_RTPKRMAX_REG(base) = (value))
#define TRNG_RMW_RTPKRMAX(base, mask, value) (TRNG_WR_RTPKRMAX(base, (TRNG_RD_RTPKRMAX(base) & ~(mask)) | (value)))
#define TRNG_SET_RTPKRMAX(base, value) (BME_OR32(&TRNG_RTPKRMAX_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTPKRMAX(base, value) (BME_AND32(&TRNG_RTPKRMAX_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTPKRMAX(base, value) (BME_XOR32(&TRNG_RTPKRMAX_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRMAX bitfields
 */

/*!
 * @name Register TRNG_RTPKRMAX, field PKR_MAX[23:0] (RW)
 *
 * Poker Maximum Limit. During the TRNG Statistical Checks, a "Poker Test" is
 * run which requires a maximum and minimum limit. The maximum allowable result is
 * programmed in the true[PKR_MAX] register. This field is writable only if
 * true[PRGM] bit is 1. This register is cleared to 006920h (decimal 26912) by writing
 * the true[RST_DEF] bit to 1. Note that the true and true registers combined
 * are used to define the minimum allowable Poker result, which is PKR_MAX -
 * PKR_RNG + 1. Note that if true[PRGM] bit is 0, this register address is used to read
 * the Poker Test Square Calculation result in register true, as defined in the
 * following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRMAX_PKR_MAX field. */
#define TRNG_RD_RTPKRMAX_PKR_MAX(base) ((TRNG_RTPKRMAX_REG(base) & TRNG_RTPKRMAX_PKR_MAX_MASK) >> TRNG_RTPKRMAX_PKR_MAX_SHIFT)
#define TRNG_BRD_RTPKRMAX_PKR_MAX(base) (TRNG_RD_RTPKRMAX_PKR_MAX(base))

/*! @brief Set the PKR_MAX field to a new value. */
#define TRNG_WR_RTPKRMAX_PKR_MAX(base, value) (TRNG_RMW_RTPKRMAX(base, TRNG_RTPKRMAX_PKR_MAX_MASK, TRNG_RTPKRMAX_PKR_MAX(value)))
#define TRNG_BWR_RTPKRMAX_PKR_MAX(base, value) (TRNG_WR_RTPKRMAX_PKR_MAX(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSDCTL - RNG Seed Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSDCTL - RNG Seed Control Register (RW)
 *
 * Reset value: 0x0C8009C4U
 *
 * The RNG Seed Control Register contains two fields. One field defines the
 * length (in system clocks) of each Entropy sample (ENT_DLY), and the other field
 * indicates the number of samples that will taken during each TRNG Entropy
 * generation (SAMP_SIZE).
 */
/*!
 * @name Constants and macros for entire TRNG_RTSDCTL register
 */
/*@{*/
#define TRNG_RD_RTSDCTL(base)    (TRNG_RTSDCTL_REG(base))
#define TRNG_WR_RTSDCTL(base, value) (TRNG_RTSDCTL_REG(base) = (value))
#define TRNG_RMW_RTSDCTL(base, mask, value) (TRNG_WR_RTSDCTL(base, (TRNG_RD_RTSDCTL(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSDCTL(base, value) (BME_OR32(&TRNG_RTSDCTL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSDCTL(base, value) (BME_AND32(&TRNG_RTSDCTL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSDCTL(base, value) (BME_XOR32(&TRNG_RTSDCTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSDCTL bitfields
 */

/*!
 * @name Register TRNG_RTSDCTL, field SAMP_SIZE[15:0] (RW)
 *
 * Sample Size. Defines the total number of Entropy samples that will be taken
 * during Entropy generation. This field is writable only if true[PRGM] bit is 1.
 * This field will read zeroes if true[PRGM] = 0. This field is cleared to 09C4h
 * (decimal 2500) by writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSDCTL_SAMP_SIZE field. */
#define TRNG_RD_RTSDCTL_SAMP_SIZE(base) ((TRNG_RTSDCTL_REG(base) & TRNG_RTSDCTL_SAMP_SIZE_MASK) >> TRNG_RTSDCTL_SAMP_SIZE_SHIFT)
#define TRNG_BRD_RTSDCTL_SAMP_SIZE(base) (TRNG_RD_RTSDCTL_SAMP_SIZE(base))

/*! @brief Set the SAMP_SIZE field to a new value. */
#define TRNG_WR_RTSDCTL_SAMP_SIZE(base, value) (TRNG_RMW_RTSDCTL(base, TRNG_RTSDCTL_SAMP_SIZE_MASK, TRNG_RTSDCTL_SAMP_SIZE(value)))
#define TRNG_BWR_RTSDCTL_SAMP_SIZE(base, value) (TRNG_WR_RTSDCTL_SAMP_SIZE(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSDCTL, field ENT_DLY[31:16] (RW)
 *
 * Entropy Delay. Defines the length (in system clocks) of each Entropy sample
 * taken. This field is writable only if true[PRGM] bit is 1. This field will read
 * zeroes if true[PRGM] = 0. This field is cleared to 0C80h (decimal 3200) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSDCTL_ENT_DLY field. */
#define TRNG_RD_RTSDCTL_ENT_DLY(base) ((TRNG_RTSDCTL_REG(base) & TRNG_RTSDCTL_ENT_DLY_MASK) >> TRNG_RTSDCTL_ENT_DLY_SHIFT)
#define TRNG_BRD_RTSDCTL_ENT_DLY(base) (TRNG_RD_RTSDCTL_ENT_DLY(base))

/*! @brief Set the ENT_DLY field to a new value. */
#define TRNG_WR_RTSDCTL_ENT_DLY(base, value) (TRNG_RMW_RTSDCTL(base, TRNG_RTSDCTL_ENT_DLY_MASK, TRNG_RTSDCTL_ENT_DLY(value)))
#define TRNG_BWR_RTSDCTL_ENT_DLY(base, value) (TRNG_WR_RTSDCTL_ENT_DLY(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTTOTSAM - RNG Total Samples Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTTOTSAM - RNG Total Samples Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Total Samples Register is a read-only register used to read the total
 * number of samples taken during Entropy generation. It is used to give an
 * indication of how often a sample is actually used during Von Neumann sampling.
 * Note that this offset (0xBASE_0614) is used as true if true[PRGM] is 1. If
 * true[PRGM] is 0, this offset is used as true readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTTOTSAM register
 */
/*@{*/
#define TRNG_RD_RTTOTSAM(base)   (TRNG_RTTOTSAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTTOTSAM bitfields
 */

/*!
 * @name Register TRNG_RTTOTSAM, field TOT_SAM[19:0] (RO)
 *
 * Total Samples. During Entropy generation, the total number of raw samples is
 * counted. This count is useful in determining how often a sample is used during
 * Von Neumann sampling. The count may be read through this register, if
 * true[PRGM] bit is 0. Note that if true[PRGM] bit is 1, this register address is used
 * to access the Sparse Bit Limit in register true, as defined in the previous
 * section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTTOTSAM_TOT_SAM field. */
#define TRNG_RD_RTTOTSAM_TOT_SAM(base) ((TRNG_RTTOTSAM_REG(base) & TRNG_RTTOTSAM_TOT_SAM_MASK) >> TRNG_RTTOTSAM_TOT_SAM_SHIFT)
#define TRNG_BRD_RTTOTSAM_TOT_SAM(base) (TRNG_RD_RTTOTSAM_TOT_SAM(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSBLIM - RNG Sparse Bit Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSBLIM - RNG Sparse Bit Limit Register (RW)
 *
 * Reset value: 0x0000003FU
 *
 * The RNG Sparse Bit Limit Register is used when Von Neumann sampling is
 * selected during Entropy Generation. It defines the maximum number of consecutive Von
 * Neumann samples which may be discarded before an error is generated. Note
 * that this address (0xBASE_0614) is used as true only if true[PRGM] is 1. If
 * true[PRGM] is 0, this address is used as true readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSBLIM register
 */
/*@{*/
#define TRNG_RD_RTSBLIM(base)    (TRNG_RTSBLIM_REG(base))
#define TRNG_WR_RTSBLIM(base, value) (TRNG_RTSBLIM_REG(base) = (value))
#define TRNG_RMW_RTSBLIM(base, mask, value) (TRNG_WR_RTSBLIM(base, (TRNG_RD_RTSBLIM(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSBLIM(base, value) (BME_OR32(&TRNG_RTSBLIM_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSBLIM(base, value) (BME_AND32(&TRNG_RTSBLIM_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSBLIM(base, value) (BME_XOR32(&TRNG_RTSBLIM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSBLIM bitfields
 */

/*!
 * @name Register TRNG_RTSBLIM, field SB_LIM[9:0] (RW)
 *
 * Sparse Bit Limit. During Von Neumann sampling (if enabled by true[SAMP_MODE],
 * samples are discarded if two consecutive raw samples are both 0 or both 1. If
 * this discarding occurs for a long period of time, it indicates that there is
 * insufficient Entropy. The Sparse Bit Limit defines the maximum number of
 * consecutive samples that may be discarded before an error is generated. This field
 * is writable only if true[PRGM] bit is 1. This register is cleared to 03hF by
 * writing the true[RST_DEF] bit to 1. Note that if true[PRGM] bit is 0, this
 * register address is used to read the Total Samples count in register true, as
 * defined in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSBLIM_SB_LIM field. */
#define TRNG_RD_RTSBLIM_SB_LIM(base) ((TRNG_RTSBLIM_REG(base) & TRNG_RTSBLIM_SB_LIM_MASK) >> TRNG_RTSBLIM_SB_LIM_SHIFT)
#define TRNG_BRD_RTSBLIM_SB_LIM(base) (TRNG_RD_RTSBLIM_SB_LIM(base))

/*! @brief Set the SB_LIM field to a new value. */
#define TRNG_WR_RTSBLIM_SB_LIM(base, value) (TRNG_RMW_RTSBLIM(base, TRNG_RTSBLIM_SB_LIM_MASK, TRNG_RTSBLIM_SB_LIM(value)))
#define TRNG_BWR_RTSBLIM_SB_LIM(base, value) (TRNG_WR_RTSBLIM_SB_LIM(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTFRQMIN - RNG Frequency Count Minimum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTFRQMIN - RNG Frequency Count Minimum Limit Register (RW)
 *
 * Reset value: 0x00000640U
 *
 * The RNG Frequency Count Minimum Limit Register defines the minimum allowable
 * count taken by the Entropy sample counter during each Entropy sample. During
 * any sample period, if the count is less than this programmed minimum, a
 * Frequency Count Fail is flagged in true[FCT_FAIL] and an error is generated.
 */
/*!
 * @name Constants and macros for entire TRNG_RTFRQMIN register
 */
/*@{*/
#define TRNG_RD_RTFRQMIN(base)   (TRNG_RTFRQMIN_REG(base))
#define TRNG_WR_RTFRQMIN(base, value) (TRNG_RTFRQMIN_REG(base) = (value))
#define TRNG_RMW_RTFRQMIN(base, mask, value) (TRNG_WR_RTFRQMIN(base, (TRNG_RD_RTFRQMIN(base) & ~(mask)) | (value)))
#define TRNG_SET_RTFRQMIN(base, value) (BME_OR32(&TRNG_RTFRQMIN_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTFRQMIN(base, value) (BME_AND32(&TRNG_RTFRQMIN_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTFRQMIN(base, value) (BME_XOR32(&TRNG_RTFRQMIN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTFRQMIN bitfields
 */

/*!
 * @name Register TRNG_RTFRQMIN, field FRQ_MIN[21:0] (RW)
 *
 * Frequency Count Minimum Limit. Defines the minimum allowable count taken
 * during each entropy sample. This field is writable only if true[PRGM] bit is 1.
 * This field will read zeroes if true[PRGM] = 0. This field is cleared to 0000h64
 * by writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTFRQMIN_FRQ_MIN field. */
#define TRNG_RD_RTFRQMIN_FRQ_MIN(base) ((TRNG_RTFRQMIN_REG(base) & TRNG_RTFRQMIN_FRQ_MIN_MASK) >> TRNG_RTFRQMIN_FRQ_MIN_SHIFT)
#define TRNG_BRD_RTFRQMIN_FRQ_MIN(base) (TRNG_RD_RTFRQMIN_FRQ_MIN(base))

/*! @brief Set the FRQ_MIN field to a new value. */
#define TRNG_WR_RTFRQMIN_FRQ_MIN(base, value) (TRNG_RMW_RTFRQMIN(base, TRNG_RTFRQMIN_FRQ_MIN_MASK, TRNG_RTFRQMIN_FRQ_MIN(value)))
#define TRNG_BWR_RTFRQMIN_FRQ_MIN(base, value) (TRNG_WR_RTFRQMIN_FRQ_MIN(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTFRQCNT - RNG Frequency Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTFRQCNT - RNG Frequency Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Frequency Count Register is a read-only register used to read the
 * frequency counter within the TRNG entropy generator. It will read all zeroes
 * unless true[TRNG_ACC] = 1. Note that this offset (0xBASE_061C) is used as true if
 * true[PRGM] is 1. If true[PRGM] is 0, this offset is used as true readback
 * register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTFRQCNT register
 */
/*@{*/
#define TRNG_RD_RTFRQCNT(base)   (TRNG_RTFRQCNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTFRQCNT bitfields
 */

/*!
 * @name Register TRNG_RTFRQCNT, field FRQ_CT[21:0] (RO)
 *
 * Frequency Count. If true[TRNG_ACC] = 1, reads a sample frequency count taken
 * during entropy generation. Requires true[PRGM] = 0. Note that if true[PRGM]
 * bit is 1, this register address is used to access the Poker Test Maximum Limit
 * in register true, as defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTFRQCNT_FRQ_CT field. */
#define TRNG_RD_RTFRQCNT_FRQ_CT(base) ((TRNG_RTFRQCNT_REG(base) & TRNG_RTFRQCNT_FRQ_CT_MASK) >> TRNG_RTFRQCNT_FRQ_CT_SHIFT)
#define TRNG_BRD_RTFRQCNT_FRQ_CT(base) (TRNG_RD_RTFRQCNT_FRQ_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTFRQMAX - RNG Frequency Count Maximum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTFRQMAX - RNG Frequency Count Maximum Limit Register (RW)
 *
 * Reset value: 0x00006400U
 *
 * The RNG Frequency Count Maximum Limit Register defines the maximum allowable
 * count taken by the Entropy sample counter during each Entropy sample. During
 * any sample period, if the count is greater than this programmed maximum, a
 * Frequency Count Fail is flagged in true[FCT_FAIL] and an error is generated. Note
 * that this address (061C) is used as true only if true[PRGM] is 1. If
 * true[PRGM] is 0, this address is used as true readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTFRQMAX register
 */
/*@{*/
#define TRNG_RD_RTFRQMAX(base)   (TRNG_RTFRQMAX_REG(base))
#define TRNG_WR_RTFRQMAX(base, value) (TRNG_RTFRQMAX_REG(base) = (value))
#define TRNG_RMW_RTFRQMAX(base, mask, value) (TRNG_WR_RTFRQMAX(base, (TRNG_RD_RTFRQMAX(base) & ~(mask)) | (value)))
#define TRNG_SET_RTFRQMAX(base, value) (BME_OR32(&TRNG_RTFRQMAX_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTFRQMAX(base, value) (BME_AND32(&TRNG_RTFRQMAX_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTFRQMAX(base, value) (BME_XOR32(&TRNG_RTFRQMAX_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTFRQMAX bitfields
 */

/*!
 * @name Register TRNG_RTFRQMAX, field FRQ_MAX[21:0] (RW)
 *
 * Frequency Counter Maximum Limit. Defines the maximum allowable count taken
 * during each entropy sample. This field is writable only if true[PRGM] bit is 1.
 * This register is cleared to 000640h by writing the true[RST_DEF] bit to 1.
 * Note that if true[PRGM] bit is 0, this register address is used to read the
 * Frequency Count result in register true, as defined in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTFRQMAX_FRQ_MAX field. */
#define TRNG_RD_RTFRQMAX_FRQ_MAX(base) ((TRNG_RTFRQMAX_REG(base) & TRNG_RTFRQMAX_FRQ_MAX_MASK) >> TRNG_RTFRQMAX_FRQ_MAX_SHIFT)
#define TRNG_BRD_RTFRQMAX_FRQ_MAX(base) (TRNG_RD_RTFRQMAX_FRQ_MAX(base))

/*! @brief Set the FRQ_MAX field to a new value. */
#define TRNG_WR_RTFRQMAX_FRQ_MAX(base, value) (TRNG_RMW_RTFRQMAX(base, TRNG_RTFRQMAX_FRQ_MAX_MASK, TRNG_RTFRQMAX_FRQ_MAX(value)))
#define TRNG_BWR_RTFRQMAX_FRQ_MAX(base, value) (TRNG_WR_RTFRQMAX_FRQ_MAX(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCMC - RNG Statistical Check Monobit Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCMC - RNG Statistical Check Monobit Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Monobit Count Register is a read-only register used
 * to read the final monobit count after entropy generation. This counter starts
 * with the value in true[MONO_MAX], and is decremented each time a one is
 * sampled. Note that this offset (0xBASE_0620) is used as true if true[PRGM] is 1. If
 * true[PRGM] is 0, this offset is used as true readback register, as described
 * here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCMC register
 */
/*@{*/
#define TRNG_RD_RTSCMC(base)     (TRNG_RTSCMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCMC bitfields
 */

/*!
 * @name Register TRNG_RTSCMC, field MONO_CT[15:0] (RO)
 *
 * Monobit Count. Reads the final Monobit count after entropy generation.
 * Requires true[PRGM] = 0. Note that if true[PRGM] bit is 1, this register address is
 * used to access the Statistical Check Monobit Limit in register true, as
 * defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCMC_MONO_CT field. */
#define TRNG_RD_RTSCMC_MONO_CT(base) ((TRNG_RTSCMC_REG(base) & TRNG_RTSCMC_MONO_CT_MASK) >> TRNG_RTSCMC_MONO_CT_SHIFT)
#define TRNG_BRD_RTSCMC_MONO_CT(base) (TRNG_RD_RTSCMC_MONO_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCML - RNG Statistical Check Monobit Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCML - RNG Statistical Check Monobit Limit Register (RW)
 *
 * Reset value: 0x010C0568U
 *
 * The RNG Statistical Check Monobit Limit Register defines the allowable
 * maximum and minimum number of ones/zero detected during entropy generation. To pass
 * the test, the number of ones/zeroes generated must be less than the programmed
 * maximum value, and the number of ones/zeroes generated must be greater than
 * (maximum - range). If this test fails, the Retry Counter in true will be
 * decremented, and a retry will occur if the Retry Count has not reached zero. If the
 * Retry Count has reached zero, an error will be generated. Note that this
 * offset (0xBASE_0620) is used as true only if true[PRGM] is 1. If true[PRGM] is 0,
 * this offset is used as true readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCML register
 */
/*@{*/
#define TRNG_RD_RTSCML(base)     (TRNG_RTSCML_REG(base))
#define TRNG_WR_RTSCML(base, value) (TRNG_RTSCML_REG(base) = (value))
#define TRNG_RMW_RTSCML(base, mask, value) (TRNG_WR_RTSCML(base, (TRNG_RD_RTSCML(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCML(base, value) (BME_OR32(&TRNG_RTSCML_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCML(base, value) (BME_AND32(&TRNG_RTSCML_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCML(base, value) (BME_XOR32(&TRNG_RTSCML_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCML bitfields
 */

/*!
 * @name Register TRNG_RTSCML, field MONO_MAX[15:0] (RW)
 *
 * Monobit Maximum Limit. Defines the maximum allowable count taken during
 * entropy generation. The number of ones/zeroes detected during entropy generation
 * must be less than MONO_MAX, else a retry or error will occur. This register is
 * cleared to 00056Bh (decimal 1387) by writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCML_MONO_MAX field. */
#define TRNG_RD_RTSCML_MONO_MAX(base) ((TRNG_RTSCML_REG(base) & TRNG_RTSCML_MONO_MAX_MASK) >> TRNG_RTSCML_MONO_MAX_SHIFT)
#define TRNG_BRD_RTSCML_MONO_MAX(base) (TRNG_RD_RTSCML_MONO_MAX(base))

/*! @brief Set the MONO_MAX field to a new value. */
#define TRNG_WR_RTSCML_MONO_MAX(base, value) (TRNG_RMW_RTSCML(base, TRNG_RTSCML_MONO_MAX_MASK, TRNG_RTSCML_MONO_MAX(value)))
#define TRNG_BWR_RTSCML_MONO_MAX(base, value) (TRNG_WR_RTSCML_MONO_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSCML, field MONO_RNG[31:16] (RW)
 *
 * Monobit Range. The number of ones/zeroes detected during entropy generation
 * must be greater than MONO_MAX - MONO_RNG, else a retry or error will occur.
 * This register is cleared to 000112h (decimal 274) by writing the true[RST_DEF]
 * bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCML_MONO_RNG field. */
#define TRNG_RD_RTSCML_MONO_RNG(base) ((TRNG_RTSCML_REG(base) & TRNG_RTSCML_MONO_RNG_MASK) >> TRNG_RTSCML_MONO_RNG_SHIFT)
#define TRNG_BRD_RTSCML_MONO_RNG(base) (TRNG_RD_RTSCML_MONO_RNG(base))

/*! @brief Set the MONO_RNG field to a new value. */
#define TRNG_WR_RTSCML_MONO_RNG(base, value) (TRNG_RMW_RTSCML(base, TRNG_RTSCML_MONO_RNG_MASK, TRNG_RTSCML_MONO_RNG(value)))
#define TRNG_BWR_RTSCML_MONO_RNG(base, value) (TRNG_WR_RTSCML_MONO_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR1C - RNG Statistical Check Run Length 1 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR1C - RNG Statistical Check Run Length 1 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 1 Counters Register is a read-only
 * register used to read the final Run Length 1 counts after entropy generation. These
 * counters start with the value in true1L[RUN1_MAX]. The R1_1_CT decrements
 * each time a single one is sampled (preceded by a zero and followed by a zero).
 * The R1_0_CT decrements each time a single zero is sampled (preceded by a one and
 * followed by a one). Note that this offset (0xBASE_0624) is used as true1L if
 * true[PRGM] is 1. If true[PRGM] is 0, this offset is used as true1C readback
 * register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR1C register
 */
/*@{*/
#define TRNG_RD_RTSCR1C(base)    (TRNG_RTSCR1C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR1C bitfields
 */

/*!
 * @name Register TRNG_RTSCR1C, field R1_0_CT[14:0] (RO)
 *
 * Runs of Zero, Length 1 Count. Reads the final Runs of Zeroes, length 1 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR1C_R1_0_CT field. */
#define TRNG_RD_RTSCR1C_R1_0_CT(base) ((TRNG_RTSCR1C_REG(base) & TRNG_RTSCR1C_R1_0_CT_MASK) >> TRNG_RTSCR1C_R1_0_CT_SHIFT)
#define TRNG_BRD_RTSCR1C_R1_0_CT(base) (TRNG_RD_RTSCR1C_R1_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTSCR1C, field R1_1_CT[30:16] (RO)
 *
 * Runs of One, Length 1 Count. Reads the final Runs of Ones, length 1 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR1C_R1_1_CT field. */
#define TRNG_RD_RTSCR1C_R1_1_CT(base) ((TRNG_RTSCR1C_REG(base) & TRNG_RTSCR1C_R1_1_CT_MASK) >> TRNG_RTSCR1C_R1_1_CT_SHIFT)
#define TRNG_BRD_RTSCR1C_R1_1_CT(base) (TRNG_RD_RTSCR1C_R1_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR1L - RNG Statistical Check Run Length 1 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR1L - RNG Statistical Check Run Length 1 Limit Register (RW)
 *
 * Reset value: 0x00B20195U
 *
 * The RNG Statistical Check Run Length 1 Limit Register defines the allowable
 * maximum and minimum number of runs of length 1 detected during entropy
 * generation. To pass the test, the number of runs of length 1 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 1 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in true will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will be
 * generated. Note that this address (0xBASE_0624) is used as true1L only if
 * true[PRGM] is 1. If true[PRGM] is 0, this address is used as true1C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR1L register
 */
/*@{*/
#define TRNG_RD_RTSCR1L(base)    (TRNG_RTSCR1L_REG(base))
#define TRNG_WR_RTSCR1L(base, value) (TRNG_RTSCR1L_REG(base) = (value))
#define TRNG_RMW_RTSCR1L(base, mask, value) (TRNG_WR_RTSCR1L(base, (TRNG_RD_RTSCR1L(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCR1L(base, value) (BME_OR32(&TRNG_RTSCR1L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCR1L(base, value) (BME_AND32(&TRNG_RTSCR1L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCR1L(base, value) (BME_XOR32(&TRNG_RTSCR1L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR1L bitfields
 */

/*!
 * @name Register TRNG_RTSCR1L, field RUN1_MAX[14:0] (RW)
 *
 * Run Length 1 Maximum Limit. Defines the maximum allowable runs of length 1
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 1 detected during entropy generation must be less than RUN1_MAX, else a
 * retry or error will occur. This register is cleared to 01E5h (decimal 485) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR1L_RUN1_MAX field. */
#define TRNG_RD_RTSCR1L_RUN1_MAX(base) ((TRNG_RTSCR1L_REG(base) & TRNG_RTSCR1L_RUN1_MAX_MASK) >> TRNG_RTSCR1L_RUN1_MAX_SHIFT)
#define TRNG_BRD_RTSCR1L_RUN1_MAX(base) (TRNG_RD_RTSCR1L_RUN1_MAX(base))

/*! @brief Set the RUN1_MAX field to a new value. */
#define TRNG_WR_RTSCR1L_RUN1_MAX(base, value) (TRNG_RMW_RTSCR1L(base, TRNG_RTSCR1L_RUN1_MAX_MASK, TRNG_RTSCR1L_RUN1_MAX(value)))
#define TRNG_BWR_RTSCR1L_RUN1_MAX(base, value) (TRNG_WR_RTSCR1L_RUN1_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSCR1L, field RUN1_RNG[30:16] (RW)
 *
 * Run Length 1 Range. The number of runs of length 1 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN1_MAX - RUN1_RNG, else a
 * retry or error will occur. This register is cleared to 0102h (decimal 258) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR1L_RUN1_RNG field. */
#define TRNG_RD_RTSCR1L_RUN1_RNG(base) ((TRNG_RTSCR1L_REG(base) & TRNG_RTSCR1L_RUN1_RNG_MASK) >> TRNG_RTSCR1L_RUN1_RNG_SHIFT)
#define TRNG_BRD_RTSCR1L_RUN1_RNG(base) (TRNG_RD_RTSCR1L_RUN1_RNG(base))

/*! @brief Set the RUN1_RNG field to a new value. */
#define TRNG_WR_RTSCR1L_RUN1_RNG(base, value) (TRNG_RMW_RTSCR1L(base, TRNG_RTSCR1L_RUN1_RNG_MASK, TRNG_RTSCR1L_RUN1_RNG(value)))
#define TRNG_BWR_RTSCR1L_RUN1_RNG(base, value) (TRNG_WR_RTSCR1L_RUN1_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR2L - RNG Statistical Check Run Length 2 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR2L - RNG Statistical Check Run Length 2 Limit Register (RW)
 *
 * Reset value: 0x007A00DCU
 *
 * The RNG Statistical Check Run Length 2 Limit Register defines the allowable
 * maximum and minimum number of runs of length 2 detected during entropy
 * generation. To pass the test, the number of runs of length 2 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 2 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in true will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will be
 * generated. Note that this address (0xBASE_0628) is used as true2L only if
 * true[PRGM] is 1. If true[PRGM] is 0, this address is used as true2C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR2L register
 */
/*@{*/
#define TRNG_RD_RTSCR2L(base)    (TRNG_RTSCR2L_REG(base))
#define TRNG_WR_RTSCR2L(base, value) (TRNG_RTSCR2L_REG(base) = (value))
#define TRNG_RMW_RTSCR2L(base, mask, value) (TRNG_WR_RTSCR2L(base, (TRNG_RD_RTSCR2L(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCR2L(base, value) (BME_OR32(&TRNG_RTSCR2L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCR2L(base, value) (BME_AND32(&TRNG_RTSCR2L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCR2L(base, value) (BME_XOR32(&TRNG_RTSCR2L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR2L bitfields
 */

/*!
 * @name Register TRNG_RTSCR2L, field RUN2_MAX[13:0] (RW)
 *
 * Run Length 2 Maximum Limit. Defines the maximum allowable runs of length 2
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 2 detected during entropy generation must be less than RUN2_MAX, else a
 * retry or error will occur. This register is cleared to 00DCh (decimal 220) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR2L_RUN2_MAX field. */
#define TRNG_RD_RTSCR2L_RUN2_MAX(base) ((TRNG_RTSCR2L_REG(base) & TRNG_RTSCR2L_RUN2_MAX_MASK) >> TRNG_RTSCR2L_RUN2_MAX_SHIFT)
#define TRNG_BRD_RTSCR2L_RUN2_MAX(base) (TRNG_RD_RTSCR2L_RUN2_MAX(base))

/*! @brief Set the RUN2_MAX field to a new value. */
#define TRNG_WR_RTSCR2L_RUN2_MAX(base, value) (TRNG_RMW_RTSCR2L(base, TRNG_RTSCR2L_RUN2_MAX_MASK, TRNG_RTSCR2L_RUN2_MAX(value)))
#define TRNG_BWR_RTSCR2L_RUN2_MAX(base, value) (TRNG_WR_RTSCR2L_RUN2_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSCR2L, field RUN2_RNG[29:16] (RW)
 *
 * Run Length 2 Range. The number of runs of length 2 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN2_MAX - RUN2_RNG, else a
 * retry or error will occur. This register is cleared to 007Ah (decimal 122) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR2L_RUN2_RNG field. */
#define TRNG_RD_RTSCR2L_RUN2_RNG(base) ((TRNG_RTSCR2L_REG(base) & TRNG_RTSCR2L_RUN2_RNG_MASK) >> TRNG_RTSCR2L_RUN2_RNG_SHIFT)
#define TRNG_BRD_RTSCR2L_RUN2_RNG(base) (TRNG_RD_RTSCR2L_RUN2_RNG(base))

/*! @brief Set the RUN2_RNG field to a new value. */
#define TRNG_WR_RTSCR2L_RUN2_RNG(base, value) (TRNG_RMW_RTSCR2L(base, TRNG_RTSCR2L_RUN2_RNG_MASK, TRNG_RTSCR2L_RUN2_RNG(value)))
#define TRNG_BWR_RTSCR2L_RUN2_RNG(base, value) (TRNG_WR_RTSCR2L_RUN2_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR2C - RNG Statistical Check Run Length 2 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR2C - RNG Statistical Check Run Length 2 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 2 Counters Register is a read-only
 * register used to read the final Run Length 2 counts after entropy generation. These
 * counters start with the value in true2L[RUN2_MAX]. The R2_1_CT decrements
 * each time two consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R2_0_CT decrements each time two consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0628) is
 * used as true2L if true[PRGM] is 1. If true[PRGM] is 0, this offset is used as
 * true2C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR2C register
 */
/*@{*/
#define TRNG_RD_RTSCR2C(base)    (TRNG_RTSCR2C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR2C bitfields
 */

/*!
 * @name Register TRNG_RTSCR2C, field R2_0_CT[13:0] (RO)
 *
 * Runs of Zero, Length 2 Count. Reads the final Runs of Zeroes, length 2 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR2C_R2_0_CT field. */
#define TRNG_RD_RTSCR2C_R2_0_CT(base) ((TRNG_RTSCR2C_REG(base) & TRNG_RTSCR2C_R2_0_CT_MASK) >> TRNG_RTSCR2C_R2_0_CT_SHIFT)
#define TRNG_BRD_RTSCR2C_R2_0_CT(base) (TRNG_RD_RTSCR2C_R2_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTSCR2C, field R2_1_CT[29:16] (RO)
 *
 * Runs of One, Length 2 Count. Reads the final Runs of Ones, length 2 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR2C_R2_1_CT field. */
#define TRNG_RD_RTSCR2C_R2_1_CT(base) ((TRNG_RTSCR2C_REG(base) & TRNG_RTSCR2C_R2_1_CT_MASK) >> TRNG_RTSCR2C_R2_1_CT_SHIFT)
#define TRNG_BRD_RTSCR2C_R2_1_CT(base) (TRNG_RD_RTSCR2C_R2_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR3C - RNG Statistical Check Run Length 3 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR3C - RNG Statistical Check Run Length 3 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 3 Counters Register is a read-only
 * register used to read the final Run Length 3 counts after entropy generation. These
 * counters start with the value in true3L[RUN3_MAX]. The R3_1_CT decrements
 * each time three consecutive ones are sampled (preceded by a zero and followed by
 * a zero). The R3_0_CT decrements each time three consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset
 * (0xBASE_062C) is used as true3L if true[PRGM] is 1. If true[PRGM] is 0, this offset is
 * used as true3C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR3C register
 */
/*@{*/
#define TRNG_RD_RTSCR3C(base)    (TRNG_RTSCR3C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR3C bitfields
 */

/*!
 * @name Register TRNG_RTSCR3C, field R3_0_CT[12:0] (RO)
 *
 * Runs of Zeroes, Length 3 Count. Reads the final Runs of Zeroes, length 3
 * count after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR3C_R3_0_CT field. */
#define TRNG_RD_RTSCR3C_R3_0_CT(base) ((TRNG_RTSCR3C_REG(base) & TRNG_RTSCR3C_R3_0_CT_MASK) >> TRNG_RTSCR3C_R3_0_CT_SHIFT)
#define TRNG_BRD_RTSCR3C_R3_0_CT(base) (TRNG_RD_RTSCR3C_R3_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTSCR3C, field R3_1_CT[28:16] (RO)
 *
 * Runs of Ones, Length 3 Count. Reads the final Runs of Ones, length 3 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR3C_R3_1_CT field. */
#define TRNG_RD_RTSCR3C_R3_1_CT(base) ((TRNG_RTSCR3C_REG(base) & TRNG_RTSCR3C_R3_1_CT_MASK) >> TRNG_RTSCR3C_R3_1_CT_SHIFT)
#define TRNG_BRD_RTSCR3C_R3_1_CT(base) (TRNG_RD_RTSCR3C_R3_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR3L - RNG Statistical Check Run Length 3 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR3L - RNG Statistical Check Run Length 3 Limit Register (RW)
 *
 * Reset value: 0x0058007DU
 *
 * The RNG Statistical Check Run Length 3 Limit Register defines the allowable
 * maximum and minimum number of runs of length 3 detected during entropy
 * generation. To pass the test, the number of runs of length 3 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 3 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in true will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will be
 * generated. Note that this address (0xBASE_062C) is used as true3L only if
 * true[PRGM] is 1. If true[PRGM] is 0, this address is used as true3C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR3L register
 */
/*@{*/
#define TRNG_RD_RTSCR3L(base)    (TRNG_RTSCR3L_REG(base))
#define TRNG_WR_RTSCR3L(base, value) (TRNG_RTSCR3L_REG(base) = (value))
#define TRNG_RMW_RTSCR3L(base, mask, value) (TRNG_WR_RTSCR3L(base, (TRNG_RD_RTSCR3L(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCR3L(base, value) (BME_OR32(&TRNG_RTSCR3L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCR3L(base, value) (BME_AND32(&TRNG_RTSCR3L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCR3L(base, value) (BME_XOR32(&TRNG_RTSCR3L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR3L bitfields
 */

/*!
 * @name Register TRNG_RTSCR3L, field RUN3_MAX[12:0] (RW)
 *
 * Run Length 3 Maximum Limit. Defines the maximum allowable runs of length 3
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 3 detected during entropy generation must be less than RUN3_MAX, else a
 * retry or error will occur. This register is cleared to 007Dh (decimal 125) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR3L_RUN3_MAX field. */
#define TRNG_RD_RTSCR3L_RUN3_MAX(base) ((TRNG_RTSCR3L_REG(base) & TRNG_RTSCR3L_RUN3_MAX_MASK) >> TRNG_RTSCR3L_RUN3_MAX_SHIFT)
#define TRNG_BRD_RTSCR3L_RUN3_MAX(base) (TRNG_RD_RTSCR3L_RUN3_MAX(base))

/*! @brief Set the RUN3_MAX field to a new value. */
#define TRNG_WR_RTSCR3L_RUN3_MAX(base, value) (TRNG_RMW_RTSCR3L(base, TRNG_RTSCR3L_RUN3_MAX_MASK, TRNG_RTSCR3L_RUN3_MAX(value)))
#define TRNG_BWR_RTSCR3L_RUN3_MAX(base, value) (TRNG_WR_RTSCR3L_RUN3_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSCR3L, field RUN3_RNG[28:16] (RW)
 *
 * Run Length 3 Range. The number of runs of length 3 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN3_MAX - RUN3_RNG, else a
 * retry or error will occur. This register is cleared to 0058h (decimal 88) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR3L_RUN3_RNG field. */
#define TRNG_RD_RTSCR3L_RUN3_RNG(base) ((TRNG_RTSCR3L_REG(base) & TRNG_RTSCR3L_RUN3_RNG_MASK) >> TRNG_RTSCR3L_RUN3_RNG_SHIFT)
#define TRNG_BRD_RTSCR3L_RUN3_RNG(base) (TRNG_RD_RTSCR3L_RUN3_RNG(base))

/*! @brief Set the RUN3_RNG field to a new value. */
#define TRNG_WR_RTSCR3L_RUN3_RNG(base, value) (TRNG_RMW_RTSCR3L(base, TRNG_RTSCR3L_RUN3_RNG_MASK, TRNG_RTSCR3L_RUN3_RNG(value)))
#define TRNG_BWR_RTSCR3L_RUN3_RNG(base, value) (TRNG_WR_RTSCR3L_RUN3_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR4C - RNG Statistical Check Run Length 4 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR4C - RNG Statistical Check Run Length 4 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 4 Counters Register is a read-only
 * register used to read the final Run Length 4 counts after entropy generation. These
 * counters start with the value in true4L[RUN4_MAX]. The R4_1_CT decrements
 * each time four consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R4_0_CT decrements each time four consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0630)
 * is used as true4L if true[PRGM] is 1. If true[PRGM] is 0, this offset is used
 * as true4C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR4C register
 */
/*@{*/
#define TRNG_RD_RTSCR4C(base)    (TRNG_RTSCR4C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR4C bitfields
 */

/*!
 * @name Register TRNG_RTSCR4C, field R4_0_CT[11:0] (RO)
 *
 * Runs of Zero, Length 4 Count. Reads the final Runs of Ones, length 4 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR4C_R4_0_CT field. */
#define TRNG_RD_RTSCR4C_R4_0_CT(base) ((TRNG_RTSCR4C_REG(base) & TRNG_RTSCR4C_R4_0_CT_MASK) >> TRNG_RTSCR4C_R4_0_CT_SHIFT)
#define TRNG_BRD_RTSCR4C_R4_0_CT(base) (TRNG_RD_RTSCR4C_R4_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTSCR4C, field R4_1_CT[27:16] (RO)
 *
 * Runs of One, Length 4 Count. Reads the final Runs of Ones, length 4 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR4C_R4_1_CT field. */
#define TRNG_RD_RTSCR4C_R4_1_CT(base) ((TRNG_RTSCR4C_REG(base) & TRNG_RTSCR4C_R4_1_CT_MASK) >> TRNG_RTSCR4C_R4_1_CT_SHIFT)
#define TRNG_BRD_RTSCR4C_R4_1_CT(base) (TRNG_RD_RTSCR4C_R4_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR4L - RNG Statistical Check Run Length 4 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR4L - RNG Statistical Check Run Length 4 Limit Register (RW)
 *
 * Reset value: 0x0040004BU
 *
 * The RNG Statistical Check Run Length 4 Limit Register defines the allowable
 * maximum and minimum number of runs of length 4 detected during entropy
 * generation. To pass the test, the number of runs of length 4 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 4 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in true will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will be
 * generated. Note that this address (0xBASE_0630) is used as true4L only if
 * true[PRGM] is 1. If true[PRGM] is 0, this address is used as true4C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR4L register
 */
/*@{*/
#define TRNG_RD_RTSCR4L(base)    (TRNG_RTSCR4L_REG(base))
#define TRNG_WR_RTSCR4L(base, value) (TRNG_RTSCR4L_REG(base) = (value))
#define TRNG_RMW_RTSCR4L(base, mask, value) (TRNG_WR_RTSCR4L(base, (TRNG_RD_RTSCR4L(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCR4L(base, value) (BME_OR32(&TRNG_RTSCR4L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCR4L(base, value) (BME_AND32(&TRNG_RTSCR4L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCR4L(base, value) (BME_XOR32(&TRNG_RTSCR4L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR4L bitfields
 */

/*!
 * @name Register TRNG_RTSCR4L, field RUN4_MAX[11:0] (RW)
 *
 * Run Length 4 Maximum Limit. Defines the maximum allowable runs of length 4
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 4 detected during entropy generation must be less than RUN4_MAX, else a
 * retry or error will occur. This register is cleared to 004Bh (decimal 75) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR4L_RUN4_MAX field. */
#define TRNG_RD_RTSCR4L_RUN4_MAX(base) ((TRNG_RTSCR4L_REG(base) & TRNG_RTSCR4L_RUN4_MAX_MASK) >> TRNG_RTSCR4L_RUN4_MAX_SHIFT)
#define TRNG_BRD_RTSCR4L_RUN4_MAX(base) (TRNG_RD_RTSCR4L_RUN4_MAX(base))

/*! @brief Set the RUN4_MAX field to a new value. */
#define TRNG_WR_RTSCR4L_RUN4_MAX(base, value) (TRNG_RMW_RTSCR4L(base, TRNG_RTSCR4L_RUN4_MAX_MASK, TRNG_RTSCR4L_RUN4_MAX(value)))
#define TRNG_BWR_RTSCR4L_RUN4_MAX(base, value) (TRNG_WR_RTSCR4L_RUN4_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSCR4L, field RUN4_RNG[27:16] (RW)
 *
 * Run Length 4 Range. The number of runs of length 4 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN4_MAX - RUN4_RNG, else a
 * retry or error will occur. This register is cleared to 0040h (decimal 64) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR4L_RUN4_RNG field. */
#define TRNG_RD_RTSCR4L_RUN4_RNG(base) ((TRNG_RTSCR4L_REG(base) & TRNG_RTSCR4L_RUN4_RNG_MASK) >> TRNG_RTSCR4L_RUN4_RNG_SHIFT)
#define TRNG_BRD_RTSCR4L_RUN4_RNG(base) (TRNG_RD_RTSCR4L_RUN4_RNG(base))

/*! @brief Set the RUN4_RNG field to a new value. */
#define TRNG_WR_RTSCR4L_RUN4_RNG(base, value) (TRNG_RMW_RTSCR4L(base, TRNG_RTSCR4L_RUN4_RNG_MASK, TRNG_RTSCR4L_RUN4_RNG(value)))
#define TRNG_BWR_RTSCR4L_RUN4_RNG(base, value) (TRNG_WR_RTSCR4L_RUN4_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR5L - RNG Statistical Check Run Length 5 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR5L - RNG Statistical Check Run Length 5 Limit Register (RW)
 *
 * Reset value: 0x002E002FU
 *
 * The RNG Statistical Check Run Length 5 Limit Register defines the allowable
 * maximum and minimum number of runs of length 5 detected during entropy
 * generation. To pass the test, the number of runs of length 5 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 5 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in true will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will be
 * generated. Note that this address (0xBASE_0634) is used as true5L only if
 * true[PRGM] is 1. If true[PRGM] is 0, this address is used as true5C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR5L register
 */
/*@{*/
#define TRNG_RD_RTSCR5L(base)    (TRNG_RTSCR5L_REG(base))
#define TRNG_WR_RTSCR5L(base, value) (TRNG_RTSCR5L_REG(base) = (value))
#define TRNG_RMW_RTSCR5L(base, mask, value) (TRNG_WR_RTSCR5L(base, (TRNG_RD_RTSCR5L(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCR5L(base, value) (BME_OR32(&TRNG_RTSCR5L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCR5L(base, value) (BME_AND32(&TRNG_RTSCR5L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCR5L(base, value) (BME_XOR32(&TRNG_RTSCR5L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR5L bitfields
 */

/*!
 * @name Register TRNG_RTSCR5L, field RUN5_MAX[10:0] (RW)
 *
 * Run Length 5 Maximum Limit. Defines the maximum allowable runs of length 5
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 5 detected during entropy generation must be less than RUN5_MAX, else a
 * retry or error will occur. This register is cleared to 002Fh (decimal 47) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR5L_RUN5_MAX field. */
#define TRNG_RD_RTSCR5L_RUN5_MAX(base) ((TRNG_RTSCR5L_REG(base) & TRNG_RTSCR5L_RUN5_MAX_MASK) >> TRNG_RTSCR5L_RUN5_MAX_SHIFT)
#define TRNG_BRD_RTSCR5L_RUN5_MAX(base) (TRNG_RD_RTSCR5L_RUN5_MAX(base))

/*! @brief Set the RUN5_MAX field to a new value. */
#define TRNG_WR_RTSCR5L_RUN5_MAX(base, value) (TRNG_RMW_RTSCR5L(base, TRNG_RTSCR5L_RUN5_MAX_MASK, TRNG_RTSCR5L_RUN5_MAX(value)))
#define TRNG_BWR_RTSCR5L_RUN5_MAX(base, value) (TRNG_WR_RTSCR5L_RUN5_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSCR5L, field RUN5_RNG[26:16] (RW)
 *
 * Run Length 5 Range. The number of runs of length 5 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN5_MAX - RUN5_RNG, else a
 * retry or error will occur. This register is cleared to 002Eh (decimal 46) by
 * writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR5L_RUN5_RNG field. */
#define TRNG_RD_RTSCR5L_RUN5_RNG(base) ((TRNG_RTSCR5L_REG(base) & TRNG_RTSCR5L_RUN5_RNG_MASK) >> TRNG_RTSCR5L_RUN5_RNG_SHIFT)
#define TRNG_BRD_RTSCR5L_RUN5_RNG(base) (TRNG_RD_RTSCR5L_RUN5_RNG(base))

/*! @brief Set the RUN5_RNG field to a new value. */
#define TRNG_WR_RTSCR5L_RUN5_RNG(base, value) (TRNG_RMW_RTSCR5L(base, TRNG_RTSCR5L_RUN5_RNG_MASK, TRNG_RTSCR5L_RUN5_RNG(value)))
#define TRNG_BWR_RTSCR5L_RUN5_RNG(base, value) (TRNG_WR_RTSCR5L_RUN5_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR5C - RNG Statistical Check Run Length 5 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR5C - RNG Statistical Check Run Length 5 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 5 Counters Register is a read-only
 * register used to read the final Run Length 5 counts after entropy generation. These
 * counters start with the value in true5L[RUN5_MAX]. The R5_1_CT decrements
 * each time five consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R5_0_CT decrements each time five consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0634)
 * is used as true5L if true[PRGM] is 1. If true[PRGM] is 0, this offset is used
 * as true5C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR5C register
 */
/*@{*/
#define TRNG_RD_RTSCR5C(base)    (TRNG_RTSCR5C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR5C bitfields
 */

/*!
 * @name Register TRNG_RTSCR5C, field R5_0_CT[10:0] (RO)
 *
 * Runs of Zero, Length 5 Count. Reads the final Runs of Ones, length 5 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR5C_R5_0_CT field. */
#define TRNG_RD_RTSCR5C_R5_0_CT(base) ((TRNG_RTSCR5C_REG(base) & TRNG_RTSCR5C_R5_0_CT_MASK) >> TRNG_RTSCR5C_R5_0_CT_SHIFT)
#define TRNG_BRD_RTSCR5C_R5_0_CT(base) (TRNG_RD_RTSCR5C_R5_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTSCR5C, field R5_1_CT[26:16] (RO)
 *
 * Runs of One, Length 5 Count. Reads the final Runs of Ones, length 5 count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR5C_R5_1_CT field. */
#define TRNG_RD_RTSCR5C_R5_1_CT(base) ((TRNG_RTSCR5C_REG(base) & TRNG_RTSCR5C_R5_1_CT_MASK) >> TRNG_RTSCR5C_R5_1_CT_SHIFT)
#define TRNG_BRD_RTSCR5C_R5_1_CT(base) (TRNG_RD_RTSCR5C_R5_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR6PC - RNG Statistical Check Run Length 6+ Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR6PC - RNG Statistical Check Run Length 6+ Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 6+ Counters Register is a read-only
 * register used to read the final Run Length 6+ counts after entropy generation.
 * These counters start with the value in true6PL[RUN6P_MAX]. The R6P_1_CT
 * decrements each time six or more consecutive ones are sampled (preceded by a zero and
 * followed by a zero). The R6P_0_CT decrements each time six or more consecutive
 * zeroes are sampled (preceded by a one and followed by a one). Note that this
 * offset (0xBASE_0638) is used as true6PL if true[PRGM] is 1. If true[PRGM] is 0,
 * this offset is used as true6PC readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR6PC register
 */
/*@{*/
#define TRNG_RD_RTSCR6PC(base)   (TRNG_RTSCR6PC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR6PC bitfields
 */

/*!
 * @name Register TRNG_RTSCR6PC, field R6P_0_CT[10:0] (RO)
 *
 * Runs of Zero, Length 6+ Count. Reads the final Runs of Ones, length 6+ count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR6PC_R6P_0_CT field. */
#define TRNG_RD_RTSCR6PC_R6P_0_CT(base) ((TRNG_RTSCR6PC_REG(base) & TRNG_RTSCR6PC_R6P_0_CT_MASK) >> TRNG_RTSCR6PC_R6P_0_CT_SHIFT)
#define TRNG_BRD_RTSCR6PC_R6P_0_CT(base) (TRNG_RD_RTSCR6PC_R6P_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTSCR6PC, field R6P_1_CT[26:16] (RO)
 *
 * Runs of One, Length 6+ Count. Reads the final Runs of Ones, length 6+ count
 * after entropy generation. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR6PC_R6P_1_CT field. */
#define TRNG_RD_RTSCR6PC_R6P_1_CT(base) ((TRNG_RTSCR6PC_REG(base) & TRNG_RTSCR6PC_R6P_1_CT_MASK) >> TRNG_RTSCR6PC_R6P_1_CT_SHIFT)
#define TRNG_BRD_RTSCR6PC_R6P_1_CT(base) (TRNG_RD_RTSCR6PC_R6P_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTSCR6PL - RNG Statistical Check Run Length 6+ Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSCR6PL - RNG Statistical Check Run Length 6+ Limit Register (RW)
 *
 * Reset value: 0x002E002FU
 *
 * The RNG Statistical Check Run Length 6+ Limit Register defines the allowable
 * maximum and minimum number of runs of length 6 or more detected during entropy
 * generation. To pass the test, the number of runs of length 6 or more (for
 * samples of both 0 and 1) must be less than the programmed maximum value, and the
 * number of runs of length 6 or more must be greater than (maximum - range). If
 * this test fails, the Retry Counter in true will be decremented, and a retry
 * will occur if the Retry Count has not reached zero. If the Retry Count has
 * reached zero, an error will be generated. Note that this offset (0xBASE_0638) is
 * used as true6PL only if true[PRGM] is 1. If true[PRGM] is 0, this offset is used
 * as true6PC readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSCR6PL register
 */
/*@{*/
#define TRNG_RD_RTSCR6PL(base)   (TRNG_RTSCR6PL_REG(base))
#define TRNG_WR_RTSCR6PL(base, value) (TRNG_RTSCR6PL_REG(base) = (value))
#define TRNG_RMW_RTSCR6PL(base, mask, value) (TRNG_WR_RTSCR6PL(base, (TRNG_RD_RTSCR6PL(base) & ~(mask)) | (value)))
#define TRNG_SET_RTSCR6PL(base, value) (BME_OR32(&TRNG_RTSCR6PL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_RTSCR6PL(base, value) (BME_AND32(&TRNG_RTSCR6PL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_RTSCR6PL(base, value) (BME_XOR32(&TRNG_RTSCR6PL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSCR6PL bitfields
 */

/*!
 * @name Register TRNG_RTSCR6PL, field RUN6P_MAX[10:0] (RW)
 *
 * Run Length 6+ Maximum Limit. Defines the maximum allowable runs of length 6
 * or more (for both 0 and 1) detected during entropy generation. The number of
 * runs of length 6 or more detected during entropy generation must be less than
 * RUN6P_MAX, else a retry or error will occur. This register is cleared to 002Fh
 * (decimal 47) by writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR6PL_RUN6P_MAX field. */
#define TRNG_RD_RTSCR6PL_RUN6P_MAX(base) ((TRNG_RTSCR6PL_REG(base) & TRNG_RTSCR6PL_RUN6P_MAX_MASK) >> TRNG_RTSCR6PL_RUN6P_MAX_SHIFT)
#define TRNG_BRD_RTSCR6PL_RUN6P_MAX(base) (TRNG_RD_RTSCR6PL_RUN6P_MAX(base))

/*! @brief Set the RUN6P_MAX field to a new value. */
#define TRNG_WR_RTSCR6PL_RUN6P_MAX(base, value) (TRNG_RMW_RTSCR6PL(base, TRNG_RTSCR6PL_RUN6P_MAX_MASK, TRNG_RTSCR6PL_RUN6P_MAX(value)))
#define TRNG_BWR_RTSCR6PL_RUN6P_MAX(base, value) (TRNG_WR_RTSCR6PL_RUN6P_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_RTSCR6PL, field RUN6P_RNG[26:16] (RW)
 *
 * Run Length 6+ Range. The number of runs of length 6 or more (for both 0 and
 * 1) detected during entropy generation must be greater than RUN6P_MAX -
 * RUN6P_RNG, else a retry or error will occur. This register is cleared to 002Eh
 * (decimal 46) by writing the true[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSCR6PL_RUN6P_RNG field. */
#define TRNG_RD_RTSCR6PL_RUN6P_RNG(base) ((TRNG_RTSCR6PL_REG(base) & TRNG_RTSCR6PL_RUN6P_RNG_MASK) >> TRNG_RTSCR6PL_RUN6P_RNG_SHIFT)
#define TRNG_BRD_RTSCR6PL_RUN6P_RNG(base) (TRNG_RD_RTSCR6PL_RUN6P_RNG(base))

/*! @brief Set the RUN6P_RNG field to a new value. */
#define TRNG_WR_RTSCR6PL_RUN6P_RNG(base, value) (TRNG_RMW_RTSCR6PL(base, TRNG_RTSCR6PL_RUN6P_RNG_MASK, TRNG_RTSCR6PL_RUN6P_RNG(value)))
#define TRNG_BWR_RTSCR6PL_RUN6P_RNG(base, value) (TRNG_WR_RTSCR6PL_RUN6P_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_RTSTATUS - RNG Status Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTSTATUS - RNG Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Various statistical tests are run as a normal part of the TRNG's entropy
 * generation process. The least-significant 16 bits of the true register reflect the
 * result of each of these tests. The status of these bits will be valid when
 * the TRNG has finished its entropy generation process. Software can determine
 * when this occurs by polling the ENT_VAL bit in the RNG Miscellaneous Control
 * Register. Note that there is a very small probability that a statistical test will
 * fail even though the TRNG is operating properly. If this happens the TRNG
 * will automatically retry the entire entropy generation process, including running
 * all the statistical tests. The value in RETRY_CT is decremented each time an
 * entropy generation retry occurs. If a statistical check fails when the retry
 * count is nonzero, a retry is initiated. But if a statistical check fails when
 * the retry count is zero, an error is generated by the RNG. By default RETRY_CT
 * is initialized to 1, but software can increase the retry count by writing to
 * the RTY_CT field in the true register. All 0s will be returned if this register
 * address is read while the RNG is in Program Mode (see PRGM field in true
 * register. If this register is read while the RNG is in Run Mode the value returned
 * will be formatted as follows.
 */
/*!
 * @name Constants and macros for entire TRNG_RTSTATUS register
 */
/*@{*/
#define TRNG_RD_RTSTATUS(base)   (TRNG_RTSTATUS_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTSTATUS bitfields
 */

/*!
 * @name Register TRNG_RTSTATUS, field TF1BR0[0] (RO)
 *
 * Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF1BR0 field. */
#define TRNG_RD_RTSTATUS_TF1BR0(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF1BR0_MASK) >> TRNG_RTSTATUS_TF1BR0_SHIFT)
#define TRNG_BRD_RTSTATUS_TF1BR0(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF1BR0_SHIFT, TRNG_RTSTATUS_TF1BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF1BR1[1] (RO)
 *
 * Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF1BR1 field. */
#define TRNG_RD_RTSTATUS_TF1BR1(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF1BR1_MASK) >> TRNG_RTSTATUS_TF1BR1_SHIFT)
#define TRNG_BRD_RTSTATUS_TF1BR1(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF1BR1_SHIFT, TRNG_RTSTATUS_TF1BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF2BR0[2] (RO)
 *
 * Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF2BR0 field. */
#define TRNG_RD_RTSTATUS_TF2BR0(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF2BR0_MASK) >> TRNG_RTSTATUS_TF2BR0_SHIFT)
#define TRNG_BRD_RTSTATUS_TF2BR0(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF2BR0_SHIFT, TRNG_RTSTATUS_TF2BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF2BR1[3] (RO)
 *
 * Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF2BR1 field. */
#define TRNG_RD_RTSTATUS_TF2BR1(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF2BR1_MASK) >> TRNG_RTSTATUS_TF2BR1_SHIFT)
#define TRNG_BRD_RTSTATUS_TF2BR1(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF2BR1_SHIFT, TRNG_RTSTATUS_TF2BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF3BR0[4] (RO)
 *
 * Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF3BR0 field. */
#define TRNG_RD_RTSTATUS_TF3BR0(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF3BR0_MASK) >> TRNG_RTSTATUS_TF3BR0_SHIFT)
#define TRNG_BRD_RTSTATUS_TF3BR0(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF3BR0_SHIFT, TRNG_RTSTATUS_TF3BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF3BR1[5] (RO)
 *
 * Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF3BR1 field. */
#define TRNG_RD_RTSTATUS_TF3BR1(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF3BR1_MASK) >> TRNG_RTSTATUS_TF3BR1_SHIFT)
#define TRNG_BRD_RTSTATUS_TF3BR1(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF3BR1_SHIFT, TRNG_RTSTATUS_TF3BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF4BR0[6] (RO)
 *
 * Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF4BR0 field. */
#define TRNG_RD_RTSTATUS_TF4BR0(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF4BR0_MASK) >> TRNG_RTSTATUS_TF4BR0_SHIFT)
#define TRNG_BRD_RTSTATUS_TF4BR0(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF4BR0_SHIFT, TRNG_RTSTATUS_TF4BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF4BR1[7] (RO)
 *
 * Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF4BR1 field. */
#define TRNG_RD_RTSTATUS_TF4BR1(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF4BR1_MASK) >> TRNG_RTSTATUS_TF4BR1_SHIFT)
#define TRNG_BRD_RTSTATUS_TF4BR1(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF4BR1_SHIFT, TRNG_RTSTATUS_TF4BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF5BR0[8] (RO)
 *
 * Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF5BR0 field. */
#define TRNG_RD_RTSTATUS_TF5BR0(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF5BR0_MASK) >> TRNG_RTSTATUS_TF5BR0_SHIFT)
#define TRNG_BRD_RTSTATUS_TF5BR0(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF5BR0_SHIFT, TRNG_RTSTATUS_TF5BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF5BR1[9] (RO)
 *
 * Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF5BR1 field. */
#define TRNG_RD_RTSTATUS_TF5BR1(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF5BR1_MASK) >> TRNG_RTSTATUS_TF5BR1_SHIFT)
#define TRNG_BRD_RTSTATUS_TF5BR1(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF5BR1_SHIFT, TRNG_RTSTATUS_TF5BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF6PBR0[10] (RO)
 *
 * Test Fail, 6 Plus Bit Run, Sampling 0s. If TF6PBR0=1, the 6 Plus Bit Run,
 * Sampling 0s Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF6PBR0 field. */
#define TRNG_RD_RTSTATUS_TF6PBR0(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF6PBR0_MASK) >> TRNG_RTSTATUS_TF6PBR0_SHIFT)
#define TRNG_BRD_RTSTATUS_TF6PBR0(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF6PBR0_SHIFT, TRNG_RTSTATUS_TF6PBR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TF6PBR1[11] (RO)
 *
 * Test Fail, 6 Plus Bit Run, Sampling 1s. If TF6PBR1=1, the 6 Plus Bit Run,
 * Sampling 1s Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TF6PBR1 field. */
#define TRNG_RD_RTSTATUS_TF6PBR1(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TF6PBR1_MASK) >> TRNG_RTSTATUS_TF6PBR1_SHIFT)
#define TRNG_BRD_RTSTATUS_TF6PBR1(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TF6PBR1_SHIFT, TRNG_RTSTATUS_TF6PBR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TFSB[12] (RO)
 *
 * Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TFSB field. */
#define TRNG_RD_RTSTATUS_TFSB(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TFSB_MASK) >> TRNG_RTSTATUS_TFSB_SHIFT)
#define TRNG_BRD_RTSTATUS_TFSB(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TFSB_SHIFT, TRNG_RTSTATUS_TFSB_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TFLR[13] (RO)
 *
 * Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TFLR field. */
#define TRNG_RD_RTSTATUS_TFLR(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TFLR_MASK) >> TRNG_RTSTATUS_TFLR_SHIFT)
#define TRNG_BRD_RTSTATUS_TFLR(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TFLR_SHIFT, TRNG_RTSTATUS_TFLR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TFP[14] (RO)
 *
 * Test Fail, Poker. If TFP=1, the Poker Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TFP field. */
#define TRNG_RD_RTSTATUS_TFP(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TFP_MASK) >> TRNG_RTSTATUS_TFP_SHIFT)
#define TRNG_BRD_RTSTATUS_TFP(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TFP_SHIFT, TRNG_RTSTATUS_TFP_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field TFMB[15] (RO)
 *
 * Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_TFMB field. */
#define TRNG_RD_RTSTATUS_TFMB(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_TFMB_MASK) >> TRNG_RTSTATUS_TFMB_SHIFT)
#define TRNG_BRD_RTSTATUS_TFMB(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_TFMB_SHIFT, TRNG_RTSTATUS_TFMB_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_RTSTATUS, field RETRY_CT[19:16] (RO)
 *
 * RETRY COUNT. This represents the current number of entropy generation retries
 * left before a statistical text failure will cause the RNG to generate an
 * error condition.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTSTATUS_RETRY_CT field. */
#define TRNG_RD_RTSTATUS_RETRY_CT(base) ((TRNG_RTSTATUS_REG(base) & TRNG_RTSTATUS_RETRY_CT_MASK) >> TRNG_RTSTATUS_RETRY_CT_SHIFT)
#define TRNG_BRD_RTSTATUS_RETRY_CT(base) (BME_UBFX32(&TRNG_RTSTATUS_REG(base), TRNG_RTSTATUS_RETRY_CT_SHIFT, TRNG_RTSTATUS_RETRY_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT0 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT0 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT0 register
 */
/*@{*/
#define TRNG_RD_RTENT0(base)     (TRNG_RTENT0_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT1 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT1 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT1 register
 */
/*@{*/
#define TRNG_RD_RTENT1(base)     (TRNG_RTENT1_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT2 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT2 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT2 register
 */
/*@{*/
#define TRNG_RD_RTENT2(base)     (TRNG_RTENT2_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT3 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT3 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT3 register
 */
/*@{*/
#define TRNG_RD_RTENT3(base)     (TRNG_RTENT3_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT4 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT4 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT4 register
 */
/*@{*/
#define TRNG_RD_RTENT4(base)     (TRNG_RTENT4_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT5 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT5 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT5 register
 */
/*@{*/
#define TRNG_RD_RTENT5(base)     (TRNG_RTENT5_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT6 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT6 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT6 register
 */
/*@{*/
#define TRNG_RD_RTENT6(base)     (TRNG_RTENT6_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT7 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT7 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT7 register
 */
/*@{*/
#define TRNG_RD_RTENT7(base)     (TRNG_RTENT7_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT8 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT8 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT8 register
 */
/*@{*/
#define TRNG_RD_RTENT8(base)     (TRNG_RTENT8_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT9 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT9 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT9 register
 */
/*@{*/
#define TRNG_RD_RTENT9(base)     (TRNG_RTENT9_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT10 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT10 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT10 register
 */
/*@{*/
#define TRNG_RD_RTENT10(base)    (TRNG_RTENT10_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT11 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT11 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT11 register
 */
/*@{*/
#define TRNG_RD_RTENT11(base)    (TRNG_RTENT11_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT12 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT12 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT12 register
 */
/*@{*/
#define TRNG_RD_RTENT12(base)    (TRNG_RTENT12_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT13 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT13 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT13 register
 */
/*@{*/
#define TRNG_RD_RTENT13(base)    (TRNG_RTENT13_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT14 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT14 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT14 register
 */
/*@{*/
#define TRNG_RD_RTENT14(base)    (TRNG_RTENT14_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTENT15 - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTENT15 - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the true[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the true[ENT_VAL] bit will be set to 1. At this
 * point, true0 through true15 may be read to retrieve the 512-bit entropy
 * value. Note that once true15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that true15 be read last. These
 * registers are readable only when true[PRGM] = 0 (Run Mode), true[TRNG_ACC] =
 * 1 (TRNG access mode) and true[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTENT15 register
 */
/*@{*/
#define TRNG_RD_RTENT15(base)    (TRNG_RTENT15_REG(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 1 and 0 Register is a read-only
 * register used to read the final Poker test counts of 1h and 0h patterns. The Poker 0h
 * Count increments each time a nibble of sample data is found to be 0h. The
 * Poker 1h Count increments each time a nibble of sample data is found to be 1h.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNT10 register
 */
/*@{*/
#define TRNG_RD_RTPKRCNT10(base) (TRNG_RTPKRCNT10_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNT10 bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNT10, field PKR_0_CT[15:0] (RO)
 *
 * Poker 0h Count. Total number of nibbles of sample data which were found to be
 * 0h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT10_PKR_0_CT field. */
#define TRNG_RD_RTPKRCNT10_PKR_0_CT(base) ((TRNG_RTPKRCNT10_REG(base) & TRNG_RTPKRCNT10_PKR_0_CT_MASK) >> TRNG_RTPKRCNT10_PKR_0_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT10_PKR_0_CT(base) (TRNG_RD_RTPKRCNT10_PKR_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNT10, field PKR_1_CT[31:16] (RO)
 *
 * Poker 1h Count. Total number of nibbles of sample data which were found to be
 * 1h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT10_PKR_1_CT field. */
#define TRNG_RD_RTPKRCNT10_PKR_1_CT(base) ((TRNG_RTPKRCNT10_REG(base) & TRNG_RTPKRCNT10_PKR_1_CT_MASK) >> TRNG_RTPKRCNT10_PKR_1_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT10_PKR_1_CT(base) (TRNG_RD_RTPKRCNT10_PKR_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 3 and 2 Register is a read-only
 * register used to read the final Poker test counts of 3h and 2h patterns. The Poker 2h
 * Count increments each time a nibble of sample data is found to be 2h. The
 * Poker 3h Count increments each time a nibble of sample data is found to be 3h.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNT32 register
 */
/*@{*/
#define TRNG_RD_RTPKRCNT32(base) (TRNG_RTPKRCNT32_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNT32 bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNT32, field PKR_2_CT[15:0] (RO)
 *
 * Poker 2h Count. Total number of nibbles of sample data which were found to be
 * 2h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT32_PKR_2_CT field. */
#define TRNG_RD_RTPKRCNT32_PKR_2_CT(base) ((TRNG_RTPKRCNT32_REG(base) & TRNG_RTPKRCNT32_PKR_2_CT_MASK) >> TRNG_RTPKRCNT32_PKR_2_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT32_PKR_2_CT(base) (TRNG_RD_RTPKRCNT32_PKR_2_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNT32, field PKR_3_CT[31:16] (RO)
 *
 * Poker 3h Count. Total number of nibbles of sample data which were found to be
 * 3h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT32_PKR_3_CT field. */
#define TRNG_RD_RTPKRCNT32_PKR_3_CT(base) ((TRNG_RTPKRCNT32_REG(base) & TRNG_RTPKRCNT32_PKR_3_CT_MASK) >> TRNG_RTPKRCNT32_PKR_3_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT32_PKR_3_CT(base) (TRNG_RD_RTPKRCNT32_PKR_3_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 5 and 4 Register is a read-only
 * register used to read the final Poker test counts of 5h and 4h patterns. The Poker 4h
 * Count increments each time a nibble of sample data is found to be 4h. The
 * Poker 5h Count increments each time a nibble of sample data is found to be 5h.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNT54 register
 */
/*@{*/
#define TRNG_RD_RTPKRCNT54(base) (TRNG_RTPKRCNT54_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNT54 bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNT54, field PKR_4_CT[15:0] (RO)
 *
 * Poker 4h Count. Total number of nibbles of sample data which were found to be
 * 4h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT54_PKR_4_CT field. */
#define TRNG_RD_RTPKRCNT54_PKR_4_CT(base) ((TRNG_RTPKRCNT54_REG(base) & TRNG_RTPKRCNT54_PKR_4_CT_MASK) >> TRNG_RTPKRCNT54_PKR_4_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT54_PKR_4_CT(base) (TRNG_RD_RTPKRCNT54_PKR_4_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNT54, field PKR_5_CT[31:16] (RO)
 *
 * Poker 5h Count. Total number of nibbles of sample data which were found to be
 * 5h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT54_PKR_5_CT field. */
#define TRNG_RD_RTPKRCNT54_PKR_5_CT(base) ((TRNG_RTPKRCNT54_REG(base) & TRNG_RTPKRCNT54_PKR_5_CT_MASK) >> TRNG_RTPKRCNT54_PKR_5_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT54_PKR_5_CT(base) (TRNG_RD_RTPKRCNT54_PKR_5_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 7 and 6 Register is a read-only
 * register used to read the final Poker test counts of 7h and 6h patterns. The Poker 6h
 * Count increments each time a nibble of sample data is found to be 6h. The
 * Poker 7h Count increments each time a nibble of sample data is found to be 7h.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNT76 register
 */
/*@{*/
#define TRNG_RD_RTPKRCNT76(base) (TRNG_RTPKRCNT76_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNT76 bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNT76, field PKR_6_CT[15:0] (RO)
 *
 * Poker 6h Count. Total number of nibbles of sample data which were found to be
 * 6h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT76_PKR_6_CT field. */
#define TRNG_RD_RTPKRCNT76_PKR_6_CT(base) ((TRNG_RTPKRCNT76_REG(base) & TRNG_RTPKRCNT76_PKR_6_CT_MASK) >> TRNG_RTPKRCNT76_PKR_6_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT76_PKR_6_CT(base) (TRNG_RD_RTPKRCNT76_PKR_6_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNT76, field PKR_7_CT[31:16] (RO)
 *
 * Poker 7h Count. Total number of nibbles of sample data which were found to be
 * 7h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT76_PKR_7_CT field. */
#define TRNG_RD_RTPKRCNT76_PKR_7_CT(base) ((TRNG_RTPKRCNT76_REG(base) & TRNG_RTPKRCNT76_PKR_7_CT_MASK) >> TRNG_RTPKRCNT76_PKR_7_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT76_PKR_7_CT(base) (TRNG_RD_RTPKRCNT76_PKR_7_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 9 and 8 Register is a read-only
 * register used to read the final Poker test counts of 9h and 8h patterns. The Poker 8h
 * Count increments each time a nibble of sample data is found to be 8h. The
 * Poker 9h Count increments each time a nibble of sample data is found to be 9h.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNT98 register
 */
/*@{*/
#define TRNG_RD_RTPKRCNT98(base) (TRNG_RTPKRCNT98_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNT98 bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNT98, field PKR_8_CT[15:0] (RO)
 *
 * Poker 8h Count. Total number of nibbles of sample data which were found to be
 * 8h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT98_PKR_8_CT field. */
#define TRNG_RD_RTPKRCNT98_PKR_8_CT(base) ((TRNG_RTPKRCNT98_REG(base) & TRNG_RTPKRCNT98_PKR_8_CT_MASK) >> TRNG_RTPKRCNT98_PKR_8_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT98_PKR_8_CT(base) (TRNG_RD_RTPKRCNT98_PKR_8_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNT98, field PKR_9_CT[31:16] (RO)
 *
 * Poker 9h Count. Total number of nibbles of sample data which were found to be
 * 9h. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNT98_PKR_9_CT field. */
#define TRNG_RD_RTPKRCNT98_PKR_9_CT(base) ((TRNG_RTPKRCNT98_REG(base) & TRNG_RTPKRCNT98_PKR_9_CT_MASK) >> TRNG_RTPKRCNT98_PKR_9_CT_SHIFT)
#define TRNG_BRD_RTPKRCNT98_PKR_9_CT(base) (TRNG_RD_RTPKRCNT98_PKR_9_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNTBA - RNG Statistical Check Poker Count B and A Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNTBA - RNG Statistical Check Poker Count B and A Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count B and A Register is a read-only
 * register used to read the final Poker test counts of Bh and Ah patterns. The Poker Ah
 * Count increments each time a nibble of sample data is found to be Ah. The
 * Poker Bh Count increments each time a nibble of sample data is found to be Bh.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNTBA register
 */
/*@{*/
#define TRNG_RD_RTPKRCNTBA(base) (TRNG_RTPKRCNTBA_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNTBA bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNTBA, field PKR_A_CT[15:0] (RO)
 *
 * Poker Ah Count. Total number of nibbles of sample data which were found to be
 * Ah. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNTBA_PKR_A_CT field. */
#define TRNG_RD_RTPKRCNTBA_PKR_A_CT(base) ((TRNG_RTPKRCNTBA_REG(base) & TRNG_RTPKRCNTBA_PKR_A_CT_MASK) >> TRNG_RTPKRCNTBA_PKR_A_CT_SHIFT)
#define TRNG_BRD_RTPKRCNTBA_PKR_A_CT(base) (TRNG_RD_RTPKRCNTBA_PKR_A_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNTBA, field PKR_B_CT[31:16] (RO)
 *
 * Poker Bh Count. Total number of nibbles of sample data which were found to be
 * Bh. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNTBA_PKR_B_CT field. */
#define TRNG_RD_RTPKRCNTBA_PKR_B_CT(base) ((TRNG_RTPKRCNTBA_REG(base) & TRNG_RTPKRCNTBA_PKR_B_CT_MASK) >> TRNG_RTPKRCNTBA_PKR_B_CT_SHIFT)
#define TRNG_BRD_RTPKRCNTBA_PKR_B_CT(base) (TRNG_RD_RTPKRCNTBA_PKR_B_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNTDC - RNG Statistical Check Poker Count D and C Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNTDC - RNG Statistical Check Poker Count D and C Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count D and C Register is a read-only
 * register used to read the final Poker test counts of Dh and Ch patterns. The Poker Ch
 * Count increments each time a nibble of sample data is found to be Ch. The
 * Poker Dh Count increments each time a nibble of sample data is found to be Dh.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNTDC register
 */
/*@{*/
#define TRNG_RD_RTPKRCNTDC(base) (TRNG_RTPKRCNTDC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNTDC bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNTDC, field PKR_C_CT[15:0] (RO)
 *
 * Poker Ch Count. Total number of nibbles of sample data which were found to be
 * Ch. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNTDC_PKR_C_CT field. */
#define TRNG_RD_RTPKRCNTDC_PKR_C_CT(base) ((TRNG_RTPKRCNTDC_REG(base) & TRNG_RTPKRCNTDC_PKR_C_CT_MASK) >> TRNG_RTPKRCNTDC_PKR_C_CT_SHIFT)
#define TRNG_BRD_RTPKRCNTDC_PKR_C_CT(base) (TRNG_RD_RTPKRCNTDC_PKR_C_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNTDC, field PKR_D_CT[31:16] (RO)
 *
 * Poker Dh Count. Total number of nibbles of sample data which were found to be
 * Dh. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNTDC_PKR_D_CT field. */
#define TRNG_RD_RTPKRCNTDC_PKR_D_CT(base) ((TRNG_RTPKRCNTDC_REG(base) & TRNG_RTPKRCNTDC_PKR_D_CT_MASK) >> TRNG_RTPKRCNTDC_PKR_D_CT_SHIFT)
#define TRNG_BRD_RTPKRCNTDC_PKR_D_CT(base) (TRNG_RD_RTPKRCNTDC_PKR_D_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_RTPKRCNTFE - RNG Statistical Check Poker Count F and E Register
 ******************************************************************************/

/*!
 * @brief TRNG_RTPKRCNTFE - RNG Statistical Check Poker Count F and E Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count F and E Register is a read-only
 * register used to read the final Poker test counts of Fh and Eh patterns. The Poker Eh
 * Count increments each time a nibble of sample data is found to be Eh. The
 * Poker Fh Count increments each time a nibble of sample data is found to be Fh.
 * Note that this register is readable only if true[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_RTPKRCNTFE register
 */
/*@{*/
#define TRNG_RD_RTPKRCNTFE(base) (TRNG_RTPKRCNTFE_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_RTPKRCNTFE bitfields
 */

/*!
 * @name Register TRNG_RTPKRCNTFE, field PKR_E_CT[15:0] (RO)
 *
 * Poker Eh Count. Total number of nibbles of sample data which were found to be
 * Eh. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNTFE_PKR_E_CT field. */
#define TRNG_RD_RTPKRCNTFE_PKR_E_CT(base) ((TRNG_RTPKRCNTFE_REG(base) & TRNG_RTPKRCNTFE_PKR_E_CT_MASK) >> TRNG_RTPKRCNTFE_PKR_E_CT_SHIFT)
#define TRNG_BRD_RTPKRCNTFE_PKR_E_CT(base) (TRNG_RD_RTPKRCNTFE_PKR_E_CT(base))
/*@}*/

/*!
 * @name Register TRNG_RTPKRCNTFE, field PKR_F_CT[31:16] (RO)
 *
 * Poker Fh Count. Total number of nibbles of sample data which were found to be
 * Fh. Requires true[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_RTPKRCNTFE_PKR_F_CT field. */
#define TRNG_RD_RTPKRCNTFE_PKR_F_CT(base) ((TRNG_RTPKRCNTFE_REG(base) & TRNG_RTPKRCNTFE_PKR_F_CT_MASK) >> TRNG_RTPKRCNTFE_PKR_F_CT_SHIFT)
#define TRNG_BRD_RTPKRCNTFE_PKR_F_CT(base) (TRNG_RD_RTPKRCNTFE_PKR_F_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SA_TRNG_SEC_CFG - RNG Security Configuration Register
 ******************************************************************************/

/*!
 * @brief TRNG_SA_TRNG_SEC_CFG - RNG Security Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Security Configuration Register is a read/write register used to
 * control the test mode, programmability and state modes of the RNG. Many bits are
 * place holders for this version. More configurability will be added here. Clears
 * on asynchronous reset. For SA-TRNG releases before 2014/July/01, offsets 0xA0
 * to 0xAC used to be 0xB0 to 0xBC respectively. So, update newer tests that use
 * these registers, if hard coded.
 */
/*!
 * @name Constants and macros for entire TRNG_SA_TRNG_SEC_CFG register
 */
/*@{*/
#define TRNG_RD_SA_TRNG_SEC_CFG(base) (TRNG_SA_TRNG_SEC_CFG_REG(base))
#define TRNG_WR_SA_TRNG_SEC_CFG(base, value) (TRNG_SA_TRNG_SEC_CFG_REG(base) = (value))
#define TRNG_RMW_SA_TRNG_SEC_CFG(base, mask, value) (TRNG_WR_SA_TRNG_SEC_CFG(base, (TRNG_RD_SA_TRNG_SEC_CFG(base) & ~(mask)) | (value)))
#define TRNG_SET_SA_TRNG_SEC_CFG(base, value) (BME_OR32(&TRNG_SA_TRNG_SEC_CFG_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SA_TRNG_SEC_CFG(base, value) (BME_AND32(&TRNG_SA_TRNG_SEC_CFG_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SA_TRNG_SEC_CFG(base, value) (BME_XOR32(&TRNG_SA_TRNG_SEC_CFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SA_TRNG_SEC_CFG bitfields
 */

/*!
 * @name Register TRNG_SA_TRNG_SEC_CFG, field SH0[0] (RW)
 *
 * Reserved. DRNG specific, not applicable to this version.
 *
 * Values:
 * - 0b0 - See DRNG version.
 * - 0b1 - See DRNG version.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_SEC_CFG_SH0 field. */
#define TRNG_RD_SA_TRNG_SEC_CFG_SH0(base) ((TRNG_SA_TRNG_SEC_CFG_REG(base) & TRNG_SA_TRNG_SEC_CFG_SH0_MASK) >> TRNG_SA_TRNG_SEC_CFG_SH0_SHIFT)
#define TRNG_BRD_SA_TRNG_SEC_CFG_SH0(base) (BME_UBFX32(&TRNG_SA_TRNG_SEC_CFG_REG(base), TRNG_SA_TRNG_SEC_CFG_SH0_SHIFT, TRNG_SA_TRNG_SEC_CFG_SH0_WIDTH))

/*! @brief Set the SH0 field to a new value. */
#define TRNG_WR_SA_TRNG_SEC_CFG_SH0(base, value) (TRNG_RMW_SA_TRNG_SEC_CFG(base, TRNG_SA_TRNG_SEC_CFG_SH0_MASK, TRNG_SA_TRNG_SEC_CFG_SH0(value)))
#define TRNG_BWR_SA_TRNG_SEC_CFG_SH0(base, value) (BME_BFI32(&TRNG_SA_TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_SEC_CFG_SH0_SHIFT), TRNG_SA_TRNG_SEC_CFG_SH0_SHIFT, TRNG_SA_TRNG_SEC_CFG_SH0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_SEC_CFG, field NO_PRGM[1] (RW)
 *
 * If set the TRNG registers cannot be programmed. That is, regardless of the
 * TRNG access mode in the SA-TRNG Miscellaneous Control Register.
 *
 * Values:
 * - 0b0 - Programability of registers controlled only by the RNG Miscellaneous
 *     Control Register's access mode bit.
 * - 0b1 - Overides RNG Miscellaneous Control Register access mode and prevents
 *     TRNG register programming.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_SEC_CFG_NO_PRGM field. */
#define TRNG_RD_SA_TRNG_SEC_CFG_NO_PRGM(base) ((TRNG_SA_TRNG_SEC_CFG_REG(base) & TRNG_SA_TRNG_SEC_CFG_NO_PRGM_MASK) >> TRNG_SA_TRNG_SEC_CFG_NO_PRGM_SHIFT)
#define TRNG_BRD_SA_TRNG_SEC_CFG_NO_PRGM(base) (BME_UBFX32(&TRNG_SA_TRNG_SEC_CFG_REG(base), TRNG_SA_TRNG_SEC_CFG_NO_PRGM_SHIFT, TRNG_SA_TRNG_SEC_CFG_NO_PRGM_WIDTH))

/*! @brief Set the NO_PRGM field to a new value. */
#define TRNG_WR_SA_TRNG_SEC_CFG_NO_PRGM(base, value) (TRNG_RMW_SA_TRNG_SEC_CFG(base, TRNG_SA_TRNG_SEC_CFG_NO_PRGM_MASK, TRNG_SA_TRNG_SEC_CFG_NO_PRGM(value)))
#define TRNG_BWR_SA_TRNG_SEC_CFG_NO_PRGM(base, value) (BME_BFI32(&TRNG_SA_TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_SEC_CFG_NO_PRGM_SHIFT), TRNG_SA_TRNG_SEC_CFG_NO_PRGM_SHIFT, TRNG_SA_TRNG_SEC_CFG_NO_PRGM_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_SEC_CFG, field SK_VAL[2] (RW)
 *
 * Reserved. DRNG-specific, not applicable to this version.
 *
 * Values:
 * - 0b0 - See DRNG version.
 * - 0b1 - See DRNG version.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_SEC_CFG_SK_VAL field. */
#define TRNG_RD_SA_TRNG_SEC_CFG_SK_VAL(base) ((TRNG_SA_TRNG_SEC_CFG_REG(base) & TRNG_SA_TRNG_SEC_CFG_SK_VAL_MASK) >> TRNG_SA_TRNG_SEC_CFG_SK_VAL_SHIFT)
#define TRNG_BRD_SA_TRNG_SEC_CFG_SK_VAL(base) (BME_UBFX32(&TRNG_SA_TRNG_SEC_CFG_REG(base), TRNG_SA_TRNG_SEC_CFG_SK_VAL_SHIFT, TRNG_SA_TRNG_SEC_CFG_SK_VAL_WIDTH))

/*! @brief Set the SK_VAL field to a new value. */
#define TRNG_WR_SA_TRNG_SEC_CFG_SK_VAL(base, value) (TRNG_RMW_SA_TRNG_SEC_CFG(base, TRNG_SA_TRNG_SEC_CFG_SK_VAL_MASK, TRNG_SA_TRNG_SEC_CFG_SK_VAL(value)))
#define TRNG_BWR_SA_TRNG_SEC_CFG_SK_VAL(base, value) (BME_BFI32(&TRNG_SA_TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_SEC_CFG_SK_VAL_SHIFT), TRNG_SA_TRNG_SEC_CFG_SK_VAL_SHIFT, TRNG_SA_TRNG_SEC_CFG_SK_VAL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SA_TRNG_INT_CTRL - RNG Interrupt Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_SA_TRNG_INT_CTRL - RNG Interrupt Control Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The RNG Interrupt Control Register is a read/write register used to control
 * the status for the (currently) three important interrupts that are generated by
 * the TRNG. See true register description above. Each interrupt can be cleared
 * by de-asserting the corresponding bit in the true register. Only a new
 * interrupt will reassert the corresponding bit in the status register. Even if the
 * interrupt is cleared or masked, interrupt status information can be read from the
 * true register.
 */
/*!
 * @name Constants and macros for entire TRNG_SA_TRNG_INT_CTRL register
 */
/*@{*/
#define TRNG_RD_SA_TRNG_INT_CTRL(base) (TRNG_SA_TRNG_INT_CTRL_REG(base))
#define TRNG_WR_SA_TRNG_INT_CTRL(base, value) (TRNG_SA_TRNG_INT_CTRL_REG(base) = (value))
#define TRNG_RMW_SA_TRNG_INT_CTRL(base, mask, value) (TRNG_WR_SA_TRNG_INT_CTRL(base, (TRNG_RD_SA_TRNG_INT_CTRL(base) & ~(mask)) | (value)))
#define TRNG_SET_SA_TRNG_INT_CTRL(base, value) (BME_OR32(&TRNG_SA_TRNG_INT_CTRL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SA_TRNG_INT_CTRL(base, value) (BME_AND32(&TRNG_SA_TRNG_INT_CTRL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SA_TRNG_INT_CTRL(base, value) (BME_XOR32(&TRNG_SA_TRNG_INT_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SA_TRNG_INT_CTRL bitfields
 */

/*!
 * @name Register TRNG_SA_TRNG_INT_CTRL, field HW_ERR[0] (RW)
 *
 * Bit position that can be cleared if corresponding bit of true has been
 * asserted.
 *
 * Values:
 * - 0b0 - Corresponding bit of true cleared.
 * - 0b1 - Corresponding bit of true active.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_CTRL_HW_ERR field. */
#define TRNG_RD_SA_TRNG_INT_CTRL_HW_ERR(base) ((TRNG_SA_TRNG_INT_CTRL_REG(base) & TRNG_SA_TRNG_INT_CTRL_HW_ERR_MASK) >> TRNG_SA_TRNG_INT_CTRL_HW_ERR_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_CTRL_HW_ERR(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_CTRL_REG(base), TRNG_SA_TRNG_INT_CTRL_HW_ERR_SHIFT, TRNG_SA_TRNG_INT_CTRL_HW_ERR_WIDTH))

/*! @brief Set the HW_ERR field to a new value. */
#define TRNG_WR_SA_TRNG_INT_CTRL_HW_ERR(base, value) (TRNG_RMW_SA_TRNG_INT_CTRL(base, TRNG_SA_TRNG_INT_CTRL_HW_ERR_MASK, TRNG_SA_TRNG_INT_CTRL_HW_ERR(value)))
#define TRNG_BWR_SA_TRNG_INT_CTRL_HW_ERR(base, value) (BME_BFI32(&TRNG_SA_TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_INT_CTRL_HW_ERR_SHIFT), TRNG_SA_TRNG_INT_CTRL_HW_ERR_SHIFT, TRNG_SA_TRNG_INT_CTRL_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_INT_CTRL, field ENT_VAL[1] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_CTRL_ENT_VAL field. */
#define TRNG_RD_SA_TRNG_INT_CTRL_ENT_VAL(base) ((TRNG_SA_TRNG_INT_CTRL_REG(base) & TRNG_SA_TRNG_INT_CTRL_ENT_VAL_MASK) >> TRNG_SA_TRNG_INT_CTRL_ENT_VAL_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_CTRL_ENT_VAL(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_CTRL_REG(base), TRNG_SA_TRNG_INT_CTRL_ENT_VAL_SHIFT, TRNG_SA_TRNG_INT_CTRL_ENT_VAL_WIDTH))

/*! @brief Set the ENT_VAL field to a new value. */
#define TRNG_WR_SA_TRNG_INT_CTRL_ENT_VAL(base, value) (TRNG_RMW_SA_TRNG_INT_CTRL(base, TRNG_SA_TRNG_INT_CTRL_ENT_VAL_MASK, TRNG_SA_TRNG_INT_CTRL_ENT_VAL(value)))
#define TRNG_BWR_SA_TRNG_INT_CTRL_ENT_VAL(base, value) (BME_BFI32(&TRNG_SA_TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_INT_CTRL_ENT_VAL_SHIFT), TRNG_SA_TRNG_INT_CTRL_ENT_VAL_SHIFT, TRNG_SA_TRNG_INT_CTRL_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_INT_CTRL, field FRQ_CT_FAIL[2] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL field. */
#define TRNG_RD_SA_TRNG_INT_CTRL_FRQ_CT_FAIL(base) ((TRNG_SA_TRNG_INT_CTRL_REG(base) & TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_MASK) >> TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_CTRL_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_CTRL_REG(base), TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT, TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_SA_TRNG_INT_CTRL_FRQ_CT_FAIL(base, value) (TRNG_RMW_SA_TRNG_INT_CTRL(base, TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_MASK, TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL(value)))
#define TRNG_BWR_SA_TRNG_INT_CTRL_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_SA_TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT), TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT, TRNG_SA_TRNG_INT_CTRL_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_INT_CTRL, field UNUSED[31:3] (RW)
 *
 * Reserved but writeable.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_CTRL_UNUSED field. */
#define TRNG_RD_SA_TRNG_INT_CTRL_UNUSED(base) ((TRNG_SA_TRNG_INT_CTRL_REG(base) & TRNG_SA_TRNG_INT_CTRL_UNUSED_MASK) >> TRNG_SA_TRNG_INT_CTRL_UNUSED_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_CTRL_UNUSED(base) (TRNG_RD_SA_TRNG_INT_CTRL_UNUSED(base))

/*! @brief Set the UNUSED field to a new value. */
#define TRNG_WR_SA_TRNG_INT_CTRL_UNUSED(base, value) (TRNG_RMW_SA_TRNG_INT_CTRL(base, TRNG_SA_TRNG_INT_CTRL_UNUSED_MASK, TRNG_SA_TRNG_INT_CTRL_UNUSED(value)))
#define TRNG_BWR_SA_TRNG_INT_CTRL_UNUSED(base, value) (TRNG_WR_SA_TRNG_INT_CTRL_UNUSED(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SA_TRNG_INT_MASK - RNG Mask Register
 ******************************************************************************/

/*!
 * @brief TRNG_SA_TRNG_INT_MASK - RNG Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Interrupt Mask Register is a read/write register used to disable/mask
 * the status reporting of the (currently) three important interrupts that are
 * generated by the TRNG. See true register description above. Each interrupt can
 * be masked/disabled by de-asserting the corresponding bit in the true register.
 * Only setting this bit high will re-enable the interrupt in the status
 * register. Even if the interrupt is cleared or masked, interrupt status information
 * can be read from the true register.
 */
/*!
 * @name Constants and macros for entire TRNG_SA_TRNG_INT_MASK register
 */
/*@{*/
#define TRNG_RD_SA_TRNG_INT_MASK(base) (TRNG_SA_TRNG_INT_MASK_REG(base))
#define TRNG_WR_SA_TRNG_INT_MASK(base, value) (TRNG_SA_TRNG_INT_MASK_REG(base) = (value))
#define TRNG_RMW_SA_TRNG_INT_MASK(base, mask, value) (TRNG_WR_SA_TRNG_INT_MASK(base, (TRNG_RD_SA_TRNG_INT_MASK(base) & ~(mask)) | (value)))
#define TRNG_SET_SA_TRNG_INT_MASK(base, value) (BME_OR32(&TRNG_SA_TRNG_INT_MASK_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SA_TRNG_INT_MASK(base, value) (BME_AND32(&TRNG_SA_TRNG_INT_MASK_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SA_TRNG_INT_MASK(base, value) (BME_XOR32(&TRNG_SA_TRNG_INT_MASK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SA_TRNG_INT_MASK bitfields
 */

/*!
 * @name Register TRNG_SA_TRNG_INT_MASK, field HW_ERR[0] (RW)
 *
 * Bit position that can be cleared if corresponding bit of true has been
 * asserted.
 *
 * Values:
 * - 0b0 - Corresponding interrupt of true is masked.
 * - 0b1 - Corresponding bit of true is active.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_MASK_HW_ERR field. */
#define TRNG_RD_SA_TRNG_INT_MASK_HW_ERR(base) ((TRNG_SA_TRNG_INT_MASK_REG(base) & TRNG_SA_TRNG_INT_MASK_HW_ERR_MASK) >> TRNG_SA_TRNG_INT_MASK_HW_ERR_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_MASK_HW_ERR(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_MASK_REG(base), TRNG_SA_TRNG_INT_MASK_HW_ERR_SHIFT, TRNG_SA_TRNG_INT_MASK_HW_ERR_WIDTH))

/*! @brief Set the HW_ERR field to a new value. */
#define TRNG_WR_SA_TRNG_INT_MASK_HW_ERR(base, value) (TRNG_RMW_SA_TRNG_INT_MASK(base, TRNG_SA_TRNG_INT_MASK_HW_ERR_MASK, TRNG_SA_TRNG_INT_MASK_HW_ERR(value)))
#define TRNG_BWR_SA_TRNG_INT_MASK_HW_ERR(base, value) (BME_BFI32(&TRNG_SA_TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_INT_MASK_HW_ERR_SHIFT), TRNG_SA_TRNG_INT_MASK_HW_ERR_SHIFT, TRNG_SA_TRNG_INT_MASK_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_INT_MASK, field ENT_VAL[1] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_MASK_ENT_VAL field. */
#define TRNG_RD_SA_TRNG_INT_MASK_ENT_VAL(base) ((TRNG_SA_TRNG_INT_MASK_REG(base) & TRNG_SA_TRNG_INT_MASK_ENT_VAL_MASK) >> TRNG_SA_TRNG_INT_MASK_ENT_VAL_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_MASK_ENT_VAL(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_MASK_REG(base), TRNG_SA_TRNG_INT_MASK_ENT_VAL_SHIFT, TRNG_SA_TRNG_INT_MASK_ENT_VAL_WIDTH))

/*! @brief Set the ENT_VAL field to a new value. */
#define TRNG_WR_SA_TRNG_INT_MASK_ENT_VAL(base, value) (TRNG_RMW_SA_TRNG_INT_MASK(base, TRNG_SA_TRNG_INT_MASK_ENT_VAL_MASK, TRNG_SA_TRNG_INT_MASK_ENT_VAL(value)))
#define TRNG_BWR_SA_TRNG_INT_MASK_ENT_VAL(base, value) (BME_BFI32(&TRNG_SA_TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_INT_MASK_ENT_VAL_SHIFT), TRNG_SA_TRNG_INT_MASK_ENT_VAL_SHIFT, TRNG_SA_TRNG_INT_MASK_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_INT_MASK, field FRQ_CT_FAIL[2] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL field. */
#define TRNG_RD_SA_TRNG_INT_MASK_FRQ_CT_FAIL(base) ((TRNG_SA_TRNG_INT_MASK_REG(base) & TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_MASK) >> TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_MASK_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_MASK_REG(base), TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT, TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_SA_TRNG_INT_MASK_FRQ_CT_FAIL(base, value) (TRNG_RMW_SA_TRNG_INT_MASK(base, TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_MASK, TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL(value)))
#define TRNG_BWR_SA_TRNG_INT_MASK_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_SA_TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT), TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT, TRNG_SA_TRNG_INT_MASK_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SA_TRNG_INT_STATUS - RNG Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief TRNG_SA_TRNG_INT_STATUS - RNG Interrupt Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Interrupt Status Register is a read register used to control and
 * provide status for the (currently) three important interrupts that are generated
 * by the TRNG. The ipi_rng_int_b interrupt signals that RNG has either generated
 * a Frequency Count Fail, Entropy Valid or Error Interrupt. The cause of the
 * interrupt can be decoded by checking the least significant bits of the true
 * register. Each interrupt can be temporarily cleared by de-asserting the
 * corresponding bit in the true register. To mask the interrupts, clear the corresponding
 * bits in the true register. The description of each of the 3 interrupts is
 * defined in the Block Guide under the true register description. Even if the
 * interrupt is cleared or masked, interrupt status information can be read from the
 * true register.
 */
/*!
 * @name Constants and macros for entire TRNG_SA_TRNG_INT_STATUS register
 */
/*@{*/
#define TRNG_RD_SA_TRNG_INT_STATUS(base) (TRNG_SA_TRNG_INT_STATUS_REG(base))
#define TRNG_WR_SA_TRNG_INT_STATUS(base, value) (TRNG_SA_TRNG_INT_STATUS_REG(base) = (value))
#define TRNG_RMW_SA_TRNG_INT_STATUS(base, mask, value) (TRNG_WR_SA_TRNG_INT_STATUS(base, (TRNG_RD_SA_TRNG_INT_STATUS(base) & ~(mask)) | (value)))
#define TRNG_SET_SA_TRNG_INT_STATUS(base, value) (BME_OR32(&TRNG_SA_TRNG_INT_STATUS_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SA_TRNG_INT_STATUS(base, value) (BME_AND32(&TRNG_SA_TRNG_INT_STATUS_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SA_TRNG_INT_STATUS(base, value) (BME_XOR32(&TRNG_SA_TRNG_INT_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SA_TRNG_INT_STATUS bitfields
 */

/*!
 * @name Register TRNG_SA_TRNG_INT_STATUS, field HW_ERR[0] (RO)
 *
 * Read: Error status. 1 = error detected. 0 = no error. Any HW error in the
 * TRNG will trigger this interrupt.
 *
 * Values:
 * - 0b0 - no error
 * - 0b1 - error detected.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_STATUS_HW_ERR field. */
#define TRNG_RD_SA_TRNG_INT_STATUS_HW_ERR(base) ((TRNG_SA_TRNG_INT_STATUS_REG(base) & TRNG_SA_TRNG_INT_STATUS_HW_ERR_MASK) >> TRNG_SA_TRNG_INT_STATUS_HW_ERR_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_STATUS_HW_ERR(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_STATUS_REG(base), TRNG_SA_TRNG_INT_STATUS_HW_ERR_SHIFT, TRNG_SA_TRNG_INT_STATUS_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_INT_STATUS, field ENT_VAL[1] (RO)
 *
 * Read only: Entropy Valid. Will assert only if TRNG ACC bit is set, and then
 * after an entropy value is generated. Will be cleared when true15 is read.
 * (true0 through true14 should be read before reading true15).
 *
 * Values:
 * - 0b0 - Busy generation entropy. Any value read is invalid.
 * - 0b1 - TRNG can be stopped and entropy is valid if read.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_STATUS_ENT_VAL field. */
#define TRNG_RD_SA_TRNG_INT_STATUS_ENT_VAL(base) ((TRNG_SA_TRNG_INT_STATUS_REG(base) & TRNG_SA_TRNG_INT_STATUS_ENT_VAL_MASK) >> TRNG_SA_TRNG_INT_STATUS_ENT_VAL_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_STATUS_ENT_VAL(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_STATUS_REG(base), TRNG_SA_TRNG_INT_STATUS_ENT_VAL_SHIFT, TRNG_SA_TRNG_INT_STATUS_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_INT_STATUS, field FRQ_CT_FAIL[2] (RW)
 *
 * Read only: Frequency Count Fail. The frequency counter has detected a
 * failure. This may be due to improper programming of the true and/or true registers,
 * or a hardware failure in the ring oscillator.
 *
 * Values:
 * - 0b0 - No hardware nor self test frequency errors.
 * - 0b1 - The frequency counter has detected a failure.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL field. */
#define TRNG_RD_SA_TRNG_INT_STATUS_FRQ_CT_FAIL(base) ((TRNG_SA_TRNG_INT_STATUS_REG(base) & TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_MASK) >> TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_SA_TRNG_INT_STATUS_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_SA_TRNG_INT_STATUS_REG(base), TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT, TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_SA_TRNG_INT_STATUS_FRQ_CT_FAIL(base, value) (TRNG_RMW_SA_TRNG_INT_STATUS(base, TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_MASK, TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL(value)))
#define TRNG_BWR_SA_TRNG_INT_STATUS_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_SA_TRNG_INT_STATUS_REG(base), ((uint32_t)(value) << TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT), TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT, TRNG_SA_TRNG_INT_STATUS_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SA_TRNG_VID1 - RNG Version ID Register (MS)
 ******************************************************************************/

/*!
 * @brief TRNG_SA_TRNG_VID1 - RNG Version ID Register (MS) (RO)
 *
 * Reset value: 0x00300100U
 *
 * The RNG Version ID Register is a read only register used to identify the
 * version of the TRNG in use. This register as well as true should both be read to
 * verify the expected version.
 */
/*!
 * @name Constants and macros for entire TRNG_SA_TRNG_VID1 register
 */
/*@{*/
#define TRNG_RD_SA_TRNG_VID1(base) (TRNG_SA_TRNG_VID1_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SA_TRNG_VID1 bitfields
 */

/*!
 * @name Register TRNG_SA_TRNG_VID1, field RNG_MIN_REV[7:0] (RO)
 *
 * Shows the Freescale IP's Minor revision of the TRNG.
 *
 * Values:
 * - 0b00000000 - Minor revision number for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_VID1_RNG_MIN_REV field. */
#define TRNG_RD_SA_TRNG_VID1_RNG_MIN_REV(base) ((TRNG_SA_TRNG_VID1_REG(base) & TRNG_SA_TRNG_VID1_RNG_MIN_REV_MASK) >> TRNG_SA_TRNG_VID1_RNG_MIN_REV_SHIFT)
#define TRNG_BRD_SA_TRNG_VID1_RNG_MIN_REV(base) (BME_UBFX32(&TRNG_SA_TRNG_VID1_REG(base), TRNG_SA_TRNG_VID1_RNG_MIN_REV_SHIFT, TRNG_SA_TRNG_VID1_RNG_MIN_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_VID1, field RNG_MAJ_REV[15:8] (RO)
 *
 * Shows the Freescale IP's Major revision of the TRNG.
 *
 * Values:
 * - 0b00000001 - Major revision number for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_VID1_RNG_MAJ_REV field. */
#define TRNG_RD_SA_TRNG_VID1_RNG_MAJ_REV(base) ((TRNG_SA_TRNG_VID1_REG(base) & TRNG_SA_TRNG_VID1_RNG_MAJ_REV_MASK) >> TRNG_SA_TRNG_VID1_RNG_MAJ_REV_SHIFT)
#define TRNG_BRD_SA_TRNG_VID1_RNG_MAJ_REV(base) (BME_UBFX32(&TRNG_SA_TRNG_VID1_REG(base), TRNG_SA_TRNG_VID1_RNG_MAJ_REV_SHIFT, TRNG_SA_TRNG_VID1_RNG_MAJ_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_VID1, field RNG_IP_ID[31:16] (RO)
 *
 * Shows the Freescale IP ID.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_VID1_RNG_IP_ID field. */
#define TRNG_RD_SA_TRNG_VID1_RNG_IP_ID(base) ((TRNG_SA_TRNG_VID1_REG(base) & TRNG_SA_TRNG_VID1_RNG_IP_ID_MASK) >> TRNG_SA_TRNG_VID1_RNG_IP_ID_SHIFT)
#define TRNG_BRD_SA_TRNG_VID1_RNG_IP_ID(base) (TRNG_RD_SA_TRNG_VID1_RNG_IP_ID(base))
/*@}*/

/*******************************************************************************
 * TRNG_SA_TRNG_VID2 - RNG Version ID Register (LS)
 ******************************************************************************/

/*!
 * @brief TRNG_SA_TRNG_VID2 - RNG Version ID Register (LS) (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Version ID Register LSB is a read only register used to identify the
 * architecture of the TRNG in use. This register as well as true should both be
 * read to verify the expected version.
 */
/*!
 * @name Constants and macros for entire TRNG_SA_TRNG_VID2 register
 */
/*@{*/
#define TRNG_RD_SA_TRNG_VID2(base) (TRNG_SA_TRNG_VID2_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SA_TRNG_VID2 bitfields
 */

/*!
 * @name Register TRNG_SA_TRNG_VID2, field RNG_CONFIG_OPT[7:0] (RO)
 *
 * Shows the Freescale IP's Configuaration options for the TRNG.
 *
 * Values:
 * - 0b00000000 - TRNG_CONFIG_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_VID2_RNG_CONFIG_OPT field. */
#define TRNG_RD_SA_TRNG_VID2_RNG_CONFIG_OPT(base) ((TRNG_SA_TRNG_VID2_REG(base) & TRNG_SA_TRNG_VID2_RNG_CONFIG_OPT_MASK) >> TRNG_SA_TRNG_VID2_RNG_CONFIG_OPT_SHIFT)
#define TRNG_BRD_SA_TRNG_VID2_RNG_CONFIG_OPT(base) (BME_UBFX32(&TRNG_SA_TRNG_VID2_REG(base), TRNG_SA_TRNG_VID2_RNG_CONFIG_OPT_SHIFT, TRNG_SA_TRNG_VID2_RNG_CONFIG_OPT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_VID2, field RNG_ECO_REV[15:8] (RO)
 *
 * Shows the Freescale IP's ECO revision of the TRNG.
 *
 * Values:
 * - 0b00000000 - TRNG_ECO_REV for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_VID2_RNG_ECO_REV field. */
#define TRNG_RD_SA_TRNG_VID2_RNG_ECO_REV(base) ((TRNG_SA_TRNG_VID2_REG(base) & TRNG_SA_TRNG_VID2_RNG_ECO_REV_MASK) >> TRNG_SA_TRNG_VID2_RNG_ECO_REV_SHIFT)
#define TRNG_BRD_SA_TRNG_VID2_RNG_ECO_REV(base) (BME_UBFX32(&TRNG_SA_TRNG_VID2_REG(base), TRNG_SA_TRNG_VID2_RNG_ECO_REV_SHIFT, TRNG_SA_TRNG_VID2_RNG_ECO_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_VID2, field RNG_INTG_OPT[23:16] (RO)
 *
 * Shows the Freescale integration options for the TRNG.
 *
 * Values:
 * - 0b00000000 - INTG_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_VID2_RNG_INTG_OPT field. */
#define TRNG_RD_SA_TRNG_VID2_RNG_INTG_OPT(base) ((TRNG_SA_TRNG_VID2_REG(base) & TRNG_SA_TRNG_VID2_RNG_INTG_OPT_MASK) >> TRNG_SA_TRNG_VID2_RNG_INTG_OPT_SHIFT)
#define TRNG_BRD_SA_TRNG_VID2_RNG_INTG_OPT(base) (BME_UBFX32(&TRNG_SA_TRNG_VID2_REG(base), TRNG_SA_TRNG_VID2_RNG_INTG_OPT_SHIFT, TRNG_SA_TRNG_VID2_RNG_INTG_OPT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SA_TRNG_VID2, field RNG_ERA[31:24] (RO)
 *
 * Shows the Freescale compile options for the TRNG.
 *
 * Values:
 * - 0b00000000 - COMPILE_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SA_TRNG_VID2_RNG_ERA field. */
#define TRNG_RD_SA_TRNG_VID2_RNG_ERA(base) ((TRNG_SA_TRNG_VID2_REG(base) & TRNG_SA_TRNG_VID2_RNG_ERA_MASK) >> TRNG_SA_TRNG_VID2_RNG_ERA_SHIFT)
#define TRNG_BRD_SA_TRNG_VID2_RNG_ERA(base) (BME_UBFX32(&TRNG_SA_TRNG_VID2_REG(base), TRNG_SA_TRNG_VID2_RNG_ERA_SHIFT, TRNG_SA_TRNG_VID2_RNG_ERA_WIDTH))
/*@}*/

/*
 * MKL28Z7 TSI
 *
 * Touch sense input
 *
 * Registers defined in this header file:
 * - TSI_GENCS - TSI General Control and Status Register
 * - TSI_DATA - TSI DATA Register
 * - TSI_TSHD - TSI Threshold Register
 */

#define TSI_INSTANCE_COUNT (1U) /*!< Number of instances of the TSI module. */
#define TSI0_IDX (0U) /*!< Instance number for TSI0. */

/*******************************************************************************
 * TSI_GENCS - TSI General Control and Status Register
 ******************************************************************************/

/*!
 * @brief TSI_GENCS - TSI General Control and Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This control register provides various control and configuration information
 * for the TSI module. When TSI is working, the configuration bits (GENCS[TSIEN],
 * GENCS[TSIIEN], and GENCS[STM]) must not be changed. The EOSF flag is kept
 * until the software acknowledge it.
 */
/*!
 * @name Constants and macros for entire TSI_GENCS register
 */
/*@{*/
#define TSI_RD_GENCS(base)       (TSI_GENCS_REG(base))
#define TSI_WR_GENCS(base, value) (TSI_GENCS_REG(base) = (value))
#define TSI_RMW_GENCS(base, mask, value) (TSI_WR_GENCS(base, (TSI_RD_GENCS(base) & ~(mask)) | (value)))
#define TSI_SET_GENCS(base, value) (BME_OR32(&TSI_GENCS_REG(base), (uint32_t)(value)))
#define TSI_CLR_GENCS(base, value) (BME_AND32(&TSI_GENCS_REG(base), (uint32_t)(~(value))))
#define TSI_TOG_GENCS(base, value) (BME_XOR32(&TSI_GENCS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TSI_GENCS bitfields
 */

/*!
 * @name Register TSI_GENCS, field EOSDMEO[0] (RW)
 *
 * This bit makes simultaneous DMA request at End-of-Scan and Interrupt at
 * Out-of-Range possible. EOSDMEO has precedence to ESOR when trying to set this bit
 * and ESOR bit. When EOSDMEO = 1, End-of-Scan will generate DMA request and
 * Out-of-Range will generate interrupt.
 *
 * Values:
 * - 0b0 - Do not enable the End-of-Scan DMA transfer request only. Depending on
 *     ESOR state, either Out-of-Range or End-of-Scan can trigger a DMA transfer
 *     request and interrupt.
 * - 0b1 - Only the End-of-Scan event can trigger a DMA transfer request. The
 *     Out-of-Range event only and always triggers an interrupt if TSIIE is set.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_EOSDMEO field. */
#define TSI_RD_GENCS_EOSDMEO(base) ((TSI_GENCS_REG(base) & TSI_GENCS_EOSDMEO_MASK) >> TSI_GENCS_EOSDMEO_SHIFT)
#define TSI_BRD_GENCS_EOSDMEO(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_EOSDMEO_SHIFT, TSI_GENCS_EOSDMEO_WIDTH))

/*! @brief Set the EOSDMEO field to a new value. */
#define TSI_WR_GENCS_EOSDMEO(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_EOSDMEO_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_EOSDMEO(value)))
#define TSI_BWR_GENCS_EOSDMEO(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_EOSDMEO_SHIFT), TSI_GENCS_EOSDMEO_SHIFT, TSI_GENCS_EOSDMEO_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field CURSW[1] (RW)
 *
 * This bit specifies if the current sources of electrode oscillator and
 * reference oscillator are swapped.
 *
 * Values:
 * - 0b0 - The current source pair are not swapped.
 * - 0b1 - The current source pair are swapped.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_CURSW field. */
#define TSI_RD_GENCS_CURSW(base) ((TSI_GENCS_REG(base) & TSI_GENCS_CURSW_MASK) >> TSI_GENCS_CURSW_SHIFT)
#define TSI_BRD_GENCS_CURSW(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_CURSW_SHIFT, TSI_GENCS_CURSW_WIDTH))

/*! @brief Set the CURSW field to a new value. */
#define TSI_WR_GENCS_CURSW(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_CURSW_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_CURSW(value)))
#define TSI_BWR_GENCS_CURSW(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_CURSW_SHIFT), TSI_GENCS_CURSW_SHIFT, TSI_GENCS_CURSW_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field EOSF[2] (W1C)
 *
 * This flag is set when all active electrodes are finished scanning after a
 * scan trigger. Write "1" , when this flag is set, to clear it.
 *
 * Values:
 * - 0b0 - Scan not complete.
 * - 0b1 - Scan complete.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_EOSF field. */
#define TSI_RD_GENCS_EOSF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_EOSF_MASK) >> TSI_GENCS_EOSF_SHIFT)
#define TSI_BRD_GENCS_EOSF(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_EOSF_SHIFT, TSI_GENCS_EOSF_WIDTH))

/*! @brief Set the EOSF field to a new value. */
#define TSI_WR_GENCS_EOSF(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_EOSF(value)))
#define TSI_BWR_GENCS_EOSF(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_EOSF_SHIFT), TSI_GENCS_EOSF_SHIFT, TSI_GENCS_EOSF_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field SCNIP[3] (RO)
 *
 * This read-only bit indicates if scan is in progress. This bit will get
 * asserted after the analog bias circuit is stable after a trigger and it changes
 * automatically by the TSI.
 *
 * Values:
 * - 0b0 - No scan in progress.
 * - 0b1 - Scan in progress.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_SCNIP field. */
#define TSI_RD_GENCS_SCNIP(base) ((TSI_GENCS_REG(base) & TSI_GENCS_SCNIP_MASK) >> TSI_GENCS_SCNIP_SHIFT)
#define TSI_BRD_GENCS_SCNIP(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_SCNIP_SHIFT, TSI_GENCS_SCNIP_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field STM[4] (RW)
 *
 * This bit specifies the trigger mode. User is allowed to change this bit when
 * TSI is not working in progress.
 *
 * Values:
 * - 0b0 - Software trigger scan.
 * - 0b1 - Hardware trigger scan.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_STM field. */
#define TSI_RD_GENCS_STM(base) ((TSI_GENCS_REG(base) & TSI_GENCS_STM_MASK) >> TSI_GENCS_STM_SHIFT)
#define TSI_BRD_GENCS_STM(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_STM_SHIFT, TSI_GENCS_STM_WIDTH))

/*! @brief Set the STM field to a new value. */
#define TSI_WR_GENCS_STM(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_STM_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_STM(value)))
#define TSI_BWR_GENCS_STM(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_STM_SHIFT), TSI_GENCS_STM_SHIFT, TSI_GENCS_STM_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field STPE[5] (RW)
 *
 * This bit enables TSI module function in low power modes (stop, VLPS, LLS and
 * VLLS{3,2,1}).
 *
 * Values:
 * - 0b0 - TSI is disabled when MCU goes into low power mode.
 * - 0b1 - Allows TSI to continue running in all low power modes.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_STPE field. */
#define TSI_RD_GENCS_STPE(base) ((TSI_GENCS_REG(base) & TSI_GENCS_STPE_MASK) >> TSI_GENCS_STPE_SHIFT)
#define TSI_BRD_GENCS_STPE(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_STPE_SHIFT, TSI_GENCS_STPE_WIDTH))

/*! @brief Set the STPE field to a new value. */
#define TSI_WR_GENCS_STPE(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_STPE_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_STPE(value)))
#define TSI_BWR_GENCS_STPE(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_STPE_SHIFT), TSI_GENCS_STPE_SHIFT, TSI_GENCS_STPE_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field TSIIEN[6] (RW)
 *
 * This bit enables TSI module interrupt request to CPU when the scan completes.
 * The interrupt will wake MCU from low power mode if this interrupt is enabled.
 *
 * Values:
 * - 0b0 - TSI interrupt is disabled.
 * - 0b1 - TSI interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_TSIIEN field. */
#define TSI_RD_GENCS_TSIIEN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_TSIIEN_MASK) >> TSI_GENCS_TSIIEN_SHIFT)
#define TSI_BRD_GENCS_TSIIEN(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_TSIIEN_SHIFT, TSI_GENCS_TSIIEN_WIDTH))

/*! @brief Set the TSIIEN field to a new value. */
#define TSI_WR_GENCS_TSIIEN(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_TSIIEN_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_TSIIEN(value)))
#define TSI_BWR_GENCS_TSIIEN(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_TSIIEN_SHIFT), TSI_GENCS_TSIIEN_SHIFT, TSI_GENCS_TSIIEN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field TSIEN[7] (RW)
 *
 * This bit enables TSI module.
 *
 * Values:
 * - 0b0 - TSI module disabled.
 * - 0b1 - TSI module enabled.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_TSIEN field. */
#define TSI_RD_GENCS_TSIEN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_TSIEN_MASK) >> TSI_GENCS_TSIEN_SHIFT)
#define TSI_BRD_GENCS_TSIEN(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_TSIEN_SHIFT, TSI_GENCS_TSIEN_WIDTH))

/*! @brief Set the TSIEN field to a new value. */
#define TSI_WR_GENCS_TSIEN(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_TSIEN_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_TSIEN(value)))
#define TSI_BWR_GENCS_TSIEN(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_TSIEN_SHIFT), TSI_GENCS_TSIEN_SHIFT, TSI_GENCS_TSIEN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field NSCN[12:8] (RW)
 *
 * These bits indicate the scan number for each electrode. The scan number is
 * equal to NSCN + 1, which allows the scan time ranges from 1 to 32. By default,
 * NSCN is configured as 0, which asserts the TSI scans once on the selected
 * eletrode channel.
 *
 * Values:
 * - 0b00000 - Once per electrode
 * - 0b00001 - Twice per electrode
 * - 0b00010 - 3 times per electrode
 * - 0b00011 - 4 times per electrode
 * - 0b00100 - 5 times per electrode
 * - 0b00101 - 6 times per electrode
 * - 0b00110 - 7 times per electrode
 * - 0b00111 - 8 times per electrode
 * - 0b01000 - 9 times per electrode
 * - 0b01001 - 10 times per electrode
 * - 0b01010 - 11 times per electrode
 * - 0b01011 - 12 times per electrode
 * - 0b01100 - 13 times per electrode
 * - 0b01101 - 14 times per electrode
 * - 0b01110 - 15 times per electrode
 * - 0b01111 - 16 times per electrode
 * - 0b10000 - 17 times per electrode
 * - 0b10001 - 18 times per electrode
 * - 0b10010 - 19 times per electrode
 * - 0b10011 - 20 times per electrode
 * - 0b10100 - 21 times per electrode
 * - 0b10101 - 22 times per electrode
 * - 0b10110 - 23 times per electrode
 * - 0b10111 - 24 times per electrode
 * - 0b11000 - 25 times per electrode
 * - 0b11001 - 26 times per electrode
 * - 0b11010 - 27 times per electrode
 * - 0b11011 - 28 times per electrode
 * - 0b11100 - 29 times per electrode
 * - 0b11101 - 30 times per electrode
 * - 0b11110 - 31 times per electrode
 * - 0b11111 - 32 times per electrode
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_NSCN field. */
#define TSI_RD_GENCS_NSCN(base) ((TSI_GENCS_REG(base) & TSI_GENCS_NSCN_MASK) >> TSI_GENCS_NSCN_SHIFT)
#define TSI_BRD_GENCS_NSCN(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_NSCN_SHIFT, TSI_GENCS_NSCN_WIDTH))

/*! @brief Set the NSCN field to a new value. */
#define TSI_WR_GENCS_NSCN(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_NSCN_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_NSCN(value)))
#define TSI_BWR_GENCS_NSCN(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_NSCN_SHIFT), TSI_GENCS_NSCN_SHIFT, TSI_GENCS_NSCN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field PS[15:13] (RW)
 *
 * These bits indicate the prescaler of the output of electrode oscillator.
 *
 * Values:
 * - 0b000 - Electrode Oscillator Frequency divided by 1
 * - 0b001 - Electrode Oscillator Frequency divided by 2
 * - 0b010 - Electrode Oscillator Frequency divided by 4
 * - 0b011 - Electrode Oscillator Frequency divided by 8
 * - 0b100 - Electrode Oscillator Frequency divided by 16
 * - 0b101 - Electrode Oscillator Frequency divided by 32
 * - 0b110 - Electrode Oscillator Frequency divided by 64
 * - 0b111 - Electrode Oscillator Frequency divided by 128
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_PS field. */
#define TSI_RD_GENCS_PS(base) ((TSI_GENCS_REG(base) & TSI_GENCS_PS_MASK) >> TSI_GENCS_PS_SHIFT)
#define TSI_BRD_GENCS_PS(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_PS_SHIFT, TSI_GENCS_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define TSI_WR_GENCS_PS(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_PS_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_PS(value)))
#define TSI_BWR_GENCS_PS(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_PS_SHIFT), TSI_GENCS_PS_SHIFT, TSI_GENCS_PS_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field EXTCHRG[18:16] (RW)
 *
 * These bits indicate the electrode oscillator charge and discharge current
 * value.
 *
 * Values:
 * - 0b000 - 500 nA.
 * - 0b001 - 1 uA.
 * - 0b010 - 2 uA.
 * - 0b011 - 4 uA.
 * - 0b100 - 8 uA.
 * - 0b101 - 16 uA.
 * - 0b110 - 32 uA.
 * - 0b111 - 64 uA.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_EXTCHRG field. */
#define TSI_RD_GENCS_EXTCHRG(base) ((TSI_GENCS_REG(base) & TSI_GENCS_EXTCHRG_MASK) >> TSI_GENCS_EXTCHRG_SHIFT)
#define TSI_BRD_GENCS_EXTCHRG(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_EXTCHRG_SHIFT, TSI_GENCS_EXTCHRG_WIDTH))

/*! @brief Set the EXTCHRG field to a new value. */
#define TSI_WR_GENCS_EXTCHRG(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_EXTCHRG_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_EXTCHRG(value)))
#define TSI_BWR_GENCS_EXTCHRG(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_EXTCHRG_SHIFT), TSI_GENCS_EXTCHRG_SHIFT, TSI_GENCS_EXTCHRG_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field DVOLT[20:19] (RW)
 *
 * These bits indicate the oscillator's voltage rails as below.
 *
 * Values:
 * - 0b00 - DV = 1.026 V; VP = 1.328 V; Vm = 0.302 V.
 * - 0b01 - DV = 0.592 V; VP = 1.111 V; Vm = 0.519 V.
 * - 0b10 - DV = 0.342 V; VP = 0.986 V; Vm = 0.644 V.
 * - 0b11 - DV = 0.197 V; VP = 0.914 V; Vm = 0.716 V.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_DVOLT field. */
#define TSI_RD_GENCS_DVOLT(base) ((TSI_GENCS_REG(base) & TSI_GENCS_DVOLT_MASK) >> TSI_GENCS_DVOLT_SHIFT)
#define TSI_BRD_GENCS_DVOLT(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_DVOLT_SHIFT, TSI_GENCS_DVOLT_WIDTH))

/*! @brief Set the DVOLT field to a new value. */
#define TSI_WR_GENCS_DVOLT(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_DVOLT_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_DVOLT(value)))
#define TSI_BWR_GENCS_DVOLT(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_DVOLT_SHIFT), TSI_GENCS_DVOLT_SHIFT, TSI_GENCS_DVOLT_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field REFCHRG[23:21] (RW)
 *
 * These bits indicate the reference oscillator charge and discharge current
 * value.
 *
 * Values:
 * - 0b000 - 500 nA.
 * - 0b001 - 1 uA.
 * - 0b010 - 2 uA.
 * - 0b011 - 4 uA.
 * - 0b100 - 8 uA.
 * - 0b101 - 16 uA.
 * - 0b110 - 32 uA.
 * - 0b111 - 64 uA.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_REFCHRG field. */
#define TSI_RD_GENCS_REFCHRG(base) ((TSI_GENCS_REG(base) & TSI_GENCS_REFCHRG_MASK) >> TSI_GENCS_REFCHRG_SHIFT)
#define TSI_BRD_GENCS_REFCHRG(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_REFCHRG_SHIFT, TSI_GENCS_REFCHRG_WIDTH))

/*! @brief Set the REFCHRG field to a new value. */
#define TSI_WR_GENCS_REFCHRG(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_REFCHRG_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_REFCHRG(value)))
#define TSI_BWR_GENCS_REFCHRG(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_REFCHRG_SHIFT), TSI_GENCS_REFCHRG_SHIFT, TSI_GENCS_REFCHRG_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field MODE[27:24] (RW)
 *
 * Set up TSI analog modes, especially, setting MODE[3:2] to not 2'b00 will
 * configure TSI to noise detection modes. MODE[1:0] take no effect on TSI operation
 * mode and should always write to 2'b00 for setting up. When reading this field
 * will return the analog status. Refer to chapter "Noise detection mode" for
 * details.
 *
 * Values:
 * - 0b0000 - Set TSI in capacitive sensing(non-noise detection) mode.
 * - 0b0100 - Set TSI analog to work in single threshold noise detection mode
 *     and the frequency limitation circuit is disabled.
 * - 0b1000 - Set TSI analog to work in single threshold noise detection mode
 *     and the frequency limitation circuit is enabled to work in higher
 *     frequencies operations.
 * - 0b1100 - Set TSI analog to work in automatic noise detection mode.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_MODE field. */
#define TSI_RD_GENCS_MODE(base) ((TSI_GENCS_REG(base) & TSI_GENCS_MODE_MASK) >> TSI_GENCS_MODE_SHIFT)
#define TSI_BRD_GENCS_MODE(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_MODE_SHIFT, TSI_GENCS_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define TSI_WR_GENCS_MODE(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_MODE_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_MODE(value)))
#define TSI_BWR_GENCS_MODE(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_MODE_SHIFT), TSI_GENCS_MODE_SHIFT, TSI_GENCS_MODE_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field ESOR[28] (RW)
 *
 * This bit is used to select out-of-range or end-of-scan event to generate an
 * interrupt.
 *
 * Values:
 * - 0b0 - Out-of-range interrupt is allowed.
 * - 0b1 - End-of-scan interrupt is allowed.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_ESOR field. */
#define TSI_RD_GENCS_ESOR(base) ((TSI_GENCS_REG(base) & TSI_GENCS_ESOR_MASK) >> TSI_GENCS_ESOR_SHIFT)
#define TSI_BRD_GENCS_ESOR(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_ESOR_SHIFT, TSI_GENCS_ESOR_WIDTH))

/*! @brief Set the ESOR field to a new value. */
#define TSI_WR_GENCS_ESOR(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_ESOR_MASK | TSI_GENCS_EOSF_MASK | TSI_GENCS_OUTRGF_MASK), TSI_GENCS_ESOR(value)))
#define TSI_BWR_GENCS_ESOR(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_ESOR_SHIFT), TSI_GENCS_ESOR_SHIFT, TSI_GENCS_ESOR_WIDTH))
/*@}*/

/*!
 * @name Register TSI_GENCS, field OUTRGF[31] (W1C)
 *
 * This flag is set if the result register of the enabled electrode is out of
 * the range defined by the TSI_THRESHOLD register. This flag is set only when TSI
 * is configured in non-noise detection mode. It can be read once the CPU wakes.
 * Write "1" , when this flag is set, to clear it.
 */
/*@{*/
/*! @brief Read current value of the TSI_GENCS_OUTRGF field. */
#define TSI_RD_GENCS_OUTRGF(base) ((TSI_GENCS_REG(base) & TSI_GENCS_OUTRGF_MASK) >> TSI_GENCS_OUTRGF_SHIFT)
#define TSI_BRD_GENCS_OUTRGF(base) (BME_UBFX32(&TSI_GENCS_REG(base), TSI_GENCS_OUTRGF_SHIFT, TSI_GENCS_OUTRGF_WIDTH))

/*! @brief Set the OUTRGF field to a new value. */
#define TSI_WR_GENCS_OUTRGF(base, value) (TSI_RMW_GENCS(base, (TSI_GENCS_OUTRGF_MASK | TSI_GENCS_EOSF_MASK), TSI_GENCS_OUTRGF(value)))
#define TSI_BWR_GENCS_OUTRGF(base, value) (BME_BFI32(&TSI_GENCS_REG(base), ((uint32_t)(value) << TSI_GENCS_OUTRGF_SHIFT), TSI_GENCS_OUTRGF_SHIFT, TSI_GENCS_OUTRGF_WIDTH))
/*@}*/

/*******************************************************************************
 * TSI_DATA - TSI DATA Register
 ******************************************************************************/

/*!
 * @brief TSI_DATA - TSI DATA Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_DATA register
 */
/*@{*/
#define TSI_RD_DATA(base)        (TSI_DATA_REG(base))
#define TSI_WR_DATA(base, value) (TSI_DATA_REG(base) = (value))
#define TSI_RMW_DATA(base, mask, value) (TSI_WR_DATA(base, (TSI_RD_DATA(base) & ~(mask)) | (value)))
#define TSI_SET_DATA(base, value) (BME_OR32(&TSI_DATA_REG(base), (uint32_t)(value)))
#define TSI_CLR_DATA(base, value) (BME_AND32(&TSI_DATA_REG(base), (uint32_t)(~(value))))
#define TSI_TOG_DATA(base, value) (BME_XOR32(&TSI_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TSI_DATA bitfields
 */

/*!
 * @name Register TSI_DATA, field TSICNT[15:0] (RO)
 *
 * These read-only bits record the accumulated scan counter value ticked by the
 * reference oscillator.
 */
/*@{*/
/*! @brief Read current value of the TSI_DATA_TSICNT field. */
#define TSI_RD_DATA_TSICNT(base) ((TSI_DATA_REG(base) & TSI_DATA_TSICNT_MASK) >> TSI_DATA_TSICNT_SHIFT)
#define TSI_BRD_DATA_TSICNT(base) (TSI_RD_DATA_TSICNT(base))
/*@}*/

/*!
 * @name Register TSI_DATA, field SWTS[22] (WORZ)
 *
 * This write-only bit is a software start trigger. When STM bit is clear, write
 * "1" to this bit will start a scan. The electrode channel to be scanned is
 * determinated by TSI_DATA[TSICH] bits.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Start a scan to determine which channel is specified by
 *     TSI_DATA[TSICH].
 */
/*@{*/
/*! @brief Set the SWTS field to a new value. */
#define TSI_WR_DATA_SWTS(base, value) (TSI_RMW_DATA(base, TSI_DATA_SWTS_MASK, TSI_DATA_SWTS(value)))
#define TSI_BWR_DATA_SWTS(base, value) (BME_BFI32(&TSI_DATA_REG(base), ((uint32_t)(value) << TSI_DATA_SWTS_SHIFT), TSI_DATA_SWTS_SHIFT, TSI_DATA_SWTS_WIDTH))
/*@}*/

/*!
 * @name Register TSI_DATA, field DMAEN[23] (RW)
 *
 * This bit is used together with the TSI interrupt enable bits(TSIIE, ESOR) to
 * generate a DMA transfer request instead of an interrupt.
 *
 * Values:
 * - 0b0 - Interrupt is selected when the interrupt enable bit is set and the
 *     corresponding TSI events assert.
 * - 0b1 - DMA transfer request is selected when the interrupt enable bit is set
 *     and the corresponding TSI events assert.
 */
/*@{*/
/*! @brief Read current value of the TSI_DATA_DMAEN field. */
#define TSI_RD_DATA_DMAEN(base) ((TSI_DATA_REG(base) & TSI_DATA_DMAEN_MASK) >> TSI_DATA_DMAEN_SHIFT)
#define TSI_BRD_DATA_DMAEN(base) (BME_UBFX32(&TSI_DATA_REG(base), TSI_DATA_DMAEN_SHIFT, TSI_DATA_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define TSI_WR_DATA_DMAEN(base, value) (TSI_RMW_DATA(base, TSI_DATA_DMAEN_MASK, TSI_DATA_DMAEN(value)))
#define TSI_BWR_DATA_DMAEN(base, value) (BME_BFI32(&TSI_DATA_REG(base), ((uint32_t)(value) << TSI_DATA_DMAEN_SHIFT), TSI_DATA_DMAEN_SHIFT, TSI_DATA_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register TSI_DATA, field TSICH[31:28] (RW)
 *
 * These bits specify current channel to be measured. In hardware trigger mode
 * (TSI_GENCS[STM] = 1), the scan will not start until the hardware trigger
 * occurs. In software trigger mode (TSI_GENCS[STM] = 0), the scan starts immediately
 * when TSI_DATA[SWTS] bit is written by 1.
 *
 * Values:
 * - 0b0000 - Channel 0.
 * - 0b0001 - Channel 1.
 * - 0b0010 - Channel 2.
 * - 0b0011 - Channel 3.
 * - 0b0100 - Channel 4.
 * - 0b0101 - Channel 5.
 * - 0b0110 - Channel 6.
 * - 0b0111 - Channel 7.
 * - 0b1000 - Channel 8.
 * - 0b1001 - Channel 9.
 * - 0b1010 - Channel 10.
 * - 0b1011 - Channel 11.
 * - 0b1100 - Channel 12.
 * - 0b1101 - Channel 13.
 * - 0b1110 - Channel 14.
 * - 0b1111 - Channel 15.
 */
/*@{*/
/*! @brief Read current value of the TSI_DATA_TSICH field. */
#define TSI_RD_DATA_TSICH(base) ((TSI_DATA_REG(base) & TSI_DATA_TSICH_MASK) >> TSI_DATA_TSICH_SHIFT)
#define TSI_BRD_DATA_TSICH(base) (BME_UBFX32(&TSI_DATA_REG(base), TSI_DATA_TSICH_SHIFT, TSI_DATA_TSICH_WIDTH))

/*! @brief Set the TSICH field to a new value. */
#define TSI_WR_DATA_TSICH(base, value) (TSI_RMW_DATA(base, TSI_DATA_TSICH_MASK, TSI_DATA_TSICH(value)))
#define TSI_BWR_DATA_TSICH(base, value) (BME_BFI32(&TSI_DATA_REG(base), ((uint32_t)(value) << TSI_DATA_TSICH_SHIFT), TSI_DATA_TSICH_SHIFT, TSI_DATA_TSICH_WIDTH))
/*@}*/

/*******************************************************************************
 * TSI_TSHD - TSI Threshold Register
 ******************************************************************************/

/*!
 * @brief TSI_TSHD - TSI Threshold Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TSI_TSHD register
 */
/*@{*/
#define TSI_RD_TSHD(base)        (TSI_TSHD_REG(base))
#define TSI_WR_TSHD(base, value) (TSI_TSHD_REG(base) = (value))
#define TSI_RMW_TSHD(base, mask, value) (TSI_WR_TSHD(base, (TSI_RD_TSHD(base) & ~(mask)) | (value)))
#define TSI_SET_TSHD(base, value) (BME_OR32(&TSI_TSHD_REG(base), (uint32_t)(value)))
#define TSI_CLR_TSHD(base, value) (BME_AND32(&TSI_TSHD_REG(base), (uint32_t)(~(value))))
#define TSI_TOG_TSHD(base, value) (BME_XOR32(&TSI_TSHD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TSI_TSHD bitfields
 */

/*!
 * @name Register TSI_TSHD, field THRESL[15:0] (RW)
 *
 * This half-word specifies the low threshold of the wakeup channel.
 */
/*@{*/
/*! @brief Read current value of the TSI_TSHD_THRESL field. */
#define TSI_RD_TSHD_THRESL(base) ((TSI_TSHD_REG(base) & TSI_TSHD_THRESL_MASK) >> TSI_TSHD_THRESL_SHIFT)
#define TSI_BRD_TSHD_THRESL(base) (TSI_RD_TSHD_THRESL(base))

/*! @brief Set the THRESL field to a new value. */
#define TSI_WR_TSHD_THRESL(base, value) (TSI_RMW_TSHD(base, TSI_TSHD_THRESL_MASK, TSI_TSHD_THRESL(value)))
#define TSI_BWR_TSHD_THRESL(base, value) (TSI_WR_TSHD_THRESL(base, value))
/*@}*/

/*!
 * @name Register TSI_TSHD, field THRESH[31:16] (RW)
 *
 * This half-word specifies the high threshold of the wakeup channel.
 */
/*@{*/
/*! @brief Read current value of the TSI_TSHD_THRESH field. */
#define TSI_RD_TSHD_THRESH(base) ((TSI_TSHD_REG(base) & TSI_TSHD_THRESH_MASK) >> TSI_TSHD_THRESH_SHIFT)
#define TSI_BRD_TSHD_THRESH(base) (TSI_RD_TSHD_THRESH(base))

/*! @brief Set the THRESH field to a new value. */
#define TSI_WR_TSHD_THRESH(base, value) (TSI_RMW_TSHD(base, TSI_TSHD_THRESH_MASK, TSI_TSHD_THRESH(value)))
#define TSI_BWR_TSHD_THRESH(base, value) (TSI_WR_TSHD_THRESH(base, value))
/*@}*/

/*
 * MKL28Z7 TSTMR
 *
 * Timestamp Timer
 *
 * Registers defined in this header file:
 * - TSTMR_L - Time Stamp Timer Register Low
 * - TSTMR_H - Time Stamp Timer Register High
 */

#define TSTMR_INSTANCE_COUNT (2U) /*!< Number of instances of the TSTMR module. */
#define TSTMR0_IDX (0U) /*!< Instance number for TSTMR0. */
#define TSTMR1_IDX (1U) /*!< Instance number for TSTMR1. */

/*******************************************************************************
 * TSTMR_L - Time Stamp Timer Register Low
 ******************************************************************************/

/*!
 * @brief TSTMR_L - Time Stamp Timer Register Low (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Time Stamp Timer is a 56-bit clock cycle counter, reset by system reset.
 * It is readable by way of the TSTMRH and TSTMRL registers. Only 32-bit read
 * accesses are allowed. Any other access will generate a transfer error.
 */
/*!
 * @name Constants and macros for entire TSTMR_L register
 */
/*@{*/
#define TSTMR_RD_L(base)         (TSTMR_L_REG(base))
/*@}*/

/*******************************************************************************
 * TSTMR_H - Time Stamp Timer Register High
 ******************************************************************************/

/*!
 * @brief TSTMR_H - Time Stamp Timer Register High (RO)
 *
 * Reset value: 0x00000000U
 *
 * The Time Stamp Timer is a 56-bit clock cycle counter, reset by system reset.
 * It is readable by way of the TSTMR_H and TSTMR_L registers. Only 32-bit read
 * accesses are allowed. Any other access will generate a transfer error.
 */
/*!
 * @name Constants and macros for entire TSTMR_H register
 */
/*@{*/
#define TSTMR_RD_H(base)         (TSTMR_H_REG(base))
/*@}*/

/*
 * Constants & macros for individual TSTMR_H bitfields
 */

/*!
 * @name Register TSTMR_H, field VALUE[23:0] (RO)
 *
 * Upper 24 bits of the 56-bit time stamp value.. The software must read the
 * TSTMR_L first, followed by a read to TSTMR_H to retrieve the complete value. The
 * all-zero reset value may not be readable because the value will increment
 * before it can be read by the software.
 */
/*@{*/
/*! @brief Read current value of the TSTMR_H_VALUE field. */
#define TSTMR_RD_H_VALUE(base) ((TSTMR_H_REG(base) & TSTMR_H_VALUE_MASK) >> TSTMR_H_VALUE_SHIFT)
#define TSTMR_BRD_H_VALUE(base) (TSTMR_RD_H_VALUE(base))
/*@}*/

/*
 * MKL28Z7 USB
 *
 * Universal Serial Bus, OTG Capable Controller
 *
 * Registers defined in this header file:
 * - USB_PERID - Peripheral ID register
 * - USB_IDCOMP - Peripheral ID Complement register
 * - USB_REV - Peripheral Revision register
 * - USB_ADDINFO - Peripheral Additional Info register
 * - USB_OTGISTAT - OTG Interrupt Status register
 * - USB_OTGICR - OTG Interrupt Control register
 * - USB_OTGSTAT - OTG Status register
 * - USB_OTGCTL - OTG Control register
 * - USB_ISTAT - Interrupt Status register
 * - USB_INTEN - Interrupt Enable register
 * - USB_ERRSTAT - Error Interrupt Status register
 * - USB_ERREN - Error Interrupt Enable register
 * - USB_STAT - Status register
 * - USB_CTL - Control register
 * - USB_ADDR - Address register
 * - USB_BDTPAGE1 - BDT Page register 1
 * - USB_FRMNUML - Frame Number register Low
 * - USB_FRMNUMH - Frame Number register High
 * - USB_TOKEN - Token register
 * - USB_SOFTHLD - SOF Threshold register
 * - USB_BDTPAGE2 - BDT Page Register 2
 * - USB_BDTPAGE3 - BDT Page Register 3
 * - USB_ENDPT - Endpoint Control register
 * - USB_USBCTRL - USB Control register
 * - USB_OBSERVE - USB OTG Observe register
 * - USB_CONTROL - USB OTG Control register
 * - USB_USBTRC0 - USB Transceiver Control register 0
 * - USB_USBFRMADJUST - Frame Adjust Register
 * - USB_KEEP_ALIVE_CTRL - Keep Alive mode control
 * - USB_KEEP_ALIVE_WKCTRL - Keep Alive mode wakeup control
 * - USB_MISCCTRL - Miscellaneous Control register
 * - USB_CLK_RECOVER_CTRL - USB Clock recovery control
 * - USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 * - USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 * - USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 */

#define USB_INSTANCE_COUNT (1U) /*!< Number of instances of the USB module. */
#define USB0_IDX (0U) /*!< Instance number for USB0. */

/*******************************************************************************
 * USB_PERID - Peripheral ID register
 ******************************************************************************/

/*!
 * @brief USB_PERID - Peripheral ID register (RO)
 *
 * Reset value: 0x04U
 *
 * Reads back the value of 0x04. This value is defined for the USB peripheral.
 */
/*!
 * @name Constants and macros for entire USB_PERID register
 */
/*@{*/
#define USB_RD_PERID(base)       (USB_PERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_PERID bitfields
 */

/*!
 * @name Register USB_PERID, field ID[5:0] (RO)
 *
 * This field always reads 0x4h.
 */
/*@{*/
/*! @brief Read current value of the USB_PERID_ID field. */
#define USB_RD_PERID_ID(base) ((USB_PERID_REG(base) & USB_PERID_ID_MASK) >> USB_PERID_ID_SHIFT)
#define USB_BRD_PERID_ID(base) (BME_UBFX8(&USB_PERID_REG(base), USB_PERID_ID_SHIFT, USB_PERID_ID_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_IDCOMP - Peripheral ID Complement register
 ******************************************************************************/

/*!
 * @brief USB_IDCOMP - Peripheral ID Complement register (RO)
 *
 * Reset value: 0xFBU
 *
 * Reads back the complement of the Peripheral ID register. For the USB
 * peripheral, the value is 0xFB.
 */
/*!
 * @name Constants and macros for entire USB_IDCOMP register
 */
/*@{*/
#define USB_RD_IDCOMP(base)      (USB_IDCOMP_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_IDCOMP bitfields
 */

/*!
 * @name Register USB_IDCOMP, field NID[5:0] (RO)
 *
 * Ones' complement of PERID[ID]. bits.
 */
/*@{*/
/*! @brief Read current value of the USB_IDCOMP_NID field. */
#define USB_RD_IDCOMP_NID(base) ((USB_IDCOMP_REG(base) & USB_IDCOMP_NID_MASK) >> USB_IDCOMP_NID_SHIFT)
#define USB_BRD_IDCOMP_NID(base) (BME_UBFX8(&USB_IDCOMP_REG(base), USB_IDCOMP_NID_SHIFT, USB_IDCOMP_NID_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_REV - Peripheral Revision register
 ******************************************************************************/

/*!
 * @brief USB_REV - Peripheral Revision register (RO)
 *
 * Reset value: 0x33U
 *
 * Contains the revision number of the USB module.
 */
/*!
 * @name Constants and macros for entire USB_REV register
 */
/*@{*/
#define USB_RD_REV(base)         (USB_REV_REG(base))
/*@}*/

/*******************************************************************************
 * USB_ADDINFO - Peripheral Additional Info register
 ******************************************************************************/

/*!
 * @brief USB_ADDINFO - Peripheral Additional Info register (RO)
 *
 * Reset value: 0x01U
 *
 * Reads back the value of the Host Enable bit.
 */
/*!
 * @name Constants and macros for entire USB_ADDINFO register
 */
/*@{*/
#define USB_RD_ADDINFO(base)     (USB_ADDINFO_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_ADDINFO bitfields
 */

/*!
 * @name Register USB_ADDINFO, field IEHOST[0] (RO)
 *
 * This bit is set if host mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDINFO_IEHOST field. */
#define USB_RD_ADDINFO_IEHOST(base) ((USB_ADDINFO_REG(base) & USB_ADDINFO_IEHOST_MASK) >> USB_ADDINFO_IEHOST_SHIFT)
#define USB_BRD_ADDINFO_IEHOST(base) (BME_UBFX8(&USB_ADDINFO_REG(base), USB_ADDINFO_IEHOST_SHIFT, USB_ADDINFO_IEHOST_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_OTGISTAT - OTG Interrupt Status register
 ******************************************************************************/

/*!
 * @brief USB_OTGISTAT - OTG Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Records changes of the ID sense and VBUS signals. Software can read this
 * register to determine the event that triggers an interrupt. Only bits that have
 * changed since the last software read are set. Writing a one to a bit clears the
 * associated interrupt.
 */
/*!
 * @name Constants and macros for entire USB_OTGISTAT register
 */
/*@{*/
#define USB_RD_OTGISTAT(base)    (USB_OTGISTAT_REG(base))
#define USB_WR_OTGISTAT(base, value) (USB_OTGISTAT_REG(base) = (value))
#define USB_RMW_OTGISTAT(base, mask, value) (USB_WR_OTGISTAT(base, (USB_RD_OTGISTAT(base) & ~(mask)) | (value)))
#define USB_SET_OTGISTAT(base, value) (BME_OR8(&USB_OTGISTAT_REG(base), (uint8_t)(value)))
#define USB_CLR_OTGISTAT(base, value) (BME_AND8(&USB_OTGISTAT_REG(base), (uint8_t)(~(value))))
#define USB_TOG_OTGISTAT(base, value) (BME_XOR8(&USB_OTGISTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGISTAT bitfields
 */

/*!
 * @name Register USB_OTGISTAT, field AVBUSCHG[0] (RW)
 *
 * This bit is set when a change in VBUS is detected on an A device.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_AVBUSCHG field. */
#define USB_RD_OTGISTAT_AVBUSCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_AVBUSCHG_MASK) >> USB_OTGISTAT_AVBUSCHG_SHIFT)
#define USB_BRD_OTGISTAT_AVBUSCHG(base) (BME_UBFX8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_AVBUSCHG_SHIFT, USB_OTGISTAT_AVBUSCHG_WIDTH))

/*! @brief Set the AVBUSCHG field to a new value. */
#define USB_WR_OTGISTAT_AVBUSCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_AVBUSCHG_MASK, USB_OTGISTAT_AVBUSCHG(value)))
#define USB_BWR_OTGISTAT_AVBUSCHG(base, value) (BME_BFI8(&USB_OTGISTAT_REG(base), ((uint8_t)(value) << USB_OTGISTAT_AVBUSCHG_SHIFT), USB_OTGISTAT_AVBUSCHG_SHIFT, USB_OTGISTAT_AVBUSCHG_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field B_SESS_CHG[2] (RW)
 *
 * This bit is set when a change in VBUS is detected on a B device.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_B_SESS_CHG field. */
#define USB_RD_OTGISTAT_B_SESS_CHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_B_SESS_CHG_MASK) >> USB_OTGISTAT_B_SESS_CHG_SHIFT)
#define USB_BRD_OTGISTAT_B_SESS_CHG(base) (BME_UBFX8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_B_SESS_CHG_SHIFT, USB_OTGISTAT_B_SESS_CHG_WIDTH))

/*! @brief Set the B_SESS_CHG field to a new value. */
#define USB_WR_OTGISTAT_B_SESS_CHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_B_SESS_CHG_MASK, USB_OTGISTAT_B_SESS_CHG(value)))
#define USB_BWR_OTGISTAT_B_SESS_CHG(base, value) (BME_BFI8(&USB_OTGISTAT_REG(base), ((uint8_t)(value) << USB_OTGISTAT_B_SESS_CHG_SHIFT), USB_OTGISTAT_B_SESS_CHG_SHIFT, USB_OTGISTAT_B_SESS_CHG_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field SESSVLDCHG[3] (RW)
 *
 * This bit is set when a change in VBUS is detected indicating a session valid
 * or a session no longer valid.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_SESSVLDCHG field. */
#define USB_RD_OTGISTAT_SESSVLDCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_SESSVLDCHG_MASK) >> USB_OTGISTAT_SESSVLDCHG_SHIFT)
#define USB_BRD_OTGISTAT_SESSVLDCHG(base) (BME_UBFX8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_SESSVLDCHG_SHIFT, USB_OTGISTAT_SESSVLDCHG_WIDTH))

/*! @brief Set the SESSVLDCHG field to a new value. */
#define USB_WR_OTGISTAT_SESSVLDCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_SESSVLDCHG_MASK, USB_OTGISTAT_SESSVLDCHG(value)))
#define USB_BWR_OTGISTAT_SESSVLDCHG(base, value) (BME_BFI8(&USB_OTGISTAT_REG(base), ((uint8_t)(value) << USB_OTGISTAT_SESSVLDCHG_SHIFT), USB_OTGISTAT_SESSVLDCHG_SHIFT, USB_OTGISTAT_SESSVLDCHG_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field LINE_STATE_CHG[5] (RW)
 *
 * This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits)
 * are stable without change for 1 millisecond, and the value of the line state
 * is different from the last time when the line state was stable. It is set on
 * transitions between SE0 and J-state, SE0 and K-state, and J-state and K-state.
 * Changes in J-state while SE0 is true do not cause an interrupt. This interrupt
 * can be used in detecting Reset, Resume, Connect, and Data Line Pulse
 * signaling.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_LINE_STATE_CHG field. */
#define USB_RD_OTGISTAT_LINE_STATE_CHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_LINE_STATE_CHG_MASK) >> USB_OTGISTAT_LINE_STATE_CHG_SHIFT)
#define USB_BRD_OTGISTAT_LINE_STATE_CHG(base) (BME_UBFX8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_LINE_STATE_CHG_SHIFT, USB_OTGISTAT_LINE_STATE_CHG_WIDTH))

/*! @brief Set the LINE_STATE_CHG field to a new value. */
#define USB_WR_OTGISTAT_LINE_STATE_CHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_LINE_STATE_CHG_MASK, USB_OTGISTAT_LINE_STATE_CHG(value)))
#define USB_BWR_OTGISTAT_LINE_STATE_CHG(base, value) (BME_BFI8(&USB_OTGISTAT_REG(base), ((uint8_t)(value) << USB_OTGISTAT_LINE_STATE_CHG_SHIFT), USB_OTGISTAT_LINE_STATE_CHG_SHIFT, USB_OTGISTAT_LINE_STATE_CHG_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field ONEMSEC[6] (RW)
 *
 * This bit is set when the 1 millisecond timer expires. This bit stays asserted
 * until cleared by software. The interrupt must be serviced every millisecond
 * to avoid losing 1msec counts.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_ONEMSEC field. */
#define USB_RD_OTGISTAT_ONEMSEC(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_ONEMSEC_MASK) >> USB_OTGISTAT_ONEMSEC_SHIFT)
#define USB_BRD_OTGISTAT_ONEMSEC(base) (BME_UBFX8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_ONEMSEC_SHIFT, USB_OTGISTAT_ONEMSEC_WIDTH))

/*! @brief Set the ONEMSEC field to a new value. */
#define USB_WR_OTGISTAT_ONEMSEC(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_ONEMSEC_MASK, USB_OTGISTAT_ONEMSEC(value)))
#define USB_BWR_OTGISTAT_ONEMSEC(base, value) (BME_BFI8(&USB_OTGISTAT_REG(base), ((uint8_t)(value) << USB_OTGISTAT_ONEMSEC_SHIFT), USB_OTGISTAT_ONEMSEC_SHIFT, USB_OTGISTAT_ONEMSEC_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field IDCHG[7] (RW)
 *
 * This bit is set when a change in the ID Signal from the USB connector is
 * sensed.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_IDCHG field. */
#define USB_RD_OTGISTAT_IDCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_IDCHG_MASK) >> USB_OTGISTAT_IDCHG_SHIFT)
#define USB_BRD_OTGISTAT_IDCHG(base) (BME_UBFX8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_IDCHG_SHIFT, USB_OTGISTAT_IDCHG_WIDTH))

/*! @brief Set the IDCHG field to a new value. */
#define USB_WR_OTGISTAT_IDCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_IDCHG_MASK, USB_OTGISTAT_IDCHG(value)))
#define USB_BWR_OTGISTAT_IDCHG(base, value) (BME_BFI8(&USB_OTGISTAT_REG(base), ((uint8_t)(value) << USB_OTGISTAT_IDCHG_SHIFT), USB_OTGISTAT_IDCHG_SHIFT, USB_OTGISTAT_IDCHG_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_OTGICR - OTG Interrupt Control register
 ******************************************************************************/

/*!
 * @brief USB_OTGICR - OTG Interrupt Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Enables the corresponding interrupt status bits defined in the OTG Interrupt
 * Status Register.
 */
/*!
 * @name Constants and macros for entire USB_OTGICR register
 */
/*@{*/
#define USB_RD_OTGICR(base)      (USB_OTGICR_REG(base))
#define USB_WR_OTGICR(base, value) (USB_OTGICR_REG(base) = (value))
#define USB_RMW_OTGICR(base, mask, value) (USB_WR_OTGICR(base, (USB_RD_OTGICR(base) & ~(mask)) | (value)))
#define USB_SET_OTGICR(base, value) (BME_OR8(&USB_OTGICR_REG(base), (uint8_t)(value)))
#define USB_CLR_OTGICR(base, value) (BME_AND8(&USB_OTGICR_REG(base), (uint8_t)(~(value))))
#define USB_TOG_OTGICR(base, value) (BME_XOR8(&USB_OTGICR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGICR bitfields
 */

/*!
 * @name Register USB_OTGICR, field AVBUSEN[0] (RW)
 *
 * Values:
 * - 0b0 - Disables the AVBUSCHG interrupt.
 * - 0b1 - Enables the AVBUSCHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_AVBUSEN field. */
#define USB_RD_OTGICR_AVBUSEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_AVBUSEN_MASK) >> USB_OTGICR_AVBUSEN_SHIFT)
#define USB_BRD_OTGICR_AVBUSEN(base) (BME_UBFX8(&USB_OTGICR_REG(base), USB_OTGICR_AVBUSEN_SHIFT, USB_OTGICR_AVBUSEN_WIDTH))

/*! @brief Set the AVBUSEN field to a new value. */
#define USB_WR_OTGICR_AVBUSEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_AVBUSEN_MASK, USB_OTGICR_AVBUSEN(value)))
#define USB_BWR_OTGICR_AVBUSEN(base, value) (BME_BFI8(&USB_OTGICR_REG(base), ((uint8_t)(value) << USB_OTGICR_AVBUSEN_SHIFT), USB_OTGICR_AVBUSEN_SHIFT, USB_OTGICR_AVBUSEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGICR, field BSESSEN[2] (RW)
 *
 * Values:
 * - 0b0 - Disables the B_SESS_CHG interrupt.
 * - 0b1 - Enables the B_SESS_CHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_BSESSEN field. */
#define USB_RD_OTGICR_BSESSEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_BSESSEN_MASK) >> USB_OTGICR_BSESSEN_SHIFT)
#define USB_BRD_OTGICR_BSESSEN(base) (BME_UBFX8(&USB_OTGICR_REG(base), USB_OTGICR_BSESSEN_SHIFT, USB_OTGICR_BSESSEN_WIDTH))

/*! @brief Set the BSESSEN field to a new value. */
#define USB_WR_OTGICR_BSESSEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_BSESSEN_MASK, USB_OTGICR_BSESSEN(value)))
#define USB_BWR_OTGICR_BSESSEN(base, value) (BME_BFI8(&USB_OTGICR_REG(base), ((uint8_t)(value) << USB_OTGICR_BSESSEN_SHIFT), USB_OTGICR_BSESSEN_SHIFT, USB_OTGICR_BSESSEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGICR, field SESSVLDEN[3] (RW)
 *
 * Values:
 * - 0b0 - Disables the SESSVLDCHG interrupt.
 * - 0b1 - Enables the SESSVLDCHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_SESSVLDEN field. */
#define USB_RD_OTGICR_SESSVLDEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_SESSVLDEN_MASK) >> USB_OTGICR_SESSVLDEN_SHIFT)
#define USB_BRD_OTGICR_SESSVLDEN(base) (BME_UBFX8(&USB_OTGICR_REG(base), USB_OTGICR_SESSVLDEN_SHIFT, USB_OTGICR_SESSVLDEN_WIDTH))

/*! @brief Set the SESSVLDEN field to a new value. */
#define USB_WR_OTGICR_SESSVLDEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_SESSVLDEN_MASK, USB_OTGICR_SESSVLDEN(value)))
#define USB_BWR_OTGICR_SESSVLDEN(base, value) (BME_BFI8(&USB_OTGICR_REG(base), ((uint8_t)(value) << USB_OTGICR_SESSVLDEN_SHIFT), USB_OTGICR_SESSVLDEN_SHIFT, USB_OTGICR_SESSVLDEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGICR, field LINESTATEEN[5] (RW)
 *
 * Values:
 * - 0b0 - Disables the LINE_STAT_CHG interrupt.
 * - 0b1 - Enables the LINE_STAT_CHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_LINESTATEEN field. */
#define USB_RD_OTGICR_LINESTATEEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_LINESTATEEN_MASK) >> USB_OTGICR_LINESTATEEN_SHIFT)
#define USB_BRD_OTGICR_LINESTATEEN(base) (BME_UBFX8(&USB_OTGICR_REG(base), USB_OTGICR_LINESTATEEN_SHIFT, USB_OTGICR_LINESTATEEN_WIDTH))

/*! @brief Set the LINESTATEEN field to a new value. */
#define USB_WR_OTGICR_LINESTATEEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_LINESTATEEN_MASK, USB_OTGICR_LINESTATEEN(value)))
#define USB_BWR_OTGICR_LINESTATEEN(base, value) (BME_BFI8(&USB_OTGICR_REG(base), ((uint8_t)(value) << USB_OTGICR_LINESTATEEN_SHIFT), USB_OTGICR_LINESTATEEN_SHIFT, USB_OTGICR_LINESTATEEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGICR, field ONEMSECEN[6] (RW)
 *
 * Values:
 * - 0b0 - Diables the 1ms timer interrupt.
 * - 0b1 - Enables the 1ms timer interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_ONEMSECEN field. */
#define USB_RD_OTGICR_ONEMSECEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_ONEMSECEN_MASK) >> USB_OTGICR_ONEMSECEN_SHIFT)
#define USB_BRD_OTGICR_ONEMSECEN(base) (BME_UBFX8(&USB_OTGICR_REG(base), USB_OTGICR_ONEMSECEN_SHIFT, USB_OTGICR_ONEMSECEN_WIDTH))

/*! @brief Set the ONEMSECEN field to a new value. */
#define USB_WR_OTGICR_ONEMSECEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_ONEMSECEN_MASK, USB_OTGICR_ONEMSECEN(value)))
#define USB_BWR_OTGICR_ONEMSECEN(base, value) (BME_BFI8(&USB_OTGICR_REG(base), ((uint8_t)(value) << USB_OTGICR_ONEMSECEN_SHIFT), USB_OTGICR_ONEMSECEN_SHIFT, USB_OTGICR_ONEMSECEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGICR, field IDEN[7] (RW)
 *
 * Values:
 * - 0b0 - The ID interrupt is disabled
 * - 0b1 - The ID interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_IDEN field. */
#define USB_RD_OTGICR_IDEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_IDEN_MASK) >> USB_OTGICR_IDEN_SHIFT)
#define USB_BRD_OTGICR_IDEN(base) (BME_UBFX8(&USB_OTGICR_REG(base), USB_OTGICR_IDEN_SHIFT, USB_OTGICR_IDEN_WIDTH))

/*! @brief Set the IDEN field to a new value. */
#define USB_WR_OTGICR_IDEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_IDEN_MASK, USB_OTGICR_IDEN(value)))
#define USB_BWR_OTGICR_IDEN(base, value) (BME_BFI8(&USB_OTGICR_REG(base), ((uint8_t)(value) << USB_OTGICR_IDEN_SHIFT), USB_OTGICR_IDEN_SHIFT, USB_OTGICR_IDEN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_OTGSTAT - OTG Status register
 ******************************************************************************/

/*!
 * @brief USB_OTGSTAT - OTG Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Displays the actual value from the external comparator outputs of the ID pin
 * and VBUS.
 */
/*!
 * @name Constants and macros for entire USB_OTGSTAT register
 */
/*@{*/
#define USB_RD_OTGSTAT(base)     (USB_OTGSTAT_REG(base))
#define USB_WR_OTGSTAT(base, value) (USB_OTGSTAT_REG(base) = (value))
#define USB_RMW_OTGSTAT(base, mask, value) (USB_WR_OTGSTAT(base, (USB_RD_OTGSTAT(base) & ~(mask)) | (value)))
#define USB_SET_OTGSTAT(base, value) (BME_OR8(&USB_OTGSTAT_REG(base), (uint8_t)(value)))
#define USB_CLR_OTGSTAT(base, value) (BME_AND8(&USB_OTGSTAT_REG(base), (uint8_t)(~(value))))
#define USB_TOG_OTGSTAT(base, value) (BME_XOR8(&USB_OTGSTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGSTAT bitfields
 */

/*!
 * @name Register USB_OTGSTAT, field AVBUSVLD[0] (RW)
 *
 * Values:
 * - 0b0 - The VBUS voltage is below the A VBUS Valid threshold.
 * - 0b1 - The VBUS voltage is above the A VBUS Valid threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_AVBUSVLD field. */
#define USB_RD_OTGSTAT_AVBUSVLD(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_AVBUSVLD_MASK) >> USB_OTGSTAT_AVBUSVLD_SHIFT)
#define USB_BRD_OTGSTAT_AVBUSVLD(base) (BME_UBFX8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_AVBUSVLD_SHIFT, USB_OTGSTAT_AVBUSVLD_WIDTH))

/*! @brief Set the AVBUSVLD field to a new value. */
#define USB_WR_OTGSTAT_AVBUSVLD(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_AVBUSVLD_MASK, USB_OTGSTAT_AVBUSVLD(value)))
#define USB_BWR_OTGSTAT_AVBUSVLD(base, value) (BME_BFI8(&USB_OTGSTAT_REG(base), ((uint8_t)(value) << USB_OTGSTAT_AVBUSVLD_SHIFT), USB_OTGSTAT_AVBUSVLD_SHIFT, USB_OTGSTAT_AVBUSVLD_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field BSESSEND[2] (RW)
 *
 * Values:
 * - 0b0 - The VBUS voltage is above the B session end threshold.
 * - 0b1 - The VBUS voltage is below the B session end threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_BSESSEND field. */
#define USB_RD_OTGSTAT_BSESSEND(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_BSESSEND_MASK) >> USB_OTGSTAT_BSESSEND_SHIFT)
#define USB_BRD_OTGSTAT_BSESSEND(base) (BME_UBFX8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_BSESSEND_SHIFT, USB_OTGSTAT_BSESSEND_WIDTH))

/*! @brief Set the BSESSEND field to a new value. */
#define USB_WR_OTGSTAT_BSESSEND(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_BSESSEND_MASK, USB_OTGSTAT_BSESSEND(value)))
#define USB_BWR_OTGSTAT_BSESSEND(base, value) (BME_BFI8(&USB_OTGSTAT_REG(base), ((uint8_t)(value) << USB_OTGSTAT_BSESSEND_SHIFT), USB_OTGSTAT_BSESSEND_SHIFT, USB_OTGSTAT_BSESSEND_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field SESS_VLD[3] (RW)
 *
 * Values:
 * - 0b0 - The VBUS voltage is below the B session valid threshold
 * - 0b1 - The VBUS voltage is above the B session valid threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_SESS_VLD field. */
#define USB_RD_OTGSTAT_SESS_VLD(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_SESS_VLD_MASK) >> USB_OTGSTAT_SESS_VLD_SHIFT)
#define USB_BRD_OTGSTAT_SESS_VLD(base) (BME_UBFX8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_SESS_VLD_SHIFT, USB_OTGSTAT_SESS_VLD_WIDTH))

/*! @brief Set the SESS_VLD field to a new value. */
#define USB_WR_OTGSTAT_SESS_VLD(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_SESS_VLD_MASK, USB_OTGSTAT_SESS_VLD(value)))
#define USB_BWR_OTGSTAT_SESS_VLD(base, value) (BME_BFI8(&USB_OTGSTAT_REG(base), ((uint8_t)(value) << USB_OTGSTAT_SESS_VLD_SHIFT), USB_OTGSTAT_SESS_VLD_SHIFT, USB_OTGSTAT_SESS_VLD_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field LINESTATESTABLE[5] (RW)
 *
 * Indicates that the internal signals that control the LINE_STATE_CHG field of
 * OTGISTAT are stable for at least 1 ms. This bit is used to provide a hardware
 * debounce of the linestate in detection of Connect, Disconnect and Resume
 * signaling. First read LINE_STATE_CHG field and then read this field. If this field
 * reads as 1, then the value of LINE_STATE_CHG can be considered stable.
 *
 * Values:
 * - 0b0 - The LINE_STAT_CHG bit is not yet stable.
 * - 0b1 - The LINE_STAT_CHG bit has been debounced and is stable.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_LINESTATESTABLE field. */
#define USB_RD_OTGSTAT_LINESTATESTABLE(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_LINESTATESTABLE_MASK) >> USB_OTGSTAT_LINESTATESTABLE_SHIFT)
#define USB_BRD_OTGSTAT_LINESTATESTABLE(base) (BME_UBFX8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_LINESTATESTABLE_SHIFT, USB_OTGSTAT_LINESTATESTABLE_WIDTH))

/*! @brief Set the LINESTATESTABLE field to a new value. */
#define USB_WR_OTGSTAT_LINESTATESTABLE(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_LINESTATESTABLE_MASK, USB_OTGSTAT_LINESTATESTABLE(value)))
#define USB_BWR_OTGSTAT_LINESTATESTABLE(base, value) (BME_BFI8(&USB_OTGSTAT_REG(base), ((uint8_t)(value) << USB_OTGSTAT_LINESTATESTABLE_SHIFT), USB_OTGSTAT_LINESTATESTABLE_SHIFT, USB_OTGSTAT_LINESTATESTABLE_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ONEMSECEN[6] (RW)
 *
 * This bit is reserved for the 1ms count, but it is not useful to software.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_ONEMSECEN field. */
#define USB_RD_OTGSTAT_ONEMSECEN(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_ONEMSECEN_MASK) >> USB_OTGSTAT_ONEMSECEN_SHIFT)
#define USB_BRD_OTGSTAT_ONEMSECEN(base) (BME_UBFX8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ONEMSECEN_SHIFT, USB_OTGSTAT_ONEMSECEN_WIDTH))

/*! @brief Set the ONEMSECEN field to a new value. */
#define USB_WR_OTGSTAT_ONEMSECEN(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_ONEMSECEN_MASK, USB_OTGSTAT_ONEMSECEN(value)))
#define USB_BWR_OTGSTAT_ONEMSECEN(base, value) (BME_BFI8(&USB_OTGSTAT_REG(base), ((uint8_t)(value) << USB_OTGSTAT_ONEMSECEN_SHIFT), USB_OTGSTAT_ONEMSECEN_SHIFT, USB_OTGSTAT_ONEMSECEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ID[7] (RW)
 *
 * Indicates the current state of the ID pin on the USB connector
 *
 * Values:
 * - 0b0 - Indicates a Type A cable is plugged into the USB connector.
 * - 0b1 - Indicates no cable is attached or a Type B cable is plugged into the
 *     USB connector.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_ID field. */
#define USB_RD_OTGSTAT_ID(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_ID_MASK) >> USB_OTGSTAT_ID_SHIFT)
#define USB_BRD_OTGSTAT_ID(base) (BME_UBFX8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ID_SHIFT, USB_OTGSTAT_ID_WIDTH))

/*! @brief Set the ID field to a new value. */
#define USB_WR_OTGSTAT_ID(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_ID_MASK, USB_OTGSTAT_ID(value)))
#define USB_BWR_OTGSTAT_ID(base, value) (BME_BFI8(&USB_OTGSTAT_REG(base), ((uint8_t)(value) << USB_OTGSTAT_ID_SHIFT), USB_OTGSTAT_ID_SHIFT, USB_OTGSTAT_ID_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_OTGCTL - OTG Control register
 ******************************************************************************/

/*!
 * @brief USB_OTGCTL - OTG Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Controls the operation of VBUS and Data Line termination resistors.
 */
/*!
 * @name Constants and macros for entire USB_OTGCTL register
 */
/*@{*/
#define USB_RD_OTGCTL(base)      (USB_OTGCTL_REG(base))
#define USB_WR_OTGCTL(base, value) (USB_OTGCTL_REG(base) = (value))
#define USB_RMW_OTGCTL(base, mask, value) (USB_WR_OTGCTL(base, (USB_RD_OTGCTL(base) & ~(mask)) | (value)))
#define USB_SET_OTGCTL(base, value) (BME_OR8(&USB_OTGCTL_REG(base), (uint8_t)(value)))
#define USB_CLR_OTGCTL(base, value) (BME_AND8(&USB_OTGCTL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_OTGCTL(base, value) (BME_XOR8(&USB_OTGCTL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGCTL bitfields
 */

/*!
 * @name Register USB_OTGCTL, field OTGEN[2] (RW)
 *
 * Values:
 * - 0b0 - If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then
 *     the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+
 *     and D- Data Line pull-down resistors are engaged.
 * - 0b1 - The pull-up and pull-down controls in this register are used.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_OTGEN field. */
#define USB_RD_OTGCTL_OTGEN(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_OTGEN_MASK) >> USB_OTGCTL_OTGEN_SHIFT)
#define USB_BRD_OTGCTL_OTGEN(base) (BME_UBFX8(&USB_OTGCTL_REG(base), USB_OTGCTL_OTGEN_SHIFT, USB_OTGCTL_OTGEN_WIDTH))

/*! @brief Set the OTGEN field to a new value. */
#define USB_WR_OTGCTL_OTGEN(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_OTGEN_MASK, USB_OTGCTL_OTGEN(value)))
#define USB_BWR_OTGCTL_OTGEN(base, value) (BME_BFI8(&USB_OTGCTL_REG(base), ((uint8_t)(value) << USB_OTGCTL_OTGEN_SHIFT), USB_OTGCTL_OTGEN_SHIFT, USB_OTGCTL_OTGEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DMLOW[4] (RW)
 *
 * Values:
 * - 0b0 - D- pulldown resistor is not enabled.
 * - 0b1 - D- pulldown resistor is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DMLOW field. */
#define USB_RD_OTGCTL_DMLOW(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DMLOW_MASK) >> USB_OTGCTL_DMLOW_SHIFT)
#define USB_BRD_OTGCTL_DMLOW(base) (BME_UBFX8(&USB_OTGCTL_REG(base), USB_OTGCTL_DMLOW_SHIFT, USB_OTGCTL_DMLOW_WIDTH))

/*! @brief Set the DMLOW field to a new value. */
#define USB_WR_OTGCTL_DMLOW(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DMLOW_MASK, USB_OTGCTL_DMLOW(value)))
#define USB_BWR_OTGCTL_DMLOW(base, value) (BME_BFI8(&USB_OTGCTL_REG(base), ((uint8_t)(value) << USB_OTGCTL_DMLOW_SHIFT), USB_OTGCTL_DMLOW_SHIFT, USB_OTGCTL_DMLOW_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPLOW[5] (RW)
 *
 * This bit should always be enabled together with bit 4 (DMLOW)
 *
 * Values:
 * - 0b0 - D+ pulldown resistor is not enabled.
 * - 0b1 - D+ pulldown resistor is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DPLOW field. */
#define USB_RD_OTGCTL_DPLOW(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DPLOW_MASK) >> USB_OTGCTL_DPLOW_SHIFT)
#define USB_BRD_OTGCTL_DPLOW(base) (BME_UBFX8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPLOW_SHIFT, USB_OTGCTL_DPLOW_WIDTH))

/*! @brief Set the DPLOW field to a new value. */
#define USB_WR_OTGCTL_DPLOW(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DPLOW_MASK, USB_OTGCTL_DPLOW(value)))
#define USB_BWR_OTGCTL_DPLOW(base, value) (BME_BFI8(&USB_OTGCTL_REG(base), ((uint8_t)(value) << USB_OTGCTL_DPLOW_SHIFT), USB_OTGCTL_DPLOW_SHIFT, USB_OTGCTL_DPLOW_WIDTH))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPHIGH[7] (RW)
 *
 * Values:
 * - 0b0 - D+ pullup resistor is not enabled
 * - 0b1 - D+ pullup resistor is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DPHIGH field. */
#define USB_RD_OTGCTL_DPHIGH(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DPHIGH_MASK) >> USB_OTGCTL_DPHIGH_SHIFT)
#define USB_BRD_OTGCTL_DPHIGH(base) (BME_UBFX8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPHIGH_SHIFT, USB_OTGCTL_DPHIGH_WIDTH))

/*! @brief Set the DPHIGH field to a new value. */
#define USB_WR_OTGCTL_DPHIGH(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DPHIGH_MASK, USB_OTGCTL_DPHIGH(value)))
#define USB_BWR_OTGCTL_DPHIGH(base, value) (BME_BFI8(&USB_OTGCTL_REG(base), ((uint8_t)(value) << USB_OTGCTL_DPHIGH_SHIFT), USB_OTGCTL_DPHIGH_SHIFT, USB_OTGCTL_DPHIGH_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_ISTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief USB_ISTAT - Interrupt Status register (W1C)
 *
 * Reset value: 0x00U
 *
 * Contains fields for each of the interrupt sources within the USB Module. Each
 * of these fields are qualified with their respective interrupt enable bits.
 * All fields of this register are logically OR'd together along with the OTG
 * Interrupt Status Register (OTGSTAT) to form a single interrupt source for the
 * processor's interrupt controller. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. This register
 * contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ISTAT register
 */
/*@{*/
#define USB_RD_ISTAT(base)       (USB_ISTAT_REG(base))
#define USB_WR_ISTAT(base, value) (USB_ISTAT_REG(base) = (value))
#define USB_RMW_ISTAT(base, mask, value) (USB_WR_ISTAT(base, (USB_RD_ISTAT(base) & ~(mask)) | (value)))
#define USB_SET_ISTAT(base, value) (BME_OR8(&USB_ISTAT_REG(base), (uint8_t)(value)))
#define USB_CLR_ISTAT(base, value) (BME_AND8(&USB_ISTAT_REG(base), (uint8_t)(~(value))))
#define USB_TOG_ISTAT(base, value) (BME_XOR8(&USB_ISTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_ISTAT bitfields
 */

/*!
 * @name Register USB_ISTAT, field USBRST[0] (W1C)
 *
 * This bit is set when the USB Module has decoded a valid USB reset. This
 * informs the processor that it should write 0x00 into the address register and
 * enable endpoint 0. USBRST is set after a USB reset has been detected for 2.5
 * microseconds. It is not asserted again until the USB reset condition has been
 * removed and then reasserted.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_USBRST field. */
#define USB_RD_ISTAT_USBRST(base) ((USB_ISTAT_REG(base) & USB_ISTAT_USBRST_MASK) >> USB_ISTAT_USBRST_SHIFT)
#define USB_BRD_ISTAT_USBRST(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_USBRST_SHIFT, USB_ISTAT_USBRST_WIDTH))

/*! @brief Set the USBRST field to a new value. */
#define USB_WR_ISTAT_USBRST(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_USBRST(value)))
#define USB_BWR_ISTAT_USBRST(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_USBRST_SHIFT), USB_ISTAT_USBRST_SHIFT, USB_ISTAT_USBRST_WIDTH))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ERROR[1] (W1C)
 *
 * This bit is set when any of the error conditions within Error Interrupt
 * Status (ERRSTAT) register occur. The processor must then read the ERRSTAT register
 * to determine the source of the error.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_ERROR field. */
#define USB_RD_ISTAT_ERROR(base) ((USB_ISTAT_REG(base) & USB_ISTAT_ERROR_MASK) >> USB_ISTAT_ERROR_SHIFT)
#define USB_BRD_ISTAT_ERROR(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_ERROR_SHIFT, USB_ISTAT_ERROR_WIDTH))

/*! @brief Set the ERROR field to a new value. */
#define USB_WR_ISTAT_ERROR(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_ERROR_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_ERROR(value)))
#define USB_BWR_ISTAT_ERROR(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_ERROR_SHIFT), USB_ISTAT_ERROR_SHIFT, USB_ISTAT_ERROR_WIDTH))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SOFTOK[2] (W1C)
 *
 * This bit is set when the USB Module receives a Start Of Frame (SOF) token. In
 * Host mode this field is set when the SOF threshold is reached
 * (MISCCTRL[SOFBUSSET]=0), or when the SOF counter reaches 0 (MISCCTRL[SOFBUSSET]=1), so that
 * software can prepare for the next SOF.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_SOFTOK field. */
#define USB_RD_ISTAT_SOFTOK(base) ((USB_ISTAT_REG(base) & USB_ISTAT_SOFTOK_MASK) >> USB_ISTAT_SOFTOK_SHIFT)
#define USB_BRD_ISTAT_SOFTOK(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_SOFTOK_SHIFT, USB_ISTAT_SOFTOK_WIDTH))

/*! @brief Set the SOFTOK field to a new value. */
#define USB_WR_ISTAT_SOFTOK(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_SOFTOK_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_SOFTOK(value)))
#define USB_BWR_ISTAT_SOFTOK(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_SOFTOK_SHIFT), USB_ISTAT_SOFTOK_SHIFT, USB_ISTAT_SOFTOK_WIDTH))
/*@}*/

/*!
 * @name Register USB_ISTAT, field TOKDNE[3] (W1C)
 *
 * This bit is set when the current token being processed has completed. The
 * processor must immediately read the STATUS (STAT) register to determine the
 * EndPoint and BD used for this token. Clearing this bit (by writing a one) causes
 * STAT to be cleared or the STAT holding register to be loaded into the STAT
 * register.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_TOKDNE field. */
#define USB_RD_ISTAT_TOKDNE(base) ((USB_ISTAT_REG(base) & USB_ISTAT_TOKDNE_MASK) >> USB_ISTAT_TOKDNE_SHIFT)
#define USB_BRD_ISTAT_TOKDNE(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_TOKDNE_SHIFT, USB_ISTAT_TOKDNE_WIDTH))

/*! @brief Set the TOKDNE field to a new value. */
#define USB_WR_ISTAT_TOKDNE(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_TOKDNE_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_TOKDNE(value)))
#define USB_BWR_ISTAT_TOKDNE(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_TOKDNE_SHIFT), USB_ISTAT_TOKDNE_SHIFT, USB_ISTAT_TOKDNE_WIDTH))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SLEEP[4] (W1C)
 *
 * This bit is set when the USB Module detects a constant idle on the USB bus
 * for 3 ms. The sleep timer is reset by activity on the USB bus.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_SLEEP field. */
#define USB_RD_ISTAT_SLEEP(base) ((USB_ISTAT_REG(base) & USB_ISTAT_SLEEP_MASK) >> USB_ISTAT_SLEEP_SHIFT)
#define USB_BRD_ISTAT_SLEEP(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_SLEEP_SHIFT, USB_ISTAT_SLEEP_WIDTH))

/*! @brief Set the SLEEP field to a new value. */
#define USB_WR_ISTAT_SLEEP(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_SLEEP_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_SLEEP(value)))
#define USB_BWR_ISTAT_SLEEP(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_SLEEP_SHIFT), USB_ISTAT_SLEEP_SHIFT, USB_ISTAT_SLEEP_WIDTH))
/*@}*/

/*!
 * @name Register USB_ISTAT, field RESUME[5] (W1C)
 *
 * This bit is set when a K-state is observed on the DP/DM signals for 2.5 us.
 * When not in suspend mode this interrupt must be disabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_RESUME field. */
#define USB_RD_ISTAT_RESUME(base) ((USB_ISTAT_REG(base) & USB_ISTAT_RESUME_MASK) >> USB_ISTAT_RESUME_SHIFT)
#define USB_BRD_ISTAT_RESUME(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_RESUME_SHIFT, USB_ISTAT_RESUME_WIDTH))

/*! @brief Set the RESUME field to a new value. */
#define USB_WR_ISTAT_RESUME(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_RESUME_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_RESUME(value)))
#define USB_BWR_ISTAT_RESUME(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_RESUME_SHIFT), USB_ISTAT_RESUME_SHIFT, USB_ISTAT_RESUME_WIDTH))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ATTACH[6] (W1C)
 *
 * This field is set when the USB Module detects an attach of a USB device. This
 * field is only valid if CTL[HOSTMODEEN]=1. This interrupt signifies that a
 * peripheral is now present and must be configured; it is asserted if there have
 * been no transitions on the USB for 2.5 us and the current bus state is not SE0."
 *
 * Values:
 * - 0b0 - No Attach is detected since the last time the ATTACH bit was cleared.
 * - 0b1 - A peripheral is now present and must be configured (a stable non-SE0
 *     state is detected for more than 2.5 us).
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_ATTACH field. */
#define USB_RD_ISTAT_ATTACH(base) ((USB_ISTAT_REG(base) & USB_ISTAT_ATTACH_MASK) >> USB_ISTAT_ATTACH_SHIFT)
#define USB_BRD_ISTAT_ATTACH(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_ATTACH_SHIFT, USB_ISTAT_ATTACH_WIDTH))

/*! @brief Set the ATTACH field to a new value. */
#define USB_WR_ISTAT_ATTACH(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_ATTACH_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_ATTACH(value)))
#define USB_BWR_ISTAT_ATTACH(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_ATTACH_SHIFT), USB_ISTAT_ATTACH_SHIFT, USB_ISTAT_ATTACH_WIDTH))
/*@}*/

/*!
 * @name Register USB_ISTAT, field STALL[7] (W1C)
 *
 * In Target mode this bit is asserted when a STALL handshake is sent by the
 * SIE. In Host mode this bit is set when the USB Module detects a STALL acknowledge
 * during the handshake phase of a USB transaction.This interrupt can be used to
 * determine whether the last USB transaction was completed successfully or
 * stalled.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_STALL field. */
#define USB_RD_ISTAT_STALL(base) ((USB_ISTAT_REG(base) & USB_ISTAT_STALL_MASK) >> USB_ISTAT_STALL_SHIFT)
#define USB_BRD_ISTAT_STALL(base) (BME_UBFX8(&USB_ISTAT_REG(base), USB_ISTAT_STALL_SHIFT, USB_ISTAT_STALL_WIDTH))

/*! @brief Set the STALL field to a new value. */
#define USB_WR_ISTAT_STALL(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_STALL_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK), USB_ISTAT_STALL(value)))
#define USB_BWR_ISTAT_STALL(base, value) (BME_BFI8(&USB_ISTAT_REG(base), ((uint8_t)(value) << USB_ISTAT_STALL_SHIFT), USB_ISTAT_STALL_SHIFT, USB_ISTAT_STALL_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_INTEN - Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief USB_INTEN - Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable fields for each of the interrupt sources within the USB
 * Module. Setting any of these bits enables the respective interrupt source in the
 * ISTAT register. This register contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_INTEN register
 */
/*@{*/
#define USB_RD_INTEN(base)       (USB_INTEN_REG(base))
#define USB_WR_INTEN(base, value) (USB_INTEN_REG(base) = (value))
#define USB_RMW_INTEN(base, mask, value) (USB_WR_INTEN(base, (USB_RD_INTEN(base) & ~(mask)) | (value)))
#define USB_SET_INTEN(base, value) (BME_OR8(&USB_INTEN_REG(base), (uint8_t)(value)))
#define USB_CLR_INTEN(base, value) (BME_AND8(&USB_INTEN_REG(base), (uint8_t)(~(value))))
#define USB_TOG_INTEN(base, value) (BME_XOR8(&USB_INTEN_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_INTEN bitfields
 */

/*!
 * @name Register USB_INTEN, field USBRSTEN[0] (RW)
 *
 * Values:
 * - 0b0 - Disables the USBRST interrupt.
 * - 0b1 - Enables the USBRST interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_USBRSTEN field. */
#define USB_RD_INTEN_USBRSTEN(base) ((USB_INTEN_REG(base) & USB_INTEN_USBRSTEN_MASK) >> USB_INTEN_USBRSTEN_SHIFT)
#define USB_BRD_INTEN_USBRSTEN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_USBRSTEN_SHIFT, USB_INTEN_USBRSTEN_WIDTH))

/*! @brief Set the USBRSTEN field to a new value. */
#define USB_WR_INTEN_USBRSTEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_USBRSTEN_MASK, USB_INTEN_USBRSTEN(value)))
#define USB_BWR_INTEN_USBRSTEN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_USBRSTEN_SHIFT), USB_INTEN_USBRSTEN_SHIFT, USB_INTEN_USBRSTEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_INTEN, field ERROREN[1] (RW)
 *
 * Values:
 * - 0b0 - Disables the ERROR interrupt.
 * - 0b1 - Enables the ERROR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_ERROREN field. */
#define USB_RD_INTEN_ERROREN(base) ((USB_INTEN_REG(base) & USB_INTEN_ERROREN_MASK) >> USB_INTEN_ERROREN_SHIFT)
#define USB_BRD_INTEN_ERROREN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_ERROREN_SHIFT, USB_INTEN_ERROREN_WIDTH))

/*! @brief Set the ERROREN field to a new value. */
#define USB_WR_INTEN_ERROREN(base, value) (USB_RMW_INTEN(base, USB_INTEN_ERROREN_MASK, USB_INTEN_ERROREN(value)))
#define USB_BWR_INTEN_ERROREN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_ERROREN_SHIFT), USB_INTEN_ERROREN_SHIFT, USB_INTEN_ERROREN_WIDTH))
/*@}*/

/*!
 * @name Register USB_INTEN, field SOFTOKEN[2] (RW)
 *
 * Values:
 * - 0b0 - Disbles the SOFTOK interrupt.
 * - 0b1 - Enables the SOFTOK interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_SOFTOKEN field. */
#define USB_RD_INTEN_SOFTOKEN(base) ((USB_INTEN_REG(base) & USB_INTEN_SOFTOKEN_MASK) >> USB_INTEN_SOFTOKEN_SHIFT)
#define USB_BRD_INTEN_SOFTOKEN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_SOFTOKEN_SHIFT, USB_INTEN_SOFTOKEN_WIDTH))

/*! @brief Set the SOFTOKEN field to a new value. */
#define USB_WR_INTEN_SOFTOKEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_SOFTOKEN_MASK, USB_INTEN_SOFTOKEN(value)))
#define USB_BWR_INTEN_SOFTOKEN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_SOFTOKEN_SHIFT), USB_INTEN_SOFTOKEN_SHIFT, USB_INTEN_SOFTOKEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_INTEN, field TOKDNEEN[3] (RW)
 *
 * Values:
 * - 0b0 - Disables the TOKDNE interrupt.
 * - 0b1 - Enables the TOKDNE interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_TOKDNEEN field. */
#define USB_RD_INTEN_TOKDNEEN(base) ((USB_INTEN_REG(base) & USB_INTEN_TOKDNEEN_MASK) >> USB_INTEN_TOKDNEEN_SHIFT)
#define USB_BRD_INTEN_TOKDNEEN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_TOKDNEEN_SHIFT, USB_INTEN_TOKDNEEN_WIDTH))

/*! @brief Set the TOKDNEEN field to a new value. */
#define USB_WR_INTEN_TOKDNEEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_TOKDNEEN_MASK, USB_INTEN_TOKDNEEN(value)))
#define USB_BWR_INTEN_TOKDNEEN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_TOKDNEEN_SHIFT), USB_INTEN_TOKDNEEN_SHIFT, USB_INTEN_TOKDNEEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_INTEN, field SLEEPEN[4] (RW)
 *
 * Values:
 * - 0b0 - Disables the SLEEP interrupt.
 * - 0b1 - Enables the SLEEP interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_SLEEPEN field. */
#define USB_RD_INTEN_SLEEPEN(base) ((USB_INTEN_REG(base) & USB_INTEN_SLEEPEN_MASK) >> USB_INTEN_SLEEPEN_SHIFT)
#define USB_BRD_INTEN_SLEEPEN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_SLEEPEN_SHIFT, USB_INTEN_SLEEPEN_WIDTH))

/*! @brief Set the SLEEPEN field to a new value. */
#define USB_WR_INTEN_SLEEPEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_SLEEPEN_MASK, USB_INTEN_SLEEPEN(value)))
#define USB_BWR_INTEN_SLEEPEN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_SLEEPEN_SHIFT), USB_INTEN_SLEEPEN_SHIFT, USB_INTEN_SLEEPEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_INTEN, field RESUMEEN[5] (RW)
 *
 * Values:
 * - 0b0 - Disables the RESUME interrupt.
 * - 0b1 - Enables the RESUME interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_RESUMEEN field. */
#define USB_RD_INTEN_RESUMEEN(base) ((USB_INTEN_REG(base) & USB_INTEN_RESUMEEN_MASK) >> USB_INTEN_RESUMEEN_SHIFT)
#define USB_BRD_INTEN_RESUMEEN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_RESUMEEN_SHIFT, USB_INTEN_RESUMEEN_WIDTH))

/*! @brief Set the RESUMEEN field to a new value. */
#define USB_WR_INTEN_RESUMEEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_RESUMEEN_MASK, USB_INTEN_RESUMEEN(value)))
#define USB_BWR_INTEN_RESUMEEN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_RESUMEEN_SHIFT), USB_INTEN_RESUMEEN_SHIFT, USB_INTEN_RESUMEEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_INTEN, field ATTACHEN[6] (RW)
 *
 * Values:
 * - 0b0 - Disables the ATTACH interrupt.
 * - 0b1 - Enables the ATTACH interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_ATTACHEN field. */
#define USB_RD_INTEN_ATTACHEN(base) ((USB_INTEN_REG(base) & USB_INTEN_ATTACHEN_MASK) >> USB_INTEN_ATTACHEN_SHIFT)
#define USB_BRD_INTEN_ATTACHEN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_ATTACHEN_SHIFT, USB_INTEN_ATTACHEN_WIDTH))

/*! @brief Set the ATTACHEN field to a new value. */
#define USB_WR_INTEN_ATTACHEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_ATTACHEN_MASK, USB_INTEN_ATTACHEN(value)))
#define USB_BWR_INTEN_ATTACHEN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_ATTACHEN_SHIFT), USB_INTEN_ATTACHEN_SHIFT, USB_INTEN_ATTACHEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_INTEN, field STALLEN[7] (RW)
 *
 * Values:
 * - 0b0 - Diasbles the STALL interrupt.
 * - 0b1 - Enables the STALL interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_STALLEN field. */
#define USB_RD_INTEN_STALLEN(base) ((USB_INTEN_REG(base) & USB_INTEN_STALLEN_MASK) >> USB_INTEN_STALLEN_SHIFT)
#define USB_BRD_INTEN_STALLEN(base) (BME_UBFX8(&USB_INTEN_REG(base), USB_INTEN_STALLEN_SHIFT, USB_INTEN_STALLEN_WIDTH))

/*! @brief Set the STALLEN field to a new value. */
#define USB_WR_INTEN_STALLEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_STALLEN_MASK, USB_INTEN_STALLEN(value)))
#define USB_BWR_INTEN_STALLEN(base, value) (BME_BFI8(&USB_INTEN_REG(base), ((uint8_t)(value) << USB_INTEN_STALLEN_SHIFT), USB_INTEN_STALLEN_SHIFT, USB_INTEN_STALLEN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_ERRSTAT - Error Interrupt Status register
 ******************************************************************************/

/*!
 * @brief USB_ERRSTAT - Error Interrupt Status register (W1C)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error sources within the USB Module.
 * Each of these bits are qualified with their respective error enable bits. All
 * bits of this register are logically OR'd together and the result placed in the
 * ERROR bit of the ISTAT register. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. Each bit is set
 * as soon as the error condition is detected. Therefore, the interrupt does not
 * typically correspond with the end of a token being processed. This register
 * contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ERRSTAT register
 */
/*@{*/
#define USB_RD_ERRSTAT(base)     (USB_ERRSTAT_REG(base))
#define USB_WR_ERRSTAT(base, value) (USB_ERRSTAT_REG(base) = (value))
#define USB_RMW_ERRSTAT(base, mask, value) (USB_WR_ERRSTAT(base, (USB_RD_ERRSTAT(base) & ~(mask)) | (value)))
#define USB_SET_ERRSTAT(base, value) (BME_OR8(&USB_ERRSTAT_REG(base), (uint8_t)(value)))
#define USB_CLR_ERRSTAT(base, value) (BME_AND8(&USB_ERRSTAT_REG(base), (uint8_t)(~(value))))
#define USB_TOG_ERRSTAT(base, value) (BME_XOR8(&USB_ERRSTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_ERRSTAT bitfields
 */

/*!
 * @name Register USB_ERRSTAT, field PIDERR[0] (W1C)
 *
 * This bit is set when the PID check field fails.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_PIDERR field. */
#define USB_RD_ERRSTAT_PIDERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_PIDERR_MASK) >> USB_ERRSTAT_PIDERR_SHIFT)
#define USB_BRD_ERRSTAT_PIDERR(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_PIDERR_SHIFT, USB_ERRSTAT_PIDERR_WIDTH))

/*! @brief Set the PIDERR field to a new value. */
#define USB_WR_ERRSTAT_PIDERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_PIDERR(value)))
#define USB_BWR_ERRSTAT_PIDERR(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_PIDERR_SHIFT), USB_ERRSTAT_PIDERR_SHIFT, USB_ERRSTAT_PIDERR_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC5EOF[1] (W1C)
 *
 * This error interrupt has two functions. When the USB Module is operating in
 * peripheral mode (CTL[HOSTMODEEN]=0), this interrupt detects CRC5 errors in the
 * token packets generated by the host. If set the token packet was rejected due
 * to a CRC5 error. When the USB Module is operating in host mode
 * (CTL[HOSTMODEEN]=1), this interrupt detects End Of Frame (EOF) error conditions. This occurs
 * when the USB Module is transmitting or receiving data and the SOF counter
 * reaches zero. This interrupt is useful when developing USB packet scheduling
 * software to ensure that no USB transactions cross the start of the next frame.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_CRC5EOF field. */
#define USB_RD_ERRSTAT_CRC5EOF(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_CRC5EOF_MASK) >> USB_ERRSTAT_CRC5EOF_SHIFT)
#define USB_BRD_ERRSTAT_CRC5EOF(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC5EOF_SHIFT, USB_ERRSTAT_CRC5EOF_WIDTH))

/*! @brief Set the CRC5EOF field to a new value. */
#define USB_WR_ERRSTAT_CRC5EOF(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_CRC5EOF(value)))
#define USB_BWR_ERRSTAT_CRC5EOF(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_CRC5EOF_SHIFT), USB_ERRSTAT_CRC5EOF_SHIFT, USB_ERRSTAT_CRC5EOF_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC16[2] (W1C)
 *
 * This bit is set when a data packet is rejected due to a CRC16 error.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_CRC16 field. */
#define USB_RD_ERRSTAT_CRC16(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_CRC16_MASK) >> USB_ERRSTAT_CRC16_SHIFT)
#define USB_BRD_ERRSTAT_CRC16(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC16_SHIFT, USB_ERRSTAT_CRC16_WIDTH))

/*! @brief Set the CRC16 field to a new value. */
#define USB_WR_ERRSTAT_CRC16(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_CRC16(value)))
#define USB_BWR_ERRSTAT_CRC16(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_CRC16_SHIFT), USB_ERRSTAT_CRC16_SHIFT, USB_ERRSTAT_CRC16_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DFN8[3] (W1C)
 *
 * This bit is set if the data field received was not 8 bits in length. USB
 * Specification 1.0 requires that data fields be an integral number of bytes. If the
 * data field was not an integral number of bytes, this bit is set.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_DFN8 field. */
#define USB_RD_ERRSTAT_DFN8(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_DFN8_MASK) >> USB_ERRSTAT_DFN8_SHIFT)
#define USB_BRD_ERRSTAT_DFN8(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DFN8_SHIFT, USB_ERRSTAT_DFN8_WIDTH))

/*! @brief Set the DFN8 field to a new value. */
#define USB_WR_ERRSTAT_DFN8(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_DFN8(value)))
#define USB_BWR_ERRSTAT_DFN8(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_DFN8_SHIFT), USB_ERRSTAT_DFN8_SHIFT, USB_ERRSTAT_DFN8_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTOERR[4] (W1C)
 *
 * This bit is set when a bus turnaround timeout error occurs. The USB module
 * contains a bus turnaround timer that keeps track of the amount of time elapsed
 * between the token and data phases of a SETUP or OUT TOKEN or the data and
 * handshake phases of a IN TOKEN. If more than 16 bit times are counted from the
 * previous EOP before a transition from IDLE, a bus turnaround timeout error occurs.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_BTOERR field. */
#define USB_RD_ERRSTAT_BTOERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_BTOERR_MASK) >> USB_ERRSTAT_BTOERR_SHIFT)
#define USB_BRD_ERRSTAT_BTOERR(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTOERR_SHIFT, USB_ERRSTAT_BTOERR_WIDTH))

/*! @brief Set the BTOERR field to a new value. */
#define USB_WR_ERRSTAT_BTOERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_BTOERR(value)))
#define USB_BWR_ERRSTAT_BTOERR(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_BTOERR_SHIFT), USB_ERRSTAT_BTOERR_SHIFT, USB_ERRSTAT_BTOERR_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DMAERR[5] (W1C)
 *
 * This bit is set if the USB Module has requested a DMA access to read a new
 * BDT but has not been given the bus before it needs to receive or transmit data.
 * If processing a TX transfer this would cause a transmit data underflow
 * condition. If processing a RX transfer this would cause a receive data overflow
 * condition. This interrupt is useful when developing device arbitration hardware for
 * the microprocessor and the USB module to minimize bus request and bus grant
 * latency. This bit is also set if a data packet to or from the host is larger
 * than the buffer size allocated in the BDT. In this case the data packet is
 * truncated as it is put in buffer memory.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_DMAERR field. */
#define USB_RD_ERRSTAT_DMAERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_DMAERR_MASK) >> USB_ERRSTAT_DMAERR_SHIFT)
#define USB_BRD_ERRSTAT_DMAERR(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DMAERR_SHIFT, USB_ERRSTAT_DMAERR_WIDTH))

/*! @brief Set the DMAERR field to a new value. */
#define USB_WR_ERRSTAT_DMAERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_DMAERR(value)))
#define USB_BWR_ERRSTAT_DMAERR(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_DMAERR_SHIFT), USB_ERRSTAT_DMAERR_SHIFT, USB_ERRSTAT_DMAERR_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field OWNERR[6] (W1C)
 *
 * This field is valid when the USB Module is operating in peripheral mode
 * (CTL[HOSTMODEEN]=0). It is set if the USB Module requires a new BD for SETUP, ISO
 * IN, or ISO OUT transfer while a new BD is not available.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_OWNERR field. */
#define USB_RD_ERRSTAT_OWNERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_OWNERR_MASK) >> USB_ERRSTAT_OWNERR_SHIFT)
#define USB_BRD_ERRSTAT_OWNERR(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_OWNERR_SHIFT, USB_ERRSTAT_OWNERR_WIDTH))

/*! @brief Set the OWNERR field to a new value. */
#define USB_WR_ERRSTAT_OWNERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_OWNERR(value)))
#define USB_BWR_ERRSTAT_OWNERR(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_OWNERR_SHIFT), USB_ERRSTAT_OWNERR_SHIFT, USB_ERRSTAT_OWNERR_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTSERR[7] (W1C)
 *
 * This bit is set when a bit stuff error is detected. If set, the corresponding
 * packet is rejected due to the error.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_BTSERR field. */
#define USB_RD_ERRSTAT_BTSERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_BTSERR_MASK) >> USB_ERRSTAT_BTSERR_SHIFT)
#define USB_BRD_ERRSTAT_BTSERR(base) (BME_UBFX8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTSERR_SHIFT, USB_ERRSTAT_BTSERR_WIDTH))

/*! @brief Set the BTSERR field to a new value. */
#define USB_WR_ERRSTAT_BTSERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_BTSERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK), USB_ERRSTAT_BTSERR(value)))
#define USB_BWR_ERRSTAT_BTSERR(base, value) (BME_BFI8(&USB_ERRSTAT_REG(base), ((uint8_t)(value) << USB_ERRSTAT_BTSERR_SHIFT), USB_ERRSTAT_BTSERR_SHIFT, USB_ERRSTAT_BTSERR_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_ERREN - Error Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief USB_ERREN - Error Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error interrupt sources within the USB
 * module. Setting any of these bits enables the respective interrupt source in
 * ERRSTAT. Each bit is set as soon as the error condition is detected. Therefore,
 * the interrupt does not typically correspond with the end of a token being
 * processed. This register contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ERREN register
 */
/*@{*/
#define USB_RD_ERREN(base)       (USB_ERREN_REG(base))
#define USB_WR_ERREN(base, value) (USB_ERREN_REG(base) = (value))
#define USB_RMW_ERREN(base, mask, value) (USB_WR_ERREN(base, (USB_RD_ERREN(base) & ~(mask)) | (value)))
#define USB_SET_ERREN(base, value) (BME_OR8(&USB_ERREN_REG(base), (uint8_t)(value)))
#define USB_CLR_ERREN(base, value) (BME_AND8(&USB_ERREN_REG(base), (uint8_t)(~(value))))
#define USB_TOG_ERREN(base, value) (BME_XOR8(&USB_ERREN_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_ERREN bitfields
 */

/*!
 * @name Register USB_ERREN, field PIDERREN[0] (RW)
 *
 * Values:
 * - 0b0 - Disables the PIDERR interrupt.
 * - 0b1 - Enters the PIDERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_PIDERREN field. */
#define USB_RD_ERREN_PIDERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_PIDERREN_MASK) >> USB_ERREN_PIDERREN_SHIFT)
#define USB_BRD_ERREN_PIDERREN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_PIDERREN_SHIFT, USB_ERREN_PIDERREN_WIDTH))

/*! @brief Set the PIDERREN field to a new value. */
#define USB_WR_ERREN_PIDERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_PIDERREN_MASK, USB_ERREN_PIDERREN(value)))
#define USB_BWR_ERREN_PIDERREN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_PIDERREN_SHIFT), USB_ERREN_PIDERREN_SHIFT, USB_ERREN_PIDERREN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC5EOFEN[1] (RW)
 *
 * Values:
 * - 0b0 - Disables the CRC5/EOF interrupt.
 * - 0b1 - Enables the CRC5/EOF interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_CRC5EOFEN field. */
#define USB_RD_ERREN_CRC5EOFEN(base) ((USB_ERREN_REG(base) & USB_ERREN_CRC5EOFEN_MASK) >> USB_ERREN_CRC5EOFEN_SHIFT)
#define USB_BRD_ERREN_CRC5EOFEN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_CRC5EOFEN_SHIFT, USB_ERREN_CRC5EOFEN_WIDTH))

/*! @brief Set the CRC5EOFEN field to a new value. */
#define USB_WR_ERREN_CRC5EOFEN(base, value) (USB_RMW_ERREN(base, USB_ERREN_CRC5EOFEN_MASK, USB_ERREN_CRC5EOFEN(value)))
#define USB_BWR_ERREN_CRC5EOFEN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_CRC5EOFEN_SHIFT), USB_ERREN_CRC5EOFEN_SHIFT, USB_ERREN_CRC5EOFEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC16EN[2] (RW)
 *
 * Values:
 * - 0b0 - Disables the CRC16 interrupt.
 * - 0b1 - Enables the CRC16 interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_CRC16EN field. */
#define USB_RD_ERREN_CRC16EN(base) ((USB_ERREN_REG(base) & USB_ERREN_CRC16EN_MASK) >> USB_ERREN_CRC16EN_SHIFT)
#define USB_BRD_ERREN_CRC16EN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_CRC16EN_SHIFT, USB_ERREN_CRC16EN_WIDTH))

/*! @brief Set the CRC16EN field to a new value. */
#define USB_WR_ERREN_CRC16EN(base, value) (USB_RMW_ERREN(base, USB_ERREN_CRC16EN_MASK, USB_ERREN_CRC16EN(value)))
#define USB_BWR_ERREN_CRC16EN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_CRC16EN_SHIFT), USB_ERREN_CRC16EN_SHIFT, USB_ERREN_CRC16EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERREN, field DFN8EN[3] (RW)
 *
 * Values:
 * - 0b0 - Disables the DFN8 interrupt.
 * - 0b1 - Enables the DFN8 interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_DFN8EN field. */
#define USB_RD_ERREN_DFN8EN(base) ((USB_ERREN_REG(base) & USB_ERREN_DFN8EN_MASK) >> USB_ERREN_DFN8EN_SHIFT)
#define USB_BRD_ERREN_DFN8EN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_DFN8EN_SHIFT, USB_ERREN_DFN8EN_WIDTH))

/*! @brief Set the DFN8EN field to a new value. */
#define USB_WR_ERREN_DFN8EN(base, value) (USB_RMW_ERREN(base, USB_ERREN_DFN8EN_MASK, USB_ERREN_DFN8EN(value)))
#define USB_BWR_ERREN_DFN8EN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_DFN8EN_SHIFT), USB_ERREN_DFN8EN_SHIFT, USB_ERREN_DFN8EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTOERREN[4] (RW)
 *
 * Values:
 * - 0b0 - Disables the BTOERR interrupt.
 * - 0b1 - Enables the BTOERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_BTOERREN field. */
#define USB_RD_ERREN_BTOERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_BTOERREN_MASK) >> USB_ERREN_BTOERREN_SHIFT)
#define USB_BRD_ERREN_BTOERREN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_BTOERREN_SHIFT, USB_ERREN_BTOERREN_WIDTH))

/*! @brief Set the BTOERREN field to a new value. */
#define USB_WR_ERREN_BTOERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_BTOERREN_MASK, USB_ERREN_BTOERREN(value)))
#define USB_BWR_ERREN_BTOERREN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_BTOERREN_SHIFT), USB_ERREN_BTOERREN_SHIFT, USB_ERREN_BTOERREN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERREN, field DMAERREN[5] (RW)
 *
 * Values:
 * - 0b0 - Disables the DMAERR interrupt.
 * - 0b1 - Enables the DMAERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_DMAERREN field. */
#define USB_RD_ERREN_DMAERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_DMAERREN_MASK) >> USB_ERREN_DMAERREN_SHIFT)
#define USB_BRD_ERREN_DMAERREN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_DMAERREN_SHIFT, USB_ERREN_DMAERREN_WIDTH))

/*! @brief Set the DMAERREN field to a new value. */
#define USB_WR_ERREN_DMAERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_DMAERREN_MASK, USB_ERREN_DMAERREN(value)))
#define USB_BWR_ERREN_DMAERREN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_DMAERREN_SHIFT), USB_ERREN_DMAERREN_SHIFT, USB_ERREN_DMAERREN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERREN, field OWNERREN[6] (RW)
 *
 * This field is valid when the USB module is operating in peripheral mode
 * (CTL[HOSTMODEEN]=0).
 *
 * Values:
 * - 0b0 - Disables the OWNERR interrupt.
 * - 0b1 - Enables the OWNERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_OWNERREN field. */
#define USB_RD_ERREN_OWNERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_OWNERREN_MASK) >> USB_ERREN_OWNERREN_SHIFT)
#define USB_BRD_ERREN_OWNERREN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_OWNERREN_SHIFT, USB_ERREN_OWNERREN_WIDTH))

/*! @brief Set the OWNERREN field to a new value. */
#define USB_WR_ERREN_OWNERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_OWNERREN_MASK, USB_ERREN_OWNERREN(value)))
#define USB_BWR_ERREN_OWNERREN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_OWNERREN_SHIFT), USB_ERREN_OWNERREN_SHIFT, USB_ERREN_OWNERREN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTSERREN[7] (RW)
 *
 * Values:
 * - 0b0 - Disables the BTSERR interrupt.
 * - 0b1 - Enables the BTSERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_BTSERREN field. */
#define USB_RD_ERREN_BTSERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_BTSERREN_MASK) >> USB_ERREN_BTSERREN_SHIFT)
#define USB_BRD_ERREN_BTSERREN(base) (BME_UBFX8(&USB_ERREN_REG(base), USB_ERREN_BTSERREN_SHIFT, USB_ERREN_BTSERREN_WIDTH))

/*! @brief Set the BTSERREN field to a new value. */
#define USB_WR_ERREN_BTSERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_BTSERREN_MASK, USB_ERREN_BTSERREN(value)))
#define USB_BWR_ERREN_BTSERREN(base, value) (BME_BFI8(&USB_ERREN_REG(base), ((uint8_t)(value) << USB_ERREN_BTSERREN_SHIFT), USB_ERREN_BTSERREN_SHIFT, USB_ERREN_BTSERREN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_STAT - Status register
 ******************************************************************************/

/*!
 * @brief USB_STAT - Status register (RO)
 *
 * Reset value: 0x00U
 *
 * Reports the transaction status within the USB module. When the processor's
 * interrupt controller has received a TOKDNE, interrupt the Status Register must
 * be read to determine the status of the previous endpoint communication. The
 * data in the status register is valid when TOKDNE interrupt is asserted. The
 * Status register is actually a read window into a status FIFO maintained by the USB
 * module. When the USB module uses a BD, it updates the Status register. If
 * another USB transaction is performed before the TOKDNE interrupt is serviced, the
 * USB module stores the status of the next transaction in the STAT FIFO. Thus
 * STAT is actually a four byte FIFO that allows the processor core to process one
 * transaction while the SIE is processing the next transaction. Clearing the
 * TOKDNE bit in the ISTAT register causes the SIE to update STAT with the contents
 * of the next STAT value. If the data in the STAT holding register is valid, the
 * SIE immediately reasserts to TOKDNE interrupt.
 */
/*!
 * @name Constants and macros for entire USB_STAT register
 */
/*@{*/
#define USB_RD_STAT(base)        (USB_STAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_STAT bitfields
 */

/*!
 * @name Register USB_STAT, field ODD[2] (RO)
 *
 * This bit is set if the last buffer descriptor updated was in the odd bank of
 * the BDT.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_ODD field. */
#define USB_RD_STAT_ODD(base) ((USB_STAT_REG(base) & USB_STAT_ODD_MASK) >> USB_STAT_ODD_SHIFT)
#define USB_BRD_STAT_ODD(base) (BME_UBFX8(&USB_STAT_REG(base), USB_STAT_ODD_SHIFT, USB_STAT_ODD_WIDTH))
/*@}*/

/*!
 * @name Register USB_STAT, field TX[3] (RO)
 *
 * Values:
 * - 0b0 - The most recent transaction was a receive operation.
 * - 0b1 - The most recent transaction was a transmit operation.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_TX field. */
#define USB_RD_STAT_TX(base) ((USB_STAT_REG(base) & USB_STAT_TX_MASK) >> USB_STAT_TX_SHIFT)
#define USB_BRD_STAT_TX(base) (BME_UBFX8(&USB_STAT_REG(base), USB_STAT_TX_SHIFT, USB_STAT_TX_WIDTH))
/*@}*/

/*!
 * @name Register USB_STAT, field ENDP[7:4] (RO)
 *
 * This four-bit field encodes the endpoint address that received or transmitted
 * the previous token. This allows the processor core to determine the BDT entry
 * that was updated by the last USB transaction.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_ENDP field. */
#define USB_RD_STAT_ENDP(base) ((USB_STAT_REG(base) & USB_STAT_ENDP_MASK) >> USB_STAT_ENDP_SHIFT)
#define USB_BRD_STAT_ENDP(base) (BME_UBFX8(&USB_STAT_REG(base), USB_STAT_ENDP_SHIFT, USB_STAT_ENDP_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_CTL - Control register
 ******************************************************************************/

/*!
 * @brief USB_CTL - Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Provides various control and configuration information for the USB module.
 */
/*!
 * @name Constants and macros for entire USB_CTL register
 */
/*@{*/
#define USB_RD_CTL(base)         (USB_CTL_REG(base))
#define USB_WR_CTL(base, value)  (USB_CTL_REG(base) = (value))
#define USB_RMW_CTL(base, mask, value) (USB_WR_CTL(base, (USB_RD_CTL(base) & ~(mask)) | (value)))
#define USB_SET_CTL(base, value) (BME_OR8(&USB_CTL_REG(base), (uint8_t)(value)))
#define USB_CLR_CTL(base, value) (BME_AND8(&USB_CTL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_CTL(base, value) (BME_XOR8(&USB_CTL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_CTL bitfields
 */

/*!
 * @name Register USB_CTL, field USBENSOFEN[0] (RW)
 *
 * Setting this bit enables the USB-FS to operate; clearing it disables the
 * USB-FS. Setting the bit causes the SIE to reset all of its ODD bits to the BDTs.
 * Therefore, setting this bit resets much of the logic in the SIE. When host mode
 * is enabled, clearing this bit causes the SIE to stop sending SOF tokens.
 *
 * Values:
 * - 0b0 - Disables the USB Module.
 * - 0b1 - Enables the USB Module.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_USBENSOFEN field. */
#define USB_RD_CTL_USBENSOFEN(base) ((USB_CTL_REG(base) & USB_CTL_USBENSOFEN_MASK) >> USB_CTL_USBENSOFEN_SHIFT)
#define USB_BRD_CTL_USBENSOFEN(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_USBENSOFEN_SHIFT, USB_CTL_USBENSOFEN_WIDTH))

/*! @brief Set the USBENSOFEN field to a new value. */
#define USB_WR_CTL_USBENSOFEN(base, value) (USB_RMW_CTL(base, USB_CTL_USBENSOFEN_MASK, USB_CTL_USBENSOFEN(value)))
#define USB_BWR_CTL_USBENSOFEN(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_USBENSOFEN_SHIFT), USB_CTL_USBENSOFEN_SHIFT, USB_CTL_USBENSOFEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_CTL, field ODDRST[1] (RW)
 *
 * Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which
 * then specifies the EVEN BDT bank.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_ODDRST field. */
#define USB_RD_CTL_ODDRST(base) ((USB_CTL_REG(base) & USB_CTL_ODDRST_MASK) >> USB_CTL_ODDRST_SHIFT)
#define USB_BRD_CTL_ODDRST(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_ODDRST_SHIFT, USB_CTL_ODDRST_WIDTH))

/*! @brief Set the ODDRST field to a new value. */
#define USB_WR_CTL_ODDRST(base, value) (USB_RMW_CTL(base, USB_CTL_ODDRST_MASK, USB_CTL_ODDRST(value)))
#define USB_BWR_CTL_ODDRST(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_ODDRST_SHIFT), USB_CTL_ODDRST_SHIFT, USB_CTL_ODDRST_WIDTH))
/*@}*/

/*!
 * @name Register USB_CTL, field RESUME[2] (RW)
 *
 * When set to 1 this bit enables the USB Module to execute resume signaling.
 * This allows the USB Module to perform remote wake-up. Software must set RESUME
 * to 1 for the required amount of time and then clear it to 0. If HOSTMODEENis
 * set, the USB module appends a Low Speed End of Packet to the Resume signaling
 * when the RESUME bit is cleared. For more information on RESUME signaling see
 * Section 7.1.4.5 of the USB specification version 1.0.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_RESUME field. */
#define USB_RD_CTL_RESUME(base) ((USB_CTL_REG(base) & USB_CTL_RESUME_MASK) >> USB_CTL_RESUME_SHIFT)
#define USB_BRD_CTL_RESUME(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_RESUME_SHIFT, USB_CTL_RESUME_WIDTH))

/*! @brief Set the RESUME field to a new value. */
#define USB_WR_CTL_RESUME(base, value) (USB_RMW_CTL(base, USB_CTL_RESUME_MASK, USB_CTL_RESUME(value)))
#define USB_BWR_CTL_RESUME(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_RESUME_SHIFT), USB_CTL_RESUME_SHIFT, USB_CTL_RESUME_WIDTH))
/*@}*/

/*!
 * @name Register USB_CTL, field HOSTMODEEN[3] (RW)
 *
 * When set to 1, this bit enables the USB Module to operate in Host mode. In
 * host mode, the USB module performs USB transactions under the programmed control
 * of the host processor.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_HOSTMODEEN field. */
#define USB_RD_CTL_HOSTMODEEN(base) ((USB_CTL_REG(base) & USB_CTL_HOSTMODEEN_MASK) >> USB_CTL_HOSTMODEEN_SHIFT)
#define USB_BRD_CTL_HOSTMODEEN(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_HOSTMODEEN_SHIFT, USB_CTL_HOSTMODEEN_WIDTH))

/*! @brief Set the HOSTMODEEN field to a new value. */
#define USB_WR_CTL_HOSTMODEEN(base, value) (USB_RMW_CTL(base, USB_CTL_HOSTMODEEN_MASK, USB_CTL_HOSTMODEEN(value)))
#define USB_BWR_CTL_HOSTMODEEN(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_HOSTMODEEN_SHIFT), USB_CTL_HOSTMODEEN_SHIFT, USB_CTL_HOSTMODEEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_CTL, field RESET[4] (RW)
 *
 * Setting this bit enables the USB Module to generate USB reset signaling. This
 * allows the USB Module to reset USB peripherals. This control signal is only
 * valid in Host mode (CTL[HOSTMODEEN]=1). Software must set RESET to 1 for the
 * required amount of time and then clear it to 0 to end reset signaling. For more
 * information on reset signaling see Section 7.1.4.3 of the USB specification
 * version 1.0.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_RESET field. */
#define USB_RD_CTL_RESET(base) ((USB_CTL_REG(base) & USB_CTL_RESET_MASK) >> USB_CTL_RESET_SHIFT)
#define USB_BRD_CTL_RESET(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_RESET_SHIFT, USB_CTL_RESET_WIDTH))

/*! @brief Set the RESET field to a new value. */
#define USB_WR_CTL_RESET(base, value) (USB_RMW_CTL(base, USB_CTL_RESET_MASK, USB_CTL_RESET(value)))
#define USB_BWR_CTL_RESET(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_RESET_SHIFT), USB_CTL_RESET_SHIFT, USB_CTL_RESET_WIDTH))
/*@}*/

/*!
 * @name Register USB_CTL, field TXSUSPENDTOKENBUSY[5] (RW)
 *
 * In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB
 * token. Software must not write more token commands to the Token Register when
 * TOKEN_BUSY is set. Software should check this field before writing any tokens
 * to the Token Register to ensure that token commands are not lost. In Target
 * mode, TXD_SUSPEND is set when the SIE has disabled packet transmission and
 * reception. Clearing this bit allows the SIE to continue token processing. This bit
 * is set by the SIE when a SETUP Token is received allowing software to dequeue
 * any pending packet transactions in the BDT before resuming token processing.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_TXSUSPENDTOKENBUSY field. */
#define USB_RD_CTL_TXSUSPENDTOKENBUSY(base) ((USB_CTL_REG(base) & USB_CTL_TXSUSPENDTOKENBUSY_MASK) >> USB_CTL_TXSUSPENDTOKENBUSY_SHIFT)
#define USB_BRD_CTL_TXSUSPENDTOKENBUSY(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_TXSUSPENDTOKENBUSY_SHIFT, USB_CTL_TXSUSPENDTOKENBUSY_WIDTH))

/*! @brief Set the TXSUSPENDTOKENBUSY field to a new value. */
#define USB_WR_CTL_TXSUSPENDTOKENBUSY(base, value) (USB_RMW_CTL(base, USB_CTL_TXSUSPENDTOKENBUSY_MASK, USB_CTL_TXSUSPENDTOKENBUSY(value)))
#define USB_BWR_CTL_TXSUSPENDTOKENBUSY(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_TXSUSPENDTOKENBUSY_SHIFT), USB_CTL_TXSUSPENDTOKENBUSY_SHIFT, USB_CTL_TXSUSPENDTOKENBUSY_WIDTH))
/*@}*/

/*!
 * @name Register USB_CTL, field SE0[6] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_SE0 field. */
#define USB_RD_CTL_SE0(base) ((USB_CTL_REG(base) & USB_CTL_SE0_MASK) >> USB_CTL_SE0_SHIFT)
#define USB_BRD_CTL_SE0(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_SE0_SHIFT, USB_CTL_SE0_WIDTH))

/*! @brief Set the SE0 field to a new value. */
#define USB_WR_CTL_SE0(base, value) (USB_RMW_CTL(base, USB_CTL_SE0_MASK, USB_CTL_SE0(value)))
#define USB_BWR_CTL_SE0(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_SE0_SHIFT), USB_CTL_SE0_SHIFT, USB_CTL_SE0_WIDTH))
/*@}*/

/*!
 * @name Register USB_CTL, field JSTATE[7] (RW)
 *
 * The polarity of this signal is affected by the current state of LSEN .
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_JSTATE field. */
#define USB_RD_CTL_JSTATE(base) ((USB_CTL_REG(base) & USB_CTL_JSTATE_MASK) >> USB_CTL_JSTATE_SHIFT)
#define USB_BRD_CTL_JSTATE(base) (BME_UBFX8(&USB_CTL_REG(base), USB_CTL_JSTATE_SHIFT, USB_CTL_JSTATE_WIDTH))

/*! @brief Set the JSTATE field to a new value. */
#define USB_WR_CTL_JSTATE(base, value) (USB_RMW_CTL(base, USB_CTL_JSTATE_MASK, USB_CTL_JSTATE(value)))
#define USB_BWR_CTL_JSTATE(base, value) (BME_BFI8(&USB_CTL_REG(base), ((uint8_t)(value) << USB_CTL_JSTATE_SHIFT), USB_CTL_JSTATE_SHIFT, USB_CTL_JSTATE_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_ADDR - Address register
 ******************************************************************************/

/*!
 * @brief USB_ADDR - Address register (RW)
 *
 * Reset value: 0x00U
 *
 * Holds the unique USB address that the USB module decodes when in Peripheral
 * mode (CTL[HOSTMODEEN]=0). When operating in Host mode (CTL[HOSTMODEEN]=1) the
 * USB module transmits this address with a TOKEN packet. This enables the USB
 * module to uniquely address any USB peripheral. In either mode, CTL[USBENSOFEN]
 * must be 1. The Address register is reset to 0x00 after the reset input becomes
 * active or the USB module decodes a USB reset signal. This action initializes
 * the Address register to decode address 0x00 as required by the USB specification.
 */
/*!
 * @name Constants and macros for entire USB_ADDR register
 */
/*@{*/
#define USB_RD_ADDR(base)        (USB_ADDR_REG(base))
#define USB_WR_ADDR(base, value) (USB_ADDR_REG(base) = (value))
#define USB_RMW_ADDR(base, mask, value) (USB_WR_ADDR(base, (USB_RD_ADDR(base) & ~(mask)) | (value)))
#define USB_SET_ADDR(base, value) (BME_OR8(&USB_ADDR_REG(base), (uint8_t)(value)))
#define USB_CLR_ADDR(base, value) (BME_AND8(&USB_ADDR_REG(base), (uint8_t)(~(value))))
#define USB_TOG_ADDR(base, value) (BME_XOR8(&USB_ADDR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_ADDR bitfields
 */

/*!
 * @name Register USB_ADDR, field ADDR[6:0] (RW)
 *
 * Defines the USB address that the USB module decodes in peripheral mode, or
 * transmits when in host mode.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDR_ADDR field. */
#define USB_RD_ADDR_ADDR(base) ((USB_ADDR_REG(base) & USB_ADDR_ADDR_MASK) >> USB_ADDR_ADDR_SHIFT)
#define USB_BRD_ADDR_ADDR(base) (BME_UBFX8(&USB_ADDR_REG(base), USB_ADDR_ADDR_SHIFT, USB_ADDR_ADDR_WIDTH))

/*! @brief Set the ADDR field to a new value. */
#define USB_WR_ADDR_ADDR(base, value) (USB_RMW_ADDR(base, USB_ADDR_ADDR_MASK, USB_ADDR_ADDR(value)))
#define USB_BWR_ADDR_ADDR(base, value) (BME_BFI8(&USB_ADDR_REG(base), ((uint8_t)(value) << USB_ADDR_ADDR_SHIFT), USB_ADDR_ADDR_SHIFT, USB_ADDR_ADDR_WIDTH))
/*@}*/

/*!
 * @name Register USB_ADDR, field LSEN[7] (RW)
 *
 * Informs the USB module that the next token command written to the token
 * register must be performed at low speed. This enables the USB module to perform the
 * necessary preamble required for low-speed data transmissions.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDR_LSEN field. */
#define USB_RD_ADDR_LSEN(base) ((USB_ADDR_REG(base) & USB_ADDR_LSEN_MASK) >> USB_ADDR_LSEN_SHIFT)
#define USB_BRD_ADDR_LSEN(base) (BME_UBFX8(&USB_ADDR_REG(base), USB_ADDR_LSEN_SHIFT, USB_ADDR_LSEN_WIDTH))

/*! @brief Set the LSEN field to a new value. */
#define USB_WR_ADDR_LSEN(base, value) (USB_RMW_ADDR(base, USB_ADDR_LSEN_MASK, USB_ADDR_LSEN(value)))
#define USB_BWR_ADDR_LSEN(base, value) (BME_BFI8(&USB_ADDR_REG(base), ((uint8_t)(value) << USB_ADDR_LSEN_SHIFT), USB_ADDR_LSEN_SHIFT, USB_ADDR_LSEN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE1 - BDT Page register 1
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE1 - BDT Page register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Provides address bits 15 through 9 of the base address where the current
 * Buffer Descriptor Table (BDT) resides in system memory. See Buffer Descriptor
 * Table. The 32-bit BDT Base Address is always aligned on 512-byte boundaries, so
 * bits 8 through 0 of the base address are always zero.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE1 register
 */
/*@{*/
#define USB_RD_BDTPAGE1(base)    (USB_BDTPAGE1_REG(base))
#define USB_WR_BDTPAGE1(base, value) (USB_BDTPAGE1_REG(base) = (value))
#define USB_RMW_BDTPAGE1(base, mask, value) (USB_WR_BDTPAGE1(base, (USB_RD_BDTPAGE1(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE1(base, value) (BME_OR8(&USB_BDTPAGE1_REG(base), (uint8_t)(value)))
#define USB_CLR_BDTPAGE1(base, value) (BME_AND8(&USB_BDTPAGE1_REG(base), (uint8_t)(~(value))))
#define USB_TOG_BDTPAGE1(base, value) (BME_XOR8(&USB_BDTPAGE1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE1 bitfields
 */

/*!
 * @name Register USB_BDTPAGE1, field BDTBA[7:1] (RW)
 *
 * Provides address bits 15 through 9 of the BDT base address.
 */
/*@{*/
/*! @brief Read current value of the USB_BDTPAGE1_BDTBA field. */
#define USB_RD_BDTPAGE1_BDTBA(base) ((USB_BDTPAGE1_REG(base) & USB_BDTPAGE1_BDTBA_MASK) >> USB_BDTPAGE1_BDTBA_SHIFT)
#define USB_BRD_BDTPAGE1_BDTBA(base) (BME_UBFX8(&USB_BDTPAGE1_REG(base), USB_BDTPAGE1_BDTBA_SHIFT, USB_BDTPAGE1_BDTBA_WIDTH))

/*! @brief Set the BDTBA field to a new value. */
#define USB_WR_BDTPAGE1_BDTBA(base, value) (USB_RMW_BDTPAGE1(base, USB_BDTPAGE1_BDTBA_MASK, USB_BDTPAGE1_BDTBA(value)))
#define USB_BWR_BDTPAGE1_BDTBA(base, value) (BME_BFI8(&USB_BDTPAGE1_REG(base), ((uint8_t)(value) << USB_BDTPAGE1_BDTBA_SHIFT), USB_BDTPAGE1_BDTBA_SHIFT, USB_BDTPAGE1_BDTBA_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_FRMNUML - Frame Number register Low
 ******************************************************************************/

/*!
 * @brief USB_FRMNUML - Frame Number register Low (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
/*!
 * @name Constants and macros for entire USB_FRMNUML register
 */
/*@{*/
#define USB_RD_FRMNUML(base)     (USB_FRMNUML_REG(base))
#define USB_WR_FRMNUML(base, value) (USB_FRMNUML_REG(base) = (value))
#define USB_RMW_FRMNUML(base, mask, value) (USB_WR_FRMNUML(base, (USB_RD_FRMNUML(base) & ~(mask)) | (value)))
#define USB_SET_FRMNUML(base, value) (BME_OR8(&USB_FRMNUML_REG(base), (uint8_t)(value)))
#define USB_CLR_FRMNUML(base, value) (BME_AND8(&USB_FRMNUML_REG(base), (uint8_t)(~(value))))
#define USB_TOG_FRMNUML(base, value) (BME_XOR8(&USB_FRMNUML_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * USB_FRMNUMH - Frame Number register High
 ******************************************************************************/

/*!
 * @brief USB_FRMNUMH - Frame Number register High (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
/*!
 * @name Constants and macros for entire USB_FRMNUMH register
 */
/*@{*/
#define USB_RD_FRMNUMH(base)     (USB_FRMNUMH_REG(base))
#define USB_WR_FRMNUMH(base, value) (USB_FRMNUMH_REG(base) = (value))
#define USB_RMW_FRMNUMH(base, mask, value) (USB_WR_FRMNUMH(base, (USB_RD_FRMNUMH(base) & ~(mask)) | (value)))
#define USB_SET_FRMNUMH(base, value) (BME_OR8(&USB_FRMNUMH_REG(base), (uint8_t)(value)))
#define USB_CLR_FRMNUMH(base, value) (BME_AND8(&USB_FRMNUMH_REG(base), (uint8_t)(~(value))))
#define USB_TOG_FRMNUMH(base, value) (BME_XOR8(&USB_FRMNUMH_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUMH bitfields
 */

/*!
 * @name Register USB_FRMNUMH, field FRM[2:0] (RW)
 *
 * This 3-bit field and the 8-bit field in the Frame Number Register Low are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
/*! @brief Read current value of the USB_FRMNUMH_FRM field. */
#define USB_RD_FRMNUMH_FRM(base) ((USB_FRMNUMH_REG(base) & USB_FRMNUMH_FRM_MASK) >> USB_FRMNUMH_FRM_SHIFT)
#define USB_BRD_FRMNUMH_FRM(base) (BME_UBFX8(&USB_FRMNUMH_REG(base), USB_FRMNUMH_FRM_SHIFT, USB_FRMNUMH_FRM_WIDTH))

/*! @brief Set the FRM field to a new value. */
#define USB_WR_FRMNUMH_FRM(base, value) (USB_RMW_FRMNUMH(base, USB_FRMNUMH_FRM_MASK, USB_FRMNUMH_FRM(value)))
#define USB_BWR_FRMNUMH_FRM(base, value) (BME_BFI8(&USB_FRMNUMH_REG(base), ((uint8_t)(value) << USB_FRMNUMH_FRM_SHIFT), USB_FRMNUMH_FRM_SHIFT, USB_FRMNUMH_FRM_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_TOKEN - Token register
 ******************************************************************************/

/*!
 * @brief USB_TOKEN - Token register (RW)
 *
 * Reset value: 0x00U
 *
 * Used to initiate USB transactions when in host mode (CTL[HOSTMODEEN]=1). When
 * the software needs to execute a USB transaction to a peripheral, it writes
 * the TOKEN type and endpoint to this register. After this register has been
 * written, the USB module begins the specified USB transaction to the address
 * contained in the address register. The processor core must always check that the
 * TOKEN_BUSY bit in the control register is not 1 before writing to the Token
 * Register. This ensures that the token commands are not overwritten before they can
 * be executed. The address register and endpoint control register 0 are also used
 * when performing a token command and therefore must also be written before the
 * Token Register. The address register is used to select the USB peripheral
 * address transmitted by the token command. The endpoint control register
 * determines the handshake and retry policies used during the transfer.
 */
/*!
 * @name Constants and macros for entire USB_TOKEN register
 */
/*@{*/
#define USB_RD_TOKEN(base)       (USB_TOKEN_REG(base))
#define USB_WR_TOKEN(base, value) (USB_TOKEN_REG(base) = (value))
#define USB_RMW_TOKEN(base, mask, value) (USB_WR_TOKEN(base, (USB_RD_TOKEN(base) & ~(mask)) | (value)))
#define USB_SET_TOKEN(base, value) (BME_OR8(&USB_TOKEN_REG(base), (uint8_t)(value)))
#define USB_CLR_TOKEN(base, value) (BME_AND8(&USB_TOKEN_REG(base), (uint8_t)(~(value))))
#define USB_TOG_TOKEN(base, value) (BME_XOR8(&USB_TOKEN_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_TOKEN bitfields
 */

/*!
 * @name Register USB_TOKEN, field TOKENENDPT[3:0] (RW)
 *
 * Holds the Endpoint address for the token command. The four bit value written
 * must be a valid endpoint.
 */
/*@{*/
/*! @brief Read current value of the USB_TOKEN_TOKENENDPT field. */
#define USB_RD_TOKEN_TOKENENDPT(base) ((USB_TOKEN_REG(base) & USB_TOKEN_TOKENENDPT_MASK) >> USB_TOKEN_TOKENENDPT_SHIFT)
#define USB_BRD_TOKEN_TOKENENDPT(base) (BME_UBFX8(&USB_TOKEN_REG(base), USB_TOKEN_TOKENENDPT_SHIFT, USB_TOKEN_TOKENENDPT_WIDTH))

/*! @brief Set the TOKENENDPT field to a new value. */
#define USB_WR_TOKEN_TOKENENDPT(base, value) (USB_RMW_TOKEN(base, USB_TOKEN_TOKENENDPT_MASK, USB_TOKEN_TOKENENDPT(value)))
#define USB_BWR_TOKEN_TOKENENDPT(base, value) (BME_BFI8(&USB_TOKEN_REG(base), ((uint8_t)(value) << USB_TOKEN_TOKENENDPT_SHIFT), USB_TOKEN_TOKENENDPT_SHIFT, USB_TOKEN_TOKENENDPT_WIDTH))
/*@}*/

/*!
 * @name Register USB_TOKEN, field TOKENPID[7:4] (RW)
 *
 * Contains the token type executed by the USB module.
 *
 * Values:
 * - 0b0001 - OUT Token. USB Module performs an OUT (TX) transaction.
 * - 0b1001 - IN Token. USB Module performs an In (RX) transaction.
 * - 0b1101 - SETUP Token. USB Module performs a SETUP (TX) transaction
 */
/*@{*/
/*! @brief Read current value of the USB_TOKEN_TOKENPID field. */
#define USB_RD_TOKEN_TOKENPID(base) ((USB_TOKEN_REG(base) & USB_TOKEN_TOKENPID_MASK) >> USB_TOKEN_TOKENPID_SHIFT)
#define USB_BRD_TOKEN_TOKENPID(base) (BME_UBFX8(&USB_TOKEN_REG(base), USB_TOKEN_TOKENPID_SHIFT, USB_TOKEN_TOKENPID_WIDTH))

/*! @brief Set the TOKENPID field to a new value. */
#define USB_WR_TOKEN_TOKENPID(base, value) (USB_RMW_TOKEN(base, USB_TOKEN_TOKENPID_MASK, USB_TOKEN_TOKENPID(value)))
#define USB_BWR_TOKEN_TOKENPID(base, value) (BME_BFI8(&USB_TOKEN_REG(base), ((uint8_t)(value) << USB_TOKEN_TOKENPID_SHIFT), USB_TOKEN_TOKENPID_SHIFT, USB_TOKEN_TOKENPID_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_SOFTHLD - SOF Threshold register
 ******************************************************************************/

/*!
 * @brief USB_SOFTHLD - SOF Threshold register (RW)
 *
 * Reset value: 0x00U
 *
 * The SOF Threshold Register is used only in Host mode (CTL[HOSTMODEEN]=1).
 * When in Host mode, the 14-bit SOF counter counts the interval between SOF frames.
 * The SOF must be transmitted every 1ms so therefore the SOF counter is loaded
 * with a value of 12000. When the SOF counter reaches zero, a Start Of Frame
 * (SOF) token is transmitted. The SOF threshold register is used to program the
 * number of USB byte times when SOFDYNTHLD=0, or 8 byte times when SOFDYNTHLD=1,
 * before the SOF stops initiating token packet transactions. This register must be
 * set to a value that ensures that other packets are not actively being
 * transmitted when the SOF time counts to zero. When the SOF counter reaches the
 * threshold value, no more tokens are transmitted until after the SOF has been
 * transmitted. The value programmed into the threshold register must reserve enough
 * time to ensure the worst case transaction completes. In general the worst case
 * transaction is an IN token followed by a data packet from the target followed by
 * the response from the host. The actual time required is a function of the
 * maximum packet size on the bus. Typical values for the SOF threshold are: 64-byte
 * packets=74; 32-byte packets=42; 16-byte packets=26; 8-byte packets=18.
 */
/*!
 * @name Constants and macros for entire USB_SOFTHLD register
 */
/*@{*/
#define USB_RD_SOFTHLD(base)     (USB_SOFTHLD_REG(base))
#define USB_WR_SOFTHLD(base, value) (USB_SOFTHLD_REG(base) = (value))
#define USB_RMW_SOFTHLD(base, mask, value) (USB_WR_SOFTHLD(base, (USB_RD_SOFTHLD(base) & ~(mask)) | (value)))
#define USB_SET_SOFTHLD(base, value) (BME_OR8(&USB_SOFTHLD_REG(base), (uint8_t)(value)))
#define USB_CLR_SOFTHLD(base, value) (BME_AND8(&USB_SOFTHLD_REG(base), (uint8_t)(~(value))))
#define USB_TOG_SOFTHLD(base, value) (BME_XOR8(&USB_SOFTHLD_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE2 - BDT Page Register 2
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE2 - BDT Page Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE2 register
 */
/*@{*/
#define USB_RD_BDTPAGE2(base)    (USB_BDTPAGE2_REG(base))
#define USB_WR_BDTPAGE2(base, value) (USB_BDTPAGE2_REG(base) = (value))
#define USB_RMW_BDTPAGE2(base, mask, value) (USB_WR_BDTPAGE2(base, (USB_RD_BDTPAGE2(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE2(base, value) (BME_OR8(&USB_BDTPAGE2_REG(base), (uint8_t)(value)))
#define USB_CLR_BDTPAGE2(base, value) (BME_AND8(&USB_BDTPAGE2_REG(base), (uint8_t)(~(value))))
#define USB_TOG_BDTPAGE2(base, value) (BME_XOR8(&USB_BDTPAGE2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE3 - BDT Page Register 3
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE3 - BDT Page Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE3 register
 */
/*@{*/
#define USB_RD_BDTPAGE3(base)    (USB_BDTPAGE3_REG(base))
#define USB_WR_BDTPAGE3(base, value) (USB_BDTPAGE3_REG(base) = (value))
#define USB_RMW_BDTPAGE3(base, mask, value) (USB_WR_BDTPAGE3(base, (USB_RD_BDTPAGE3(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE3(base, value) (BME_OR8(&USB_BDTPAGE3_REG(base), (uint8_t)(value)))
#define USB_CLR_BDTPAGE3(base, value) (BME_AND8(&USB_BDTPAGE3_REG(base), (uint8_t)(~(value))))
#define USB_TOG_BDTPAGE3(base, value) (BME_XOR8(&USB_BDTPAGE3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * USB_ENDPT - Endpoint Control register
 ******************************************************************************/

/*!
 * @brief USB_ENDPT - Endpoint Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains the endpoint control bits for each of the 16 endpoints available
 * within the USB module for a decoded address. The format for these registers is
 * shown in the following figure. Endpoint 0 (ENDPT0) is associated with control
 * pipe 0, which is required for all USB functions. Therefore, after a USBRST
 * interrupt occurs the processor core should set ENDPT0 to contain 0x0D. In Host mode
 * ENDPT0 is used to determine the handshake, retry and low speed
 * characteristics of the host transfer. For Control, Bulk and Interrupt transfers, the EPHSHK
 * bit should be 1. For Isochronous transfers it should be 0. Common values to
 * use for ENDPT0 in host mode are 0x4D for Control, Bulk, and Interrupt transfers,
 * and 0x4C for Isochronous transfers. The three bits EPCTLDIS, EPRXEN, and
 * EPTXEN define if an endpoint is enabled and define the direction of the endpoint.
 * The endpoint enable/direction control is defined in the following table.
 * Endpoint enable and direction control EPCTLDIS EPRXEN EPTXEN Endpoint
 * enable/direction control X 0 0 Disable endpoint X 0 1 Enable endpoint for Tx transfers only
 * X 1 0 Enable endpoint for Rx transfers only 1 1 1 Enable endpoint for Rx and
 * Tx transfers 0 1 1 Enable Endpoint for RX and TX as well as control (SETUP)
 * transfers.
 */
/*!
 * @name Constants and macros for entire USB_ENDPT register
 */
/*@{*/
#define USB_RD_ENDPT(base, index) (USB_ENDPT_REG(base, index))
#define USB_WR_ENDPT(base, index, value) (USB_ENDPT_REG(base, index) = (value))
#define USB_RMW_ENDPT(base, index, mask, value) (USB_WR_ENDPT(base, index, (USB_RD_ENDPT(base, index) & ~(mask)) | (value)))
#define USB_SET_ENDPT(base, index, value) (BME_OR8(&USB_ENDPT_REG(base, index), (uint8_t)(value)))
#define USB_CLR_ENDPT(base, index, value) (BME_AND8(&USB_ENDPT_REG(base, index), (uint8_t)(~(value))))
#define USB_TOG_ENDPT(base, index, value) (BME_XOR8(&USB_ENDPT_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_ENDPT bitfields
 */

/*!
 * @name Register USB_ENDPT, field EPHSHK[0] (RW)
 *
 * When set this bit enables an endpoint to perform handshaking during a
 * transaction to this endpoint. This bit is generally 1 unless the endpoint is
 * Isochronous.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPHSHK field. */
#define USB_RD_ENDPT_EPHSHK(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPHSHK_MASK) >> USB_ENDPT_EPHSHK_SHIFT)
#define USB_BRD_ENDPT_EPHSHK(base, index) (BME_UBFX8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPHSHK_SHIFT, USB_ENDPT_EPHSHK_WIDTH))

/*! @brief Set the EPHSHK field to a new value. */
#define USB_WR_ENDPT_EPHSHK(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPHSHK_MASK, USB_ENDPT_EPHSHK(value)))
#define USB_BWR_ENDPT_EPHSHK(base, index, value) (BME_BFI8(&USB_ENDPT_REG(base, index), ((uint8_t)(value) << USB_ENDPT_EPHSHK_SHIFT), USB_ENDPT_EPHSHK_SHIFT, USB_ENDPT_EPHSHK_WIDTH))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPSTALL[1] (RW)
 *
 * When set this bit indicates that the endpoint is called. This bit has
 * priority over all other control bits in the EndPoint Enable Register, but it is only
 * valid if EPTXEN=1 or EPRXEN=1. Any access to this endpoint causes the USB
 * Module to return a STALL handshake. After an endpoint is stalled it requires
 * intervention from the Host Controller.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPSTALL field. */
#define USB_RD_ENDPT_EPSTALL(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPSTALL_MASK) >> USB_ENDPT_EPSTALL_SHIFT)
#define USB_BRD_ENDPT_EPSTALL(base, index) (BME_UBFX8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPSTALL_SHIFT, USB_ENDPT_EPSTALL_WIDTH))

/*! @brief Set the EPSTALL field to a new value. */
#define USB_WR_ENDPT_EPSTALL(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPSTALL_MASK, USB_ENDPT_EPSTALL(value)))
#define USB_BWR_ENDPT_EPSTALL(base, index, value) (BME_BFI8(&USB_ENDPT_REG(base, index), ((uint8_t)(value) << USB_ENDPT_EPSTALL_SHIFT), USB_ENDPT_EPSTALL_SHIFT, USB_ENDPT_EPSTALL_WIDTH))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPTXEN[2] (RW)
 *
 * This bit, when set, enables the endpoint for TX transfers. See
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPTXEN field. */
#define USB_RD_ENDPT_EPTXEN(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPTXEN_MASK) >> USB_ENDPT_EPTXEN_SHIFT)
#define USB_BRD_ENDPT_EPTXEN(base, index) (BME_UBFX8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPTXEN_SHIFT, USB_ENDPT_EPTXEN_WIDTH))

/*! @brief Set the EPTXEN field to a new value. */
#define USB_WR_ENDPT_EPTXEN(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPTXEN_MASK, USB_ENDPT_EPTXEN(value)))
#define USB_BWR_ENDPT_EPTXEN(base, index, value) (BME_BFI8(&USB_ENDPT_REG(base, index), ((uint8_t)(value) << USB_ENDPT_EPTXEN_SHIFT), USB_ENDPT_EPTXEN_SHIFT, USB_ENDPT_EPTXEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPRXEN[3] (RW)
 *
 * This bit, when set, enables the endpoint for RX transfers. See
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPRXEN field. */
#define USB_RD_ENDPT_EPRXEN(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPRXEN_MASK) >> USB_ENDPT_EPRXEN_SHIFT)
#define USB_BRD_ENDPT_EPRXEN(base, index) (BME_UBFX8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPRXEN_SHIFT, USB_ENDPT_EPRXEN_WIDTH))

/*! @brief Set the EPRXEN field to a new value. */
#define USB_WR_ENDPT_EPRXEN(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPRXEN_MASK, USB_ENDPT_EPRXEN(value)))
#define USB_BWR_ENDPT_EPRXEN(base, index, value) (BME_BFI8(&USB_ENDPT_REG(base, index), ((uint8_t)(value) << USB_ENDPT_EPRXEN_SHIFT), USB_ENDPT_EPRXEN_SHIFT, USB_ENDPT_EPRXEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPCTLDIS[4] (RW)
 *
 * This bit, when set, disables control (SETUP) transfers. When cleared, control
 * transfers are enabled. This applies if and only if the EPRXEN and EPTXEN bits
 * are also set. See
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPCTLDIS field. */
#define USB_RD_ENDPT_EPCTLDIS(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPCTLDIS_MASK) >> USB_ENDPT_EPCTLDIS_SHIFT)
#define USB_BRD_ENDPT_EPCTLDIS(base, index) (BME_UBFX8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPCTLDIS_SHIFT, USB_ENDPT_EPCTLDIS_WIDTH))

/*! @brief Set the EPCTLDIS field to a new value. */
#define USB_WR_ENDPT_EPCTLDIS(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPCTLDIS_MASK, USB_ENDPT_EPCTLDIS(value)))
#define USB_BWR_ENDPT_EPCTLDIS(base, index, value) (BME_BFI8(&USB_ENDPT_REG(base, index), ((uint8_t)(value) << USB_ENDPT_EPCTLDIS_SHIFT), USB_ENDPT_EPCTLDIS_SHIFT, USB_ENDPT_EPCTLDIS_WIDTH))
/*@}*/

/*!
 * @name Register USB_ENDPT, field RETRYDIS[6] (RW)
 *
 * This is a Host mode only bit and is present in the control register for
 * endpoint 0 (ENDPT0) only. When set this bit causes the host to not retry NAK'ed
 * (Negative Acknowledgement) transactions. When a transaction is NAKed, the BDT PID
 * field is updated with the NAK PID, and the TOKEN_DNE interrupt is set. When
 * this bit is cleared, NAKed transactions are retried in hardware. This bit must
 * be set when the host is attempting to poll an interrupt endpoint.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_RETRYDIS field. */
#define USB_RD_ENDPT_RETRYDIS(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_RETRYDIS_MASK) >> USB_ENDPT_RETRYDIS_SHIFT)
#define USB_BRD_ENDPT_RETRYDIS(base, index) (BME_UBFX8(&USB_ENDPT_REG(base, index), USB_ENDPT_RETRYDIS_SHIFT, USB_ENDPT_RETRYDIS_WIDTH))

/*! @brief Set the RETRYDIS field to a new value. */
#define USB_WR_ENDPT_RETRYDIS(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_RETRYDIS_MASK, USB_ENDPT_RETRYDIS(value)))
#define USB_BWR_ENDPT_RETRYDIS(base, index, value) (BME_BFI8(&USB_ENDPT_REG(base, index), ((uint8_t)(value) << USB_ENDPT_RETRYDIS_SHIFT), USB_ENDPT_RETRYDIS_SHIFT, USB_ENDPT_RETRYDIS_WIDTH))
/*@}*/

/*!
 * @name Register USB_ENDPT, field HOSTWOHUB[7] (RW)
 *
 * Host without a hub This is a Host mode only field and is present in the
 * control register for endpoint 0 (ENDPT0) only.
 *
 * Values:
 * - 0b0 - Low-speed device connected to Host through a hub. PRE_PID will be
 *     generated as required.
 * - 0b1 - Low-speed device directly connected. No hub, or no low-speed device
 *     attached.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_HOSTWOHUB field. */
#define USB_RD_ENDPT_HOSTWOHUB(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_HOSTWOHUB_MASK) >> USB_ENDPT_HOSTWOHUB_SHIFT)
#define USB_BRD_ENDPT_HOSTWOHUB(base, index) (BME_UBFX8(&USB_ENDPT_REG(base, index), USB_ENDPT_HOSTWOHUB_SHIFT, USB_ENDPT_HOSTWOHUB_WIDTH))

/*! @brief Set the HOSTWOHUB field to a new value. */
#define USB_WR_ENDPT_HOSTWOHUB(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_HOSTWOHUB_MASK, USB_ENDPT_HOSTWOHUB(value)))
#define USB_BWR_ENDPT_HOSTWOHUB(base, index, value) (BME_BFI8(&USB_ENDPT_REG(base, index), ((uint8_t)(value) << USB_ENDPT_HOSTWOHUB_SHIFT), USB_ENDPT_HOSTWOHUB_SHIFT, USB_ENDPT_HOSTWOHUB_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_USBCTRL - USB Control register
 ******************************************************************************/

/*!
 * @brief USB_USBCTRL - USB Control register (RW)
 *
 * Reset value: 0xC0U
 */
/*!
 * @name Constants and macros for entire USB_USBCTRL register
 */
/*@{*/
#define USB_RD_USBCTRL(base)     (USB_USBCTRL_REG(base))
#define USB_WR_USBCTRL(base, value) (USB_USBCTRL_REG(base) = (value))
#define USB_RMW_USBCTRL(base, mask, value) (USB_WR_USBCTRL(base, (USB_RD_USBCTRL(base) & ~(mask)) | (value)))
#define USB_SET_USBCTRL(base, value) (BME_OR8(&USB_USBCTRL_REG(base), (uint8_t)(value)))
#define USB_CLR_USBCTRL(base, value) (BME_AND8(&USB_USBCTRL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_USBCTRL(base, value) (BME_XOR8(&USB_USBCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_USBCTRL bitfields
 */

/*!
 * @name Register USB_USBCTRL, field UARTSEL[4] (RW)
 *
 * Selects USB signals to be used as UART signals.
 *
 * Values:
 * - 0b0 - USB signals not used as UART signals.
 * - 0b1 - USB signals used as UART signals.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_UARTSEL field. */
#define USB_RD_USBCTRL_UARTSEL(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_UARTSEL_MASK) >> USB_USBCTRL_UARTSEL_SHIFT)
#define USB_BRD_USBCTRL_UARTSEL(base) (BME_UBFX8(&USB_USBCTRL_REG(base), USB_USBCTRL_UARTSEL_SHIFT, USB_USBCTRL_UARTSEL_WIDTH))

/*! @brief Set the UARTSEL field to a new value. */
#define USB_WR_USBCTRL_UARTSEL(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_UARTSEL_MASK, USB_USBCTRL_UARTSEL(value)))
#define USB_BWR_USBCTRL_UARTSEL(base, value) (BME_BFI8(&USB_USBCTRL_REG(base), ((uint8_t)(value) << USB_USBCTRL_UARTSEL_SHIFT), USB_USBCTRL_UARTSEL_SHIFT, USB_USBCTRL_UARTSEL_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field UARTCHLS[5] (RW)
 *
 * This field is valid only when USB signals are selected to be used as UART
 * signals.
 *
 * Values:
 * - 0b0 - USB DP/DM signals used as UART TX/RX.
 * - 0b1 - USB DP/DM signals used as UART RX/TX.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_UARTCHLS field. */
#define USB_RD_USBCTRL_UARTCHLS(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_UARTCHLS_MASK) >> USB_USBCTRL_UARTCHLS_SHIFT)
#define USB_BRD_USBCTRL_UARTCHLS(base) (BME_UBFX8(&USB_USBCTRL_REG(base), USB_USBCTRL_UARTCHLS_SHIFT, USB_USBCTRL_UARTCHLS_WIDTH))

/*! @brief Set the UARTCHLS field to a new value. */
#define USB_WR_USBCTRL_UARTCHLS(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_UARTCHLS_MASK, USB_USBCTRL_UARTCHLS(value)))
#define USB_BWR_USBCTRL_UARTCHLS(base, value) (BME_BFI8(&USB_USBCTRL_REG(base), ((uint8_t)(value) << USB_USBCTRL_UARTCHLS_SHIFT), USB_USBCTRL_UARTCHLS_SHIFT, USB_USBCTRL_UARTCHLS_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field PDE[6] (RW)
 *
 * Enables the weak pulldowns on the USB transceiver.
 *
 * Values:
 * - 0b0 - Weak pulldowns are disabled on D+ and D-.
 * - 0b1 - Weak pulldowns are enabled on D+ and D-.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_PDE field. */
#define USB_RD_USBCTRL_PDE(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_PDE_MASK) >> USB_USBCTRL_PDE_SHIFT)
#define USB_BRD_USBCTRL_PDE(base) (BME_UBFX8(&USB_USBCTRL_REG(base), USB_USBCTRL_PDE_SHIFT, USB_USBCTRL_PDE_WIDTH))

/*! @brief Set the PDE field to a new value. */
#define USB_WR_USBCTRL_PDE(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_PDE_MASK, USB_USBCTRL_PDE(value)))
#define USB_BWR_USBCTRL_PDE(base, value) (BME_BFI8(&USB_USBCTRL_REG(base), ((uint8_t)(value) << USB_USBCTRL_PDE_SHIFT), USB_USBCTRL_PDE_SHIFT, USB_USBCTRL_PDE_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field SUSP[7] (RW)
 *
 * Places the USB transceiver into the suspend state.
 *
 * Values:
 * - 0b0 - USB transceiver is not in suspend state.
 * - 0b1 - USB transceiver is in suspend state.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_SUSP field. */
#define USB_RD_USBCTRL_SUSP(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_SUSP_MASK) >> USB_USBCTRL_SUSP_SHIFT)
#define USB_BRD_USBCTRL_SUSP(base) (BME_UBFX8(&USB_USBCTRL_REG(base), USB_USBCTRL_SUSP_SHIFT, USB_USBCTRL_SUSP_WIDTH))

/*! @brief Set the SUSP field to a new value. */
#define USB_WR_USBCTRL_SUSP(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_SUSP_MASK, USB_USBCTRL_SUSP(value)))
#define USB_BWR_USBCTRL_SUSP(base, value) (BME_BFI8(&USB_USBCTRL_REG(base), ((uint8_t)(value) << USB_USBCTRL_SUSP_SHIFT), USB_USBCTRL_SUSP_SHIFT, USB_USBCTRL_SUSP_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_OBSERVE - USB OTG Observe register
 ******************************************************************************/

/*!
 * @brief USB_OBSERVE - USB OTG Observe register (RO)
 *
 * Reset value: 0x50U
 *
 * Provides visibility on the state of the pull-ups and pull-downs at the
 * transceiver. Useful when interfacing to an external OTG control module via a serial
 * interface.
 */
/*!
 * @name Constants and macros for entire USB_OBSERVE register
 */
/*@{*/
#define USB_RD_OBSERVE(base)     (USB_OBSERVE_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_OBSERVE bitfields
 */

/*!
 * @name Register USB_OBSERVE, field DMPD[4] (RO)
 *
 * Provides observability of the D- Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0b0 - D- pulldown disabled.
 * - 0b1 - D- pulldown enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DMPD field. */
#define USB_RD_OBSERVE_DMPD(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DMPD_MASK) >> USB_OBSERVE_DMPD_SHIFT)
#define USB_BRD_OBSERVE_DMPD(base) (BME_UBFX8(&USB_OBSERVE_REG(base), USB_OBSERVE_DMPD_SHIFT, USB_OBSERVE_DMPD_WIDTH))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPD[6] (RO)
 *
 * Provides observability of the D+ Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0b0 - D+ pulldown disabled.
 * - 0b1 - D+ pulldown enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DPPD field. */
#define USB_RD_OBSERVE_DPPD(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DPPD_MASK) >> USB_OBSERVE_DPPD_SHIFT)
#define USB_BRD_OBSERVE_DPPD(base) (BME_UBFX8(&USB_OBSERVE_REG(base), USB_OBSERVE_DPPD_SHIFT, USB_OBSERVE_DPPD_WIDTH))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPU[7] (RO)
 *
 * Provides observability of the D+ Pullup enable at the USB transceiver.
 *
 * Values:
 * - 0b0 - D+ pullup disabled.
 * - 0b1 - D+ pullup enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DPPU field. */
#define USB_RD_OBSERVE_DPPU(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DPPU_MASK) >> USB_OBSERVE_DPPU_SHIFT)
#define USB_BRD_OBSERVE_DPPU(base) (BME_UBFX8(&USB_OBSERVE_REG(base), USB_OBSERVE_DPPU_SHIFT, USB_OBSERVE_DPPU_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_CONTROL - USB OTG Control register
 ******************************************************************************/

/*!
 * @brief USB_CONTROL - USB OTG Control register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_CONTROL register
 */
/*@{*/
#define USB_RD_CONTROL(base)     (USB_CONTROL_REG(base))
#define USB_WR_CONTROL(base, value) (USB_CONTROL_REG(base) = (value))
#define USB_RMW_CONTROL(base, mask, value) (USB_WR_CONTROL(base, (USB_RD_CONTROL(base) & ~(mask)) | (value)))
#define USB_SET_CONTROL(base, value) (BME_OR8(&USB_CONTROL_REG(base), (uint8_t)(value)))
#define USB_CLR_CONTROL(base, value) (BME_AND8(&USB_CONTROL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_CONTROL(base, value) (BME_XOR8(&USB_CONTROL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_CONTROL bitfields
 */

/*!
 * @name Register USB_CONTROL, field DPPULLUPNONOTG[4] (RW)
 *
 * Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG
 * device mode.
 *
 * Values:
 * - 0b0 - DP Pullup in non-OTG device mode is not enabled.
 * - 0b1 - DP Pullup in non-OTG device mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_CONTROL_DPPULLUPNONOTG field. */
#define USB_RD_CONTROL_DPPULLUPNONOTG(base) ((USB_CONTROL_REG(base) & USB_CONTROL_DPPULLUPNONOTG_MASK) >> USB_CONTROL_DPPULLUPNONOTG_SHIFT)
#define USB_BRD_CONTROL_DPPULLUPNONOTG(base) (BME_UBFX8(&USB_CONTROL_REG(base), USB_CONTROL_DPPULLUPNONOTG_SHIFT, USB_CONTROL_DPPULLUPNONOTG_WIDTH))

/*! @brief Set the DPPULLUPNONOTG field to a new value. */
#define USB_WR_CONTROL_DPPULLUPNONOTG(base, value) (USB_RMW_CONTROL(base, USB_CONTROL_DPPULLUPNONOTG_MASK, USB_CONTROL_DPPULLUPNONOTG(value)))
#define USB_BWR_CONTROL_DPPULLUPNONOTG(base, value) (BME_BFI8(&USB_CONTROL_REG(base), ((uint8_t)(value) << USB_CONTROL_DPPULLUPNONOTG_SHIFT), USB_CONTROL_DPPULLUPNONOTG_SHIFT, USB_CONTROL_DPPULLUPNONOTG_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_USBTRC0 - USB Transceiver Control register 0
 ******************************************************************************/

/*!
 * @brief USB_USBTRC0 - USB Transceiver Control register 0 (RW)
 *
 * Reset value: 0x00U
 *
 * Includes signals for basic operation of the on-chip USB Full Speed
 * transceiver and configuration of the USB data connection that are not otherwise included
 * in the USB Full Speed controller registers.
 */
/*!
 * @name Constants and macros for entire USB_USBTRC0 register
 */
/*@{*/
#define USB_RD_USBTRC0(base)     (USB_USBTRC0_REG(base))
#define USB_WR_USBTRC0(base, value) (USB_USBTRC0_REG(base) = (value))
#define USB_RMW_USBTRC0(base, mask, value) (USB_WR_USBTRC0(base, (USB_RD_USBTRC0(base) & ~(mask)) | (value)))
#define USB_SET_USBTRC0(base, value) (BME_OR8(&USB_USBTRC0_REG(base), (uint8_t)(value)))
#define USB_CLR_USBTRC0(base, value) (BME_AND8(&USB_USBTRC0_REG(base), (uint8_t)(~(value))))
#define USB_TOG_USBTRC0(base, value) (BME_XOR8(&USB_USBTRC0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_USBTRC0 bitfields
 */

/*!
 * @name Register USB_USBTRC0, field USB_RESUME_INT[0] (RO)
 *
 * Values:
 * - 0b0 - No interrupt was generated.
 * - 0b1 - Interrupt was generated because of the USB asynchronous interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USB_RESUME_INT field. */
#define USB_RD_USBTRC0_USB_RESUME_INT(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USB_RESUME_INT_MASK) >> USB_USBTRC0_USB_RESUME_INT_SHIFT)
#define USB_BRD_USBTRC0_USB_RESUME_INT(base) (BME_UBFX8(&USB_USBTRC0_REG(base), USB_USBTRC0_USB_RESUME_INT_SHIFT, USB_USBTRC0_USB_RESUME_INT_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field SYNC_DET[1] (RO)
 *
 * Values:
 * - 0b0 - Synchronous interrupt has not been detected.
 * - 0b1 - Synchronous interrupt has been detected.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_SYNC_DET field. */
#define USB_RD_USBTRC0_SYNC_DET(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_SYNC_DET_MASK) >> USB_USBTRC0_SYNC_DET_SHIFT)
#define USB_BRD_USBTRC0_SYNC_DET(base) (BME_UBFX8(&USB_USBTRC0_REG(base), USB_USBTRC0_SYNC_DET_SHIFT, USB_USBTRC0_SYNC_DET_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USB_CLK_RECOVERY_INT[2] (RO)
 *
 * This read-only field will be set to value high at 1'b1 when any of USB clock
 * recovery interrupt conditions are detected and those interrupts are unmasked.
 * For customer use the only unmasked USB clock recovery interrupt condition
 * results from an overflow of the frequency trim setting values indicating that the
 * frequency trim calculated is out of the adjustment range of the IRC48M output
 * clock. To clear this bit after it has been set, Write 0xFF to register
 * USB_CLK_RECOVER_INT_STATUS.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USB_CLK_RECOVERY_INT field. */
#define USB_RD_USBTRC0_USB_CLK_RECOVERY_INT(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USB_CLK_RECOVERY_INT_MASK) >> USB_USBTRC0_USB_CLK_RECOVERY_INT_SHIFT)
#define USB_BRD_USBTRC0_USB_CLK_RECOVERY_INT(base) (BME_UBFX8(&USB_USBTRC0_REG(base), USB_USBTRC0_USB_CLK_RECOVERY_INT_SHIFT, USB_USBTRC0_USB_CLK_RECOVERY_INT_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field VREDG_DET[3] (RW)
 *
 * Values:
 * - 0b0 - VBUS rising edge interrupt has not been detected.
 * - 0b1 - VBUS rising edge interrupt has been detected.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_VREDG_DET field. */
#define USB_RD_USBTRC0_VREDG_DET(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_VREDG_DET_MASK) >> USB_USBTRC0_VREDG_DET_SHIFT)
#define USB_BRD_USBTRC0_VREDG_DET(base) (BME_UBFX8(&USB_USBTRC0_REG(base), USB_USBTRC0_VREDG_DET_SHIFT, USB_USBTRC0_VREDG_DET_WIDTH))

/*! @brief Set the VREDG_DET field to a new value. */
#define USB_WR_USBTRC0_VREDG_DET(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_VREDG_DET_MASK, USB_USBTRC0_VREDG_DET(value)))
#define USB_BWR_USBTRC0_VREDG_DET(base, value) (BME_BFI8(&USB_USBTRC0_REG(base), ((uint8_t)(value) << USB_USBTRC0_VREDG_DET_SHIFT), USB_USBTRC0_VREDG_DET_SHIFT, USB_USBTRC0_VREDG_DET_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field VFEDG_DET[4] (RW)
 *
 * Values:
 * - 0b0 - VBUS falling edge interrupt has not been detected.
 * - 0b1 - VBUS falling edge interrupt has been detected.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_VFEDG_DET field. */
#define USB_RD_USBTRC0_VFEDG_DET(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_VFEDG_DET_MASK) >> USB_USBTRC0_VFEDG_DET_SHIFT)
#define USB_BRD_USBTRC0_VFEDG_DET(base) (BME_UBFX8(&USB_USBTRC0_REG(base), USB_USBTRC0_VFEDG_DET_SHIFT, USB_USBTRC0_VFEDG_DET_WIDTH))

/*! @brief Set the VFEDG_DET field to a new value. */
#define USB_WR_USBTRC0_VFEDG_DET(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_VFEDG_DET_MASK, USB_USBTRC0_VFEDG_DET(value)))
#define USB_BWR_USBTRC0_VFEDG_DET(base, value) (BME_BFI8(&USB_USBTRC0_REG(base), ((uint8_t)(value) << USB_USBTRC0_VFEDG_DET_SHIFT), USB_USBTRC0_VFEDG_DET_SHIFT, USB_USBTRC0_VFEDG_DET_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESMEN[5] (RW)
 *
 * This bit, when set, allows the USB module to send an asynchronous wakeup
 * event to the MCU upon detection of resume signaling on the USB bus. The MCU then
 * re-enables clocks to the USB module. It is used for low-power suspend mode when
 * USB module clocks are stopped or the USB transceiver is in Suspend mode.
 * Async wakeup only works in device mode.
 *
 * Values:
 * - 0b0 - USB asynchronous wakeup from suspend mode disabled.
 * - 0b1 - USB asynchronous wakeup from suspend mode enabled. The asynchronous
 *     resume interrupt differs from the synchronous resume interrupt in that it
 *     asynchronously detects K-state using the unfiltered state of the D+ and D-
 *     pins. This interrupt should only be enabled when the Transceiver is
 *     suspended.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USBRESMEN field. */
#define USB_RD_USBTRC0_USBRESMEN(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USBRESMEN_MASK) >> USB_USBTRC0_USBRESMEN_SHIFT)
#define USB_BRD_USBTRC0_USBRESMEN(base) (BME_UBFX8(&USB_USBTRC0_REG(base), USB_USBTRC0_USBRESMEN_SHIFT, USB_USBTRC0_USBRESMEN_WIDTH))

/*! @brief Set the USBRESMEN field to a new value. */
#define USB_WR_USBTRC0_USBRESMEN(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_USBRESMEN_MASK, USB_USBTRC0_USBRESMEN(value)))
#define USB_BWR_USBTRC0_USBRESMEN(base, value) (BME_BFI8(&USB_USBTRC0_REG(base), ((uint8_t)(value) << USB_USBTRC0_USBRESMEN_SHIFT), USB_USBTRC0_USBRESMEN_SHIFT, USB_USBTRC0_USBRESMEN_WIDTH))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESET[7] (WO)
 *
 * Generates a hard reset to USBOTG. After this bit is set and the reset occurs,
 * this bit is automatically cleared. This bit is always read as zero. Wait two
 * USB clock cycles after setting this bit.
 *
 * Values:
 * - 0b0 - Normal USB module operation.
 * - 0b1 - Returns the USB module to its reset state.
 */
/*@{*/
/*! @brief Set the USBRESET field to a new value. */
#define USB_WR_USBTRC0_USBRESET(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_USBRESET_MASK, USB_USBTRC0_USBRESET(value)))
#define USB_BWR_USBTRC0_USBRESET(base, value) (USB_WR_USBTRC0_USBRESET(base, value))
/*@}*/

/*******************************************************************************
 * USB_USBFRMADJUST - Frame Adjust Register
 ******************************************************************************/

/*!
 * @brief USB_USBFRMADJUST - Frame Adjust Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_USBFRMADJUST register
 */
/*@{*/
#define USB_RD_USBFRMADJUST(base) (USB_USBFRMADJUST_REG(base))
#define USB_WR_USBFRMADJUST(base, value) (USB_USBFRMADJUST_REG(base) = (value))
#define USB_RMW_USBFRMADJUST(base, mask, value) (USB_WR_USBFRMADJUST(base, (USB_RD_USBFRMADJUST(base) & ~(mask)) | (value)))
#define USB_SET_USBFRMADJUST(base, value) (BME_OR8(&USB_USBFRMADJUST_REG(base), (uint8_t)(value)))
#define USB_CLR_USBFRMADJUST(base, value) (BME_AND8(&USB_USBFRMADJUST_REG(base), (uint8_t)(~(value))))
#define USB_TOG_USBFRMADJUST(base, value) (BME_XOR8(&USB_USBFRMADJUST_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * USB_KEEP_ALIVE_CTRL - Keep Alive mode control
 ******************************************************************************/

/*!
 * @brief USB_KEEP_ALIVE_CTRL - Keep Alive mode control (RW)
 *
 * Reset value: 0x08U
 */
/*!
 * @name Constants and macros for entire USB_KEEP_ALIVE_CTRL register
 */
/*@{*/
#define USB_RD_KEEP_ALIVE_CTRL(base) (USB_KEEP_ALIVE_CTRL_REG(base))
#define USB_WR_KEEP_ALIVE_CTRL(base, value) (USB_KEEP_ALIVE_CTRL_REG(base) = (value))
#define USB_RMW_KEEP_ALIVE_CTRL(base, mask, value) (USB_WR_KEEP_ALIVE_CTRL(base, (USB_RD_KEEP_ALIVE_CTRL(base) & ~(mask)) | (value)))
#define USB_SET_KEEP_ALIVE_CTRL(base, value) (BME_OR8(&USB_KEEP_ALIVE_CTRL_REG(base), (uint8_t)(value)))
#define USB_CLR_KEEP_ALIVE_CTRL(base, value) (BME_AND8(&USB_KEEP_ALIVE_CTRL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_KEEP_ALIVE_CTRL(base, value) (BME_XOR8(&USB_KEEP_ALIVE_CTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_KEEP_ALIVE_CTRL bitfields
 */

/*!
 * @name Register USB_KEEP_ALIVE_CTRL, field KEEP_ALIVE_EN[0] (RW)
 *
 * Global enable for USB_KEEP_ALIVE mode. When assert, usb shall enter
 * USB_KEEP_ALIVE mode after asserting ipg_stop; when de-assert, everything is same as
 * before. Reset to 0. Software RW.
 */
/*@{*/
/*! @brief Read current value of the USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN field. */
#define USB_RD_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN(base) ((USB_KEEP_ALIVE_CTRL_REG(base) & USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_MASK) >> USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_SHIFT)
#define USB_BRD_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN(base) (BME_UBFX8(&USB_KEEP_ALIVE_CTRL_REG(base), USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_SHIFT, USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_WIDTH))

/*! @brief Set the KEEP_ALIVE_EN field to a new value. */
#define USB_WR_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN(base, value) (USB_RMW_KEEP_ALIVE_CTRL(base, USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_MASK, USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN(value)))
#define USB_BWR_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN(base, value) (BME_BFI8(&USB_KEEP_ALIVE_CTRL_REG(base), ((uint8_t)(value) << USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_SHIFT), USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_SHIFT, USB_KEEP_ALIVE_CTRL_KEEP_ALIVE_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_KEEP_ALIVE_CTRL, field OWN_OVERRD_EN[1] (RW)
 *
 * When set to 1, during KEEP_ALIVE mode, if received token is not SETUP, the
 * OWN bit of current BD will be forced to 0, so usb core will response with NAK.
 * Reset to 0. Software RW.
 */
/*@{*/
/*! @brief Read current value of the USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN field. */
#define USB_RD_KEEP_ALIVE_CTRL_OWN_OVERRD_EN(base) ((USB_KEEP_ALIVE_CTRL_REG(base) & USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_MASK) >> USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_SHIFT)
#define USB_BRD_KEEP_ALIVE_CTRL_OWN_OVERRD_EN(base) (BME_UBFX8(&USB_KEEP_ALIVE_CTRL_REG(base), USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_SHIFT, USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_WIDTH))

/*! @brief Set the OWN_OVERRD_EN field to a new value. */
#define USB_WR_KEEP_ALIVE_CTRL_OWN_OVERRD_EN(base, value) (USB_RMW_KEEP_ALIVE_CTRL(base, USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_MASK, USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN(value)))
#define USB_BWR_KEEP_ALIVE_CTRL_OWN_OVERRD_EN(base, value) (BME_BFI8(&USB_KEEP_ALIVE_CTRL_REG(base), ((uint8_t)(value) << USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_SHIFT), USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_SHIFT, USB_KEEP_ALIVE_CTRL_OWN_OVERRD_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_KEEP_ALIVE_CTRL, field AHB_DLY_EN[3] (RW)
 *
 * Must be set to 1 to delay the first USB AHB bus transfer until after the USB
 * has exited KEEP_ALIVE mode.
 *
 * Values:
 * - 0b0 - Do not delay the USB AHB transfer if the USB AHB transfer occurs
 *     while exiting KEEP_ALIVE mode.
 * - 0b1 - Delay the USB AHB transfer until the clock is recovered, if the USB
 *     AHB transfer occurs while exiting KEEP_ALIVE mode.
 */
/*@{*/
/*! @brief Read current value of the USB_KEEP_ALIVE_CTRL_AHB_DLY_EN field. */
#define USB_RD_KEEP_ALIVE_CTRL_AHB_DLY_EN(base) ((USB_KEEP_ALIVE_CTRL_REG(base) & USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_MASK) >> USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_SHIFT)
#define USB_BRD_KEEP_ALIVE_CTRL_AHB_DLY_EN(base) (BME_UBFX8(&USB_KEEP_ALIVE_CTRL_REG(base), USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_SHIFT, USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_WIDTH))

/*! @brief Set the AHB_DLY_EN field to a new value. */
#define USB_WR_KEEP_ALIVE_CTRL_AHB_DLY_EN(base, value) (USB_RMW_KEEP_ALIVE_CTRL(base, USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_MASK, USB_KEEP_ALIVE_CTRL_AHB_DLY_EN(value)))
#define USB_BWR_KEEP_ALIVE_CTRL_AHB_DLY_EN(base, value) (BME_BFI8(&USB_KEEP_ALIVE_CTRL_REG(base), ((uint8_t)(value) << USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_SHIFT), USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_SHIFT, USB_KEEP_ALIVE_CTRL_AHB_DLY_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_KEEP_ALIVE_CTRL, field WAKE_INT_EN[4] (RW)
 *
 * Set to 1 to enable WAKE_INT_STS. Reset to 0. Software RW.
 */
/*@{*/
/*! @brief Read current value of the USB_KEEP_ALIVE_CTRL_WAKE_INT_EN field. */
#define USB_RD_KEEP_ALIVE_CTRL_WAKE_INT_EN(base) ((USB_KEEP_ALIVE_CTRL_REG(base) & USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_MASK) >> USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_SHIFT)
#define USB_BRD_KEEP_ALIVE_CTRL_WAKE_INT_EN(base) (BME_UBFX8(&USB_KEEP_ALIVE_CTRL_REG(base), USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_SHIFT, USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_WIDTH))

/*! @brief Set the WAKE_INT_EN field to a new value. */
#define USB_WR_KEEP_ALIVE_CTRL_WAKE_INT_EN(base, value) (USB_RMW_KEEP_ALIVE_CTRL(base, USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_MASK, USB_KEEP_ALIVE_CTRL_WAKE_INT_EN(value)))
#define USB_BWR_KEEP_ALIVE_CTRL_WAKE_INT_EN(base, value) (BME_BFI8(&USB_KEEP_ALIVE_CTRL_REG(base), ((uint8_t)(value) << USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_SHIFT), USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_SHIFT, USB_KEEP_ALIVE_CTRL_WAKE_INT_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_KEEP_ALIVE_CTRL, field WAKE_INT_STS[7] (RO)
 *
 * It will be set when KEEP_ALIVE mode is enabled. A SETUP token or software
 * assigned token is received. This interrupt will only be set when the token is
 * processed and USB state is IDLE. Reset to 0. software RW 1 to clear.
 */
/*@{*/
/*! @brief Read current value of the USB_KEEP_ALIVE_CTRL_WAKE_INT_STS field. */
#define USB_RD_KEEP_ALIVE_CTRL_WAKE_INT_STS(base) ((USB_KEEP_ALIVE_CTRL_REG(base) & USB_KEEP_ALIVE_CTRL_WAKE_INT_STS_MASK) >> USB_KEEP_ALIVE_CTRL_WAKE_INT_STS_SHIFT)
#define USB_BRD_KEEP_ALIVE_CTRL_WAKE_INT_STS(base) (BME_UBFX8(&USB_KEEP_ALIVE_CTRL_REG(base), USB_KEEP_ALIVE_CTRL_WAKE_INT_STS_SHIFT, USB_KEEP_ALIVE_CTRL_WAKE_INT_STS_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_KEEP_ALIVE_WKCTRL - Keep Alive mode wakeup control
 ******************************************************************************/

/*!
 * @brief USB_KEEP_ALIVE_WKCTRL - Keep Alive mode wakeup control (RW)
 *
 * Reset value: 0x01U
 */
/*!
 * @name Constants and macros for entire USB_KEEP_ALIVE_WKCTRL register
 */
/*@{*/
#define USB_RD_KEEP_ALIVE_WKCTRL(base) (USB_KEEP_ALIVE_WKCTRL_REG(base))
#define USB_WR_KEEP_ALIVE_WKCTRL(base, value) (USB_KEEP_ALIVE_WKCTRL_REG(base) = (value))
#define USB_RMW_KEEP_ALIVE_WKCTRL(base, mask, value) (USB_WR_KEEP_ALIVE_WKCTRL(base, (USB_RD_KEEP_ALIVE_WKCTRL(base) & ~(mask)) | (value)))
#define USB_SET_KEEP_ALIVE_WKCTRL(base, value) (BME_OR8(&USB_KEEP_ALIVE_WKCTRL_REG(base), (uint8_t)(value)))
#define USB_CLR_KEEP_ALIVE_WKCTRL(base, value) (BME_AND8(&USB_KEEP_ALIVE_WKCTRL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_KEEP_ALIVE_WKCTRL(base, value) (BME_XOR8(&USB_KEEP_ALIVE_WKCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_KEEP_ALIVE_WKCTRL bitfields
 */

/*!
 * @name Register USB_KEEP_ALIVE_WKCTRL, field WAKE_ON_THIS[3:0] (RW)
 *
 * Software configure it to which token can wakeup usb during KEEP_ALIVE mode.
 * Reset to 4'b0001, software RW.
 *
 * Values:
 * - 0b0001 - Wake up on receiving OUT/SETUP token packet.
 * - 0b1101 - Wake up on receiving SETUP token packet.All other values are
 *     reserved.
 */
/*@{*/
/*! @brief Read current value of the USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS field. */
#define USB_RD_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS(base) ((USB_KEEP_ALIVE_WKCTRL_REG(base) & USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_MASK) >> USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_SHIFT)
#define USB_BRD_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS(base) (BME_UBFX8(&USB_KEEP_ALIVE_WKCTRL_REG(base), USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_SHIFT, USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_WIDTH))

/*! @brief Set the WAKE_ON_THIS field to a new value. */
#define USB_WR_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS(base, value) (USB_RMW_KEEP_ALIVE_WKCTRL(base, USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_MASK, USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS(value)))
#define USB_BWR_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS(base, value) (BME_BFI8(&USB_KEEP_ALIVE_WKCTRL_REG(base), ((uint8_t)(value) << USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_SHIFT), USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_SHIFT, USB_KEEP_ALIVE_WKCTRL_WAKE_ON_THIS_WIDTH))
/*@}*/

/*!
 * @name Register USB_KEEP_ALIVE_WKCTRL, field WAKE_ENDPT[7:4] (RO)
 *
 * Indicates which endpoint causes the wakeup interrupt. Reset to 0, software
 * read only.
 */
/*@{*/
/*! @brief Read current value of the USB_KEEP_ALIVE_WKCTRL_WAKE_ENDPT field. */
#define USB_RD_KEEP_ALIVE_WKCTRL_WAKE_ENDPT(base) ((USB_KEEP_ALIVE_WKCTRL_REG(base) & USB_KEEP_ALIVE_WKCTRL_WAKE_ENDPT_MASK) >> USB_KEEP_ALIVE_WKCTRL_WAKE_ENDPT_SHIFT)
#define USB_BRD_KEEP_ALIVE_WKCTRL_WAKE_ENDPT(base) (BME_UBFX8(&USB_KEEP_ALIVE_WKCTRL_REG(base), USB_KEEP_ALIVE_WKCTRL_WAKE_ENDPT_SHIFT, USB_KEEP_ALIVE_WKCTRL_WAKE_ENDPT_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_MISCCTRL - Miscellaneous Control register
 ******************************************************************************/

/*!
 * @brief USB_MISCCTRL - Miscellaneous Control register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_MISCCTRL register
 */
/*@{*/
#define USB_RD_MISCCTRL(base)    (USB_MISCCTRL_REG(base))
#define USB_WR_MISCCTRL(base, value) (USB_MISCCTRL_REG(base) = (value))
#define USB_RMW_MISCCTRL(base, mask, value) (USB_WR_MISCCTRL(base, (USB_RD_MISCCTRL(base) & ~(mask)) | (value)))
#define USB_SET_MISCCTRL(base, value) (BME_OR8(&USB_MISCCTRL_REG(base), (uint8_t)(value)))
#define USB_CLR_MISCCTRL(base, value) (BME_AND8(&USB_MISCCTRL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_MISCCTRL(base, value) (BME_XOR8(&USB_MISCCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_MISCCTRL bitfields
 */

/*!
 * @name Register USB_MISCCTRL, field SOFDYNTHLD[0] (RW)
 *
 * This field is only valid for Host mode, that is, CTL[HOSTMODEEN]=1.
 *
 * Values:
 * - 0b0 - SOF_TOK interrupt is set when byte times SOF threshold is reached.
 * - 0b1 - SOF_TOK interrupt is set when 8 byte times SOF threshold is reached
 *     or overstepped.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_SOFDYNTHLD field. */
#define USB_RD_MISCCTRL_SOFDYNTHLD(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_SOFDYNTHLD_MASK) >> USB_MISCCTRL_SOFDYNTHLD_SHIFT)
#define USB_BRD_MISCCTRL_SOFDYNTHLD(base) (BME_UBFX8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_SOFDYNTHLD_SHIFT, USB_MISCCTRL_SOFDYNTHLD_WIDTH))

/*! @brief Set the SOFDYNTHLD field to a new value. */
#define USB_WR_MISCCTRL_SOFDYNTHLD(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_SOFDYNTHLD_MASK, USB_MISCCTRL_SOFDYNTHLD(value)))
#define USB_BWR_MISCCTRL_SOFDYNTHLD(base, value) (BME_BFI8(&USB_MISCCTRL_REG(base), ((uint8_t)(value) << USB_MISCCTRL_SOFDYNTHLD_SHIFT), USB_MISCCTRL_SOFDYNTHLD_SHIFT, USB_MISCCTRL_SOFDYNTHLD_WIDTH))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field SOFBUSSET[1] (RW)
 *
 * This field is only valid for Host mode, that is, CTL[HOSTMODEEN]=1.
 *
 * Values:
 * - 0b0 - SOF_TOK interrupt is set according to SOF threshold value.
 * - 0b1 - SOF_TOK interrupt is set when SOF counter reaches 0.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_SOFBUSSET field. */
#define USB_RD_MISCCTRL_SOFBUSSET(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_SOFBUSSET_MASK) >> USB_MISCCTRL_SOFBUSSET_SHIFT)
#define USB_BRD_MISCCTRL_SOFBUSSET(base) (BME_UBFX8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_SOFBUSSET_SHIFT, USB_MISCCTRL_SOFBUSSET_WIDTH))

/*! @brief Set the SOFBUSSET field to a new value. */
#define USB_WR_MISCCTRL_SOFBUSSET(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_SOFBUSSET_MASK, USB_MISCCTRL_SOFBUSSET(value)))
#define USB_BWR_MISCCTRL_SOFBUSSET(base, value) (BME_BFI8(&USB_MISCCTRL_REG(base), ((uint8_t)(value) << USB_MISCCTRL_SOFBUSSET_SHIFT), USB_MISCCTRL_SOFBUSSET_SHIFT, USB_MISCCTRL_SOFBUSSET_WIDTH))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field OWNERRISODIS[2] (RW)
 *
 * This field is only valid for Peripheral mode, that is, CTL[HOSTMODEEN]=0.
 *
 * Values:
 * - 0b0 - OWN error detect for ISO IN / ISO OUT is not disabled.
 * - 0b1 - OWN error detect for ISO IN / ISO OUT is disabled.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_OWNERRISODIS field. */
#define USB_RD_MISCCTRL_OWNERRISODIS(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_OWNERRISODIS_MASK) >> USB_MISCCTRL_OWNERRISODIS_SHIFT)
#define USB_BRD_MISCCTRL_OWNERRISODIS(base) (BME_UBFX8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_OWNERRISODIS_SHIFT, USB_MISCCTRL_OWNERRISODIS_WIDTH))

/*! @brief Set the OWNERRISODIS field to a new value. */
#define USB_WR_MISCCTRL_OWNERRISODIS(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_OWNERRISODIS_MASK, USB_MISCCTRL_OWNERRISODIS(value)))
#define USB_BWR_MISCCTRL_OWNERRISODIS(base, value) (BME_BFI8(&USB_MISCCTRL_REG(base), ((uint8_t)(value) << USB_MISCCTRL_OWNERRISODIS_SHIFT), USB_MISCCTRL_OWNERRISODIS_SHIFT, USB_MISCCTRL_OWNERRISODIS_WIDTH))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field VREDG_EN[3] (RW)
 *
 * Values:
 * - 0b0 - VBUS rising edge interrupt disabled.
 * - 0b1 - VBUS rising edge interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_VREDG_EN field. */
#define USB_RD_MISCCTRL_VREDG_EN(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_VREDG_EN_MASK) >> USB_MISCCTRL_VREDG_EN_SHIFT)
#define USB_BRD_MISCCTRL_VREDG_EN(base) (BME_UBFX8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_VREDG_EN_SHIFT, USB_MISCCTRL_VREDG_EN_WIDTH))

/*! @brief Set the VREDG_EN field to a new value. */
#define USB_WR_MISCCTRL_VREDG_EN(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_VREDG_EN_MASK, USB_MISCCTRL_VREDG_EN(value)))
#define USB_BWR_MISCCTRL_VREDG_EN(base, value) (BME_BFI8(&USB_MISCCTRL_REG(base), ((uint8_t)(value) << USB_MISCCTRL_VREDG_EN_SHIFT), USB_MISCCTRL_VREDG_EN_SHIFT, USB_MISCCTRL_VREDG_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field VFEDG_EN[4] (RW)
 *
 * Values:
 * - 0b0 - VBUS falling edge interrupt disabled.
 * - 0b1 - VBUS falling edge interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_VFEDG_EN field. */
#define USB_RD_MISCCTRL_VFEDG_EN(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_VFEDG_EN_MASK) >> USB_MISCCTRL_VFEDG_EN_SHIFT)
#define USB_BRD_MISCCTRL_VFEDG_EN(base) (BME_UBFX8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_VFEDG_EN_SHIFT, USB_MISCCTRL_VFEDG_EN_WIDTH))

/*! @brief Set the VFEDG_EN field to a new value. */
#define USB_WR_MISCCTRL_VFEDG_EN(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_VFEDG_EN_MASK, USB_MISCCTRL_VFEDG_EN(value)))
#define USB_BWR_MISCCTRL_VFEDG_EN(base, value) (BME_BFI8(&USB_MISCCTRL_REG(base), ((uint8_t)(value) << USB_MISCCTRL_VFEDG_EN_SHIFT), USB_MISCCTRL_VFEDG_EN_SHIFT, USB_MISCCTRL_VFEDG_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_CTRL - USB Clock recovery control
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_CTRL - USB Clock recovery control (RW)
 *
 * Reset value: 0x00U
 *
 * Signals in this register control the crystal-less USB clock mode in which the
 * internal IRC48M oscillator is tuned to match the clock extracted from the
 * incoming USB data stream. The IRC48M internal oscillator module must be enabled
 * in register USB_CLK_RECOVER_IRC_EN for this mode.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_CTRL register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_CTRL(base) (USB_CLK_RECOVER_CTRL_REG(base))
#define USB_WR_CLK_RECOVER_CTRL(base, value) (USB_CLK_RECOVER_CTRL_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_CTRL(base, mask, value) (USB_WR_CLK_RECOVER_CTRL(base, (USB_RD_CLK_RECOVER_CTRL(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_CTRL(base, value) (BME_OR8(&USB_CLK_RECOVER_CTRL_REG(base), (uint8_t)(value)))
#define USB_CLR_CLK_RECOVER_CTRL(base, value) (BME_AND8(&USB_CLK_RECOVER_CTRL_REG(base), (uint8_t)(~(value))))
#define USB_TOG_CLK_RECOVER_CTRL(base, value) (BME_XOR8(&USB_CLK_RECOVER_CTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_CTRL bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESTART_IFRTRIM_EN[5] (RW)
 *
 * IRC48 has a default trim fine value whose default value is factory trimmed
 * (the IFR trim value). Clock recover block tracks the accuracy of the clock 48Mhz
 * and keeps updating the trim fine value accordingly
 *
 * Values:
 * - 0b0 - Trim fine adjustment always works based on the previous updated trim
 *     fine value (default)
 * - 0b1 - Trim fine restarts from the IFR trim value whenever
 *     bus_reset/bus_resume is detected or module enable is desasserted
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN field. */
#define USB_RD_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base) ((USB_CLK_RECOVER_CTRL_REG(base) & USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_MASK) >> USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base) (BME_UBFX8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_SHIFT, USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_WIDTH))

/*! @brief Set the RESTART_IFRTRIM_EN field to a new value. */
#define USB_WR_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base, value) (USB_RMW_CLK_RECOVER_CTRL(base, USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_MASK, USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(value)))
#define USB_BWR_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base, value) (BME_BFI8(&USB_CLK_RECOVER_CTRL_REG(base), ((uint8_t)(value) << USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_SHIFT), USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_SHIFT, USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESET_RESUME_ROUGH_EN[6] (RW)
 *
 * The clock recovery block tracks the IRC48Mhz to get an accurate 48Mhz clock.
 * It has two phases after user enables clock_recover_en bit, rough phase and
 * tracking phase. The step to fine tune the IRC 48Mhz by adjusting the trim fine
 * value is different during these two phases. The step in rough phase is larger
 * than that in tracking phase. Switch back to rough stage whenever USB bus reset
 * or bus resume occurs.
 *
 * Values:
 * - 0b0 - Always works in tracking phase after the 1st time rough to track
 *     transition (default)
 * - 0b1 - Go back to rough stage whenever bus reset or bus resume occurs
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN field. */
#define USB_RD_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base) ((USB_CLK_RECOVER_CTRL_REG(base) & USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_MASK) >> USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base) (BME_UBFX8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_SHIFT, USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_WIDTH))

/*! @brief Set the RESET_RESUME_ROUGH_EN field to a new value. */
#define USB_WR_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base, value) (USB_RMW_CLK_RECOVER_CTRL(base, USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_MASK, USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(value)))
#define USB_BWR_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base, value) (BME_BFI8(&USB_CLK_RECOVER_CTRL_REG(base), ((uint8_t)(value) << USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_SHIFT), USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_SHIFT, USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field CLOCK_RECOVER_EN[7] (RW)
 *
 * This bit must be enabled if user wants to use the crystal-less USB mode for
 * the Full Speed USB controller and transceiver. This bit should not be set for
 * USB host mode or OTG.
 *
 * Values:
 * - 0b0 - Disable clock recovery block (default)
 * - 0b1 - Enable clock recovery block
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN field. */
#define USB_RD_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base) ((USB_CLK_RECOVER_CTRL_REG(base) & USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK) >> USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base) (BME_UBFX8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_SHIFT, USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_WIDTH))

/*! @brief Set the CLOCK_RECOVER_EN field to a new value. */
#define USB_WR_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base, value) (USB_RMW_CLK_RECOVER_CTRL(base, USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK, USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(value)))
#define USB_BWR_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base, value) (BME_BFI8(&USB_CLK_RECOVER_CTRL_REG(base), ((uint8_t)(value) << USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_SHIFT), USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_SHIFT, USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register (RW)
 *
 * Reset value: 0x01U
 *
 * Controls basic operation of the on-chip IRC48M module used to produce nominal
 * 48MHz clocks for USB crystal-less operation and other functions. See
 * additional information about the IRC48M operation in the Clock Distribution chapter.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_IRC_EN register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_IRC_EN(base) (USB_CLK_RECOVER_IRC_EN_REG(base))
#define USB_WR_CLK_RECOVER_IRC_EN(base, value) (USB_CLK_RECOVER_IRC_EN_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_IRC_EN(base, mask, value) (USB_WR_CLK_RECOVER_IRC_EN(base, (USB_RD_CLK_RECOVER_IRC_EN(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_IRC_EN(base, value) (BME_OR8(&USB_CLK_RECOVER_IRC_EN_REG(base), (uint8_t)(value)))
#define USB_CLR_CLK_RECOVER_IRC_EN(base, value) (BME_AND8(&USB_CLK_RECOVER_IRC_EN_REG(base), (uint8_t)(~(value))))
#define USB_TOG_CLK_RECOVER_IRC_EN(base, value) (BME_XOR8(&USB_CLK_RECOVER_IRC_EN_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_IRC_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field REG_EN[0] (RW)
 *
 * This bit is used to enable the local analog regulator for IRC48Mhz module.
 * This bit must be set if user wants to use the crystal-less USB clock
 * configuration.
 *
 * Values:
 * - 0b0 - IRC48M local regulator is disabled
 * - 0b1 - IRC48M local regulator is enabled (default)
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_REG_EN field. */
#define USB_RD_CLK_RECOVER_IRC_EN_REG_EN(base) ((USB_CLK_RECOVER_IRC_EN_REG(base) & USB_CLK_RECOVER_IRC_EN_REG_EN_MASK) >> USB_CLK_RECOVER_IRC_EN_REG_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_IRC_EN_REG_EN(base) (BME_UBFX8(&USB_CLK_RECOVER_IRC_EN_REG(base), USB_CLK_RECOVER_IRC_EN_REG_EN_SHIFT, USB_CLK_RECOVER_IRC_EN_REG_EN_WIDTH))

/*! @brief Set the REG_EN field to a new value. */
#define USB_WR_CLK_RECOVER_IRC_EN_REG_EN(base, value) (USB_RMW_CLK_RECOVER_IRC_EN(base, USB_CLK_RECOVER_IRC_EN_REG_EN_MASK, USB_CLK_RECOVER_IRC_EN_REG_EN(value)))
#define USB_BWR_CLK_RECOVER_IRC_EN_REG_EN(base, value) (BME_BFI8(&USB_CLK_RECOVER_IRC_EN_REG(base), ((uint8_t)(value) << USB_CLK_RECOVER_IRC_EN_REG_EN_SHIFT), USB_CLK_RECOVER_IRC_EN_REG_EN_SHIFT, USB_CLK_RECOVER_IRC_EN_REG_EN_WIDTH))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field IRC_EN[1] (RW)
 *
 * This bit is used to enable the on-chip IRC48Mhz module to generate clocks for
 * crystal-less USB. It can be used for FS USB device mode operation. This bit
 * must be set before using the crystal-less USB clock configuration.
 *
 * Values:
 * - 0b0 - Disable the IRC48M module (default)
 * - 0b1 - Enable the IRC48M module
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_IRC_EN field. */
#define USB_RD_CLK_RECOVER_IRC_EN_IRC_EN(base) ((USB_CLK_RECOVER_IRC_EN_REG(base) & USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK) >> USB_CLK_RECOVER_IRC_EN_IRC_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_IRC_EN_IRC_EN(base) (BME_UBFX8(&USB_CLK_RECOVER_IRC_EN_REG(base), USB_CLK_RECOVER_IRC_EN_IRC_EN_SHIFT, USB_CLK_RECOVER_IRC_EN_IRC_EN_WIDTH))

/*! @brief Set the IRC_EN field to a new value. */
#define USB_WR_CLK_RECOVER_IRC_EN_IRC_EN(base, value) (USB_RMW_CLK_RECOVER_IRC_EN(base, USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK, USB_CLK_RECOVER_IRC_EN_IRC_EN(value)))
#define USB_BWR_CLK_RECOVER_IRC_EN_IRC_EN(base, value) (BME_BFI8(&USB_CLK_RECOVER_IRC_EN_REG(base), ((uint8_t)(value) << USB_CLK_RECOVER_IRC_EN_IRC_EN_SHIFT), USB_CLK_RECOVER_IRC_EN_IRC_EN_SHIFT, USB_CLK_RECOVER_IRC_EN_IRC_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable (RW)
 *
 * Reset value: 0x10U
 *
 * Enables or masks the individual interrupt flags which are logically OR'ed
 * together to produce the combined interrupt indication on the USB_CLK_RECOVERY_INT
 * bit in the USB_USBTRC0 register if the indicated conditions have been
 * detected in the USB clock recovery algorithm operation.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_EN register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_INT_EN(base) (USB_CLK_RECOVER_INT_EN_REG(base))
#define USB_WR_CLK_RECOVER_INT_EN(base, value) (USB_CLK_RECOVER_INT_EN_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_INT_EN(base, mask, value) (USB_WR_CLK_RECOVER_INT_EN(base, (USB_RD_CLK_RECOVER_INT_EN(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_INT_EN(base, value) (BME_OR8(&USB_CLK_RECOVER_INT_EN_REG(base), (uint8_t)(value)))
#define USB_CLR_CLK_RECOVER_INT_EN(base, value) (BME_AND8(&USB_CLK_RECOVER_INT_EN_REG(base), (uint8_t)(~(value))))
#define USB_TOG_CLK_RECOVER_INT_EN(base, value) (BME_XOR8(&USB_CLK_RECOVER_INT_EN_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_EN, field OVF_ERROR_EN[4] (RW)
 *
 * Determines whether OVF_ERROR condition signal is used in generation of
 * USB_CLK_RECOVERY_INT.
 *
 * Values:
 * - 0b0 - The interrupt will be masked
 * - 0b1 - The interrupt will be enabled (default)
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN field. */
#define USB_RD_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base) ((USB_CLK_RECOVER_INT_EN_REG(base) & USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_MASK) >> USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base) (BME_UBFX8(&USB_CLK_RECOVER_INT_EN_REG(base), USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_SHIFT, USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_WIDTH))

/*! @brief Set the OVF_ERROR_EN field to a new value. */
#define USB_WR_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base, value) (USB_RMW_CLK_RECOVER_INT_EN(base, USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_MASK, USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(value)))
#define USB_BWR_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base, value) (BME_BFI8(&USB_CLK_RECOVER_INT_EN_REG(base), ((uint8_t)(value) << USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_SHIFT), USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_SHIFT, USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status (W1C)
 *
 * Reset value: 0x00U
 *
 * A Write operation with value high at 1'b1 on any combination of individual
 * bits will clear those bits.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_STATUS register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_INT_STATUS(base) (USB_CLK_RECOVER_INT_STATUS_REG(base))
#define USB_WR_CLK_RECOVER_INT_STATUS(base, value) (USB_CLK_RECOVER_INT_STATUS_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_INT_STATUS(base, mask, value) (USB_WR_CLK_RECOVER_INT_STATUS(base, (USB_RD_CLK_RECOVER_INT_STATUS(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_INT_STATUS(base, value) (BME_OR8(&USB_CLK_RECOVER_INT_STATUS_REG(base), (uint8_t)(value)))
#define USB_CLR_CLK_RECOVER_INT_STATUS(base, value) (BME_AND8(&USB_CLK_RECOVER_INT_STATUS_REG(base), (uint8_t)(~(value))))
#define USB_TOG_CLK_RECOVER_INT_STATUS(base, value) (BME_XOR8(&USB_CLK_RECOVER_INT_STATUS_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_STATUS bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_STATUS, field OVF_ERROR[4] (W1C)
 *
 * Indicates that the USB clock recovery algorithm has detected that the
 * frequency trim adjustment needed for the IRC48M output clock is outside the available
 * TRIM_FINE adjustment range for the IRC48M module.
 *
 * Values:
 * - 0b0 - No interrupt is reported
 * - 0b1 - Unmasked interrupt has been generated
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_INT_STATUS_OVF_ERROR field. */
#define USB_RD_CLK_RECOVER_INT_STATUS_OVF_ERROR(base) ((USB_CLK_RECOVER_INT_STATUS_REG(base) & USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_MASK) >> USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_SHIFT)
#define USB_BRD_CLK_RECOVER_INT_STATUS_OVF_ERROR(base) (BME_UBFX8(&USB_CLK_RECOVER_INT_STATUS_REG(base), USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_SHIFT, USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_WIDTH))

/*! @brief Set the OVF_ERROR field to a new value. */
#define USB_WR_CLK_RECOVER_INT_STATUS_OVF_ERROR(base, value) (USB_RMW_CLK_RECOVER_INT_STATUS(base, USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_MASK, USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(value)))
#define USB_BWR_CLK_RECOVER_INT_STATUS_OVF_ERROR(base, value) (BME_BFI8(&USB_CLK_RECOVER_INT_STATUS_REG(base), ((uint8_t)(value) << USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_SHIFT), USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_SHIFT, USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_WIDTH))
/*@}*/

/*
 * MKL28Z7 VREF
 *
 * Voltage Reference
 *
 * Registers defined in this header file:
 * - VREF_TRM - VREF Trim Register
 * - VREF_SC - VREF Status and Control Register
 * - VREF_TRM1 - VREF Trim Register 1
 * - VREF_TRM2 - VREF Trim Register 2
 * - VREF_TRM3 - VREF Trim Register 3
 */

#define VREF_INSTANCE_COUNT (1U) /*!< Number of instances of the VREF module. */
#define VREF_IDX (0U) /*!< Instance number for VREF. */

/*******************************************************************************
 * VREF_TRM - VREF Trim Register
 ******************************************************************************/

/*!
 * @brief VREF_TRM - VREF Trim Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the Voltage
 * Reference.
 */
/*!
 * @name Constants and macros for entire VREF_TRM register
 */
/*@{*/
#define VREF_RD_TRM(base)        (VREF_TRM_REG(base))
#define VREF_WR_TRM(base, value) (VREF_TRM_REG(base) = (value))
#define VREF_RMW_TRM(base, mask, value) (VREF_WR_TRM(base, (VREF_RD_TRM(base) & ~(mask)) | (value)))
#define VREF_SET_TRM(base, value) (BME_OR8(&VREF_TRM_REG(base), (uint8_t)(value)))
#define VREF_CLR_TRM(base, value) (BME_AND8(&VREF_TRM_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_TRM(base, value) (BME_XOR8(&VREF_TRM_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_TRM bitfields
 */

/*!
 * @name Register VREF_TRM, field TRIM[5:0] (RW)
 *
 * These bits change the resulting VREF by approximately +/- 0.5 mV for each
 * step. Min = minimum and max = maximum voltage reference output. For minimum and
 * maximum voltage reference output values, refer to the Data Sheet for this chip.
 *
 * Values:
 * - 0b000000 - Min
 * - 0b111111 - Max
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM_TRIM field. */
#define VREF_RD_TRM_TRIM(base) ((VREF_TRM_REG(base) & VREF_TRM_TRIM_MASK) >> VREF_TRM_TRIM_SHIFT)
#define VREF_BRD_TRM_TRIM(base) (BME_UBFX8(&VREF_TRM_REG(base), VREF_TRM_TRIM_SHIFT, VREF_TRM_TRIM_WIDTH))

/*! @brief Set the TRIM field to a new value. */
#define VREF_WR_TRM_TRIM(base, value) (VREF_RMW_TRM(base, VREF_TRM_TRIM_MASK, VREF_TRM_TRIM(value)))
#define VREF_BWR_TRM_TRIM(base, value) (BME_BFI8(&VREF_TRM_REG(base), ((uint8_t)(value) << VREF_TRM_TRIM_SHIFT), VREF_TRM_TRIM_SHIFT, VREF_TRM_TRIM_WIDTH))
/*@}*/

/*!
 * @name Register VREF_TRM, field CHOPEN[6] (RW)
 *
 * This bit is set during factory trimming of the VREF voltage. This bit should
 * be written to 1 to achieve the performance stated in the data sheet. If the
 * internal voltage regulator is being used (REGEN bit is set to 1), the chop
 * oscillator must also be enabled. If the chop oscillator is to be used in very low
 * power modes, the system (bandgap) voltage reference must also be enabled. See
 * the chip-specific VREF information (also known as "chip configuration" details)
 * for a description of how this can be achieved.
 *
 * Values:
 * - 0b0 - Chop oscillator is disabled.
 * - 0b1 - Chop oscillator is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM_CHOPEN field. */
#define VREF_RD_TRM_CHOPEN(base) ((VREF_TRM_REG(base) & VREF_TRM_CHOPEN_MASK) >> VREF_TRM_CHOPEN_SHIFT)
#define VREF_BRD_TRM_CHOPEN(base) (BME_UBFX8(&VREF_TRM_REG(base), VREF_TRM_CHOPEN_SHIFT, VREF_TRM_CHOPEN_WIDTH))

/*! @brief Set the CHOPEN field to a new value. */
#define VREF_WR_TRM_CHOPEN(base, value) (VREF_RMW_TRM(base, VREF_TRM_CHOPEN_MASK, VREF_TRM_CHOPEN(value)))
#define VREF_BWR_TRM_CHOPEN(base, value) (BME_BFI8(&VREF_TRM_REG(base), ((uint8_t)(value) << VREF_TRM_CHOPEN_SHIFT), VREF_TRM_CHOPEN_SHIFT, VREF_TRM_CHOPEN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_TRM, field FLIP[7] (RW)
 *
 * This bit reverses the amplifier polarity. It can be used to test bandgap
 * amplifier offset. This is a test only bit, with trim value stored in IFR and
 * loaded out of reset.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM_FLIP field. */
#define VREF_RD_TRM_FLIP(base) ((VREF_TRM_REG(base) & VREF_TRM_FLIP_MASK) >> VREF_TRM_FLIP_SHIFT)
#define VREF_BRD_TRM_FLIP(base) (BME_UBFX8(&VREF_TRM_REG(base), VREF_TRM_FLIP_SHIFT, VREF_TRM_FLIP_WIDTH))

/*! @brief Set the FLIP field to a new value. */
#define VREF_WR_TRM_FLIP(base, value) (VREF_RMW_TRM(base, VREF_TRM_FLIP_MASK, VREF_TRM_FLIP(value)))
#define VREF_BWR_TRM_FLIP(base, value) (BME_BFI8(&VREF_TRM_REG(base), ((uint8_t)(value) << VREF_TRM_FLIP_SHIFT), VREF_TRM_FLIP_SHIFT, VREF_TRM_FLIP_WIDTH))
/*@}*/

/*******************************************************************************
 * VREF_SC - VREF Status and Control Register
 ******************************************************************************/

/*!
 * @brief VREF_SC - VREF Status and Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the control bits used to enable the internal voltage
 * reference and to select the buffer mode to be used.
 */
/*!
 * @name Constants and macros for entire VREF_SC register
 */
/*@{*/
#define VREF_RD_SC(base)         (VREF_SC_REG(base))
#define VREF_WR_SC(base, value)  (VREF_SC_REG(base) = (value))
#define VREF_RMW_SC(base, mask, value) (VREF_WR_SC(base, (VREF_RD_SC(base) & ~(mask)) | (value)))
#define VREF_SET_SC(base, value) (BME_OR8(&VREF_SC_REG(base), (uint8_t)(value)))
#define VREF_CLR_SC(base, value) (BME_AND8(&VREF_SC_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_SC(base, value) (BME_XOR8(&VREF_SC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_SC bitfields
 */

/*!
 * @name Register VREF_SC, field MODE_LV[1:0] (RW)
 *
 * These bits select the buffer modes for the Voltage Reference module.
 *
 * Values:
 * - 0b00 - Bandgap on only, for stabilization and startup
 * - 0b01 - High power buffer mode enabled
 * - 0b10 - Low-power buffer mode enabled
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_MODE_LV field. */
#define VREF_RD_SC_MODE_LV(base) ((VREF_SC_REG(base) & VREF_SC_MODE_LV_MASK) >> VREF_SC_MODE_LV_SHIFT)
#define VREF_BRD_SC_MODE_LV(base) (BME_UBFX8(&VREF_SC_REG(base), VREF_SC_MODE_LV_SHIFT, VREF_SC_MODE_LV_WIDTH))

/*! @brief Set the MODE_LV field to a new value. */
#define VREF_WR_SC_MODE_LV(base, value) (VREF_RMW_SC(base, VREF_SC_MODE_LV_MASK, VREF_SC_MODE_LV(value)))
#define VREF_BWR_SC_MODE_LV(base, value) (BME_BFI8(&VREF_SC_REG(base), ((uint8_t)(value) << VREF_SC_MODE_LV_SHIFT), VREF_SC_MODE_LV_SHIFT, VREF_SC_MODE_LV_WIDTH))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFST[2] (RO)
 *
 * This bit indicates that the bandgap reference within the Voltage Reference
 * module has completed its startup and stabilization. This bit is valid only when
 * the chop oscillator is not being used.
 *
 * Values:
 * - 0b0 - The module is disabled or not stable.
 * - 0b1 - The module is stable.
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_VREFST field. */
#define VREF_RD_SC_VREFST(base) ((VREF_SC_REG(base) & VREF_SC_VREFST_MASK) >> VREF_SC_VREFST_SHIFT)
#define VREF_BRD_SC_VREFST(base) (BME_UBFX8(&VREF_SC_REG(base), VREF_SC_VREFST_SHIFT, VREF_SC_VREFST_WIDTH))
/*@}*/

/*!
 * @name Register VREF_SC, field TMUXEN[3] (RW)
 *
 * This bit is accessablie only in functional test mode.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_TMUXEN field. */
#define VREF_RD_SC_TMUXEN(base) ((VREF_SC_REG(base) & VREF_SC_TMUXEN_MASK) >> VREF_SC_TMUXEN_SHIFT)
#define VREF_BRD_SC_TMUXEN(base) (BME_UBFX8(&VREF_SC_REG(base), VREF_SC_TMUXEN_SHIFT, VREF_SC_TMUXEN_WIDTH))

/*! @brief Set the TMUXEN field to a new value. */
#define VREF_WR_SC_TMUXEN(base, value) (VREF_RMW_SC(base, VREF_SC_TMUXEN_MASK, VREF_SC_TMUXEN(value)))
#define VREF_BWR_SC_TMUXEN(base, value) (BME_BFI8(&VREF_SC_REG(base), ((uint8_t)(value) << VREF_SC_TMUXEN_SHIFT), VREF_SC_TMUXEN_SHIFT, VREF_SC_TMUXEN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_SC, field TRESEN[4] (RW)
 *
 * This bit is accessablie only in functional test mode.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_TRESEN field. */
#define VREF_RD_SC_TRESEN(base) ((VREF_SC_REG(base) & VREF_SC_TRESEN_MASK) >> VREF_SC_TRESEN_SHIFT)
#define VREF_BRD_SC_TRESEN(base) (BME_UBFX8(&VREF_SC_REG(base), VREF_SC_TRESEN_SHIFT, VREF_SC_TRESEN_WIDTH))

/*! @brief Set the TRESEN field to a new value. */
#define VREF_WR_SC_TRESEN(base, value) (VREF_RMW_SC(base, VREF_SC_TRESEN_MASK, VREF_SC_TRESEN(value)))
#define VREF_BWR_SC_TRESEN(base, value) (BME_BFI8(&VREF_SC_REG(base), ((uint8_t)(value) << VREF_SC_TRESEN_SHIFT), VREF_SC_TRESEN_SHIFT, VREF_SC_TRESEN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_SC, field ICOMPEN[5] (RW)
 *
 * This bit should be written to 1 to achieve the performance stated in the data
 * sheet.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_ICOMPEN field. */
#define VREF_RD_SC_ICOMPEN(base) ((VREF_SC_REG(base) & VREF_SC_ICOMPEN_MASK) >> VREF_SC_ICOMPEN_SHIFT)
#define VREF_BRD_SC_ICOMPEN(base) (BME_UBFX8(&VREF_SC_REG(base), VREF_SC_ICOMPEN_SHIFT, VREF_SC_ICOMPEN_WIDTH))

/*! @brief Set the ICOMPEN field to a new value. */
#define VREF_WR_SC_ICOMPEN(base, value) (VREF_RMW_SC(base, VREF_SC_ICOMPEN_MASK, VREF_SC_ICOMPEN(value)))
#define VREF_BWR_SC_ICOMPEN(base, value) (BME_BFI8(&VREF_SC_REG(base), ((uint8_t)(value) << VREF_SC_ICOMPEN_SHIFT), VREF_SC_ICOMPEN_SHIFT, VREF_SC_ICOMPEN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_SC, field REGEN[6] (RW)
 *
 * This bit is used to enable the internal 1.75 V regulator to produce a
 * constant internal voltage supply in order to reduce the sensitivity to external
 * supply noise and variation. If it is desired to keep the regulator enabled in very
 * low power modes, refer to the Chip Configuration details for a description on
 * how this can be achieved. This bit should be written to 1 to achieve the
 * performance stated in the data sheet. See section "Internal voltage regulator" for
 * details on the required sequence to enable the internal regulator.
 *
 * Values:
 * - 0b0 - Internal 1.75 V regulator is disabled.
 * - 0b1 - Internal 1.75 V regulator is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_REGEN field. */
#define VREF_RD_SC_REGEN(base) ((VREF_SC_REG(base) & VREF_SC_REGEN_MASK) >> VREF_SC_REGEN_SHIFT)
#define VREF_BRD_SC_REGEN(base) (BME_UBFX8(&VREF_SC_REG(base), VREF_SC_REGEN_SHIFT, VREF_SC_REGEN_WIDTH))

/*! @brief Set the REGEN field to a new value. */
#define VREF_WR_SC_REGEN(base, value) (VREF_RMW_SC(base, VREF_SC_REGEN_MASK, VREF_SC_REGEN(value)))
#define VREF_BWR_SC_REGEN(base, value) (BME_BFI8(&VREF_SC_REG(base), ((uint8_t)(value) << VREF_SC_REGEN_SHIFT), VREF_SC_REGEN_SHIFT, VREF_SC_REGEN_WIDTH))
/*@}*/

/*!
 * @name Register VREF_SC, field VREFEN[7] (RW)
 *
 * This bit is used to enable the bandgap reference within the Voltage Reference
 * module. After the VREF is enabled, turning off the clock to the VREF module
 * via the corresponding clock gate register will not disable the VREF. VREF must
 * be disabled via this VREFEN bit.
 *
 * Values:
 * - 0b0 - The module is disabled.
 * - 0b1 - The module is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_SC_VREFEN field. */
#define VREF_RD_SC_VREFEN(base) ((VREF_SC_REG(base) & VREF_SC_VREFEN_MASK) >> VREF_SC_VREFEN_SHIFT)
#define VREF_BRD_SC_VREFEN(base) (BME_UBFX8(&VREF_SC_REG(base), VREF_SC_VREFEN_SHIFT, VREF_SC_VREFEN_WIDTH))

/*! @brief Set the VREFEN field to a new value. */
#define VREF_WR_SC_VREFEN(base, value) (VREF_RMW_SC(base, VREF_SC_VREFEN_MASK, VREF_SC_VREFEN(value)))
#define VREF_BWR_SC_VREFEN(base, value) (BME_BFI8(&VREF_SC_REG(base), ((uint8_t)(value) << VREF_SC_VREFEN_SHIFT), VREF_SC_VREFEN_SHIFT, VREF_SC_VREFEN_WIDTH))
/*@}*/

/*******************************************************************************
 * VREF_TRM1 - VREF Trim Register 1
 ******************************************************************************/

/*!
 * @brief VREF_TRM1 - VREF Trim Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the bandgap
 * temperature inflection point.
 */
/*!
 * @name Constants and macros for entire VREF_TRM1 register
 */
/*@{*/
#define VREF_RD_TRM1(base)       (VREF_TRM1_REG(base))
#define VREF_WR_TRM1(base, value) (VREF_TRM1_REG(base) = (value))
#define VREF_RMW_TRM1(base, mask, value) (VREF_WR_TRM1(base, (VREF_RD_TRM1(base) & ~(mask)) | (value)))
#define VREF_SET_TRM1(base, value) (BME_OR8(&VREF_TRM1_REG(base), (uint8_t)(value)))
#define VREF_CLR_TRM1(base, value) (BME_AND8(&VREF_TRM1_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_TRM1(base, value) (BME_XOR8(&VREF_TRM1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_TRM1 bitfields
 */

/*!
 * @name Register VREF_TRM1, field BPLSB[3:0] (RW)
 *
 * These are bits for thin trimming bandgap temperature curvature. These bits
 * are active low and will shift the bandgap inflection point ~2 degree C. These
 * are test only bits, with trim value stored in IFR and loaded out of reset.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM1_BPLSB field. */
#define VREF_RD_TRM1_BPLSB(base) ((VREF_TRM1_REG(base) & VREF_TRM1_BPLSB_MASK) >> VREF_TRM1_BPLSB_SHIFT)
#define VREF_BRD_TRM1_BPLSB(base) (BME_UBFX8(&VREF_TRM1_REG(base), VREF_TRM1_BPLSB_SHIFT, VREF_TRM1_BPLSB_WIDTH))

/*! @brief Set the BPLSB field to a new value. */
#define VREF_WR_TRM1_BPLSB(base, value) (VREF_RMW_TRM1(base, VREF_TRM1_BPLSB_MASK, VREF_TRM1_BPLSB(value)))
#define VREF_BWR_TRM1_BPLSB(base, value) (BME_BFI8(&VREF_TRM1_REG(base), ((uint8_t)(value) << VREF_TRM1_BPLSB_SHIFT), VREF_TRM1_BPLSB_SHIFT, VREF_TRM1_BPLSB_WIDTH))
/*@}*/

/*!
 * @name Register VREF_TRM1, field BPMSB[7:5] (RW)
 *
 * These are bits for thin trimming bandgap temperature curvature. These bits
 * are active low and will shift the bandgap inflection point ~15 degree C/bit.
 * These are test only bits, with trim value stored in IFR and loaded out of reset.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM1_BPMSB field. */
#define VREF_RD_TRM1_BPMSB(base) ((VREF_TRM1_REG(base) & VREF_TRM1_BPMSB_MASK) >> VREF_TRM1_BPMSB_SHIFT)
#define VREF_BRD_TRM1_BPMSB(base) (BME_UBFX8(&VREF_TRM1_REG(base), VREF_TRM1_BPMSB_SHIFT, VREF_TRM1_BPMSB_WIDTH))

/*! @brief Set the BPMSB field to a new value. */
#define VREF_WR_TRM1_BPMSB(base, value) (VREF_RMW_TRM1(base, VREF_TRM1_BPMSB_MASK, VREF_TRM1_BPMSB(value)))
#define VREF_BWR_TRM1_BPMSB(base, value) (BME_BFI8(&VREF_TRM1_REG(base), ((uint8_t)(value) << VREF_TRM1_BPMSB_SHIFT), VREF_TRM1_BPMSB_SHIFT, VREF_TRM1_BPMSB_WIDTH))
/*@}*/

/*******************************************************************************
 * VREF_TRM2 - VREF Trim Register 2
 ******************************************************************************/

/*!
 * @brief VREF_TRM2 - VREF Trim Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the buffered
 * Voltage Reference.
 */
/*!
 * @name Constants and macros for entire VREF_TRM2 register
 */
/*@{*/
#define VREF_RD_TRM2(base)       (VREF_TRM2_REG(base))
#define VREF_WR_TRM2(base, value) (VREF_TRM2_REG(base) = (value))
#define VREF_RMW_TRM2(base, mask, value) (VREF_WR_TRM2(base, (VREF_RD_TRM2(base) & ~(mask)) | (value)))
#define VREF_SET_TRM2(base, value) (BME_OR8(&VREF_TRM2_REG(base), (uint8_t)(value)))
#define VREF_CLR_TRM2(base, value) (BME_AND8(&VREF_TRM2_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_TRM2(base, value) (BME_XOR8(&VREF_TRM2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_TRM2 bitfields
 */

/*!
 * @name Register VREF_TRM2, field COMPLSB[2:0] (RW)
 *
 * These are bits for trimming the curvature used for the second-order
 * temperature compensation. These are test only bits, with trim value stored in IFR and
 * loaded out of reset.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM2_COMPLSB field. */
#define VREF_RD_TRM2_COMPLSB(base) ((VREF_TRM2_REG(base) & VREF_TRM2_COMPLSB_MASK) >> VREF_TRM2_COMPLSB_SHIFT)
#define VREF_BRD_TRM2_COMPLSB(base) (BME_UBFX8(&VREF_TRM2_REG(base), VREF_TRM2_COMPLSB_SHIFT, VREF_TRM2_COMPLSB_WIDTH))

/*! @brief Set the COMPLSB field to a new value. */
#define VREF_WR_TRM2_COMPLSB(base, value) (VREF_RMW_TRM2(base, VREF_TRM2_COMPLSB_MASK, VREF_TRM2_COMPLSB(value)))
#define VREF_BWR_TRM2_COMPLSB(base, value) (BME_BFI8(&VREF_TRM2_REG(base), ((uint8_t)(value) << VREF_TRM2_COMPLSB_SHIFT), VREF_TRM2_COMPLSB_SHIFT, VREF_TRM2_COMPLSB_WIDTH))
/*@}*/

/*!
 * @name Register VREF_TRM2, field COMPMSB[7:5] (RW)
 *
 * These are bits for trimming the curvature used for the second-order
 * temperature compensation. These are test only bits, with trim value stored in IFR and
 * loaded out of reset.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM2_COMPMSB field. */
#define VREF_RD_TRM2_COMPMSB(base) ((VREF_TRM2_REG(base) & VREF_TRM2_COMPMSB_MASK) >> VREF_TRM2_COMPMSB_SHIFT)
#define VREF_BRD_TRM2_COMPMSB(base) (BME_UBFX8(&VREF_TRM2_REG(base), VREF_TRM2_COMPMSB_SHIFT, VREF_TRM2_COMPMSB_WIDTH))

/*! @brief Set the COMPMSB field to a new value. */
#define VREF_WR_TRM2_COMPMSB(base, value) (VREF_RMW_TRM2(base, VREF_TRM2_COMPMSB_MASK, VREF_TRM2_COMPMSB(value)))
#define VREF_BWR_TRM2_COMPMSB(base, value) (BME_BFI8(&VREF_TRM2_REG(base), ((uint8_t)(value) << VREF_TRM2_COMPMSB_SHIFT), VREF_TRM2_COMPMSB_SHIFT, VREF_TRM2_COMPMSB_WIDTH))
/*@}*/

/*******************************************************************************
 * VREF_TRM3 - VREF Trim Register 3
 ******************************************************************************/

/*!
 * @brief VREF_TRM3 - VREF Trim Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains bits that contain the trim data for the V to I Voltage
 * Reference.
 */
/*!
 * @name Constants and macros for entire VREF_TRM3 register
 */
/*@{*/
#define VREF_RD_TRM3(base)       (VREF_TRM3_REG(base))
#define VREF_WR_TRM3(base, value) (VREF_TRM3_REG(base) = (value))
#define VREF_RMW_TRM3(base, mask, value) (VREF_WR_TRM3(base, (VREF_RD_TRM3(base) & ~(mask)) | (value)))
#define VREF_SET_TRM3(base, value) (BME_OR8(&VREF_TRM3_REG(base), (uint8_t)(value)))
#define VREF_CLR_TRM3(base, value) (BME_AND8(&VREF_TRM3_REG(base), (uint8_t)(~(value))))
#define VREF_TOG_TRM3(base, value) (BME_XOR8(&VREF_TRM3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual VREF_TRM3 bitfields
 */

/*!
 * @name Register VREF_TRM3, field CHOPOSCTRM[3:0] (RW)
 *
 * These bits trim the chop oscillator clock. The center frequency of the chop
 * oscillator is 72 kHz at the trim value of 4'b1000. The trim step size is 5%
 * time domain when chop oscillator is enabled.
 */
/*@{*/
/*! @brief Read current value of the VREF_TRM3_CHOPOSCTRM field. */
#define VREF_RD_TRM3_CHOPOSCTRM(base) ((VREF_TRM3_REG(base) & VREF_TRM3_CHOPOSCTRM_MASK) >> VREF_TRM3_CHOPOSCTRM_SHIFT)
#define VREF_BRD_TRM3_CHOPOSCTRM(base) (BME_UBFX8(&VREF_TRM3_REG(base), VREF_TRM3_CHOPOSCTRM_SHIFT, VREF_TRM3_CHOPOSCTRM_WIDTH))

/*! @brief Set the CHOPOSCTRM field to a new value. */
#define VREF_WR_TRM3_CHOPOSCTRM(base, value) (VREF_RMW_TRM3(base, VREF_TRM3_CHOPOSCTRM_MASK, VREF_TRM3_CHOPOSCTRM(value)))
#define VREF_BWR_TRM3_CHOPOSCTRM(base, value) (BME_BFI8(&VREF_TRM3_REG(base), ((uint8_t)(value) << VREF_TRM3_CHOPOSCTRM_SHIFT), VREF_TRM3_CHOPOSCTRM_SHIFT, VREF_TRM3_CHOPOSCTRM_WIDTH))
/*@}*/

/*
 * MKL28Z7 WDOG
 *
 * Watchdog timer
 *
 * Registers defined in this header file:
 * - WDOG_CS - Watchdog Control and Status Register
 * - WDOG_CNT - Watchdog Counter Register
 * - WDOG_TOVAL - Watchdog Timeout Value Register
 * - WDOG_WIN - Watchdog Window Register
 */

#define WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define WDOG0_IDX (0U) /*!< Instance number for WDOG0. */

/*******************************************************************************
 * WDOG_CS - Watchdog Control and Status Register
 ******************************************************************************/

/*!
 * @brief WDOG_CS - Watchdog Control and Status Register (RW)
 *
 * Reset value: 0x00002180U
 *
 * This section describes the function of Watchdog Control and Status Register.
 * TST is cleared (0:0) on POR only. Any other reset does not affect the value of
 * this field.
 */
/*!
 * @name Constants and macros for entire WDOG_CS register
 */
/*@{*/
#define WDOG_RD_CS(base)         (WDOG_CS_REG(base))
#define WDOG_WR_CS(base, value)  (WDOG_CS_REG(base) = (value))
#define WDOG_RMW_CS(base, mask, value) (WDOG_WR_CS(base, (WDOG_RD_CS(base) & ~(mask)) | (value)))
#define WDOG_SET_CS(base, value) (BME_OR32(&WDOG_CS_REG(base), (uint32_t)(value)))
#define WDOG_CLR_CS(base, value) (BME_AND32(&WDOG_CS_REG(base), (uint32_t)(~(value))))
#define WDOG_TOG_CS(base, value) (BME_XOR32(&WDOG_CS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_CS bitfields
 */

/*!
 * @name Register WDOG_CS, field STOP[0] (RW)
 *
 * This write-once bit enables the watchdog to operate when the chip is in stop
 * mode.
 *
 * Values:
 * - 0b0 - Watchdog disabled in chip stop mode.
 * - 0b1 - Watchdog enabled in chip stop mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_STOP field. */
#define WDOG_RD_CS_STOP(base) ((WDOG_CS_REG(base) & WDOG_CS_STOP_MASK) >> WDOG_CS_STOP_SHIFT)
#define WDOG_BRD_CS_STOP(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_STOP_SHIFT, WDOG_CS_STOP_WIDTH))

/*! @brief Set the STOP field to a new value. */
#define WDOG_WR_CS_STOP(base, value) (WDOG_RMW_CS(base, (WDOG_CS_STOP_MASK | WDOG_CS_FLG_MASK), WDOG_CS_STOP(value)))
#define WDOG_BWR_CS_STOP(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_STOP_SHIFT), WDOG_CS_STOP_SHIFT, WDOG_CS_STOP_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field WAIT[1] (RW)
 *
 * This write-once bit enables the watchdog to operate when the chip is in wait
 * mode.
 *
 * Values:
 * - 0b0 - Watchdog disabled in chip wait mode.
 * - 0b1 - Watchdog enabled in chip wait mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_WAIT field. */
#define WDOG_RD_CS_WAIT(base) ((WDOG_CS_REG(base) & WDOG_CS_WAIT_MASK) >> WDOG_CS_WAIT_SHIFT)
#define WDOG_BRD_CS_WAIT(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_WAIT_SHIFT, WDOG_CS_WAIT_WIDTH))

/*! @brief Set the WAIT field to a new value. */
#define WDOG_WR_CS_WAIT(base, value) (WDOG_RMW_CS(base, (WDOG_CS_WAIT_MASK | WDOG_CS_FLG_MASK), WDOG_CS_WAIT(value)))
#define WDOG_BWR_CS_WAIT(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_WAIT_SHIFT), WDOG_CS_WAIT_SHIFT, WDOG_CS_WAIT_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field DBG[2] (RW)
 *
 * This write-once bit enables the watchdog to operate when the chip is in debug
 * mode.
 *
 * Values:
 * - 0b0 - Watchdog disabled in chip debug mode.
 * - 0b1 - Watchdog enabled in chip debug mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_DBG field. */
#define WDOG_RD_CS_DBG(base) ((WDOG_CS_REG(base) & WDOG_CS_DBG_MASK) >> WDOG_CS_DBG_SHIFT)
#define WDOG_BRD_CS_DBG(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_DBG_SHIFT, WDOG_CS_DBG_WIDTH))

/*! @brief Set the DBG field to a new value. */
#define WDOG_WR_CS_DBG(base, value) (WDOG_RMW_CS(base, (WDOG_CS_DBG_MASK | WDOG_CS_FLG_MASK), WDOG_CS_DBG(value)))
#define WDOG_BWR_CS_DBG(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_DBG_SHIFT), WDOG_CS_DBG_SHIFT, WDOG_CS_DBG_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field TST[4:3] (RW)
 *
 * Enables the fast test mode. The test mode allows software to exercise all
 * bits of the counter to demonstrate that the watchdog is functioning properly. See
 * the Fast testing of the watchdog section. This write-once field is cleared
 * (0:0) on POR only. Any other reset does not affect the value of this field.
 *
 * Values:
 * - 0b00 - Watchdog test mode disabled.
 * - 0b01 - Watchdog user mode enabled. (Watchdog test mode disabled.) After
 *     testing the watchdog, software should use this setting to indicate that the
 *     watchdog is functioning normally in user mode.
 * - 0b10 - Watchdog test mode enabled, only the low byte is used. CNT[CNTLOW]
 *     is compared with TOVAL[TOVALLOW].
 * - 0b11 - Watchdog test mode enabled, only the high byte is used. CNT[CNTHIGH]
 *     is compared with TOVAL[TOVALHIGH].
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_TST field. */
#define WDOG_RD_CS_TST(base) ((WDOG_CS_REG(base) & WDOG_CS_TST_MASK) >> WDOG_CS_TST_SHIFT)
#define WDOG_BRD_CS_TST(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_TST_SHIFT, WDOG_CS_TST_WIDTH))

/*! @brief Set the TST field to a new value. */
#define WDOG_WR_CS_TST(base, value) (WDOG_RMW_CS(base, (WDOG_CS_TST_MASK | WDOG_CS_FLG_MASK), WDOG_CS_TST(value)))
#define WDOG_BWR_CS_TST(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_TST_SHIFT), WDOG_CS_TST_SHIFT, WDOG_CS_TST_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field UPDATE[5] (RW)
 *
 * This write-once bit allows software to reconfigure the watchdog without a
 * reset.
 *
 * Values:
 * - 0b0 - Updates not allowed. After the initial configuration, the watchdog
 *     cannot be later modified without forcing a reset.
 * - 0b1 - Updates allowed. Software can modify the watchdog configuration
 *     registers within 128 bus clocks after performing the unlock write sequence.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_UPDATE field. */
#define WDOG_RD_CS_UPDATE(base) ((WDOG_CS_REG(base) & WDOG_CS_UPDATE_MASK) >> WDOG_CS_UPDATE_SHIFT)
#define WDOG_BRD_CS_UPDATE(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_UPDATE_SHIFT, WDOG_CS_UPDATE_WIDTH))

/*! @brief Set the UPDATE field to a new value. */
#define WDOG_WR_CS_UPDATE(base, value) (WDOG_RMW_CS(base, (WDOG_CS_UPDATE_MASK | WDOG_CS_FLG_MASK), WDOG_CS_UPDATE(value)))
#define WDOG_BWR_CS_UPDATE(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_UPDATE_SHIFT), WDOG_CS_UPDATE_SHIFT, WDOG_CS_UPDATE_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field INT[6] (RW)
 *
 * This write-once bit configures the watchdog to immediately generate an
 * interrupt request upon a reset-triggering event (timeout or illegal write to the
 * watchdog), before forcing a reset. After the interrupt vector fetch (which comes
 * after the reset-triggering event), the reset occurs after a delay of 128 bus
 * clocks.
 *
 * Values:
 * - 0b0 - Watchdog interrupts are disabled. Watchdog resets are not delayed.
 * - 0b1 - Watchdog interrupts are enabled. Watchdog resets are delayed by 128
 *     bus clocks from the interrupt vector fetch.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_INT field. */
#define WDOG_RD_CS_INT(base) ((WDOG_CS_REG(base) & WDOG_CS_INT_MASK) >> WDOG_CS_INT_SHIFT)
#define WDOG_BRD_CS_INT(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_INT_SHIFT, WDOG_CS_INT_WIDTH))

/*! @brief Set the INT field to a new value. */
#define WDOG_WR_CS_INT(base, value) (WDOG_RMW_CS(base, (WDOG_CS_INT_MASK | WDOG_CS_FLG_MASK), WDOG_CS_INT(value)))
#define WDOG_BWR_CS_INT(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_INT_SHIFT), WDOG_CS_INT_SHIFT, WDOG_CS_INT_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field EN[7] (RW)
 *
 * This write-once bit enables the watchdog counter to start counting.
 *
 * Values:
 * - 0b0 - Watchdog disabled.
 * - 0b1 - Watchdog enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_EN field. */
#define WDOG_RD_CS_EN(base)  ((WDOG_CS_REG(base) & WDOG_CS_EN_MASK) >> WDOG_CS_EN_SHIFT)
#define WDOG_BRD_CS_EN(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_EN_SHIFT, WDOG_CS_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define WDOG_WR_CS_EN(base, value) (WDOG_RMW_CS(base, (WDOG_CS_EN_MASK | WDOG_CS_FLG_MASK), WDOG_CS_EN(value)))
#define WDOG_BWR_CS_EN(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_EN_SHIFT), WDOG_CS_EN_SHIFT, WDOG_CS_EN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field CLK[9:8] (RW)
 *
 * This write-once field indicates the clock source that feeds the watchdog
 * counter. See the Clock source section.
 *
 * Values:
 * - 0b00 - Bus clock.
 * - 0b01 - Internal low-power oscillator (LPOCLK).
 * - 0b10 - 8 MHz internal reference clock.
 * - 0b11 - External clock source.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_CLK field. */
#define WDOG_RD_CS_CLK(base) ((WDOG_CS_REG(base) & WDOG_CS_CLK_MASK) >> WDOG_CS_CLK_SHIFT)
#define WDOG_BRD_CS_CLK(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_CLK_SHIFT, WDOG_CS_CLK_WIDTH))

/*! @brief Set the CLK field to a new value. */
#define WDOG_WR_CS_CLK(base, value) (WDOG_RMW_CS(base, (WDOG_CS_CLK_MASK | WDOG_CS_FLG_MASK), WDOG_CS_CLK(value)))
#define WDOG_BWR_CS_CLK(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_CLK_SHIFT), WDOG_CS_CLK_SHIFT, WDOG_CS_CLK_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field PRES[12] (RW)
 *
 * This write-once bit enables a fixed 256 pre-scaling of watchdog counter
 * reference clock. (The block diagram shows this clock divider option.)
 *
 * Values:
 * - 0b0 - 256 prescalar disabled.
 * - 0b1 - 256 prescalar enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_PRES field. */
#define WDOG_RD_CS_PRES(base) ((WDOG_CS_REG(base) & WDOG_CS_PRES_MASK) >> WDOG_CS_PRES_SHIFT)
#define WDOG_BRD_CS_PRES(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_PRES_SHIFT, WDOG_CS_PRES_WIDTH))

/*! @brief Set the PRES field to a new value. */
#define WDOG_WR_CS_PRES(base, value) (WDOG_RMW_CS(base, (WDOG_CS_PRES_MASK | WDOG_CS_FLG_MASK), WDOG_CS_PRES(value)))
#define WDOG_BWR_CS_PRES(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_PRES_SHIFT), WDOG_CS_PRES_SHIFT, WDOG_CS_PRES_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field FLG[14] (W1C)
 *
 * This bit is an interrupt indicator when INT is set in control and status
 * register 1. Write 1 to clear it.
 *
 * Values:
 * - 0b0 - No interrupt occurred.
 * - 0b1 - An interrupt occurred.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_FLG field. */
#define WDOG_RD_CS_FLG(base) ((WDOG_CS_REG(base) & WDOG_CS_FLG_MASK) >> WDOG_CS_FLG_SHIFT)
#define WDOG_BRD_CS_FLG(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_FLG_SHIFT, WDOG_CS_FLG_WIDTH))

/*! @brief Set the FLG field to a new value. */
#define WDOG_WR_CS_FLG(base, value) (WDOG_RMW_CS(base, WDOG_CS_FLG_MASK, WDOG_CS_FLG(value)))
#define WDOG_BWR_CS_FLG(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_FLG_SHIFT), WDOG_CS_FLG_SHIFT, WDOG_CS_FLG_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CS, field WIN[15] (RW)
 *
 * This write-once bit enables window mode. See the Window mode section.
 *
 * Values:
 * - 0b0 - Window mode disabled.
 * - 0b1 - Window mode enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_CS_WIN field. */
#define WDOG_RD_CS_WIN(base) ((WDOG_CS_REG(base) & WDOG_CS_WIN_MASK) >> WDOG_CS_WIN_SHIFT)
#define WDOG_BRD_CS_WIN(base) (BME_UBFX32(&WDOG_CS_REG(base), WDOG_CS_WIN_SHIFT, WDOG_CS_WIN_WIDTH))

/*! @brief Set the WIN field to a new value. */
#define WDOG_WR_CS_WIN(base, value) (WDOG_RMW_CS(base, (WDOG_CS_WIN_MASK | WDOG_CS_FLG_MASK), WDOG_CS_WIN(value)))
#define WDOG_BWR_CS_WIN(base, value) (BME_BFI32(&WDOG_CS_REG(base), ((uint32_t)(value) << WDOG_CS_WIN_SHIFT), WDOG_CS_WIN_SHIFT, WDOG_CS_WIN_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_CNT - Watchdog Counter Register
 ******************************************************************************/

/*!
 * @brief WDOG_CNT - Watchdog Counter Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes the watchdog counter register. The watchdog counter
 * register provides access to the value of the free-running watchdog counter.
 * Software can read the counter register at any time. Software cannot write directly
 * to the watchdog counter; however, two write sequences to these registers have
 * special functions: The refresh sequence resets the watchdog counter to
 * 0x0000. See the Refreshing the Watchdog section. The unlock sequence allows the
 * watchdog to be reconfigured without forcing a reset (when CS[UPDATE] = 1). See the
 * Example code: Reconfiguring the Watchdog section. All other writes to this
 * register are illegal and force a reset.
 */
/*!
 * @name Constants and macros for entire WDOG_CNT register
 */
/*@{*/
#define WDOG_RD_CNT(base)        (WDOG_CNT_REG(base))
#define WDOG_WR_CNT(base, value) (WDOG_CNT_REG(base) = (value))
#define WDOG_RMW_CNT(base, mask, value) (WDOG_WR_CNT(base, (WDOG_RD_CNT(base) & ~(mask)) | (value)))
#define WDOG_SET_CNT(base, value) (BME_OR32(&WDOG_CNT_REG(base), (uint32_t)(value)))
#define WDOG_CLR_CNT(base, value) (BME_AND32(&WDOG_CNT_REG(base), (uint32_t)(~(value))))
#define WDOG_TOG_CNT(base, value) (BME_XOR32(&WDOG_CNT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_CNT bitfields
 */

/*!
 * @name Register WDOG_CNT, field CNTLOW[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_CNT_CNTLOW field. */
#define WDOG_RD_CNT_CNTLOW(base) ((WDOG_CNT_REG(base) & WDOG_CNT_CNTLOW_MASK) >> WDOG_CNT_CNTLOW_SHIFT)
#define WDOG_BRD_CNT_CNTLOW(base) (BME_UBFX32(&WDOG_CNT_REG(base), WDOG_CNT_CNTLOW_SHIFT, WDOG_CNT_CNTLOW_WIDTH))

/*! @brief Set the CNTLOW field to a new value. */
#define WDOG_WR_CNT_CNTLOW(base, value) (WDOG_RMW_CNT(base, WDOG_CNT_CNTLOW_MASK, WDOG_CNT_CNTLOW(value)))
#define WDOG_BWR_CNT_CNTLOW(base, value) (BME_BFI32(&WDOG_CNT_REG(base), ((uint32_t)(value) << WDOG_CNT_CNTLOW_SHIFT), WDOG_CNT_CNTLOW_SHIFT, WDOG_CNT_CNTLOW_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_CNT, field CNTHIGH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_CNT_CNTHIGH field. */
#define WDOG_RD_CNT_CNTHIGH(base) ((WDOG_CNT_REG(base) & WDOG_CNT_CNTHIGH_MASK) >> WDOG_CNT_CNTHIGH_SHIFT)
#define WDOG_BRD_CNT_CNTHIGH(base) (BME_UBFX32(&WDOG_CNT_REG(base), WDOG_CNT_CNTHIGH_SHIFT, WDOG_CNT_CNTHIGH_WIDTH))

/*! @brief Set the CNTHIGH field to a new value. */
#define WDOG_WR_CNT_CNTHIGH(base, value) (WDOG_RMW_CNT(base, WDOG_CNT_CNTHIGH_MASK, WDOG_CNT_CNTHIGH(value)))
#define WDOG_BWR_CNT_CNTHIGH(base, value) (BME_BFI32(&WDOG_CNT_REG(base), ((uint32_t)(value) << WDOG_CNT_CNTHIGH_SHIFT), WDOG_CNT_CNTHIGH_SHIFT, WDOG_CNT_CNTHIGH_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_TOVAL - Watchdog Timeout Value Register
 ******************************************************************************/

/*!
 * @brief WDOG_TOVAL - Watchdog Timeout Value Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * This section describes the watchdog timeout value register. TOVAL contains
 * the 16-bit value used to set the timeout period of the watchdog. The watchdog
 * counter (CNT) is continuously compared with the timeout value (TOVAL). If the
 * counter reaches the timeout value, the watchdog forces a reset. Do not write 0
 * to the Watchdog Timeout Value Register; otherwise, the watchdog always
 * generates a reset.
 */
/*!
 * @name Constants and macros for entire WDOG_TOVAL register
 */
/*@{*/
#define WDOG_RD_TOVAL(base)      (WDOG_TOVAL_REG(base))
#define WDOG_WR_TOVAL(base, value) (WDOG_TOVAL_REG(base) = (value))
#define WDOG_RMW_TOVAL(base, mask, value) (WDOG_WR_TOVAL(base, (WDOG_RD_TOVAL(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVAL(base, value) (BME_OR32(&WDOG_TOVAL_REG(base), (uint32_t)(value)))
#define WDOG_CLR_TOVAL(base, value) (BME_AND32(&WDOG_TOVAL_REG(base), (uint32_t)(~(value))))
#define WDOG_TOG_TOVAL(base, value) (BME_XOR32(&WDOG_TOVAL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_TOVAL bitfields
 */

/*!
 * @name Register WDOG_TOVAL, field TOVALLOW[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_TOVAL_TOVALLOW field. */
#define WDOG_RD_TOVAL_TOVALLOW(base) ((WDOG_TOVAL_REG(base) & WDOG_TOVAL_TOVALLOW_MASK) >> WDOG_TOVAL_TOVALLOW_SHIFT)
#define WDOG_BRD_TOVAL_TOVALLOW(base) (BME_UBFX32(&WDOG_TOVAL_REG(base), WDOG_TOVAL_TOVALLOW_SHIFT, WDOG_TOVAL_TOVALLOW_WIDTH))

/*! @brief Set the TOVALLOW field to a new value. */
#define WDOG_WR_TOVAL_TOVALLOW(base, value) (WDOG_RMW_TOVAL(base, WDOG_TOVAL_TOVALLOW_MASK, WDOG_TOVAL_TOVALLOW(value)))
#define WDOG_BWR_TOVAL_TOVALLOW(base, value) (BME_BFI32(&WDOG_TOVAL_REG(base), ((uint32_t)(value) << WDOG_TOVAL_TOVALLOW_SHIFT), WDOG_TOVAL_TOVALLOW_SHIFT, WDOG_TOVAL_TOVALLOW_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_TOVAL, field TOVALHIGH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_TOVAL_TOVALHIGH field. */
#define WDOG_RD_TOVAL_TOVALHIGH(base) ((WDOG_TOVAL_REG(base) & WDOG_TOVAL_TOVALHIGH_MASK) >> WDOG_TOVAL_TOVALHIGH_SHIFT)
#define WDOG_BRD_TOVAL_TOVALHIGH(base) (BME_UBFX32(&WDOG_TOVAL_REG(base), WDOG_TOVAL_TOVALHIGH_SHIFT, WDOG_TOVAL_TOVALHIGH_WIDTH))

/*! @brief Set the TOVALHIGH field to a new value. */
#define WDOG_WR_TOVAL_TOVALHIGH(base, value) (WDOG_RMW_TOVAL(base, WDOG_TOVAL_TOVALHIGH_MASK, WDOG_TOVAL_TOVALHIGH(value)))
#define WDOG_BWR_TOVAL_TOVALHIGH(base, value) (BME_BFI32(&WDOG_TOVAL_REG(base), ((uint32_t)(value) << WDOG_TOVAL_TOVALHIGH_SHIFT), WDOG_TOVAL_TOVALHIGH_SHIFT, WDOG_TOVAL_TOVALHIGH_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_WIN - Watchdog Window Register
 ******************************************************************************/

/*!
 * @brief WDOG_WIN - Watchdog Window Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes the watchdog window register. When window mode is
 * enabled (CS[WIN] is set), The WIN register determines the earliest time that a
 * refresh sequence is considered valid. See the Watchdog refresh mechanism section.
 * The WIN register value must be less than the TOVAL register value.
 */
/*!
 * @name Constants and macros for entire WDOG_WIN register
 */
/*@{*/
#define WDOG_RD_WIN(base)        (WDOG_WIN_REG(base))
#define WDOG_WR_WIN(base, value) (WDOG_WIN_REG(base) = (value))
#define WDOG_RMW_WIN(base, mask, value) (WDOG_WR_WIN(base, (WDOG_RD_WIN(base) & ~(mask)) | (value)))
#define WDOG_SET_WIN(base, value) (BME_OR32(&WDOG_WIN_REG(base), (uint32_t)(value)))
#define WDOG_CLR_WIN(base, value) (BME_AND32(&WDOG_WIN_REG(base), (uint32_t)(~(value))))
#define WDOG_TOG_WIN(base, value) (BME_XOR32(&WDOG_WIN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_WIN bitfields
 */

/*!
 * @name Register WDOG_WIN, field WINLOW[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_WIN_WINLOW field. */
#define WDOG_RD_WIN_WINLOW(base) ((WDOG_WIN_REG(base) & WDOG_WIN_WINLOW_MASK) >> WDOG_WIN_WINLOW_SHIFT)
#define WDOG_BRD_WIN_WINLOW(base) (BME_UBFX32(&WDOG_WIN_REG(base), WDOG_WIN_WINLOW_SHIFT, WDOG_WIN_WINLOW_WIDTH))

/*! @brief Set the WINLOW field to a new value. */
#define WDOG_WR_WIN_WINLOW(base, value) (WDOG_RMW_WIN(base, WDOG_WIN_WINLOW_MASK, WDOG_WIN_WINLOW(value)))
#define WDOG_BWR_WIN_WINLOW(base, value) (BME_BFI32(&WDOG_WIN_REG(base), ((uint32_t)(value) << WDOG_WIN_WINLOW_SHIFT), WDOG_WIN_WINLOW_SHIFT, WDOG_WIN_WINLOW_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_WIN, field WINHIGH[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the WDOG_WIN_WINHIGH field. */
#define WDOG_RD_WIN_WINHIGH(base) ((WDOG_WIN_REG(base) & WDOG_WIN_WINHIGH_MASK) >> WDOG_WIN_WINHIGH_SHIFT)
#define WDOG_BRD_WIN_WINHIGH(base) (BME_UBFX32(&WDOG_WIN_REG(base), WDOG_WIN_WINHIGH_SHIFT, WDOG_WIN_WINHIGH_WIDTH))

/*! @brief Set the WINHIGH field to a new value. */
#define WDOG_WR_WIN_WINHIGH(base, value) (WDOG_RMW_WIN(base, WDOG_WIN_WINHIGH_MASK, WDOG_WIN_WINHIGH(value)))
#define WDOG_BWR_WIN_WINHIGH(base, value) (BME_BFI32(&WDOG_WIN_REG(base), ((uint32_t)(value) << WDOG_WIN_WINHIGH_SHIFT), WDOG_WIN_WINHIGH_SHIFT, WDOG_WIN_WINHIGH_WIDTH))
/*@}*/

/*
 * MKL28Z7 XRDC
 *
 * XRDC
 *
 * Registers defined in this header file:
 * - XRDC_CR - Control Register
 * - XRDC_HWCFG0 - Hardware Configuration Register 0
 * - XRDC_HWCFG1 - Hardware Configuration Register 1
 * - XRDC_HWCFG2 - Hardware Configuration Register 2
 * - XRDC_HWCFG3 - Hardware Configuration Register 3
 * - XRDC_MDACFG - Master Domain Assignment Configuration Register
 * - XRDC_MRCFG - Memory Region Configuration Register
 * - XRDC_DERRLOC - Domain Error Location Register
 * - XRDC_DERR_W - Domain Error Word0 Register
 * - XRDC_PID - Process Identifier
 * - XRDC_MDA_W - Master Domain Assignment W0
 * - XRDC_PDAC_W - Peripheral Domain Access Control W0
 * - XRDC_MRGD_W - Memory Region Descriptor W0
 */

#define XRDC_INSTANCE_COUNT (1U) /*!< Number of instances of the XRDC module. */
#define XRDC_IDX (0U) /*!< Instance number for XRDC. */

/*******************************************************************************
 * XRDC_CR - Control Register
 ******************************************************************************/

/*!
 * @brief XRDC_CR - Control Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * This register provides read-only status about the XRDC and a global enable
 * bit for the entire module's operation. Access: Secure Privileged Read/write
 */
/*!
 * @name Constants and macros for entire XRDC_CR register
 */
/*@{*/
#define XRDC_RD_CR(base)         (XRDC_CR_REG(base))
#define XRDC_WR_CR(base, value)  (XRDC_CR_REG(base) = (value))
#define XRDC_RMW_CR(base, mask, value) (XRDC_WR_CR(base, (XRDC_RD_CR(base) & ~(mask)) | (value)))
#define XRDC_SET_CR(base, value) (BME_OR32(&XRDC_CR_REG(base), (uint32_t)(value)))
#define XRDC_CLR_CR(base, value) (BME_AND32(&XRDC_CR_REG(base), (uint32_t)(~(value))))
#define XRDC_TOG_CR(base, value) (BME_XOR32(&XRDC_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XRDC_CR bitfields
 */

/*!
 * @name Register XRDC_CR, field GVLD[0] (RW)
 *
 * Global Valid (XRDC global enable/disable).
 *
 * Values:
 * - 0b0 - XRDC is disabled. All accesses from all bus masters to all slaves are
 *     allowed.
 * - 0b1 - XRDC is enabled.
 */
/*@{*/
/*! @brief Read current value of the XRDC_CR_GVLD field. */
#define XRDC_RD_CR_GVLD(base) ((XRDC_CR_REG(base) & XRDC_CR_GVLD_MASK) >> XRDC_CR_GVLD_SHIFT)
#define XRDC_BRD_CR_GVLD(base) (BME_UBFX32(&XRDC_CR_REG(base), XRDC_CR_GVLD_SHIFT, XRDC_CR_GVLD_WIDTH))

/*! @brief Set the GVLD field to a new value. */
#define XRDC_WR_CR_GVLD(base, value) (XRDC_RMW_CR(base, XRDC_CR_GVLD_MASK, XRDC_CR_GVLD(value)))
#define XRDC_BWR_CR_GVLD(base, value) (BME_BFI32(&XRDC_CR_REG(base), ((uint32_t)(value) << XRDC_CR_GVLD_SHIFT), XRDC_CR_GVLD_SHIFT, XRDC_CR_GVLD_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_CR, field HRL[4:1] (RO)
 *
 * Hardware Revision Level. This field specifies the XRDC's hardware and
 * definition revision level. It can be read by software to determine the functional
 * definition of the module. It is hardwired to 5 as it represents an architectural
 * descendent from previous {system} memory protection units ({S}MPU).
 */
/*@{*/
/*! @brief Read current value of the XRDC_CR_HRL field. */
#define XRDC_RD_CR_HRL(base) ((XRDC_CR_REG(base) & XRDC_CR_HRL_MASK) >> XRDC_CR_HRL_SHIFT)
#define XRDC_BRD_CR_HRL(base) (BME_UBFX32(&XRDC_CR_REG(base), XRDC_CR_HRL_SHIFT, XRDC_CR_HRL_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_CR, field MRF[7] (RO)
 *
 * Memory Region Format. This field signals the format of the memory region
 * descriptors and is defined by SoC requirements.
 *
 * Values:
 * - 0b0 - Kinetis format based on ARM Cortex-M processor core definition.
 * - 0b1 - Reserved
 */
/*@{*/
/*! @brief Read current value of the XRDC_CR_MRF field. */
#define XRDC_RD_CR_MRF(base) ((XRDC_CR_REG(base) & XRDC_CR_MRF_MASK) >> XRDC_CR_MRF_SHIFT)
#define XRDC_BRD_CR_MRF(base) (BME_UBFX32(&XRDC_CR_REG(base), XRDC_CR_MRF_SHIFT, XRDC_CR_MRF_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_CR, field VAW[8] (RO)
 *
 * Virtualization aware. This field signals the domain assignments support the
 * optional inclusion of a logical partition identifier (also known as an
 * operating system number).
 *
 * Values:
 * - 0b0 - Implementation is not virtualization aware.
 * - 0b1 - Implementation is virtualization aware.
 */
/*@{*/
/*! @brief Read current value of the XRDC_CR_VAW field. */
#define XRDC_RD_CR_VAW(base) ((XRDC_CR_REG(base) & XRDC_CR_VAW_MASK) >> XRDC_CR_VAW_SHIFT)
#define XRDC_BRD_CR_VAW(base) (BME_UBFX32(&XRDC_CR_REG(base), XRDC_CR_VAW_SHIFT, XRDC_CR_VAW_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_CR, field LK1[30] (RW)
 *
 * 1-bit Lock. This field provides a locking mechanism that can be used to limit
 * the ability to write the register. Once set, this bit remains asserted until
 * the next reset.
 *
 * Values:
 * - 0b0 - Register can be written by any secure privileged write.
 * - 0b1 - Register is locked (read-only) until the next reset.
 */
/*@{*/
/*! @brief Read current value of the XRDC_CR_LK1 field. */
#define XRDC_RD_CR_LK1(base) ((XRDC_CR_REG(base) & XRDC_CR_LK1_MASK) >> XRDC_CR_LK1_SHIFT)
#define XRDC_BRD_CR_LK1(base) (BME_UBFX32(&XRDC_CR_REG(base), XRDC_CR_LK1_SHIFT, XRDC_CR_LK1_WIDTH))

/*! @brief Set the LK1 field to a new value. */
#define XRDC_WR_CR_LK1(base, value) (XRDC_RMW_CR(base, XRDC_CR_LK1_MASK, XRDC_CR_LK1(value)))
#define XRDC_BWR_CR_LK1(base, value) (BME_BFI32(&XRDC_CR_REG(base), ((uint32_t)(value) << XRDC_CR_LK1_SHIFT), XRDC_CR_LK1_SHIFT, XRDC_CR_LK1_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_HWCFG0 - Hardware Configuration Register 0
 ******************************************************************************/

/*!
 * @brief XRDC_HWCFG0 - Hardware Configuration Register 0 (RO)
 *
 * Reset value: 0x10000000U
 *
 * This register contains information on the XRDC's hardware configuration.
 * Specifically, it defines the number of implemented domains and bus masters along
 * with the number of instances of memory region controllers (MRCs) and peripheral
 * access controllers (PACs). The register value at reset is device-specific.
 * Attempted writes are error terminated. Access: Secure Privileged Read
 */
/*!
 * @name Constants and macros for entire XRDC_HWCFG0 register
 */
/*@{*/
#define XRDC_RD_HWCFG0(base)     (XRDC_HWCFG0_REG(base))
/*@}*/

/*
 * Constants & macros for individual XRDC_HWCFG0 bitfields
 */

/*!
 * @name Register XRDC_HWCFG0, field NDID[7:0] (RO)
 *
 * Number of domains. This field defines the number of domains minus 1 in the
 * device. Add one to the field value to get the actual number of domains [1-16].
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG0_NDID field. */
#define XRDC_RD_HWCFG0_NDID(base) ((XRDC_HWCFG0_REG(base) & XRDC_HWCFG0_NDID_MASK) >> XRDC_HWCFG0_NDID_SHIFT)
#define XRDC_BRD_HWCFG0_NDID(base) (BME_UBFX32(&XRDC_HWCFG0_REG(base), XRDC_HWCFG0_NDID_SHIFT, XRDC_HWCFG0_NDID_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG0, field NMSTR[15:8] (RO)
 *
 * Number of bus masters. This field defines the number of bus masters minus 1
 * in the device. Add one to the field value to get the actual number of bus
 * masters [1-64].
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG0_NMSTR field. */
#define XRDC_RD_HWCFG0_NMSTR(base) ((XRDC_HWCFG0_REG(base) & XRDC_HWCFG0_NMSTR_MASK) >> XRDC_HWCFG0_NMSTR_SHIFT)
#define XRDC_BRD_HWCFG0_NMSTR(base) (BME_UBFX32(&XRDC_HWCFG0_REG(base), XRDC_HWCFG0_NMSTR_SHIFT, XRDC_HWCFG0_NMSTR_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG0, field NMRC[23:16] (RO)
 *
 * Number of memory region controllers. This field defines the number of MRCs
 * minus 1 in the device. Add one to the field value to get the actual number of
 * memory region controllers [1-16].
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG0_NMRC field. */
#define XRDC_RD_HWCFG0_NMRC(base) ((XRDC_HWCFG0_REG(base) & XRDC_HWCFG0_NMRC_MASK) >> XRDC_HWCFG0_NMRC_SHIFT)
#define XRDC_BRD_HWCFG0_NMRC(base) (BME_UBFX32(&XRDC_HWCFG0_REG(base), XRDC_HWCFG0_NMRC_SHIFT, XRDC_HWCFG0_NMRC_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG0, field NPAC[27:24] (RO)
 *
 * Number of peripheral access controllers. This field defines the number of
 * PACs minus 1 in the device. Add one to the field value to get the actual number
 * of peripheral access controllers [1-4].
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG0_NPAC field. */
#define XRDC_RD_HWCFG0_NPAC(base) ((XRDC_HWCFG0_REG(base) & XRDC_HWCFG0_NPAC_MASK) >> XRDC_HWCFG0_NPAC_SHIFT)
#define XRDC_BRD_HWCFG0_NPAC(base) (BME_UBFX32(&XRDC_HWCFG0_REG(base), XRDC_HWCFG0_NPAC_SHIFT, XRDC_HWCFG0_NPAC_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_HWCFG1 - Hardware Configuration Register 1
 ******************************************************************************/

/*!
 * @brief XRDC_HWCFG1 - Hardware Configuration Register 1 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register contains information on the XRDC's hardware configuration. It
 * provides a mechanism for software to determine its domain number by simply
 * reading the register. See Domain error capture management for more details on
 * typical usage. Attempted writes are error terminated. Access: Secure Privileged
 * Read
 */
/*!
 * @name Constants and macros for entire XRDC_HWCFG1 register
 */
/*@{*/
#define XRDC_RD_HWCFG1(base)     (XRDC_HWCFG1_REG(base))
/*@}*/

/*
 * Constants & macros for individual XRDC_HWCFG1 bitfields
 */

/*!
 * @name Register XRDC_HWCFG1, field DID[3:0] (RO)
 *
 * Domain identifier number. This field provides the domain number [0-15] of the
 * requesting bus master.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG1_DID field. */
#define XRDC_RD_HWCFG1_DID(base) ((XRDC_HWCFG1_REG(base) & XRDC_HWCFG1_DID_MASK) >> XRDC_HWCFG1_DID_SHIFT)
#define XRDC_BRD_HWCFG1_DID(base) (BME_UBFX32(&XRDC_HWCFG1_REG(base), XRDC_HWCFG1_DID_SHIFT, XRDC_HWCFG1_DID_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_HWCFG2 - Hardware Configuration Register 2
 ******************************************************************************/

/*!
 * @brief XRDC_HWCFG2 - Hardware Configuration Register 2 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register contains information on the XRDC's hardware configuration. It
 * provides a bitmap signaling the presence of a process identifier (PID) register
 * sourced from the given bus master. The HWCFG2 register is associated with bus
 * masters [31-0], while the HWCFG3 register covers bus masters [63-32].
 * Attempted writes are error terminated. Access: Secure Privileged Read
 */
/*!
 * @name Constants and macros for entire XRDC_HWCFG2 register
 */
/*@{*/
#define XRDC_RD_HWCFG2(base)     (XRDC_HWCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual XRDC_HWCFG2 bitfields
 */

/*!
 * @name Register XRDC_HWCFG2, field PIDP0[0] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP0 field. */
#define XRDC_RD_HWCFG2_PIDP0(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP0_MASK) >> XRDC_HWCFG2_PIDP0_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP0(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP0_SHIFT, XRDC_HWCFG2_PIDP0_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP1[1] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP1 field. */
#define XRDC_RD_HWCFG2_PIDP1(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP1_MASK) >> XRDC_HWCFG2_PIDP1_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP1(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP1_SHIFT, XRDC_HWCFG2_PIDP1_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP2[2] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP2 field. */
#define XRDC_RD_HWCFG2_PIDP2(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP2_MASK) >> XRDC_HWCFG2_PIDP2_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP2(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP2_SHIFT, XRDC_HWCFG2_PIDP2_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP3[3] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP3 field. */
#define XRDC_RD_HWCFG2_PIDP3(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP3_MASK) >> XRDC_HWCFG2_PIDP3_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP3(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP3_SHIFT, XRDC_HWCFG2_PIDP3_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP4[4] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP4 field. */
#define XRDC_RD_HWCFG2_PIDP4(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP4_MASK) >> XRDC_HWCFG2_PIDP4_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP4(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP4_SHIFT, XRDC_HWCFG2_PIDP4_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP5[5] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP5 field. */
#define XRDC_RD_HWCFG2_PIDP5(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP5_MASK) >> XRDC_HWCFG2_PIDP5_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP5(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP5_SHIFT, XRDC_HWCFG2_PIDP5_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP6[6] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP6 field. */
#define XRDC_RD_HWCFG2_PIDP6(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP6_MASK) >> XRDC_HWCFG2_PIDP6_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP6(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP6_SHIFT, XRDC_HWCFG2_PIDP6_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP7[7] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP7 field. */
#define XRDC_RD_HWCFG2_PIDP7(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP7_MASK) >> XRDC_HWCFG2_PIDP7_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP7(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP7_SHIFT, XRDC_HWCFG2_PIDP7_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP8[8] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP8 field. */
#define XRDC_RD_HWCFG2_PIDP8(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP8_MASK) >> XRDC_HWCFG2_PIDP8_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP8(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP8_SHIFT, XRDC_HWCFG2_PIDP8_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP9[9] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP9 field. */
#define XRDC_RD_HWCFG2_PIDP9(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP9_MASK) >> XRDC_HWCFG2_PIDP9_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP9(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP9_SHIFT, XRDC_HWCFG2_PIDP9_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP10[10] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP10 field. */
#define XRDC_RD_HWCFG2_PIDP10(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP10_MASK) >> XRDC_HWCFG2_PIDP10_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP10(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP10_SHIFT, XRDC_HWCFG2_PIDP10_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP11[11] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP11 field. */
#define XRDC_RD_HWCFG2_PIDP11(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP11_MASK) >> XRDC_HWCFG2_PIDP11_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP11(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP11_SHIFT, XRDC_HWCFG2_PIDP11_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP12[12] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP12 field. */
#define XRDC_RD_HWCFG2_PIDP12(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP12_MASK) >> XRDC_HWCFG2_PIDP12_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP12(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP12_SHIFT, XRDC_HWCFG2_PIDP12_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP13[13] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP13 field. */
#define XRDC_RD_HWCFG2_PIDP13(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP13_MASK) >> XRDC_HWCFG2_PIDP13_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP13(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP13_SHIFT, XRDC_HWCFG2_PIDP13_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP14[14] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP14 field. */
#define XRDC_RD_HWCFG2_PIDP14(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP14_MASK) >> XRDC_HWCFG2_PIDP14_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP14(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP14_SHIFT, XRDC_HWCFG2_PIDP14_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP15[15] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP15 field. */
#define XRDC_RD_HWCFG2_PIDP15(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP15_MASK) >> XRDC_HWCFG2_PIDP15_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP15(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP15_SHIFT, XRDC_HWCFG2_PIDP15_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP16[16] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP16 field. */
#define XRDC_RD_HWCFG2_PIDP16(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP16_MASK) >> XRDC_HWCFG2_PIDP16_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP16(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP16_SHIFT, XRDC_HWCFG2_PIDP16_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP17[17] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP17 field. */
#define XRDC_RD_HWCFG2_PIDP17(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP17_MASK) >> XRDC_HWCFG2_PIDP17_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP17(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP17_SHIFT, XRDC_HWCFG2_PIDP17_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP18[18] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP18 field. */
#define XRDC_RD_HWCFG2_PIDP18(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP18_MASK) >> XRDC_HWCFG2_PIDP18_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP18(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP18_SHIFT, XRDC_HWCFG2_PIDP18_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP19[19] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP19 field. */
#define XRDC_RD_HWCFG2_PIDP19(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP19_MASK) >> XRDC_HWCFG2_PIDP19_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP19(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP19_SHIFT, XRDC_HWCFG2_PIDP19_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP20[20] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP20 field. */
#define XRDC_RD_HWCFG2_PIDP20(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP20_MASK) >> XRDC_HWCFG2_PIDP20_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP20(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP20_SHIFT, XRDC_HWCFG2_PIDP20_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP21[21] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP21 field. */
#define XRDC_RD_HWCFG2_PIDP21(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP21_MASK) >> XRDC_HWCFG2_PIDP21_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP21(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP21_SHIFT, XRDC_HWCFG2_PIDP21_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP22[22] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP22 field. */
#define XRDC_RD_HWCFG2_PIDP22(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP22_MASK) >> XRDC_HWCFG2_PIDP22_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP22(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP22_SHIFT, XRDC_HWCFG2_PIDP22_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP23[23] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP23 field. */
#define XRDC_RD_HWCFG2_PIDP23(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP23_MASK) >> XRDC_HWCFG2_PIDP23_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP23(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP23_SHIFT, XRDC_HWCFG2_PIDP23_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP24[24] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP24 field. */
#define XRDC_RD_HWCFG2_PIDP24(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP24_MASK) >> XRDC_HWCFG2_PIDP24_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP24(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP24_SHIFT, XRDC_HWCFG2_PIDP24_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP25[25] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP25 field. */
#define XRDC_RD_HWCFG2_PIDP25(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP25_MASK) >> XRDC_HWCFG2_PIDP25_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP25(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP25_SHIFT, XRDC_HWCFG2_PIDP25_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP26[26] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP26 field. */
#define XRDC_RD_HWCFG2_PIDP26(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP26_MASK) >> XRDC_HWCFG2_PIDP26_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP26(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP26_SHIFT, XRDC_HWCFG2_PIDP26_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP27[27] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP27 field. */
#define XRDC_RD_HWCFG2_PIDP27(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP27_MASK) >> XRDC_HWCFG2_PIDP27_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP27(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP27_SHIFT, XRDC_HWCFG2_PIDP27_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP28[28] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP28 field. */
#define XRDC_RD_HWCFG2_PIDP28(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP28_MASK) >> XRDC_HWCFG2_PIDP28_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP28(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP28_SHIFT, XRDC_HWCFG2_PIDP28_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP29[29] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP29 field. */
#define XRDC_RD_HWCFG2_PIDP29(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP29_MASK) >> XRDC_HWCFG2_PIDP29_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP29(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP29_SHIFT, XRDC_HWCFG2_PIDP29_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP30[30] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP30 field. */
#define XRDC_RD_HWCFG2_PIDP30(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP30_MASK) >> XRDC_HWCFG2_PIDP30_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP30(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP30_SHIFT, XRDC_HWCFG2_PIDP30_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG2, field PIDP31[31] (RO)
 *
 * Process identifier present from bus master n, where n = [31-0]. This field
 * provides a bitmap to signal that bus master n (where n matches the bit number)
 * sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG2_PIDP31 field. */
#define XRDC_RD_HWCFG2_PIDP31(base) ((XRDC_HWCFG2_REG(base) & XRDC_HWCFG2_PIDP31_MASK) >> XRDC_HWCFG2_PIDP31_SHIFT)
#define XRDC_BRD_HWCFG2_PIDP31(base) (BME_UBFX32(&XRDC_HWCFG2_REG(base), XRDC_HWCFG2_PIDP31_SHIFT, XRDC_HWCFG2_PIDP31_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_HWCFG3 - Hardware Configuration Register 3
 ******************************************************************************/

/*!
 * @brief XRDC_HWCFG3 - Hardware Configuration Register 3 (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register contains information on the XRDC's hardware configuration.
 * Specifically, it provides a bitmap signaling the presence of a process identifier
 * (PID) register sourced from the given bus master. The HWCFG3 register is
 * associated with bus masters [63-32], while the HWCFG2 register covers bus masters
 * [31-0]. Attempted writes are error terminated. Access: Secure Privileged Read
 */
/*!
 * @name Constants and macros for entire XRDC_HWCFG3 register
 */
/*@{*/
#define XRDC_RD_HWCFG3(base)     (XRDC_HWCFG3_REG(base))
/*@}*/

/*
 * Constants & macros for individual XRDC_HWCFG3 bitfields
 */

/*!
 * @name Register XRDC_HWCFG3, field PIDP32[0] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP32 field. */
#define XRDC_RD_HWCFG3_PIDP32(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP32_MASK) >> XRDC_HWCFG3_PIDP32_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP32(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP32_SHIFT, XRDC_HWCFG3_PIDP32_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP33[1] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP33 field. */
#define XRDC_RD_HWCFG3_PIDP33(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP33_MASK) >> XRDC_HWCFG3_PIDP33_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP33(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP33_SHIFT, XRDC_HWCFG3_PIDP33_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP34[2] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP34 field. */
#define XRDC_RD_HWCFG3_PIDP34(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP34_MASK) >> XRDC_HWCFG3_PIDP34_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP34(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP34_SHIFT, XRDC_HWCFG3_PIDP34_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP35[3] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP35 field. */
#define XRDC_RD_HWCFG3_PIDP35(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP35_MASK) >> XRDC_HWCFG3_PIDP35_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP35(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP35_SHIFT, XRDC_HWCFG3_PIDP35_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP36[4] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP36 field. */
#define XRDC_RD_HWCFG3_PIDP36(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP36_MASK) >> XRDC_HWCFG3_PIDP36_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP36(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP36_SHIFT, XRDC_HWCFG3_PIDP36_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP37[5] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP37 field. */
#define XRDC_RD_HWCFG3_PIDP37(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP37_MASK) >> XRDC_HWCFG3_PIDP37_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP37(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP37_SHIFT, XRDC_HWCFG3_PIDP37_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP38[6] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP38 field. */
#define XRDC_RD_HWCFG3_PIDP38(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP38_MASK) >> XRDC_HWCFG3_PIDP38_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP38(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP38_SHIFT, XRDC_HWCFG3_PIDP38_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP39[7] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP39 field. */
#define XRDC_RD_HWCFG3_PIDP39(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP39_MASK) >> XRDC_HWCFG3_PIDP39_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP39(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP39_SHIFT, XRDC_HWCFG3_PIDP39_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP40[8] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP40 field. */
#define XRDC_RD_HWCFG3_PIDP40(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP40_MASK) >> XRDC_HWCFG3_PIDP40_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP40(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP40_SHIFT, XRDC_HWCFG3_PIDP40_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP41[9] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP41 field. */
#define XRDC_RD_HWCFG3_PIDP41(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP41_MASK) >> XRDC_HWCFG3_PIDP41_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP41(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP41_SHIFT, XRDC_HWCFG3_PIDP41_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP42[10] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP42 field. */
#define XRDC_RD_HWCFG3_PIDP42(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP42_MASK) >> XRDC_HWCFG3_PIDP42_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP42(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP42_SHIFT, XRDC_HWCFG3_PIDP42_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP43[11] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP43 field. */
#define XRDC_RD_HWCFG3_PIDP43(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP43_MASK) >> XRDC_HWCFG3_PIDP43_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP43(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP43_SHIFT, XRDC_HWCFG3_PIDP43_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP44[12] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP44 field. */
#define XRDC_RD_HWCFG3_PIDP44(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP44_MASK) >> XRDC_HWCFG3_PIDP44_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP44(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP44_SHIFT, XRDC_HWCFG3_PIDP44_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP45[13] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP45 field. */
#define XRDC_RD_HWCFG3_PIDP45(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP45_MASK) >> XRDC_HWCFG3_PIDP45_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP45(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP45_SHIFT, XRDC_HWCFG3_PIDP45_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP46[14] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP46 field. */
#define XRDC_RD_HWCFG3_PIDP46(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP46_MASK) >> XRDC_HWCFG3_PIDP46_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP46(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP46_SHIFT, XRDC_HWCFG3_PIDP46_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP47[15] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP47 field. */
#define XRDC_RD_HWCFG3_PIDP47(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP47_MASK) >> XRDC_HWCFG3_PIDP47_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP47(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP47_SHIFT, XRDC_HWCFG3_PIDP47_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP48[16] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP48 field. */
#define XRDC_RD_HWCFG3_PIDP48(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP48_MASK) >> XRDC_HWCFG3_PIDP48_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP48(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP48_SHIFT, XRDC_HWCFG3_PIDP48_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP49[17] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP49 field. */
#define XRDC_RD_HWCFG3_PIDP49(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP49_MASK) >> XRDC_HWCFG3_PIDP49_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP49(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP49_SHIFT, XRDC_HWCFG3_PIDP49_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP50[18] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP50 field. */
#define XRDC_RD_HWCFG3_PIDP50(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP50_MASK) >> XRDC_HWCFG3_PIDP50_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP50(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP50_SHIFT, XRDC_HWCFG3_PIDP50_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP51[19] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP51 field. */
#define XRDC_RD_HWCFG3_PIDP51(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP51_MASK) >> XRDC_HWCFG3_PIDP51_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP51(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP51_SHIFT, XRDC_HWCFG3_PIDP51_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP52[20] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP52 field. */
#define XRDC_RD_HWCFG3_PIDP52(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP52_MASK) >> XRDC_HWCFG3_PIDP52_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP52(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP52_SHIFT, XRDC_HWCFG3_PIDP52_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP53[21] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP53 field. */
#define XRDC_RD_HWCFG3_PIDP53(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP53_MASK) >> XRDC_HWCFG3_PIDP53_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP53(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP53_SHIFT, XRDC_HWCFG3_PIDP53_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP54[22] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP54 field. */
#define XRDC_RD_HWCFG3_PIDP54(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP54_MASK) >> XRDC_HWCFG3_PIDP54_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP54(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP54_SHIFT, XRDC_HWCFG3_PIDP54_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP55[23] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP55 field. */
#define XRDC_RD_HWCFG3_PIDP55(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP55_MASK) >> XRDC_HWCFG3_PIDP55_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP55(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP55_SHIFT, XRDC_HWCFG3_PIDP55_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP56[24] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP56 field. */
#define XRDC_RD_HWCFG3_PIDP56(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP56_MASK) >> XRDC_HWCFG3_PIDP56_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP56(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP56_SHIFT, XRDC_HWCFG3_PIDP56_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP57[25] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP57 field. */
#define XRDC_RD_HWCFG3_PIDP57(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP57_MASK) >> XRDC_HWCFG3_PIDP57_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP57(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP57_SHIFT, XRDC_HWCFG3_PIDP57_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP58[26] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP58 field. */
#define XRDC_RD_HWCFG3_PIDP58(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP58_MASK) >> XRDC_HWCFG3_PIDP58_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP58(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP58_SHIFT, XRDC_HWCFG3_PIDP58_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP59[27] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP59 field. */
#define XRDC_RD_HWCFG3_PIDP59(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP59_MASK) >> XRDC_HWCFG3_PIDP59_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP59(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP59_SHIFT, XRDC_HWCFG3_PIDP59_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP60[28] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP60 field. */
#define XRDC_RD_HWCFG3_PIDP60(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP60_MASK) >> XRDC_HWCFG3_PIDP60_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP60(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP60_SHIFT, XRDC_HWCFG3_PIDP60_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP61[29] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP61 field. */
#define XRDC_RD_HWCFG3_PIDP61(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP61_MASK) >> XRDC_HWCFG3_PIDP61_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP61(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP61_SHIFT, XRDC_HWCFG3_PIDP61_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP62[30] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP62 field. */
#define XRDC_RD_HWCFG3_PIDP62(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP62_MASK) >> XRDC_HWCFG3_PIDP62_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP62(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP62_SHIFT, XRDC_HWCFG3_PIDP62_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_HWCFG3, field PIDP63[31] (RO)
 *
 * Process identifier present from bus master n, where n = [63-32]. This field
 * provides a bitmap to signal that bus master n (where n is defined as 32 + bit
 * number) sources a process identifier register to the XRDC_MDAC logic.
 *
 * Values:
 * - 0b0 - Bus master "n" does not source a process identifier register. The
 *     XRDC_MDAC logic provides the needed PID for processor cores.
 * - 0b1 - Bus master "n" sources a process identifier register to the XRDC_MDAC
 *     logic.
 */
/*@{*/
/*! @brief Read current value of the XRDC_HWCFG3_PIDP63 field. */
#define XRDC_RD_HWCFG3_PIDP63(base) ((XRDC_HWCFG3_REG(base) & XRDC_HWCFG3_PIDP63_MASK) >> XRDC_HWCFG3_PIDP63_SHIFT)
#define XRDC_BRD_HWCFG3_PIDP63(base) (BME_UBFX32(&XRDC_HWCFG3_REG(base), XRDC_HWCFG3_PIDP63_SHIFT, XRDC_HWCFG3_PIDP63_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_MDACFG - Master Domain Assignment Configuration Register
 ******************************************************************************/

/*!
 * @brief XRDC_MDACFG - Master Domain Assignment Configuration Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register defines the number of implemented domain assignment registers
 * [1-8] for bus master n, where n+1 can specify from 1 to 64 bus masters. These
 * registers are organized as a byte-sized data array and can be read using 8-,
 * 16- or 32-bit accesses. An all-zero value (NCM = 0, NMDAR = 0) indicates a
 * non-existent bus master. Attempted writes are error terminated. Typically,
 * processor bus masters have one or more domain assignment registers, while
 * non-processor masters have a single domain assignment register. Access: Secure Privileged
 * Read
 */
/*!
 * @name Constants and macros for entire XRDC_MDACFG register
 */
/*@{*/
#define XRDC_RD_MDACFG(base, index) (XRDC_MDACFG_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual XRDC_MDACFG bitfields
 */

/*!
 * @name Register XRDC_MDACFG, field NMDAR[3:0] (RO)
 *
 * Number of master domain assignment registers for bus master n. This field
 * specifies the number of registers associated with the master domain assignment
 * register for a given bus master. The value is limited to the range [0-8], where
 * zero indicates a non-existent bus master and non-zero values indicate the
 * number of implemented registers associated with this MDAn.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDACFG_NMDAR field. */
#define XRDC_RD_MDACFG_NMDAR(base, index) ((XRDC_MDACFG_REG(base, index) & XRDC_MDACFG_NMDAR_MASK) >> XRDC_MDACFG_NMDAR_SHIFT)
#define XRDC_BRD_MDACFG_NMDAR(base, index) (BME_UBFX8(&XRDC_MDACFG_REG(base, index), XRDC_MDACFG_NMDAR_SHIFT, XRDC_MDACFG_NMDAR_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDACFG, field NCM[7] (RO)
 *
 * Non-CPU Master. This field signals that bus master n is a non-CPU master. It
 * specifies that the format of the associated MDA_Wm_n register defines a
 * non-processor domain assignment. This field is zero for a non-existent bus master.
 *
 * Values:
 * - 0b0 - Bus master is a processor.
 * - 0b1 - Bus master is a non-processor.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDACFG_NCM field. */
#define XRDC_RD_MDACFG_NCM(base, index) ((XRDC_MDACFG_REG(base, index) & XRDC_MDACFG_NCM_MASK) >> XRDC_MDACFG_NCM_SHIFT)
#define XRDC_BRD_MDACFG_NCM(base, index) (BME_UBFX8(&XRDC_MDACFG_REG(base, index), XRDC_MDACFG_NCM_SHIFT, XRDC_MDACFG_NCM_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_MRCFG - Memory Region Configuration Register
 ******************************************************************************/

/*!
 * @brief XRDC_MRCFG - Memory Region Configuration Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register defines the number of implemented memory region descriptors
 * [1-16] for each MRCn, where n+1 can specify up to 16 instances. Implementations
 * of 4, 8, 12 or 16 region descriptors are supported. These registers are
 * organized as a byte-sized data array and can be read using 8-, 16- or 32-bit
 * accesses. A zero value indicates a non-existent memory region controller instance.
 * Attempted writes are error terminated. Access: Secure Privileged Read
 */
/*!
 * @name Constants and macros for entire XRDC_MRCFG register
 */
/*@{*/
#define XRDC_RD_MRCFG(base, index) (XRDC_MRCFG_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual XRDC_MRCFG bitfields
 */

/*!
 * @name Register XRDC_MRCFG, field NMGD[4:0] (RO)
 *
 * Number of memory region descriptors for memory region controller n. This
 * field specifies the number of memory region descriptors associated with a given
 * memory region controller instance. The value is limited to the range [0-16],
 * where zero indicates a non-existent memory region controller instance and
 * non-zero values indicate the number of implemented memory region descriptors [4,
 * 8,12,16] associated with the XRDC_MRCn submodule.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRCFG_NMGD field. */
#define XRDC_RD_MRCFG_NMGD(base, index) ((XRDC_MRCFG_REG(base, index) & XRDC_MRCFG_NMGD_MASK) >> XRDC_MRCFG_NMGD_SHIFT)
#define XRDC_BRD_MRCFG_NMGD(base, index) (BME_UBFX8(&XRDC_MRCFG_REG(base, index), XRDC_MRCFG_NMGD_SHIFT, XRDC_MRCFG_NMGD_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_DERRLOC - Domain Error Location Register
 ******************************************************************************/

/*!
 * @brief XRDC_DERRLOC - Domain Error Location Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When an access violation is detected by either a memory region controller or
 * a peripheral access controller, address and attribute information of the
 * offending access is captured. Using the faulting domainID number as the index (n),
 * this array of read-only registers provide additional information signaling the
 * instance number of the submodule where the access violation(s) occurred.
 * Since the resulting exception handler needs the submodule instance to retrieve the
 * captured address and attribute information from DERR_W0_n and DERR_W1_n,
 * these registers provide the instance number details. These registers are organized
 * as a word array, indexed by the faulting domain number, with the contents of
 * each register providing a bitmap signaling the instance number(s) associated
 * with all submodules containing captured error information for that domain.
 * There may be multiple access violations, across multiple instances, pending for a
 * given domain. It is suggested that exception handler software use a "find
 * first one" instruction (alternatively known as "count leading zeroes") to quickly
 * and efficiently find the instance number containing access violation details.
 * Once the instance number has been determined, the captured error address and
 * attribute information can easily be retrieved from the domain error registers
 * (DERR_W0_n, DERR_W1_n). See Domain error capture management for more details.
 * Attempted writes are error terminated. Access: Secure Privileged Read
 */
/*!
 * @name Constants and macros for entire XRDC_DERRLOC register
 */
/*@{*/
#define XRDC_RD_DERRLOC(base, index) (XRDC_DERRLOC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual XRDC_DERRLOC bitfields
 */

/*!
 * @name Register XRDC_DERRLOC, field MRCINST[15:0] (RO)
 *
 * Memory region controller instance number. This field provides a bitmap
 * signaling the presence of a detected access violation for domain n in the
 * implemented instances of the memory region controller. Memory region controller instance
 * 0 corresponds to bit 0, instance 1 to bit 1, instance 2 to bit 2, etc.
 * Multiple bits can be set at any time indicating access violations for this domain
 * have been detected across multiple instances of the memory region controllers.
 * For each bit in this field: 0:The memory region controller has not detected an
 * access violation or is not physically present. 1:The memory region controller
 * has detected one or more access violations for this domain.
 */
/*@{*/
/*! @brief Read current value of the XRDC_DERRLOC_MRCINST field. */
#define XRDC_RD_DERRLOC_MRCINST(base, index) ((XRDC_DERRLOC_REG(base, index) & XRDC_DERRLOC_MRCINST_MASK) >> XRDC_DERRLOC_MRCINST_SHIFT)
#define XRDC_BRD_DERRLOC_MRCINST(base, index) (XRDC_RD_DERRLOC_MRCINST(base, index))
/*@}*/

/*!
 * @name Register XRDC_DERRLOC, field PACINST[19:16] (RO)
 *
 * Peripheral access controller instance number. This field provides a bitmap
 * signaling the presence of a detected access violation for domain n in the
 * implemented instances of the peripheral access controller. Peripheral access
 * controller instance 0 corresponds to bit 16, instance 1 to bit 17, etc. Multiple bits
 * can be set at any time indicating access violations for this domain have been
 * detected across multiple instances of the peripheral access controllers. For
 * each bit in this field: 0: The peripheral access controller has not detected
 * an access violation or is not physically present. 1: The peripheral access
 * controller has detected one or more access violations for this domain.
 */
/*@{*/
/*! @brief Read current value of the XRDC_DERRLOC_PACINST field. */
#define XRDC_RD_DERRLOC_PACINST(base, index) ((XRDC_DERRLOC_REG(base, index) & XRDC_DERRLOC_PACINST_MASK) >> XRDC_DERRLOC_PACINST_SHIFT)
#define XRDC_BRD_DERRLOC_PACINST(base, index) (BME_UBFX32(&XRDC_DERRLOC_REG(base, index), XRDC_DERRLOC_PACINST_SHIFT, XRDC_DERRLOC_PACINST_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_DERR_W - Domain Error Word0 Register
 ******************************************************************************/

/*!
 * @brief XRDC_DERR_W - Domain Error Word0 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * When an access violation is detected by either a memory region controller or
 * a peripheral access controller, address and attribute information of the
 * offending access is captured. This read-only register array provides the captured
 * error access address. The registers are organized in a data structure based on
 * instance number, that is, n = the instance number of the submodule which
 * detected the access violation and are read using information directly extracted
 * from the DERRLOCn registers. The memory-mapped error capture detail registers are
 * organized as twenty sequential 16-byte entries, first the 16 register sets
 * associated with the memory region controllers, then the 4 registers sets
 * associated with the peripheral access controllers. Each 16-byte structure contains
 * DERR_W0_n, DERR_W1_n, DERR_W2_n and DERR_W3_n. The error capture registers in
 * the memory region controller and peripheral access controller submodules contain
 * physical registers for each domain, but are organized in the DERR_W0_n and
 * DERR_W1_n registers to provide the information for the requesting domain only.
 * Thus, the access violation exception handler for each domain only has
 * visibility into the captured error information for its own domain. See Domain error
 * capture management for more details. When an access violation is detected and the
 * offending information captured, subsequent updates to this register are
 * disabled until the required data pattern is written to the DERR_W3_n register. At
 * that time, this register is cleared and re-enabled to capture the next access
 * violation. Attempted writes are error terminated as are attempted reads of an
 * MRC or PAC instance that is not physically present. Access: Secure Privileged
 * Read
 */
/*!
 * @name Constants and macros for entire XRDC_DERR_W register
 */
/*@{*/
#define XRDC_RD_DERR_W(base, index, index2) (XRDC_DERR_W_REG(base, index, index2))
/*@}*/

/*
 * Constants & macros for individual XRDC_DERR_W bitfields
 */

/*!
 * @name Register XRDC_DERR_W, field EDID[3:0] (RO)
 *
 * Error domain identifier. This field captures the domain identifier of the
 * access violation.
 */
/*@{*/
/*! @brief Read current value of the XRDC_DERR_W_EDID field. */
#define XRDC_RD_DERR_W_EDID(base, index, index2) ((XRDC_DERR_W_REG(base, index, index2) & XRDC_DERR_W_EDID_MASK) >> XRDC_DERR_W_EDID_SHIFT)
#define XRDC_BRD_DERR_W_EDID(base, index, index2) (BME_UBFX32(&XRDC_DERR_W_REG(base, index, index2), XRDC_DERR_W_EDID_SHIFT, XRDC_DERR_W_EDID_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_DERR_W, field EATR[10:8] (RO)
 *
 * Error attributes. This field captures certain attributes of the access
 * violation.
 *
 * Values:
 * - 0b000 - Secure user mode, instruction fetch access
 * - 0b001 - Secure user mode, data access
 * - 0b010 - Secure privileged mode, instruction fetch access
 * - 0b011 - Secure privileged mode, data access
 * - 0b100 - Nonsecure user mode, instruction fetch access
 * - 0b101 - Nonsecure user mode, data access
 * - 0b110 - Nonsecure privileged mode, instruction fetch access
 * - 0b111 - Nonsecure privileged mode, data access
 */
/*@{*/
/*! @brief Read current value of the XRDC_DERR_W_EATR field. */
#define XRDC_RD_DERR_W_EATR(base, index, index2) ((XRDC_DERR_W_REG(base, index, index2) & XRDC_DERR_W_EATR_MASK) >> XRDC_DERR_W_EATR_SHIFT)
#define XRDC_BRD_DERR_W_EATR(base, index, index2) (BME_UBFX32(&XRDC_DERR_W_REG(base, index, index2), XRDC_DERR_W_EATR_SHIFT, XRDC_DERR_W_EATR_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_DERR_W, field ERW[11] (RO)
 *
 * Error read/write. This field signals whether the captured access violation
 * occurred on a read or write reference.
 *
 * Values:
 * - 0b0 - Read access
 * - 0b1 - Write access
 */
/*@{*/
/*! @brief Read current value of the XRDC_DERR_W_ERW field. */
#define XRDC_RD_DERR_W_ERW(base, index, index2) ((XRDC_DERR_W_REG(base, index, index2) & XRDC_DERR_W_ERW_MASK) >> XRDC_DERR_W_ERW_SHIFT)
#define XRDC_BRD_DERR_W_ERW(base, index, index2) (BME_UBFX32(&XRDC_DERR_W_REG(base, index, index2), XRDC_DERR_W_ERW_SHIFT, XRDC_DERR_W_ERW_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_DERR_W, field EPORT[26:24] (RO)
 *
 * Error port. This field identifies the encoded port number of the memory
 * region controller that detected the access violation. The MRC port number
 * connection is device-specific. See the chip configuration details for more information.
 * For access violations detected by the peripheral access controller, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the XRDC_DERR_W_EPORT field. */
#define XRDC_RD_DERR_W_EPORT(base, index, index2) ((XRDC_DERR_W_REG(base, index, index2) & XRDC_DERR_W_EPORT_MASK) >> XRDC_DERR_W_EPORT_SHIFT)
#define XRDC_BRD_DERR_W_EPORT(base, index, index2) (BME_UBFX32(&XRDC_DERR_W_REG(base, index, index2), XRDC_DERR_W_EPORT_SHIFT, XRDC_DERR_W_EPORT_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_DERR_W, field EST[31:30] (RO)
 *
 * Error state. This field signals the state of access violations for this
 * domain in this instance of the memory region controller or peripheral access
 * controller. Once an access violation has been detected and the faulting address and
 * attribute information stored, subsequent errors are simply recorded as an
 * overrun condition without any data captured. After retrieving the faulting address
 * and attributes, the error capture mechanism must be rearmed by performing a
 * write to DERR_W3_n.
 *
 * Values:
 * - 0b00 - No access violation has been detected.
 * - 0b01 - No access violation has been detected.
 * - 0b10 - A single access violation has been detected.
 * - 0b11 - Multiple access violations for this domain have been detected by
 *     this submodule instance. Only the address and attribute information for the
 *     first error have been captured in DERR_W0_n and DERR_W1_n.
 */
/*@{*/
/*! @brief Read current value of the XRDC_DERR_W_EST field. */
#define XRDC_RD_DERR_W_EST(base, index, index2) ((XRDC_DERR_W_REG(base, index, index2) & XRDC_DERR_W_EST_MASK) >> XRDC_DERR_W_EST_SHIFT)
#define XRDC_BRD_DERR_W_EST(base, index, index2) (BME_UBFX32(&XRDC_DERR_W_REG(base, index, index2), XRDC_DERR_W_EST_SHIFT, XRDC_DERR_W_EST_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_DERR_W, field RECR[31:30] (WORZ)
 *
 * Rearm Error Capture Registers. This 2-bit write-only field controls the
 * rearming of the domain error capture registers. access controller. Once an access
 * violation has been detected with the faulting address and attribute information
 * stored, subsequent errors are simply recorded as an overrun condition without
 * any data captured. A write with the appropriate value in this field rearms
 * the error capture mechanism and clears the DERR_W0_n and DERR_W1_n registers. if
 * RECR == 01b then DERR_W0_n and DERR_W1_n are cleared, and re-enabled to
 * capture the next access violation else no operation is performed.
 */
/*@{*/
/*! @brief Set the RECR field to a new value. */
#define XRDC_WR_DERR_W_RECR(base, index, index2, value) (XRDC_RMW_DERR_W(base, index, index2, XRDC_DERR_W_RECR_MASK, XRDC_DERR_W_RECR(value)))
#define XRDC_BWR_DERR_W_RECR(base, index, index2, value) (BME_BFI32(&XRDC_DERR_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_DERR_W_RECR_SHIFT), XRDC_DERR_W_RECR_SHIFT, XRDC_DERR_W_RECR_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_PID - Process Identifier
 ******************************************************************************/

/*!
 * @brief XRDC_PID - Process Identifier (RW)
 *
 * Reset value: 0x00000000U
 *
 * In the XRDC's access control definition, each processor has a corresponding
 * process identifier (PID) which performs two important functions: the PID[5] bit
 * defines the secure/nonsecure attribute associated with an executing task, and
 * the entire value can be used to group tasks into different domains. While
 * certain processors include this register in their programming model definitions,
 * others do not. This register is provided for those processors that do not
 * include a PID register in their programming models. Secure privileged software
 * saves and restores the PID as part of any context switch. This data structure
 * defines an array of 32-bit values, one per bus master, that define the PID. Since
 * this register resource is only applicable to processor cores, the data
 * structure is typically sparsely populated. The HWCFG[2-3] registers provide a bitmap
 * of the implemented PIDn registers. This data structure is indexed using the
 * physical bus master number. For processors only supporting the 3-state access
 * control model (SecurePriv, SecureUser, NonsecureUser), the nonsecure_n output
 * signal from the MDAC submodule is forced to zero while in privileged mode to
 * enable precise state transitions between user and privileged modes.
 * Specifically, the MDAC logic for bus master n forms the nonsecure attribute output signal
 * as a function of 2 configuration bits: PIDn[TSM] and HWCFG{2,3}[n]. The MDAC
 * operates as described in Master Domain Assignment Controller (XRDC_MDAC). Reads
 * of the PIDn register return the contents of this register, or the PIDn value
 * directly sourced from a processor. For non-processor bus masters, this
 * register does not exist and any attempted read is error terminated. Generation of the
 * nonsecure_out[n] Attribute Configuration {PIDn[TSM], HWCFG{2,3}[n]}
 * local_nonsecure[n] nonsecure_out[n] 00b nonsecure_in[n] local_nonsecure[n] 01b
 * nonsecure_in[n] local_nonsecure[n] & ~priv_in[n] 10b PIDn[5] local_nonsecure[n] &
 * ~priv_in[n] 11b pid_in[n][5] local_nonsecure[n] & ~priv_in[n]
 */
/*!
 * @name Constants and macros for entire XRDC_PID register
 */
/*@{*/
#define XRDC_RD_PID(base, index) (XRDC_PID_REG(base, index))
#define XRDC_WR_PID(base, index, value) (XRDC_PID_REG(base, index) = (value))
#define XRDC_RMW_PID(base, index, mask, value) (XRDC_WR_PID(base, index, (XRDC_RD_PID(base, index) & ~(mask)) | (value)))
#define XRDC_SET_PID(base, index, value) (BME_OR32(&XRDC_PID_REG(base, index), (uint32_t)(value)))
#define XRDC_CLR_PID(base, index, value) (BME_AND32(&XRDC_PID_REG(base, index), (uint32_t)(~(value))))
#define XRDC_TOG_PID(base, index, value) (BME_XOR32(&XRDC_PID_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XRDC_PID bitfields
 */

/*!
 * @name Register XRDC_PID, field PID[5:0] (RW)
 *
 * Process identifier. The PIDn[5] bit determines the secure (PID[5] = 0) or
 * nonsecure (PID[5] = 1) attribute for transactions associated with the
 * corresponding processor. If the processor sources its PIDn directly, then secure
 * privileged reads of this memory location return the processor register for this field.
 */
/*@{*/
/*! @brief Read current value of the XRDC_PID_PID field. */
#define XRDC_RD_PID_PID(base, index) ((XRDC_PID_REG(base, index) & XRDC_PID_PID_MASK) >> XRDC_PID_PID_SHIFT)
#define XRDC_BRD_PID_PID(base, index) (BME_UBFX32(&XRDC_PID_REG(base, index), XRDC_PID_PID_SHIFT, XRDC_PID_PID_WIDTH))

/*! @brief Set the PID field to a new value. */
#define XRDC_WR_PID_PID(base, index, value) (XRDC_RMW_PID(base, index, XRDC_PID_PID_MASK, XRDC_PID_PID(value)))
#define XRDC_BWR_PID_PID(base, index, value) (BME_BFI32(&XRDC_PID_REG(base, index), ((uint32_t)(value) << XRDC_PID_PID_SHIFT), XRDC_PID_PID_SHIFT, XRDC_PID_PID_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PID, field TSM[28] (RW)
 *
 * Three-state model. If asserted, this bit indicates the associated processor
 * core only supports the 3-state access control model. This indicator is
 * "sticky", that is, once set, it remains set until the next reset. For processors only
 * supporting the 3-state access control model, this field must be set before
 * loading any nonsecure value into the PID. See for the specification of the
 * privileged and nonsecure attributes generated by MDAC.
 */
/*@{*/
/*! @brief Read current value of the XRDC_PID_TSM field. */
#define XRDC_RD_PID_TSM(base, index) ((XRDC_PID_REG(base, index) & XRDC_PID_TSM_MASK) >> XRDC_PID_TSM_SHIFT)
#define XRDC_BRD_PID_TSM(base, index) (BME_UBFX32(&XRDC_PID_REG(base, index), XRDC_PID_TSM_SHIFT, XRDC_PID_TSM_WIDTH))

/*! @brief Set the TSM field to a new value. */
#define XRDC_WR_PID_TSM(base, index, value) (XRDC_RMW_PID(base, index, XRDC_PID_TSM_MASK, XRDC_PID_TSM(value)))
#define XRDC_BWR_PID_TSM(base, index, value) (BME_BFI32(&XRDC_PID_REG(base, index), ((uint32_t)(value) << XRDC_PID_TSM_SHIFT), XRDC_PID_TSM_SHIFT, XRDC_PID_TSM_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PID, field LK2[30:29] (RW)
 *
 * Lock. This field provides a locking mechanism that can be used to limit the
 * ability to write the register. Once set, these bits individually remain
 * asserted until the next reset. If the processor sources its PIDn directly, that is,
 * HWCFG{2-3}[PIDPn = 1], then secure privileged reads of this memory location
 * return zero for this field.
 *
 * Values:
 * - 0b00 - Register can be written by any secure privileged write.
 * - 0b01 - Register can be written by any secure privileged write.
 * - 0b10 - Register can only be written by a secure privileged write from bus
 *     master n.
 * - 0b11 - Register is locked (read-only) until the next reset.
 */
/*@{*/
/*! @brief Read current value of the XRDC_PID_LK2 field. */
#define XRDC_RD_PID_LK2(base, index) ((XRDC_PID_REG(base, index) & XRDC_PID_LK2_MASK) >> XRDC_PID_LK2_SHIFT)
#define XRDC_BRD_PID_LK2(base, index) (BME_UBFX32(&XRDC_PID_REG(base, index), XRDC_PID_LK2_SHIFT, XRDC_PID_LK2_WIDTH))

/*! @brief Set the LK2 field to a new value. */
#define XRDC_WR_PID_LK2(base, index, value) (XRDC_RMW_PID(base, index, XRDC_PID_LK2_MASK, XRDC_PID_LK2(value)))
#define XRDC_BWR_PID_LK2(base, index, value) (BME_BFI32(&XRDC_PID_REG(base, index), ((uint32_t)(value) << XRDC_PID_LK2_SHIFT), XRDC_PID_LK2_SHIFT, XRDC_PID_LK2_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_MDA_W - Master Domain Assignment W0
 ******************************************************************************/

/*!
 * @brief XRDC_MDA_W - Master Domain Assignment W0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MDA_Wm_n registers provide a 2-dimensional data structure for assigning
 * bus masters to domains. There are up to 8 word-sized registers available for
 * each bus master (Wm), although the number of implemented registers is typically
 * less than the maximum and is defined by MDACFGn[NMDAR]. This per-master domain
 * assignment is then repeated for each bus master (MDAn). Thus, "n" specifies
 * the master number and "m" refers to the specific MDA register for a given bus
 * master. Each Wm within the MDAn structure is a word-sized definition; there are
 * two formats supported, one for processor cores and another for
 * non-processors. Processor masters typically support one or more Wm domain definitions, while
 * non-processor masters support a single Wm. The MDAC submodule is responsible
 * for the generation of domain identifiers for every transaction from every bus
 * master. If there is a single Wm for a given master, then the specified domain
 * identifier is used directly. If there are multiple Wm values for a given
 * master, then the MDAC evaluates the conditional terms to determine a "hit". For all
 * Wm "hits", their corresponding domain identifiers are simply logically summed
 * together (boolean OR). Use cases are typically expected to hit in a single Wm
 * for a processor master. Special care is needed if none of the conditional
 * terms "hit" in any Wm evaluation; for this case, the generated DID = 0 and
 * software needs to be aware of any potential access rights granted for this DID. The
 * domain format (DFMT = 0) definition allows three different specifications of
 * the DID for processors, while the DFMT = 1 supports two different
 * specifications of the DID for non-core bus masters. Access: Secure Privileged Read/write
 */
/*!
 * @name Constants and macros for entire XRDC_MDA_W register
 */
/*@{*/
#define XRDC_RD_MDA_W(base, index, index2) (XRDC_MDA_W_REG(base, index, index2))
#define XRDC_WR_MDA_W(base, index, index2, value) (XRDC_MDA_W_REG(base, index, index2) = (value))
#define XRDC_RMW_MDA_W(base, index, index2, mask, value) (XRDC_WR_MDA_W(base, index, index2, (XRDC_RD_MDA_W(base, index, index2) & ~(mask)) | (value)))
#define XRDC_SET_MDA_W(base, index, index2, value) (BME_OR32(&XRDC_MDA_W_REG(base, index, index2), (uint32_t)(value)))
#define XRDC_CLR_MDA_W(base, index, index2, value) (BME_AND32(&XRDC_MDA_W_REG(base, index, index2), (uint32_t)(~(value))))
#define XRDC_TOG_MDA_W(base, index, index2, value) (BME_XOR32(&XRDC_MDA_W_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XRDC_MDA_W bitfields
 */

/*!
 * @name Register XRDC_MDA_W, field DID[3:0] (RW)
 *
 * Domain identifier.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_DID field. */
#define XRDC_RD_MDA_W_DID(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_DID_MASK) >> XRDC_MDA_W_DID_SHIFT)
#define XRDC_BRD_MDA_W_DID(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_DID_SHIFT, XRDC_MDA_W_DID_WIDTH))

/*! @brief Set the DID field to a new value. */
#define XRDC_WR_MDA_W_DID(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_DID_MASK, XRDC_MDA_W_DID(value)))
#define XRDC_BWR_MDA_W_DID(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_DID_SHIFT), XRDC_MDA_W_DID_SHIFT, XRDC_MDA_W_DID_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field DIDSPA[5:4] (RW)
 *
 * The functionality of this field changes based on the value of DFMT: For
 * DFMT=0: Bits 1:0 define the logcal field DIDS, DID Select. This field selects the
 * source of the domain identifier. 00: Use MDAn[3:0] as the domain identifier.
 * 01: Use the input DID as the domain identifier. 10: Use MDAn[3:2] concatenated
 * with the low-order 2 bits of the input DID (DID_in[1:0]) as the domain
 * identifier. 11: Reserved for future use. For DFMT=1: Bits 1:0 define the logical field
 * PA, Privileged attribute. This field defines the privileged/user attribute
 * for non-processor cores. 00: Force the bus attribute for this master to user.
 * 01: Force the bus attribute for this master to privileged. 10: Use the bus
 * master's privileged/user attribute directly. 11: Use the bus master's
 * privileged/user attribute directly. The bus master's input privileged/user attribute is
 * used if PA = 1-, or this VLD = 0.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_DIDSPA field. */
#define XRDC_RD_MDA_W_DIDSPA(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_DIDSPA_MASK) >> XRDC_MDA_W_DIDSPA_SHIFT)
#define XRDC_BRD_MDA_W_DIDSPA(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_DIDSPA_SHIFT, XRDC_MDA_W_DIDSPA_WIDTH))

/*! @brief Set the DIDSPA field to a new value. */
#define XRDC_WR_MDA_W_DIDSPA(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_DIDSPA_MASK, XRDC_MDA_W_DIDSPA(value)))
#define XRDC_BWR_MDA_W_DIDSPA(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_DIDSPA_SHIFT), XRDC_MDA_W_DIDSPA_SHIFT, XRDC_MDA_W_DIDSPA_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field PESA[7:6] (RW)
 *
 * The functionality of this field changes based on the value of DFMT: For
 * DFMT=0: Bits 1:0 define the logical field PE, Process identifier enable. This field
 * controls the optional inclusion of the PID, qualified by PIDM, into the
 * domain hit evaluation. It provides the ability to include inclusive or exclusive
 * sets of masked PID values. 00: No process identifier is included in the domain
 * hit evaluation 01: No process identifier is included in the domain hit
 * evaluation 10: The process identifier is included in the domain hit evaluation as
 * defined by the expression:partial_domain_hit = (PE[7:6] == 10) && ((PID[21:16] &
 * ~PIDM[13:8]) == (PID & ~PIDM[13:8])) 11: The process identifier is included in
 * the domain hit evaluation as defined by the expression:partial_domain_hit =
 * (PE[7:6] == 11) && ~((PID[21:16] & ~PIDM[13:8]) == (PID & ~PIDM[13:8])) For
 * DFMT=0: Bits 1:0 define the logical field SA, Secure attribute. This field defines
 * the secure/nonsecure attribute for non-processor cores. 00: Force the bus
 * attribute for this master to secure. 01: Force the bus attribute for this master
 * to nonsecure. 10: Use the bus master's secure/nonsecure attribute directly.
 * 11: Use the bus master's secure/nonsecure attribute directly. The bus master's
 * input secure/nonsecure attribute is used if SA = 1-, or this VLD = 0.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_PESA field. */
#define XRDC_RD_MDA_W_PESA(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_PESA_MASK) >> XRDC_MDA_W_PESA_SHIFT)
#define XRDC_BRD_MDA_W_PESA(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_PESA_SHIFT, XRDC_MDA_W_PESA_WIDTH))

/*! @brief Set the PESA field to a new value. */
#define XRDC_WR_MDA_W_PESA(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_PESA_MASK, XRDC_MDA_W_PESA(value)))
#define XRDC_BWR_MDA_W_PESA(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_PESA_SHIFT), XRDC_MDA_W_PESA_SHIFT, XRDC_MDA_W_PESA_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field PIDMDIDB[21:8] (RW)
 *
 * The functionality of this field changes based on the value of DFMT: For
 * DFMT=0: Bits 13-8 define logical field PIDM, Process Identifier. This field
 * specifies that the process identifier is to be combined with the PIDM field and
 * included in the domain hit determination. The optional inclusion of the PID and
 * PIDM is controlled by the MDA_Wm_n[PE] field. Bits 7-6 are reserved. Bits 5-0
 * define logical field PIDM, Process Identifier Mask. This field provides a masking
 * capability so that multiple process identifiers can be included as part of
 * the domain hit determination. If a bit in the PIDM is set, then the
 * corresponding bit of the PID is ignored in the comparison. The optional inclusion of the
 * PID and PIDM is controlled by the MDA_Wm_n[PE] field. For DFMT=1: Bits 13-1 are
 * reserved. Bit 0 defines logical field DIDB, DID Bypass. If asserted, this
 * field enables the bypassing of an input DID value as the domain identifier for
 * this non-processor bus master. This capability allows non-processor bus masters,
 * for example, a DMA to masquerade as a processor. Once set, this field is
 * "sticky" and remains set until the next reset. 0: Use MDAn[3:0] as the domain
 * identifier. 1: Use the DID input as the domain identifier.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_PIDMDIDB field. */
#define XRDC_RD_MDA_W_PIDMDIDB(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_PIDMDIDB_MASK) >> XRDC_MDA_W_PIDMDIDB_SHIFT)
#define XRDC_BRD_MDA_W_PIDMDIDB(base, index, index2) (XRDC_RD_MDA_W_PIDMDIDB(base, index, index2))

/*! @brief Set the PIDMDIDB field to a new value. */
#define XRDC_WR_MDA_W_PIDMDIDB(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_PIDMDIDB_MASK, XRDC_MDA_W_PIDMDIDB(value)))
#define XRDC_BWR_MDA_W_PIDMDIDB(base, index, index2, value) (XRDC_WR_MDA_W_PIDMDIDB(base, index, index2, value))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field LPID[27:24] (RW)
 *
 * Logical partition Identifier. This 4-bit field defines an optional logical
 * partition identifier (as known as an operating system number) to be included in
 * the domain hit evaluation. This functionality is only available if the XRDC is
 * virtualization aware (signaled by CR[VAW] = 1).
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_LPID field. */
#define XRDC_RD_MDA_W_LPID(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_LPID_MASK) >> XRDC_MDA_W_LPID_SHIFT)
#define XRDC_BRD_MDA_W_LPID(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_LPID_SHIFT, XRDC_MDA_W_LPID_WIDTH))

/*! @brief Set the LPID field to a new value. */
#define XRDC_WR_MDA_W_LPID(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_LPID_MASK, XRDC_MDA_W_LPID(value)))
#define XRDC_BWR_MDA_W_LPID(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_LPID_SHIFT), XRDC_MDA_W_LPID_SHIFT, XRDC_MDA_W_LPID_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field LPE[28] (RW)
 *
 * Logical partition enable. If the XRDC is virtualization aware (signaled by
 * CR[VAW] = 1), this field enables the inclusion of a logical partition identifier
 * to be included in the domain hit evaluation. 0 The LPID field is not included
 * in the domain hit evaluation. 1 The LPID field is included in the domain hit
 * evaluation
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_LPE field. */
#define XRDC_RD_MDA_W_LPE(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_LPE_MASK) >> XRDC_MDA_W_LPE_SHIFT)
#define XRDC_BRD_MDA_W_LPE(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_LPE_SHIFT, XRDC_MDA_W_LPE_WIDTH))

/*! @brief Set the LPE field to a new value. */
#define XRDC_WR_MDA_W_LPE(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_LPE_MASK, XRDC_MDA_W_LPE(value)))
#define XRDC_BWR_MDA_W_LPE(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_LPE_SHIFT), XRDC_MDA_W_LPE_SHIFT, XRDC_MDA_W_LPE_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field DFMT[29] (RW)
 *
 * Domain format. This field identifies the MDA_Wm_n as a processor core domain
 * assignment (DFMT = 0) or a non-processor domain assignment (DFMT = 1).
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_DFMT field. */
#define XRDC_RD_MDA_W_DFMT(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_DFMT_MASK) >> XRDC_MDA_W_DFMT_SHIFT)
#define XRDC_BRD_MDA_W_DFMT(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_DFMT_SHIFT, XRDC_MDA_W_DFMT_WIDTH))

/*! @brief Set the DFMT field to a new value. */
#define XRDC_WR_MDA_W_DFMT(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_DFMT_MASK, XRDC_MDA_W_DFMT(value)))
#define XRDC_BWR_MDA_W_DFMT(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_DFMT_SHIFT), XRDC_MDA_W_DFMT_SHIFT, XRDC_MDA_W_DFMT_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field LK1[30] (RW)
 *
 * 1-bit Lock. This field provides a locking mechanism that can be used to limit
 * the ability to write the register. Once set, this bit remains asserted until
 * the next reset.
 *
 * Values:
 * - 0b0 - Register can be written by any secure privileged write.
 * - 0b1 - Register is locked (read-only) until the next reset.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_LK1 field. */
#define XRDC_RD_MDA_W_LK1(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_LK1_MASK) >> XRDC_MDA_W_LK1_SHIFT)
#define XRDC_BRD_MDA_W_LK1(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_LK1_SHIFT, XRDC_MDA_W_LK1_WIDTH))

/*! @brief Set the LK1 field to a new value. */
#define XRDC_WR_MDA_W_LK1(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_LK1_MASK, XRDC_MDA_W_LK1(value)))
#define XRDC_BWR_MDA_W_LK1(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_LK1_SHIFT), XRDC_MDA_W_LK1_SHIFT, XRDC_MDA_W_LK1_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MDA_W, field VLD[31] (RW)
 *
 * Valid. This field indicates the domain assignment is valid. It is further
 * qualified by CR[GVLD] = 1. The DID output is only enabled when both MDA_Wm_n[VLD]
 * and CR[GVLD] are asserted.
 *
 * Values:
 * - 0b0 - The Wm domain assignment is invalid.
 * - 0b1 - The Wm domain assignment is valid.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MDA_W_VLD field. */
#define XRDC_RD_MDA_W_VLD(base, index, index2) ((XRDC_MDA_W_REG(base, index, index2) & XRDC_MDA_W_VLD_MASK) >> XRDC_MDA_W_VLD_SHIFT)
#define XRDC_BRD_MDA_W_VLD(base, index, index2) (BME_UBFX32(&XRDC_MDA_W_REG(base, index, index2), XRDC_MDA_W_VLD_SHIFT, XRDC_MDA_W_VLD_WIDTH))

/*! @brief Set the VLD field to a new value. */
#define XRDC_WR_MDA_W_VLD(base, index, index2, value) (XRDC_RMW_MDA_W(base, index, index2, XRDC_MDA_W_VLD_MASK, XRDC_MDA_W_VLD(value)))
#define XRDC_BWR_MDA_W_VLD(base, index, index2, value) (BME_BFI32(&XRDC_MDA_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MDA_W_VLD_SHIFT), XRDC_MDA_W_VLD_SHIFT, XRDC_MDA_W_VLD_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_PDAC_W - Peripheral Domain Access Control W0
 ******************************************************************************/

/*!
 * @brief XRDC_PDAC_W - Peripheral Domain Access Control W0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDAC_Wm_n registers provide a 2-dimensional data structure for defining
 * access control policies per domain for each implemented slave peripheral. There
 * are 2 word-sized registers assigned for each peripheral "address slot" (Wm)
 * and up to 512 peripheral assignments (up to 4 peripheral access controllers,
 * each supporting up to 128 peripheral slots). The actual number of implemented
 * peripheral access controllers is defined by MDACFGn[NPAC]. Each Wm within the
 * PDACn structure is a word-sized definition; a total of two words (64 bits) is
 * needed to define the access control policies for all the domains. These
 * registers also allow a hardware semaphore to be optionally included in the access
 * control evaluation for peripherals shared by multiple domains. If enabled, the
 * state of the semaphore dynamically modifies the access control policies so that
 * only the domain "owning" it has write permission into the peripheral. The write
 * permissions for all other domains are revoked based on the semaphore state.
 * If the semaphore is not owned by any domain, the DxACP fields are evaluated
 * normally. The PAC submodule uses the peripheral access address to select the
 * appropriate PDACn register, and then uses the domain identifier associated with
 * the access to select the appropriate DxACP field. The selected DxACP field is
 * then evaluated against the attributes associated with the memory transaction to
 * determine the validity of the access. See DxACP evaluation for more details.
 * If allowed, the access proceeds, else an access violation is signaled, the
 * transfer error terminated and the appropriate address and attribute information
 * captured in the corresponding error detail registers. Access: Secure Privileged
 * Read/write
 */
/*!
 * @name Constants and macros for entire XRDC_PDAC_W register
 */
/*@{*/
#define XRDC_RD_PDAC_W(base, index, index2) (XRDC_PDAC_W_REG(base, index, index2))
#define XRDC_WR_PDAC_W(base, index, index2, value) (XRDC_PDAC_W_REG(base, index, index2) = (value))
#define XRDC_RMW_PDAC_W(base, index, index2, mask, value) (XRDC_WR_PDAC_W(base, index, index2, (XRDC_RD_PDAC_W(base, index, index2) & ~(mask)) | (value)))
#define XRDC_SET_PDAC_W(base, index, index2, value) (BME_OR32(&XRDC_PDAC_W_REG(base, index, index2), (uint32_t)(value)))
#define XRDC_CLR_PDAC_W(base, index, index2, value) (BME_AND32(&XRDC_PDAC_W_REG(base, index, index2), (uint32_t)(~(value))))
#define XRDC_TOG_PDAC_W(base, index, index2, value) (BME_XOR32(&XRDC_PDAC_W_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XRDC_PDAC_W bitfields
 */

/*!
 * @name Register XRDC_PDAC_W, field D0ACP[2:0] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D0ACP field. */
#define XRDC_RD_PDAC_W_D0ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D0ACP_MASK) >> XRDC_PDAC_W_D0ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D0ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D0ACP_SHIFT, XRDC_PDAC_W_D0ACP_WIDTH))

/*! @brief Set the D0ACP field to a new value. */
#define XRDC_WR_PDAC_W_D0ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D0ACP_MASK, XRDC_PDAC_W_D0ACP(value)))
#define XRDC_BWR_PDAC_W_D0ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D0ACP_SHIFT), XRDC_PDAC_W_D0ACP_SHIFT, XRDC_PDAC_W_D0ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D8ACP[2:0] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D8ACP field. */
#define XRDC_RD_PDAC_W_D8ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D8ACP_MASK) >> XRDC_PDAC_W_D8ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D8ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D8ACP_SHIFT, XRDC_PDAC_W_D8ACP_WIDTH))

/*! @brief Set the D8ACP field to a new value. */
#define XRDC_WR_PDAC_W_D8ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D8ACP_MASK, XRDC_PDAC_W_D8ACP(value)))
#define XRDC_BWR_PDAC_W_D8ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D8ACP_SHIFT), XRDC_PDAC_W_D8ACP_SHIFT, XRDC_PDAC_W_D8ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D1ACP[5:3] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D1ACP field. */
#define XRDC_RD_PDAC_W_D1ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D1ACP_MASK) >> XRDC_PDAC_W_D1ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D1ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D1ACP_SHIFT, XRDC_PDAC_W_D1ACP_WIDTH))

/*! @brief Set the D1ACP field to a new value. */
#define XRDC_WR_PDAC_W_D1ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D1ACP_MASK, XRDC_PDAC_W_D1ACP(value)))
#define XRDC_BWR_PDAC_W_D1ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D1ACP_SHIFT), XRDC_PDAC_W_D1ACP_SHIFT, XRDC_PDAC_W_D1ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D9ACP[5:3] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D9ACP field. */
#define XRDC_RD_PDAC_W_D9ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D9ACP_MASK) >> XRDC_PDAC_W_D9ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D9ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D9ACP_SHIFT, XRDC_PDAC_W_D9ACP_WIDTH))

/*! @brief Set the D9ACP field to a new value. */
#define XRDC_WR_PDAC_W_D9ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D9ACP_MASK, XRDC_PDAC_W_D9ACP(value)))
#define XRDC_BWR_PDAC_W_D9ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D9ACP_SHIFT), XRDC_PDAC_W_D9ACP_SHIFT, XRDC_PDAC_W_D9ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D10ACP[8:6] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D10ACP field. */
#define XRDC_RD_PDAC_W_D10ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D10ACP_MASK) >> XRDC_PDAC_W_D10ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D10ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D10ACP_SHIFT, XRDC_PDAC_W_D10ACP_WIDTH))

/*! @brief Set the D10ACP field to a new value. */
#define XRDC_WR_PDAC_W_D10ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D10ACP_MASK, XRDC_PDAC_W_D10ACP(value)))
#define XRDC_BWR_PDAC_W_D10ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D10ACP_SHIFT), XRDC_PDAC_W_D10ACP_SHIFT, XRDC_PDAC_W_D10ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D2ACP[8:6] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D2ACP field. */
#define XRDC_RD_PDAC_W_D2ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D2ACP_MASK) >> XRDC_PDAC_W_D2ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D2ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D2ACP_SHIFT, XRDC_PDAC_W_D2ACP_WIDTH))

/*! @brief Set the D2ACP field to a new value. */
#define XRDC_WR_PDAC_W_D2ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D2ACP_MASK, XRDC_PDAC_W_D2ACP(value)))
#define XRDC_BWR_PDAC_W_D2ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D2ACP_SHIFT), XRDC_PDAC_W_D2ACP_SHIFT, XRDC_PDAC_W_D2ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D11ACP[11:9] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D11ACP field. */
#define XRDC_RD_PDAC_W_D11ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D11ACP_MASK) >> XRDC_PDAC_W_D11ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D11ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D11ACP_SHIFT, XRDC_PDAC_W_D11ACP_WIDTH))

/*! @brief Set the D11ACP field to a new value. */
#define XRDC_WR_PDAC_W_D11ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D11ACP_MASK, XRDC_PDAC_W_D11ACP(value)))
#define XRDC_BWR_PDAC_W_D11ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D11ACP_SHIFT), XRDC_PDAC_W_D11ACP_SHIFT, XRDC_PDAC_W_D11ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D3ACP[11:9] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D3ACP field. */
#define XRDC_RD_PDAC_W_D3ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D3ACP_MASK) >> XRDC_PDAC_W_D3ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D3ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D3ACP_SHIFT, XRDC_PDAC_W_D3ACP_WIDTH))

/*! @brief Set the D3ACP field to a new value. */
#define XRDC_WR_PDAC_W_D3ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D3ACP_MASK, XRDC_PDAC_W_D3ACP(value)))
#define XRDC_BWR_PDAC_W_D3ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D3ACP_SHIFT), XRDC_PDAC_W_D3ACP_SHIFT, XRDC_PDAC_W_D3ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D4ACP[14:12] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D4ACP field. */
#define XRDC_RD_PDAC_W_D4ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D4ACP_MASK) >> XRDC_PDAC_W_D4ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D4ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D4ACP_SHIFT, XRDC_PDAC_W_D4ACP_WIDTH))

/*! @brief Set the D4ACP field to a new value. */
#define XRDC_WR_PDAC_W_D4ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D4ACP_MASK, XRDC_PDAC_W_D4ACP(value)))
#define XRDC_BWR_PDAC_W_D4ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D4ACP_SHIFT), XRDC_PDAC_W_D4ACP_SHIFT, XRDC_PDAC_W_D4ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D12ACP[14:12] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D12ACP field. */
#define XRDC_RD_PDAC_W_D12ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D12ACP_MASK) >> XRDC_PDAC_W_D12ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D12ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D12ACP_SHIFT, XRDC_PDAC_W_D12ACP_WIDTH))

/*! @brief Set the D12ACP field to a new value. */
#define XRDC_WR_PDAC_W_D12ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D12ACP_MASK, XRDC_PDAC_W_D12ACP(value)))
#define XRDC_BWR_PDAC_W_D12ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D12ACP_SHIFT), XRDC_PDAC_W_D12ACP_SHIFT, XRDC_PDAC_W_D12ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D5ACP[17:15] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D5ACP field. */
#define XRDC_RD_PDAC_W_D5ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D5ACP_MASK) >> XRDC_PDAC_W_D5ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D5ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D5ACP_SHIFT, XRDC_PDAC_W_D5ACP_WIDTH))

/*! @brief Set the D5ACP field to a new value. */
#define XRDC_WR_PDAC_W_D5ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D5ACP_MASK, XRDC_PDAC_W_D5ACP(value)))
#define XRDC_BWR_PDAC_W_D5ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D5ACP_SHIFT), XRDC_PDAC_W_D5ACP_SHIFT, XRDC_PDAC_W_D5ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D13ACP[17:15] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D13ACP field. */
#define XRDC_RD_PDAC_W_D13ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D13ACP_MASK) >> XRDC_PDAC_W_D13ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D13ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D13ACP_SHIFT, XRDC_PDAC_W_D13ACP_WIDTH))

/*! @brief Set the D13ACP field to a new value. */
#define XRDC_WR_PDAC_W_D13ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D13ACP_MASK, XRDC_PDAC_W_D13ACP(value)))
#define XRDC_BWR_PDAC_W_D13ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D13ACP_SHIFT), XRDC_PDAC_W_D13ACP_SHIFT, XRDC_PDAC_W_D13ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D14ACP[20:18] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D14ACP field. */
#define XRDC_RD_PDAC_W_D14ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D14ACP_MASK) >> XRDC_PDAC_W_D14ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D14ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D14ACP_SHIFT, XRDC_PDAC_W_D14ACP_WIDTH))

/*! @brief Set the D14ACP field to a new value. */
#define XRDC_WR_PDAC_W_D14ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D14ACP_MASK, XRDC_PDAC_W_D14ACP(value)))
#define XRDC_BWR_PDAC_W_D14ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D14ACP_SHIFT), XRDC_PDAC_W_D14ACP_SHIFT, XRDC_PDAC_W_D14ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D6ACP[20:18] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D6ACP field. */
#define XRDC_RD_PDAC_W_D6ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D6ACP_MASK) >> XRDC_PDAC_W_D6ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D6ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D6ACP_SHIFT, XRDC_PDAC_W_D6ACP_WIDTH))

/*! @brief Set the D6ACP field to a new value. */
#define XRDC_WR_PDAC_W_D6ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D6ACP_MASK, XRDC_PDAC_W_D6ACP(value)))
#define XRDC_BWR_PDAC_W_D6ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D6ACP_SHIFT), XRDC_PDAC_W_D6ACP_SHIFT, XRDC_PDAC_W_D6ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D15ACP[23:21] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D15ACP field. */
#define XRDC_RD_PDAC_W_D15ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D15ACP_MASK) >> XRDC_PDAC_W_D15ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D15ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D15ACP_SHIFT, XRDC_PDAC_W_D15ACP_WIDTH))

/*! @brief Set the D15ACP field to a new value. */
#define XRDC_WR_PDAC_W_D15ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D15ACP_MASK, XRDC_PDAC_W_D15ACP(value)))
#define XRDC_BWR_PDAC_W_D15ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D15ACP_SHIFT), XRDC_PDAC_W_D15ACP_SHIFT, XRDC_PDAC_W_D15ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field D7ACP[23:21] (RW)
 *
 * Domain "x" access control policy. This 3-bit field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented
 * for supported domainIDs; unsupported domainIDs are not implemented and
 * default to a zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101
 * r, w r, w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none
 * none 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_D7ACP field. */
#define XRDC_RD_PDAC_W_D7ACP(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_D7ACP_MASK) >> XRDC_PDAC_W_D7ACP_SHIFT)
#define XRDC_BRD_PDAC_W_D7ACP(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_D7ACP_SHIFT, XRDC_PDAC_W_D7ACP_WIDTH))

/*! @brief Set the D7ACP field to a new value. */
#define XRDC_WR_PDAC_W_D7ACP(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_D7ACP_MASK, XRDC_PDAC_W_D7ACP(value)))
#define XRDC_BWR_PDAC_W_D7ACP(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_D7ACP_SHIFT), XRDC_PDAC_W_D7ACP_SHIFT, XRDC_PDAC_W_D7ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field SNUM[29:24] (RW)
 *
 * Semaphore number. Include this hardware semaphore in the DxACP access
 * evaluation.
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_SNUM field. */
#define XRDC_RD_PDAC_W_SNUM(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_SNUM_MASK) >> XRDC_PDAC_W_SNUM_SHIFT)
#define XRDC_BRD_PDAC_W_SNUM(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_SNUM_SHIFT, XRDC_PDAC_W_SNUM_WIDTH))

/*! @brief Set the SNUM field to a new value. */
#define XRDC_WR_PDAC_W_SNUM(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_SNUM_MASK, XRDC_PDAC_W_SNUM(value)))
#define XRDC_BWR_PDAC_W_SNUM(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_SNUM_SHIFT), XRDC_PDAC_W_SNUM_SHIFT, XRDC_PDAC_W_SNUM_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field LK2[30:29] (RW)
 *
 * Lock. This 2-bit field provides a mechanism to limit writes to the PDACn
 * register to protect its contents. Once set, these bits individually remain
 * asserted until the next reset
 *
 * Values:
 * - 0b00 - Entire PDACn can be written.
 * - 0b01 - Entire PDACn can be written.
 * - 0b10 - Domain "x" can only update the DxACP field; no other PDACn fields
 *     can be written.
 * - 0b11 - PDACn is locked (read-only) until the next reset.
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_LK2 field. */
#define XRDC_RD_PDAC_W_LK2(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_LK2_MASK) >> XRDC_PDAC_W_LK2_SHIFT)
#define XRDC_BRD_PDAC_W_LK2(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_LK2_SHIFT, XRDC_PDAC_W_LK2_WIDTH))

/*! @brief Set the LK2 field to a new value. */
#define XRDC_WR_PDAC_W_LK2(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_LK2_MASK, XRDC_PDAC_W_LK2(value)))
#define XRDC_BWR_PDAC_W_LK2(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_LK2_SHIFT), XRDC_PDAC_W_LK2_SHIFT, XRDC_PDAC_W_LK2_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field SE[30] (RW)
 *
 * Semaphore enable. This field indicates if a semaphore (SNUM) is to be
 * included in the DxACP access evaluation.
 *
 * Values:
 * - 0b0 - Do not include a semaphore in the DxACP evaluation.
 * - 0b1 - Include the semaphore defined by W0[SNUM] in the DxACP evaluation.
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_SE field. */
#define XRDC_RD_PDAC_W_SE(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_SE_MASK) >> XRDC_PDAC_W_SE_SHIFT)
#define XRDC_BRD_PDAC_W_SE(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_SE_SHIFT, XRDC_PDAC_W_SE_WIDTH))

/*! @brief Set the SE field to a new value. */
#define XRDC_WR_PDAC_W_SE(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_SE_MASK, XRDC_PDAC_W_SE(value)))
#define XRDC_BWR_PDAC_W_SE(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_SE_SHIFT), XRDC_PDAC_W_SE_SHIFT, XRDC_PDAC_W_SE_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_PDAC_W, field VLD[31] (RW)
 *
 * Valid. This field indicates the peripheral domain access control definition
 * is valid. It is further qualified by CR[GVLD] = 1. If either CR[GVLD] or this
 * VLD flag is cleared, all accesses to the peripheral are allowed. Any write to
 * PDAC_W0_n clears the PDAC_W1_n[VLD] indicator so a coherent register state can
 * be supported.
 *
 * Values:
 * - 0b0 - The PDACn assignment is invalid.
 * - 0b1 - The PDACn assignment is valid.
 */
/*@{*/
/*! @brief Read current value of the XRDC_PDAC_W_VLD field. */
#define XRDC_RD_PDAC_W_VLD(base, index, index2) ((XRDC_PDAC_W_REG(base, index, index2) & XRDC_PDAC_W_VLD_MASK) >> XRDC_PDAC_W_VLD_SHIFT)
#define XRDC_BRD_PDAC_W_VLD(base, index, index2) (BME_UBFX32(&XRDC_PDAC_W_REG(base, index, index2), XRDC_PDAC_W_VLD_SHIFT, XRDC_PDAC_W_VLD_WIDTH))

/*! @brief Set the VLD field to a new value. */
#define XRDC_WR_PDAC_W_VLD(base, index, index2, value) (XRDC_RMW_PDAC_W(base, index, index2, XRDC_PDAC_W_VLD_MASK, XRDC_PDAC_W_VLD(value)))
#define XRDC_BWR_PDAC_W_VLD(base, index, index2, value) (BME_BFI32(&XRDC_PDAC_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_PDAC_W_VLD_SHIFT), XRDC_PDAC_W_VLD_SHIFT, XRDC_PDAC_W_VLD_WIDTH))
/*@}*/

/*******************************************************************************
 * XRDC_MRGD_W - Memory Region Descriptor W0
 ******************************************************************************/

/*!
 * @brief XRDC_MRGD_W - Memory Region Descriptor W0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MRGD_Wm_n registers provide a 2-dimensional data structure for defining
 * access control policies per domain for each supported memory region. There are
 * 4 word-size registers currently defined (and space for 8 word-sized registers)
 * in each memory region (Wm) and up to 256 memory regions (up to 16 memory
 * region controllers, each supporting up to 16 memory region descriptors). The
 * actual number of implemented memory region controllers is defined by MDACFGn[NMRC].
 * Each instance of a memory region controller (MRC) submodule can monitor up to
 * 8 system buses concurrently. Note, an AXI port counts as two system buses
 * since the read address and write address channels operate independently. Each Wm
 * within the MRGDn structure is a word-sized definition; a total of four words
 * (128 bits, W0-W3) are needed to completely define the memory region descriptor.
 * Additionally, there are another four words (W4-W7) included in each MRGDn
 * definition that are currently unused and reserved for future enhancements. XRDC
 * uses a base address plus a size (0-modulo-size) to specify memory regions. This
 * format provides addressing capabilities that are equivalent to those provided
 * in the ARM Cortex-M processor core memory protection unit. The region
 * descriptor also allows a hardware semaphore to be optionally included in the access
 * control evaluation for memory regions shared by multiple domains. If enabled,
 * the state of the semaphore dynamically modifies the access control policies so
 * that only the domain "owning" it has write permission into the region. The
 * write permissions for all other domains are revoked based on the semaphore state.
 * If the semaphore is not owned by any domain, the DxACP fields are evaluated
 * normally. The MRC submodule evaluates multiple system bus access addresses
 * versus the programmed address ranges to determine a region hit. Once a region hit
 * has been determined, the MRC then uses the domain identifier associated with
 * the access to select the appropriate DxACP field from the corresponding MRGDn.
 * The selected DxACP field is then evaluated against the attributes associated
 * with the memory transaction to determine the validity of the access. See Memory
 * region descriptor hit determination and Memory region DxACP evaluation for
 * more details. If allowed, the access proceeds, else an access violation is
 * signaled, the transfer error terminated and the appropriate address and attribute
 * information captured in the corresponding error detail registers.
 */
/*!
 * @name Constants and macros for entire XRDC_MRGD_W register
 */
/*@{*/
#define XRDC_RD_MRGD_W(base, index, index2) (XRDC_MRGD_W_REG(base, index, index2))
#define XRDC_WR_MRGD_W(base, index, index2, value) (XRDC_MRGD_W_REG(base, index, index2) = (value))
#define XRDC_RMW_MRGD_W(base, index, index2, mask, value) (XRDC_WR_MRGD_W(base, index, index2, (XRDC_RD_MRGD_W(base, index, index2) & ~(mask)) | (value)))
#define XRDC_SET_MRGD_W(base, index, index2, value) (BME_OR32(&XRDC_MRGD_W_REG(base, index, index2), (uint32_t)(value)))
#define XRDC_CLR_MRGD_W(base, index, index2, value) (BME_AND32(&XRDC_MRGD_W_REG(base, index, index2), (uint32_t)(~(value))))
#define XRDC_TOG_MRGD_W(base, index, index2, value) (BME_XOR32(&XRDC_MRGD_W_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XRDC_MRGD_W bitfields
 */

/*!
 * @name Register XRDC_MRGD_W, field SRD[7:0] (RW)
 *
 * Subregion disable. For regions of 256 bytes or larger, this field is a bitmap
 * enabling or disabling each of the eight equal-size subregions. SRD[0]
 * disables the subregion with the lowest address range, while SRD[7] disables the
 * subregion with the highest address range. If any SRD bits are asserted to disable a
 * subregion and the total region size is less than 256 bytes, the ARM
 * definition of UNPREDICTABLE behavior applies. 0: Subregion is enabled. 1: Subregion is
 * disabled.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_SRD field. */
#define XRDC_RD_MRGD_W_SRD(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_SRD_MASK) >> XRDC_MRGD_W_SRD_SHIFT)
#define XRDC_BRD_MRGD_W_SRD(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_SRD_SHIFT, XRDC_MRGD_W_SRD_WIDTH))

/*! @brief Set the SRD field to a new value. */
#define XRDC_WR_MRGD_W_SRD(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_SRD_MASK, XRDC_MRGD_W_SRD(value)))
#define XRDC_BWR_MRGD_W_SRD(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_SRD_SHIFT), XRDC_MRGD_W_SRD_SHIFT, XRDC_MRGD_W_SRD_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D8ACP[2:0] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D8ACP field. */
#define XRDC_RD_MRGD_W_D8ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D8ACP_MASK) >> XRDC_MRGD_W_D8ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D8ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D8ACP_SHIFT, XRDC_MRGD_W_D8ACP_WIDTH))

/*! @brief Set the D8ACP field to a new value. */
#define XRDC_WR_MRGD_W_D8ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D8ACP_MASK, XRDC_MRGD_W_D8ACP(value)))
#define XRDC_BWR_MRGD_W_D8ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D8ACP_SHIFT), XRDC_MRGD_W_D8ACP_SHIFT, XRDC_MRGD_W_D8ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D0ACP[2:0] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D0ACP field. */
#define XRDC_RD_MRGD_W_D0ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D0ACP_MASK) >> XRDC_MRGD_W_D0ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D0ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D0ACP_SHIFT, XRDC_MRGD_W_D0ACP_WIDTH))

/*! @brief Set the D0ACP field to a new value. */
#define XRDC_WR_MRGD_W_D0ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D0ACP_MASK, XRDC_MRGD_W_D0ACP(value)))
#define XRDC_BWR_MRGD_W_D0ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D0ACP_SHIFT), XRDC_MRGD_W_D0ACP_SHIFT, XRDC_MRGD_W_D0ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D1ACP[5:3] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D1ACP field. */
#define XRDC_RD_MRGD_W_D1ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D1ACP_MASK) >> XRDC_MRGD_W_D1ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D1ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D1ACP_SHIFT, XRDC_MRGD_W_D1ACP_WIDTH))

/*! @brief Set the D1ACP field to a new value. */
#define XRDC_WR_MRGD_W_D1ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D1ACP_MASK, XRDC_MRGD_W_D1ACP(value)))
#define XRDC_BWR_MRGD_W_D1ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D1ACP_SHIFT), XRDC_MRGD_W_D1ACP_SHIFT, XRDC_MRGD_W_D1ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D9ACP[5:3] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D9ACP field. */
#define XRDC_RD_MRGD_W_D9ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D9ACP_MASK) >> XRDC_MRGD_W_D9ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D9ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D9ACP_SHIFT, XRDC_MRGD_W_D9ACP_WIDTH))

/*! @brief Set the D9ACP field to a new value. */
#define XRDC_WR_MRGD_W_D9ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D9ACP_MASK, XRDC_MRGD_W_D9ACP(value)))
#define XRDC_BWR_MRGD_W_D9ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D9ACP_SHIFT), XRDC_MRGD_W_D9ACP_SHIFT, XRDC_MRGD_W_D9ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field BASEADDR[31:5] (RW)
 *
 * Base Address.This field defines the most significant bits of the base address
 * of the memory region (minimum size = 32 bytes). The Base Address is aligned
 * to a 0-modulo-2(SZ+1) byte address.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_BASEADDR field. */
#define XRDC_RD_MRGD_W_BASEADDR(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_BASEADDR_MASK) >> XRDC_MRGD_W_BASEADDR_SHIFT)
#define XRDC_BRD_MRGD_W_BASEADDR(base, index, index2) (XRDC_RD_MRGD_W_BASEADDR(base, index, index2))

/*! @brief Set the BASEADDR field to a new value. */
#define XRDC_WR_MRGD_W_BASEADDR(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_BASEADDR_MASK, XRDC_MRGD_W_BASEADDR(value)))
#define XRDC_BWR_MRGD_W_BASEADDR(base, index, index2, value) (XRDC_WR_MRGD_W_BASEADDR(base, index, index2, value))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D2ACP[8:6] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D2ACP field. */
#define XRDC_RD_MRGD_W_D2ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D2ACP_MASK) >> XRDC_MRGD_W_D2ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D2ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D2ACP_SHIFT, XRDC_MRGD_W_D2ACP_WIDTH))

/*! @brief Set the D2ACP field to a new value. */
#define XRDC_WR_MRGD_W_D2ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D2ACP_MASK, XRDC_MRGD_W_D2ACP(value)))
#define XRDC_BWR_MRGD_W_D2ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D2ACP_SHIFT), XRDC_MRGD_W_D2ACP_SHIFT, XRDC_MRGD_W_D2ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D10ACP[8:6] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D10ACP field. */
#define XRDC_RD_MRGD_W_D10ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D10ACP_MASK) >> XRDC_MRGD_W_D10ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D10ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D10ACP_SHIFT, XRDC_MRGD_W_D10ACP_WIDTH))

/*! @brief Set the D10ACP field to a new value. */
#define XRDC_WR_MRGD_W_D10ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D10ACP_MASK, XRDC_MRGD_W_D10ACP(value)))
#define XRDC_BWR_MRGD_W_D10ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D10ACP_SHIFT), XRDC_MRGD_W_D10ACP_SHIFT, XRDC_MRGD_W_D10ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field SZ[12:8] (RW)
 *
 * Region size. The region size is defined as 2(SZ+1) bytes.This field must be
 * >= 4 as the smallest region size is 32 bytes, else the ARM definition of
 * UNPREDICTABLE behavior applies.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_SZ field. */
#define XRDC_RD_MRGD_W_SZ(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_SZ_MASK) >> XRDC_MRGD_W_SZ_SHIFT)
#define XRDC_BRD_MRGD_W_SZ(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_SZ_SHIFT, XRDC_MRGD_W_SZ_WIDTH))

/*! @brief Set the SZ field to a new value. */
#define XRDC_WR_MRGD_W_SZ(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_SZ_MASK, XRDC_MRGD_W_SZ(value)))
#define XRDC_BWR_MRGD_W_SZ(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_SZ_SHIFT), XRDC_MRGD_W_SZ_SHIFT, XRDC_MRGD_W_SZ_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D3ACP[11:9] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D3ACP field. */
#define XRDC_RD_MRGD_W_D3ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D3ACP_MASK) >> XRDC_MRGD_W_D3ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D3ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D3ACP_SHIFT, XRDC_MRGD_W_D3ACP_WIDTH))

/*! @brief Set the D3ACP field to a new value. */
#define XRDC_WR_MRGD_W_D3ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D3ACP_MASK, XRDC_MRGD_W_D3ACP(value)))
#define XRDC_BWR_MRGD_W_D3ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D3ACP_SHIFT), XRDC_MRGD_W_D3ACP_SHIFT, XRDC_MRGD_W_D3ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D11ACP[11:9] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D11ACP field. */
#define XRDC_RD_MRGD_W_D11ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D11ACP_MASK) >> XRDC_MRGD_W_D11ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D11ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D11ACP_SHIFT, XRDC_MRGD_W_D11ACP_WIDTH))

/*! @brief Set the D11ACP field to a new value. */
#define XRDC_WR_MRGD_W_D11ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D11ACP_MASK, XRDC_MRGD_W_D11ACP(value)))
#define XRDC_BWR_MRGD_W_D11ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D11ACP_SHIFT), XRDC_MRGD_W_D11ACP_SHIFT, XRDC_MRGD_W_D11ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D12ACP[14:12] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D12ACP field. */
#define XRDC_RD_MRGD_W_D12ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D12ACP_MASK) >> XRDC_MRGD_W_D12ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D12ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D12ACP_SHIFT, XRDC_MRGD_W_D12ACP_WIDTH))

/*! @brief Set the D12ACP field to a new value. */
#define XRDC_WR_MRGD_W_D12ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D12ACP_MASK, XRDC_MRGD_W_D12ACP(value)))
#define XRDC_BWR_MRGD_W_D12ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D12ACP_SHIFT), XRDC_MRGD_W_D12ACP_SHIFT, XRDC_MRGD_W_D12ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D4ACP[14:12] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D4ACP field. */
#define XRDC_RD_MRGD_W_D4ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D4ACP_MASK) >> XRDC_MRGD_W_D4ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D4ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D4ACP_SHIFT, XRDC_MRGD_W_D4ACP_WIDTH))

/*! @brief Set the D4ACP field to a new value. */
#define XRDC_WR_MRGD_W_D4ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D4ACP_MASK, XRDC_MRGD_W_D4ACP(value)))
#define XRDC_BWR_MRGD_W_D4ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D4ACP_SHIFT), XRDC_MRGD_W_D4ACP_SHIFT, XRDC_MRGD_W_D4ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D5ACP[17:15] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D5ACP field. */
#define XRDC_RD_MRGD_W_D5ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D5ACP_MASK) >> XRDC_MRGD_W_D5ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D5ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D5ACP_SHIFT, XRDC_MRGD_W_D5ACP_WIDTH))

/*! @brief Set the D5ACP field to a new value. */
#define XRDC_WR_MRGD_W_D5ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D5ACP_MASK, XRDC_MRGD_W_D5ACP(value)))
#define XRDC_BWR_MRGD_W_D5ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D5ACP_SHIFT), XRDC_MRGD_W_D5ACP_SHIFT, XRDC_MRGD_W_D5ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D13ACP[17:15] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D13ACP field. */
#define XRDC_RD_MRGD_W_D13ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D13ACP_MASK) >> XRDC_MRGD_W_D13ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D13ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D13ACP_SHIFT, XRDC_MRGD_W_D13ACP_WIDTH))

/*! @brief Set the D13ACP field to a new value. */
#define XRDC_WR_MRGD_W_D13ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D13ACP_MASK, XRDC_MRGD_W_D13ACP(value)))
#define XRDC_BWR_MRGD_W_D13ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D13ACP_SHIFT), XRDC_MRGD_W_D13ACP_SHIFT, XRDC_MRGD_W_D13ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D6ACP[20:18] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D6ACP field. */
#define XRDC_RD_MRGD_W_D6ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D6ACP_MASK) >> XRDC_MRGD_W_D6ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D6ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D6ACP_SHIFT, XRDC_MRGD_W_D6ACP_WIDTH))

/*! @brief Set the D6ACP field to a new value. */
#define XRDC_WR_MRGD_W_D6ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D6ACP_MASK, XRDC_MRGD_W_D6ACP(value)))
#define XRDC_BWR_MRGD_W_D6ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D6ACP_SHIFT), XRDC_MRGD_W_D6ACP_SHIFT, XRDC_MRGD_W_D6ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D14ACP[20:18] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D14ACP field. */
#define XRDC_RD_MRGD_W_D14ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D14ACP_MASK) >> XRDC_MRGD_W_D14ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D14ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D14ACP_SHIFT, XRDC_MRGD_W_D14ACP_WIDTH))

/*! @brief Set the D14ACP field to a new value. */
#define XRDC_WR_MRGD_W_D14ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D14ACP_MASK, XRDC_MRGD_W_D14ACP(value)))
#define XRDC_BWR_MRGD_W_D14ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D14ACP_SHIFT), XRDC_MRGD_W_D14ACP_SHIFT, XRDC_MRGD_W_D14ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D15ACP[23:21] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D15ACP field. */
#define XRDC_RD_MRGD_W_D15ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D15ACP_MASK) >> XRDC_MRGD_W_D15ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D15ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D15ACP_SHIFT, XRDC_MRGD_W_D15ACP_WIDTH))

/*! @brief Set the D15ACP field to a new value. */
#define XRDC_WR_MRGD_W_D15ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D15ACP_MASK, XRDC_MRGD_W_D15ACP(value)))
#define XRDC_BWR_MRGD_W_D15ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D15ACP_SHIFT), XRDC_MRGD_W_D15ACP_SHIFT, XRDC_MRGD_W_D15ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field D7ACP[23:21] (RW)
 *
 * Domain "x" access control policy. This field defines the access control
 * rights for the selected domain. The encodings specify read and write access
 * capabilities based on the 4 operating states. These fields are only implemented for
 * supported domainIDs; unsupported domainIDs are not implemented and default to a
 * zero value providing no access rights. Policy SecurePriv SecureUser
 * NonsecurePriv NonsecureUser 111 r, w r, w r, w r, w 110 r, w r, w r, w none 101 r, w r,
 * w r r 100 r, w r, w r none 011 r, w r, w none none 010 r, w none none none
 * 001 r r none none 000 none none none none
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_D7ACP field. */
#define XRDC_RD_MRGD_W_D7ACP(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_D7ACP_MASK) >> XRDC_MRGD_W_D7ACP_SHIFT)
#define XRDC_BRD_MRGD_W_D7ACP(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_D7ACP_SHIFT, XRDC_MRGD_W_D7ACP_WIDTH))

/*! @brief Set the D7ACP field to a new value. */
#define XRDC_WR_MRGD_W_D7ACP(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_D7ACP_MASK, XRDC_MRGD_W_D7ACP(value)))
#define XRDC_BWR_MRGD_W_D7ACP(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_D7ACP_SHIFT), XRDC_MRGD_W_D7ACP_SHIFT, XRDC_MRGD_W_D7ACP_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field SNUM[29:24] (RW)
 *
 * Semaphore number. Include this hardware semaphore in the DxACP access
 * evaluation.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_SNUM field. */
#define XRDC_RD_MRGD_W_SNUM(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_SNUM_MASK) >> XRDC_MRGD_W_SNUM_SHIFT)
#define XRDC_BRD_MRGD_W_SNUM(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_SNUM_SHIFT, XRDC_MRGD_W_SNUM_WIDTH))

/*! @brief Set the SNUM field to a new value. */
#define XRDC_WR_MRGD_W_SNUM(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_SNUM_MASK, XRDC_MRGD_W_SNUM(value)))
#define XRDC_BWR_MRGD_W_SNUM(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_SNUM_SHIFT), XRDC_MRGD_W_SNUM_SHIFT, XRDC_MRGD_W_SNUM_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field LK2[30:29] (RW)
 *
 * Lock. This 2-bit field provides a mechanism to limit writes to the MRGDn
 * register to protect its contents. Once set, these bits individually remain
 * asserted until the next reset
 *
 * Values:
 * - 0b00 - Entire MRGDn can be written.
 * - 0b01 - Entire MRGDn can be written.
 * - 0b10 - Domain "x" can only update the DxACP field; no other MRGDn fields
 *     can be written
 * - 0b11 - MRGDn is locked (read-only) until the next reset.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_LK2 field. */
#define XRDC_RD_MRGD_W_LK2(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_LK2_MASK) >> XRDC_MRGD_W_LK2_SHIFT)
#define XRDC_BRD_MRGD_W_LK2(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_LK2_SHIFT, XRDC_MRGD_W_LK2_WIDTH))

/*! @brief Set the LK2 field to a new value. */
#define XRDC_WR_MRGD_W_LK2(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_LK2_MASK, XRDC_MRGD_W_LK2(value)))
#define XRDC_BWR_MRGD_W_LK2(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_LK2_SHIFT), XRDC_MRGD_W_LK2_SHIFT, XRDC_MRGD_W_LK2_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field SE[30] (RW)
 *
 * Semaphore enable. This field indicates if a semaphore (SNUM) is to be
 * included in the DxACP access evaluation.
 *
 * Values:
 * - 0b0 - Do not include a semaphore in the DxACP evaluation.
 * - 0b1 - Include the semaphore defined by W2[SNUM] in the DxACP evaluation.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_SE field. */
#define XRDC_RD_MRGD_W_SE(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_SE_MASK) >> XRDC_MRGD_W_SE_SHIFT)
#define XRDC_BRD_MRGD_W_SE(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_SE_SHIFT, XRDC_MRGD_W_SE_WIDTH))

/*! @brief Set the SE field to a new value. */
#define XRDC_WR_MRGD_W_SE(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_SE_MASK, XRDC_MRGD_W_SE(value)))
#define XRDC_BWR_MRGD_W_SE(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_SE_SHIFT), XRDC_MRGD_W_SE_SHIFT, XRDC_MRGD_W_SE_WIDTH))
/*@}*/

/*!
 * @name Register XRDC_MRGD_W, field VLD[31] (RW)
 *
 * Valid. This field indicates the memory region descriptor definition is valid.
 * It is further qualified by CR[GVLD] = 1. If either CR[GVLD] or this VLD flag
 * is cleared, all accesses to the memory region are allowed. Any write to
 * MRGD_W[0-2]_n clears the MRGD_W3_n[VLD] indicator so a coherent register state can
 * be supported. 0 The MRGDn assignment is invalid. 1 The MRGDn assignment is
 * valid.
 */
/*@{*/
/*! @brief Read current value of the XRDC_MRGD_W_VLD field. */
#define XRDC_RD_MRGD_W_VLD(base, index, index2) ((XRDC_MRGD_W_REG(base, index, index2) & XRDC_MRGD_W_VLD_MASK) >> XRDC_MRGD_W_VLD_SHIFT)
#define XRDC_BRD_MRGD_W_VLD(base, index, index2) (BME_UBFX32(&XRDC_MRGD_W_REG(base, index, index2), XRDC_MRGD_W_VLD_SHIFT, XRDC_MRGD_W_VLD_WIDTH))

/*! @brief Set the VLD field to a new value. */
#define XRDC_WR_MRGD_W_VLD(base, index, index2, value) (XRDC_RMW_MRGD_W(base, index, index2, XRDC_MRGD_W_VLD_MASK, XRDC_MRGD_W_VLD(value)))
#define XRDC_BWR_MRGD_W_VLD(base, index, index2, value) (BME_BFI32(&XRDC_MRGD_W_REG(base, index, index2), ((uint32_t)(value) << XRDC_MRGD_W_VLD_SHIFT), XRDC_MRGD_W_VLD_SHIFT, XRDC_MRGD_W_VLD_WIDTH))
/*@}*/

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#endif /* __MKL28Z7_EXTENSION_H__ */
/* EOF */
